/** START DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/plugin.js **/
jupyter.define('jupyterlab_vega@0.1.0/lib/plugin.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	var docregistry_1 = __jupyter_require__('jupyterlab@0.4.1/lib/docregistry/index.js');
	var rendermime_1 = __jupyter_require__('jupyterlab@0.4.1/lib/rendermime/index.js');
	var factory_1 = __jupyter_require__('jupyterlab_vega@~0.1.0/lib/factory.js');
	var renderer_1 = __jupyter_require__('jupyterlab_vega@~0.1.0/lib/renderer.js');
	__jupyter_require__('jupyterlab_vega@~0.1.0/lib/index.css');
	/**
	 * The list of file extensions for vega and vegalite.
	 */
	var VEGA_EXTENSIONS = ['.vg', 'vg.json', '.json'];
	var VEGALITE_EXTENSIONS = ['.vl', 'vl.json', '.json'];
	var vegaPlugin = {
	    id: 'jupyter.extensions.vega',
	    requires: [docregistry_1.IDocumentRegistry, rendermime_1.IRenderMime],
	    activate: activateVegaPlugin,
	    autoStart: true
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = vegaPlugin;
	/**
	 * Activate the table widget extension.
	 */
	function activateVegaPlugin(app, registry, rendermime) {
	    // Add the MIME type based renderers at the beginning of the renderers
	    rendermime.addRenderer('application/vnd.vega+json', new renderer_1.VegaRenderer(), 0);
	    rendermime.addRenderer('application/vnd.vegalite+json', new renderer_1.VegaLiteRenderer(), 0);
	    // Add file handler for standalone Vega JSON files
	    var options = {
	        fileExtensions: VEGA_EXTENSIONS,
	        defaultFor: VEGA_EXTENSIONS.slice(0, 2),
	        displayName: 'Vega',
	        modelName: 'text',
	        preferKernel: false,
	        canStartKernel: false
	    };
	    registry.addWidgetFactory(new factory_1.VegaWidgetFactory(), options);
	    // Add file handler for standalone VegaLite JSON files
	    options = {
	        fileExtensions: VEGALITE_EXTENSIONS,
	        defaultFor: VEGALITE_EXTENSIONS.slice(0, 2),
	        displayName: 'VegaLite',
	        modelName: 'text',
	        preferKernel: false,
	        canStartKernel: false
	    };
	    registry.addWidgetFactory(new factory_1.VegaLiteWidgetFactory(), options);
	}
	
})
/** END DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/plugin.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/index.js **/
jupyter.define('jupyterlab@0.4.1/lib/docregistry/index.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__jupyter_require__('jupyterlab@~0.4.1/lib/docregistry/default.js'));
	__export(__jupyter_require__('jupyterlab@~0.4.1/lib/docregistry/kernelactions.js'));
	__export(__jupyter_require__('jupyterlab@~0.4.1/lib/docregistry/kernelselector.js'));
	__export(__jupyter_require__('jupyterlab@~0.4.1/lib/docregistry/registry.js'));
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/index.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/default.js **/
jupyter.define('jupyterlab@0.4.1/lib/docregistry/default.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var CodeMirror = __jupyter_require__('codemirror@5.17.0/lib/codemirror.js');
	__jupyter_require__('codemirror@5.17.0/mode/meta.js');
	var signaling_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/signaling.js');
	/**
	 * The default implementation of a document model.
	 */
	var DocumentModel = (function () {
	    /**
	     * Construct a new document model.
	     */
	    function DocumentModel(languagePreference) {
	        this._text = '';
	        this._defaultLang = '';
	        this._dirty = false;
	        this._readOnly = false;
	        this._isDisposed = false;
	        this._defaultLang = languagePreference || '';
	    }
	    Object.defineProperty(DocumentModel.prototype, "isDisposed", {
	        /**
	         * Get whether the model factory has been disposed.
	         */
	        get: function () {
	            return this._isDisposed;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DocumentModel.prototype, "dirty", {
	        /**
	         * The dirty state of the document.
	         */
	        get: function () {
	            return this._dirty;
	        },
	        set: function (newValue) {
	            if (newValue === this._dirty) {
	                return;
	            }
	            var oldValue = this._dirty;
	            this._dirty = newValue;
	            this.stateChanged.emit({ name: 'dirty', oldValue: oldValue, newValue: newValue });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DocumentModel.prototype, "readOnly", {
	        /**
	         * The read only state of the document.
	         */
	        get: function () {
	            return this._readOnly;
	        },
	        set: function (newValue) {
	            if (newValue === this._readOnly) {
	                return;
	            }
	            var oldValue = this._readOnly;
	            this._readOnly = newValue;
	            this.stateChanged.emit({ name: 'readOnly', oldValue: oldValue, newValue: newValue });
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DocumentModel.prototype, "defaultKernelName", {
	        /**
	         * The default kernel name of the document.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DocumentModel.prototype, "defaultKernelLanguage", {
	        /**
	         * The default kernel language of the document.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._defaultLang;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the resources held by the document manager.
	     */
	    DocumentModel.prototype.dispose = function () {
	        this._isDisposed = true;
	    };
	    /**
	     * Serialize the model to a string.
	     */
	    DocumentModel.prototype.toString = function () {
	        return this._text;
	    };
	    /**
	     * Deserialize the model from a string.
	     *
	     * #### Notes
	     * Should emit a [contentChanged] signal.
	     */
	    DocumentModel.prototype.fromString = function (value) {
	        if (this._text === value) {
	            return;
	        }
	        this._text = value;
	        this.contentChanged.emit(void 0);
	        this.dirty = true;
	    };
	    /**
	     * Serialize the model to JSON.
	     */
	    DocumentModel.prototype.toJSON = function () {
	        return JSON.stringify(this._text);
	    };
	    /**
	     * Deserialize the model from JSON.
	     *
	     * #### Notes
	     * Should emit a [contentChanged] signal.
	     */
	    DocumentModel.prototype.fromJSON = function (value) {
	        this.fromString(JSON.parse(value));
	    };
	    return DocumentModel;
	}());
	exports.DocumentModel = DocumentModel;
	// Define the signals for the `DocumentModel` class.
	signaling_1.defineSignal(DocumentModel.prototype, 'contentChanged');
	signaling_1.defineSignal(DocumentModel.prototype, 'stateChanged');
	/**
	 * An implementation of a model factory for text files.
	 */
	var TextModelFactory = (function () {
	    function TextModelFactory() {
	        this._isDisposed = false;
	    }
	    Object.defineProperty(TextModelFactory.prototype, "name", {
	        /**
	         * The name of the model type.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return 'text';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextModelFactory.prototype, "fileType", {
	        /**
	         * The type of the file.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return 'file';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextModelFactory.prototype, "fileFormat", {
	        /**
	         * The format of the file.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return 'text';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextModelFactory.prototype, "isDisposed", {
	        /**
	         * Get whether the model factory has been disposed.
	         */
	        get: function () {
	            return this._isDisposed;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the resources held by the model factory.
	     */
	    TextModelFactory.prototype.dispose = function () {
	        this._isDisposed = true;
	    };
	    /**
	     * Create a new model.
	     *
	     * @param languagePreference - An optional kernel language preference.
	     *
	     * @returns A new document model.
	     */
	    TextModelFactory.prototype.createNew = function (languagePreference) {
	        return new DocumentModel(languagePreference);
	    };
	    /**
	     * Get the preferred kernel language given an extension.
	     */
	    TextModelFactory.prototype.preferredLanguage = function (ext) {
	        var mode = CodeMirror.findModeByExtension(ext.slice(1));
	        if (mode) {
	            return mode.mode;
	        }
	    };
	    return TextModelFactory;
	}());
	exports.TextModelFactory = TextModelFactory;
	/**
	 * An implementation of a model factory for base64 files.
	 */
	var Base64ModelFactory = (function (_super) {
	    __extends(Base64ModelFactory, _super);
	    function Base64ModelFactory() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Base64ModelFactory.prototype, "name", {
	        /**
	         * The name of the model type.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return 'base64';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Base64ModelFactory.prototype, "fileType", {
	        /**
	         * The type of the file.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return 'file';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Base64ModelFactory.prototype, "fileFormat", {
	        /**
	         * The format of the file.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return 'base64';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Base64ModelFactory;
	}(TextModelFactory));
	exports.Base64ModelFactory = Base64ModelFactory;
	/**
	 * The default implemetation of a widget factory.
	 */
	var ABCWidgetFactory = (function () {
	    function ABCWidgetFactory() {
	        this._isDisposed = false;
	    }
	    Object.defineProperty(ABCWidgetFactory.prototype, "isDisposed", {
	        /**
	         * Get whether the model factory has been disposed.
	         */
	        get: function () {
	            return this._isDisposed;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the resources held by the document manager.
	     */
	    ABCWidgetFactory.prototype.dispose = function () {
	        this._isDisposed = true;
	    };
	    return ABCWidgetFactory;
	}());
	exports.ABCWidgetFactory = ABCWidgetFactory;
	// Define the signals for the `ABCWidgetFactory` class.
	signaling_1.defineSignal(ABCWidgetFactory.prototype, 'widgetCreated');
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/default.js **/


/** START DEFINE BLOCK for codemirror@5.17.0/lib/codemirror.js **/
jupyter.define('codemirror@5.17.0/lib/codemirror.js', function (module, exports, __jupyter_require__) {
	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .
	
	(function(mod) {
	  if (true) // CommonJS
	    module.exports = mod();
	  else if (typeof define == "function" && define.amd) // AMD
	    return define([], mod);
	  else // Plain browser env
	    (this || window).CodeMirror = mod();
	})(function() {
	  "use strict";
	
	  // BROWSER SNIFFING
	
	  // Kludges for bugs and behavior differences that can't be feature
	  // detected are enabled based on userAgent etc sniffing.
	  var userAgent = navigator.userAgent;
	  var platform = navigator.platform;
	
	  var gecko = /gecko\/\d/i.test(userAgent);
	  var ie_upto10 = /MSIE \d/.test(userAgent);
	  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	  var ie = ie_upto10 || ie_11up;
	  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
	  var webkit = /WebKit\//.test(userAgent);
	  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	  var chrome = /Chrome\//.test(userAgent);
	  var presto = /Opera\//.test(userAgent);
	  var safari = /Apple Computer/.test(navigator.vendor);
	  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	  var phantom = /PhantomJS/.test(userAgent);
	
	  var ios = /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	  // This is woefully incomplete. Suggestions for alternative methods welcome.
	  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	  var mac = ios || /Mac/.test(platform);
	  var chromeOS = /\bCrOS\b/.test(userAgent);
	  var windows = /win/i.test(platform);
	
	  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	  if (presto_version) presto_version = Number(presto_version[1]);
	  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	  var captureRightClick = gecko || (ie && ie_version >= 9);
	
	  // Optimize some code when these features are not used.
	  var sawReadOnlySpans = false, sawCollapsedSpans = false;
	
	  // EDITOR CONSTRUCTOR
	
	  // A CodeMirror instance represents an editor. This is the object
	  // that user code is usually dealing with.
	
	  function CodeMirror(place, options) {
	    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);
	
	    this.options = options = options ? copyObj(options) : {};
	    // Determine effective options based on given values and defaults.
	    copyObj(defaults, options, false);
	    setGuttersForLineNumbers(options);
	
	    var doc = options.value;
	    if (typeof doc == "string") doc = new Doc(doc, options.mode, null, options.lineSeparator);
	    this.doc = doc;
	
	    var input = new CodeMirror.inputStyles[options.inputStyle](this);
	    var display = this.display = new Display(place, doc, input);
	    display.wrapper.CodeMirror = this;
	    updateGutters(this);
	    themeChanged(this);
	    if (options.lineWrapping)
	      this.display.wrapper.className += " CodeMirror-wrap";
	    if (options.autofocus && !mobile) display.input.focus();
	    initScrollbars(this);
	
	    this.state = {
	      keyMaps: [],  // stores maps added by addKeyMap
	      overlays: [], // highlighting overlays, as added by addOverlay
	      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	      overwrite: false,
	      delayingBlurEvent: false,
	      focused: false,
	      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
	      selectingText: false,
	      draggingText: false,
	      highlight: new Delayed(), // stores highlight worker timeout
	      keySeq: null,  // Unfinished key sequence
	      specialChars: null
	    };
	
	    var cm = this;
	
	    // Override magic textarea content restore that IE sometimes does
	    // on our hidden textarea on reload
	    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);
	
	    registerEventHandlers(this);
	    ensureGlobalHandlers();
	
	    startOperation(this);
	    this.curOp.forceUpdate = true;
	    attachDoc(this, doc);
	
	    if ((options.autofocus && !mobile) || cm.hasFocus())
	      setTimeout(bind(onFocus, this), 20);
	    else
	      onBlur(this);
	
	    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
	      optionHandlers[opt](this, options[opt], Init);
	    maybeUpdateLineNumberWidth(this);
	    if (options.finishInit) options.finishInit(this);
	    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
	    endOperation(this);
	    // Suppress optimizelegibility in Webkit, since it breaks text
	    // measuring on line wrapping boundaries.
	    if (webkit && options.lineWrapping &&
	        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	      display.lineDiv.style.textRendering = "auto";
	  }
	
	  // DISPLAY CONSTRUCTOR
	
	  // The display handles the DOM integration, both for input reading
	  // and content drawing. It holds references to DOM nodes and
	  // display-related state.
	
	  function Display(place, doc, input) {
	    var d = this;
	    this.input = input;
	
	    // Covers bottom-right square when both scrollbars are present.
	    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	    d.scrollbarFiller.setAttribute("cm-not-content", "true");
	    // Covers bottom of gutter when coverGutterNextToScrollbar is on
	    // and h scrollbar is present.
	    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	    d.gutterFiller.setAttribute("cm-not-content", "true");
	    // Will contain the actual code, positioned to cover the viewport.
	    d.lineDiv = elt("div", null, "CodeMirror-code");
	    // Elements are added to these to represent selection and cursors.
	    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	    // A visibility: hidden element used to find the size of things.
	    d.measure = elt("div", null, "CodeMirror-measure");
	    // When lines outside of the viewport are measured, they are drawn in this.
	    d.lineMeasure = elt("div", null, "CodeMirror-measure");
	    // Wraps everything that needs to exist inside the vertically-padded coordinate system
	    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                      null, "position: relative; outline: none");
	    // Moved around its parent to cover visible view.
	    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
	    // Set to the height of the document, allowing scrolling.
	    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	    d.sizerWidth = null;
	    // Behavior of elts with overflow: auto and padding is
	    // inconsistent across browsers. This is used to ensure the
	    // scrollable area is big enough.
	    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	    // Will contain the gutters, if any.
	    d.gutters = elt("div", null, "CodeMirror-gutters");
	    d.lineGutter = null;
	    // Actual scrollable element.
	    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	    d.scroller.setAttribute("tabIndex", "-1");
	    // The element in which the editor lives.
	    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
	
	    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;
	
	    if (place) {
	      if (place.appendChild) place.appendChild(d.wrapper);
	      else place(d.wrapper);
	    }
	
	    // Current rendered range (may be bigger than the view window).
	    d.viewFrom = d.viewTo = doc.first;
	    d.reportedViewFrom = d.reportedViewTo = doc.first;
	    // Information about the rendered lines.
	    d.view = [];
	    d.renderedView = null;
	    // Holds info about a single rendered line when it was rendered
	    // for measurement, while not in view.
	    d.externalMeasured = null;
	    // Empty space (in pixels) above the view
	    d.viewOffset = 0;
	    d.lastWrapHeight = d.lastWrapWidth = 0;
	    d.updateLineNumbers = null;
	
	    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	    d.scrollbarsClipped = false;
	
	    // Used to only resize the line number gutter when necessary (when
	    // the amount of lines crosses a boundary that makes its width change)
	    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	    // Set to true when a non-horizontal-scrolling line widget is
	    // added. As an optimization, line widget aligning is skipped when
	    // this is false.
	    d.alignWidgets = false;
	
	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	
	    // Tracks the maximum line length so that the horizontal scrollbar
	    // can be kept static when scrolling.
	    d.maxLine = null;
	    d.maxLineLength = 0;
	    d.maxLineChanged = false;
	
	    // Used for measuring wheel scrolling granularity
	    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
	
	    // True when shift is held down.
	    d.shift = false;
	
	    // Used to track whether anything happened since the context menu
	    // was opened.
	    d.selForContextMenu = null;
	
	    d.activeTouch = null;
	
	    input.init(d);
	  }
	
	  // STATE UPDATES
	
	  // Used to get the editor into a consistent state again when options change.
	
	  function loadMode(cm) {
	    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
	    resetModeState(cm);
	  }
	
	  function resetModeState(cm) {
	    cm.doc.iter(function(line) {
	      if (line.stateAfter) line.stateAfter = null;
	      if (line.styles) line.styles = null;
	    });
	    cm.doc.frontier = cm.doc.first;
	    startWorker(cm, 100);
	    cm.state.modeGen++;
	    if (cm.curOp) regChange(cm);
	  }
	
	  function wrappingChanged(cm) {
	    if (cm.options.lineWrapping) {
	      addClass(cm.display.wrapper, "CodeMirror-wrap");
	      cm.display.sizer.style.minWidth = "";
	      cm.display.sizerWidth = null;
	    } else {
	      rmClass(cm.display.wrapper, "CodeMirror-wrap");
	      findMaxLine(cm);
	    }
	    estimateLineHeights(cm);
	    regChange(cm);
	    clearCaches(cm);
	    setTimeout(function(){updateScrollbars(cm);}, 100);
	  }
	
	  // Returns a function that estimates the height of a line, to use as
	  // first approximation until the line becomes visible (and is thus
	  // properly measurable).
	  function estimateHeight(cm) {
	    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	    return function(line) {
	      if (lineIsHidden(cm.doc, line)) return 0;
	
	      var widgetsHeight = 0;
	      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
	        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
	      }
	
	      if (wrapping)
	        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
	      else
	        return widgetsHeight + th;
	    };
	  }
	
	  function estimateLineHeights(cm) {
	    var doc = cm.doc, est = estimateHeight(cm);
	    doc.iter(function(line) {
	      var estHeight = est(line);
	      if (estHeight != line.height) updateLineHeight(line, estHeight);
	    });
	  }
	
	  function themeChanged(cm) {
	    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	    clearCaches(cm);
	  }
	
	  function guttersChanged(cm) {
	    updateGutters(cm);
	    regChange(cm);
	    setTimeout(function(){alignHorizontally(cm);}, 20);
	  }
	
	  // Rebuild the gutter elements, ensure the margin to the left of the
	  // code matches their width.
	  function updateGutters(cm) {
	    var gutters = cm.display.gutters, specs = cm.options.gutters;
	    removeChildren(gutters);
	    for (var i = 0; i < specs.length; ++i) {
	      var gutterClass = specs[i];
	      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
	      if (gutterClass == "CodeMirror-linenumbers") {
	        cm.display.lineGutter = gElt;
	        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
	      }
	    }
	    gutters.style.display = i ? "" : "none";
	    updateGutterSpace(cm);
	  }
	
	  function updateGutterSpace(cm) {
	    var width = cm.display.gutters.offsetWidth;
	    cm.display.sizer.style.marginLeft = width + "px";
	  }
	
	  // Compute the character length of a line, taking into account
	  // collapsed ranges (see markText) that might hide parts, and join
	  // other lines onto it.
	  function lineLength(line) {
	    if (line.height == 0) return 0;
	    var len = line.text.length, merged, cur = line;
	    while (merged = collapsedSpanAtStart(cur)) {
	      var found = merged.find(0, true);
	      cur = found.from.line;
	      len += found.from.ch - found.to.ch;
	    }
	    cur = line;
	    while (merged = collapsedSpanAtEnd(cur)) {
	      var found = merged.find(0, true);
	      len -= cur.text.length - found.from.ch;
	      cur = found.to.line;
	      len += cur.text.length - found.to.ch;
	    }
	    return len;
	  }
	
	  // Find the longest line in the document.
	  function findMaxLine(cm) {
	    var d = cm.display, doc = cm.doc;
	    d.maxLine = getLine(doc, doc.first);
	    d.maxLineLength = lineLength(d.maxLine);
	    d.maxLineChanged = true;
	    doc.iter(function(line) {
	      var len = lineLength(line);
	      if (len > d.maxLineLength) {
	        d.maxLineLength = len;
	        d.maxLine = line;
	      }
	    });
	  }
	
	  // Make sure the gutters options contains the element
	  // "CodeMirror-linenumbers" when the lineNumbers option is true.
	  function setGuttersForLineNumbers(options) {
	    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
	    if (found == -1 && options.lineNumbers) {
	      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
	    } else if (found > -1 && !options.lineNumbers) {
	      options.gutters = options.gutters.slice(0);
	      options.gutters.splice(found, 1);
	    }
	  }
	
	  // SCROLLBARS
	
	  // Prepare DOM reads needed to update the scrollbars. Done in one
	  // shot to minimize update/measure roundtrips.
	  function measureForScrollbars(cm) {
	    var d = cm.display, gutterW = d.gutters.offsetWidth;
	    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	    return {
	      clientHeight: d.scroller.clientHeight,
	      viewHeight: d.wrapper.clientHeight,
	      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	      viewWidth: d.wrapper.clientWidth,
	      barLeft: cm.options.fixedGutter ? gutterW : 0,
	      docHeight: docH,
	      scrollHeight: docH + scrollGap(cm) + d.barHeight,
	      nativeBarWidth: d.nativeBarWidth,
	      gutterWidth: gutterW
	    };
	  }
	
	  function NativeScrollbars(place, scroll, cm) {
	    this.cm = cm;
	    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	    place(vert); place(horiz);
	
	    on(vert, "scroll", function() {
	      if (vert.clientHeight) scroll(vert.scrollTop, "vertical");
	    });
	    on(horiz, "scroll", function() {
	      if (horiz.clientWidth) scroll(horiz.scrollLeft, "horizontal");
	    });
	
	    this.checkedZeroWidth = false;
	    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
	  }
	
	  NativeScrollbars.prototype = copyObj({
	    update: function(measure) {
	      var needsH = measure.scrollWidth > measure.clientWidth + 1;
	      var needsV = measure.scrollHeight > measure.clientHeight + 1;
	      var sWidth = measure.nativeBarWidth;
	
	      if (needsV) {
	        this.vert.style.display = "block";
	        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	        // A bug in IE8 can cause this value to be negative, so guard it.
	        this.vert.firstChild.style.height =
	          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	      } else {
	        this.vert.style.display = "";
	        this.vert.firstChild.style.height = "0";
	      }
	
	      if (needsH) {
	        this.horiz.style.display = "block";
	        this.horiz.style.right = needsV ? sWidth + "px" : "0";
	        this.horiz.style.left = measure.barLeft + "px";
	        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	        this.horiz.firstChild.style.width =
	          (measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	      } else {
	        this.horiz.style.display = "";
	        this.horiz.firstChild.style.width = "0";
	      }
	
	      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	        if (sWidth == 0) this.zeroWidthHack();
	        this.checkedZeroWidth = true;
	      }
	
	      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};
	    },
	    setScrollLeft: function(pos) {
	      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;
	      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);
	    },
	    setScrollTop: function(pos) {
	      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;
	      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);
	    },
	    zeroWidthHack: function() {
	      var w = mac && !mac_geMountainLion ? "12px" : "18px";
	      this.horiz.style.height = this.vert.style.width = w;
	      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	      this.disableHoriz = new Delayed;
	      this.disableVert = new Delayed;
	    },
	    enableZeroWidthBar: function(bar, delay) {
	      bar.style.pointerEvents = "auto";
	      function maybeDisable() {
	        // To find out whether the scrollbar is still visible, we
	        // check whether the element under the pixel in the bottom
	        // left corner of the scrollbar box is the scrollbar box
	        // itself (when the bar is still visible) or its filler child
	        // (when the bar is hidden). If it is still visible, we keep
	        // it enabled, if it's hidden, we disable pointer events.
	        var box = bar.getBoundingClientRect();
	        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
	        if (elt != bar) bar.style.pointerEvents = "none";
	        else delay.set(1000, maybeDisable);
	      }
	      delay.set(1000, maybeDisable);
	    },
	    clear: function() {
	      var parent = this.horiz.parentNode;
	      parent.removeChild(this.horiz);
	      parent.removeChild(this.vert);
	    }
	  }, NativeScrollbars.prototype);
	
	  function NullScrollbars() {}
	
	  NullScrollbars.prototype = copyObj({
	    update: function() { return {bottom: 0, right: 0}; },
	    setScrollLeft: function() {},
	    setScrollTop: function() {},
	    clear: function() {}
	  }, NullScrollbars.prototype);
	
	  CodeMirror.scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};
	
	  function initScrollbars(cm) {
	    if (cm.display.scrollbars) {
	      cm.display.scrollbars.clear();
	      if (cm.display.scrollbars.addClass)
	        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	    }
	
	    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {
	      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	      // Prevent clicks in the scrollbars from killing focus
	      on(node, "mousedown", function() {
	        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);
	      });
	      node.setAttribute("cm-not-content", "true");
	    }, function(pos, axis) {
	      if (axis == "horizontal") setScrollLeft(cm, pos);
	      else setScrollTop(cm, pos);
	    }, cm);
	    if (cm.display.scrollbars.addClass)
	      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
	  }
	
	  function updateScrollbars(cm, measure) {
	    if (!measure) measure = measureForScrollbars(cm);
	    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	    updateScrollbarsInner(cm, measure);
	    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	        updateHeightsInViewport(cm);
	      updateScrollbarsInner(cm, measureForScrollbars(cm));
	      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	    }
	  }
	
	  // Re-synchronize the fake scrollbars with the actual size of the
	  // content.
	  function updateScrollbarsInner(cm, measure) {
	    var d = cm.display;
	    var sizes = d.scrollbars.update(measure);
	
	    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"
	
	    if (sizes.right && sizes.bottom) {
	      d.scrollbarFiller.style.display = "block";
	      d.scrollbarFiller.style.height = sizes.bottom + "px";
	      d.scrollbarFiller.style.width = sizes.right + "px";
	    } else d.scrollbarFiller.style.display = "";
	    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	      d.gutterFiller.style.display = "block";
	      d.gutterFiller.style.height = sizes.bottom + "px";
	      d.gutterFiller.style.width = measure.gutterWidth + "px";
	    } else d.gutterFiller.style.display = "";
	  }
	
	  // Compute the lines that are visible in a given viewport (defaults
	  // the the current scroll position). viewport may contain top,
	  // height, and ensure (see op.scrollToPos) properties.
	  function visibleLines(display, doc, viewport) {
	    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	    top = Math.floor(top - paddingTop(display));
	    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
	
	    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	    // forces those lines into the viewport (if possible).
	    if (viewport && viewport.ensure) {
	      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	      if (ensureFrom < from) {
	        from = ensureFrom;
	        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	        to = ensureTo;
	      }
	    }
	    return {from: from, to: Math.max(to, from + 1)};
	  }
	
	  // LINE NUMBERS
	
	  // Re-align line numbers and gutter marks to compensate for
	  // horizontal scrolling.
	  function alignHorizontally(cm) {
	    var display = cm.display, view = display.view;
	    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
	    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	    var gutterW = display.gutters.offsetWidth, left = comp + "px";
	    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
	      if (cm.options.fixedGutter && view[i].gutter)
	        view[i].gutter.style.left = left;
	      var align = view[i].alignable;
	      if (align) for (var j = 0; j < align.length; j++)
	        align[j].style.left = left;
	    }
	    if (cm.options.fixedGutter)
	      display.gutters.style.left = (comp + gutterW) + "px";
	  }
	
	  // Used to ensure that the line number gutter is still the right
	  // size for the current document size. Returns true when an update
	  // is needed.
	  function maybeUpdateLineNumberWidth(cm) {
	    if (!cm.options.lineNumbers) return false;
	    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	    if (last.length != display.lineNumChars) {
	      var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
	      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	      display.lineGutter.style.width = "";
	      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	      display.lineNumWidth = display.lineNumInnerWidth + padding;
	      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	      display.lineGutter.style.width = display.lineNumWidth + "px";
	      updateGutterSpace(cm);
	      return true;
	    }
	    return false;
	  }
	
	  function lineNumberFor(options, i) {
	    return String(options.lineNumberFormatter(i + options.firstLineNumber));
	  }
	
	  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	  // but using getBoundingClientRect to get a sub-pixel-accurate
	  // result.
	  function compensateForHScroll(display) {
	    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
	  }
	
	  // DISPLAY DRAWING
	
	  function DisplayUpdate(cm, viewport, force) {
	    var display = cm.display;
	
	    this.viewport = viewport;
	    // Store some values that we'll need later (but don't want to force a relayout for)
	    this.visible = visibleLines(display, cm.doc, viewport);
	    this.editorIsHidden = !display.wrapper.offsetWidth;
	    this.wrapperHeight = display.wrapper.clientHeight;
	    this.wrapperWidth = display.wrapper.clientWidth;
	    this.oldDisplayWidth = displayWidth(cm);
	    this.force = force;
	    this.dims = getDimensions(cm);
	    this.events = [];
	  }
	
	  DisplayUpdate.prototype.signal = function(emitter, type) {
	    if (hasHandler(emitter, type))
	      this.events.push(arguments);
	  };
	  DisplayUpdate.prototype.finish = function() {
	    for (var i = 0; i < this.events.length; i++)
	      signal.apply(null, this.events[i]);
	  };
	
	  function maybeClipScrollbars(cm) {
	    var display = cm.display;
	    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	      display.heightForcer.style.height = scrollGap(cm) + "px";
	      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	      display.scrollbarsClipped = true;
	    }
	  }
	
	  // Does the actual updating of the line display. Bails out
	  // (returning false) when there is nothing to be done and forced is
	  // false.
	  function updateDisplayIfNeeded(cm, update) {
	    var display = cm.display, doc = cm.doc;
	
	    if (update.editorIsHidden) {
	      resetView(cm);
	      return false;
	    }
	
	    // Bail out if the visible area is already rendered and nothing changed.
	    if (!update.force &&
	        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	        display.renderedView == display.view && countDirtyView(cm) == 0)
	      return false;
	
	    if (maybeUpdateLineNumberWidth(cm)) {
	      resetView(cm);
	      update.dims = getDimensions(cm);
	    }
	
	    // Compute a suitable new viewport (from & to)
	    var end = doc.first + doc.size;
	    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
	    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
	    if (sawCollapsedSpans) {
	      from = visualLineNo(cm.doc, from);
	      to = visualLineEndNo(cm.doc, to);
	    }
	
	    var different = from != display.viewFrom || to != display.viewTo ||
	      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	    adjustView(cm, from, to);
	
	    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	    // Position the mover div to align with the current scroll position
	    cm.display.mover.style.top = display.viewOffset + "px";
	
	    var toUpdate = countDirtyView(cm);
	    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	      return false;
	
	    // For big changes, we hide the enclosing element during the
	    // update, since that speeds up the operations on most browsers.
	    var focused = activeElt();
	    if (toUpdate > 4) display.lineDiv.style.display = "none";
	    patchDisplay(cm, display.updateLineNumbers, update.dims);
	    if (toUpdate > 4) display.lineDiv.style.display = "";
	    display.renderedView = display.view;
	    // There might have been a widget with a focused element that got
	    // hidden or updated, if so re-focus it.
	    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();
	
	    // Prevent selection and cursors from interfering with the scroll
	    // width and height.
	    removeChildren(display.cursorDiv);
	    removeChildren(display.selectionDiv);
	    display.gutters.style.height = display.sizer.style.minHeight = 0;
	
	    if (different) {
	      display.lastWrapHeight = update.wrapperHeight;
	      display.lastWrapWidth = update.wrapperWidth;
	      startWorker(cm, 400);
	    }
	
	    display.updateLineNumbers = null;
	
	    return true;
	  }
	
	  function postUpdateDisplay(cm, update) {
	    var viewport = update.viewport;
	
	    for (var first = true;; first = false) {
	      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	        // Clip forced viewport to actual scrollable area.
	        if (viewport && viewport.top != null)
	          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};
	        // Updated line heights might result in the drawn area not
	        // actually covering the viewport. Keep looping until it does.
	        update.visible = visibleLines(cm.display, cm.doc, viewport);
	        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	          break;
	      }
	      if (!updateDisplayIfNeeded(cm, update)) break;
	      updateHeightsInViewport(cm);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	    }
	
	    update.signal(cm, "update", cm);
	    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	    }
	  }
	
	  function updateDisplaySimple(cm, viewport) {
	    var update = new DisplayUpdate(cm, viewport);
	    if (updateDisplayIfNeeded(cm, update)) {
	      updateHeightsInViewport(cm);
	      postUpdateDisplay(cm, update);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	      update.finish();
	    }
	  }
	
	  function setDocumentHeight(cm, measure) {
	    cm.display.sizer.style.minHeight = measure.docHeight + "px";
	    cm.display.heightForcer.style.top = measure.docHeight + "px";
	    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	  }
	
	  // Read the actual heights of the rendered lines, and update their
	  // stored heights to match.
	  function updateHeightsInViewport(cm) {
	    var display = cm.display;
	    var prevBottom = display.lineDiv.offsetTop;
	    for (var i = 0; i < display.view.length; i++) {
	      var cur = display.view[i], height;
	      if (cur.hidden) continue;
	      if (ie && ie_version < 8) {
	        var bot = cur.node.offsetTop + cur.node.offsetHeight;
	        height = bot - prevBottom;
	        prevBottom = bot;
	      } else {
	        var box = cur.node.getBoundingClientRect();
	        height = box.bottom - box.top;
	      }
	      var diff = cur.line.height - height;
	      if (height < 2) height = textHeight(display);
	      if (diff > .001 || diff < -.001) {
	        updateLineHeight(cur.line, height);
	        updateWidgetHeight(cur.line);
	        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
	          updateWidgetHeight(cur.rest[j]);
	      }
	    }
	  }
	
	  // Read and store the height of line widgets associated with the
	  // given line.
	  function updateWidgetHeight(line) {
	    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
	      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
	  }
	
	  // Do a bulk-read of the DOM positions and sizes needed to draw the
	  // view, so that we don't interleave reading and writing to the DOM.
	  function getDimensions(cm) {
	    var d = cm.display, left = {}, width = {};
	    var gutterLeft = d.gutters.clientLeft;
	    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
	      width[cm.options.gutters[i]] = n.clientWidth;
	    }
	    return {fixedPos: compensateForHScroll(d),
	            gutterTotalWidth: d.gutters.offsetWidth,
	            gutterLeft: left,
	            gutterWidth: width,
	            wrapperWidth: d.wrapper.clientWidth};
	  }
	
	  // Sync the actual display DOM structure with display.view, removing
	  // nodes for lines that are no longer in view, and creating the ones
	  // that are not there yet, and updating the ones that are out of
	  // date.
	  function patchDisplay(cm, updateNumbersFrom, dims) {
	    var display = cm.display, lineNumbers = cm.options.lineNumbers;
	    var container = display.lineDiv, cur = container.firstChild;
	
	    function rm(node) {
	      var next = node.nextSibling;
	      // Works around a throw-scroll bug in OS X Webkit
	      if (webkit && mac && cm.display.currentWheelTarget == node)
	        node.style.display = "none";
	      else
	        node.parentNode.removeChild(node);
	      return next;
	    }
	
	    var view = display.view, lineN = display.viewFrom;
	    // Loop over the elements in the view, syncing cur (the DOM nodes
	    // in display.lineDiv) with the view as we go.
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (lineView.hidden) {
	      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	        var node = buildLineElement(cm, lineView, lineN, dims);
	        container.insertBefore(node, cur);
	      } else { // Already drawn
	        while (cur != lineView.node) cur = rm(cur);
	        var updateNumber = lineNumbers && updateNumbersFrom != null &&
	          updateNumbersFrom <= lineN && lineView.lineNumber;
	        if (lineView.changes) {
	          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
	          updateLineForChanges(cm, lineView, lineN, dims);
	        }
	        if (updateNumber) {
	          removeChildren(lineView.lineNumber);
	          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	        }
	        cur = lineView.node.nextSibling;
	      }
	      lineN += lineView.size;
	    }
	    while (cur) cur = rm(cur);
	  }
	
	  // When an aspect of a line changes, a string is added to
	  // lineView.changes. This updates the relevant part of the line's
	  // DOM structure.
	  function updateLineForChanges(cm, lineView, lineN, dims) {
	    for (var j = 0; j < lineView.changes.length; j++) {
	      var type = lineView.changes[j];
	      if (type == "text") updateLineText(cm, lineView);
	      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
	      else if (type == "class") updateLineClasses(lineView);
	      else if (type == "widget") updateLineWidgets(cm, lineView, dims);
	    }
	    lineView.changes = null;
	  }
	
	  // Lines with gutter elements, widgets or a background class need to
	  // be wrapped, and have the extra elements added to the wrapper div
	  function ensureLineWrapped(lineView) {
	    if (lineView.node == lineView.text) {
	      lineView.node = elt("div", null, null, "position: relative");
	      if (lineView.text.parentNode)
	        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
	      lineView.node.appendChild(lineView.text);
	      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;
	    }
	    return lineView.node;
	  }
	
	  function updateLineBackground(lineView) {
	    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	    if (cls) cls += " CodeMirror-linebackground";
	    if (lineView.background) {
	      if (cls) lineView.background.className = cls;
	      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	    } else if (cls) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	    }
	  }
	
	  // Wrapper around buildLineContent which will reuse the structure
	  // in display.externalMeasured when possible.
	  function getLineContent(cm, lineView) {
	    var ext = cm.display.externalMeasured;
	    if (ext && ext.line == lineView.line) {
	      cm.display.externalMeasured = null;
	      lineView.measure = ext.measure;
	      return ext.built;
	    }
	    return buildLineContent(cm, lineView);
	  }
	
	  // Redraw the line's text. Interacts with the background and text
	  // classes because the mode may output tokens that influence these
	  // classes.
	  function updateLineText(cm, lineView) {
	    var cls = lineView.text.className;
	    var built = getLineContent(cm, lineView);
	    if (lineView.text == lineView.node) lineView.node = built.pre;
	    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	    lineView.text = built.pre;
	    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	      lineView.bgClass = built.bgClass;
	      lineView.textClass = built.textClass;
	      updateLineClasses(lineView);
	    } else if (cls) {
	      lineView.text.className = cls;
	    }
	  }
	
	  function updateLineClasses(lineView) {
	    updateLineBackground(lineView);
	    if (lineView.line.wrapClass)
	      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
	    else if (lineView.node != lineView.text)
	      lineView.node.className = "";
	    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	    lineView.text.className = textClass || "";
	  }
	
	  function updateLineGutter(cm, lineView, lineN, dims) {
	    if (lineView.gutter) {
	      lineView.node.removeChild(lineView.gutter);
	      lineView.gutter = null;
	    }
	    if (lineView.gutterBackground) {
	      lineView.node.removeChild(lineView.gutterBackground);
	      lineView.gutterBackground = null;
	    }
	    if (lineView.line.gutterClass) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                      "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +
	                                      "px; width: " + dims.gutterTotalWidth + "px");
	      wrap.insertBefore(lineView.gutterBackground, lineView.text);
	    }
	    var markers = lineView.line.gutterMarkers;
	    if (cm.options.lineNumbers || markers) {
	      var wrap = ensureLineWrapped(lineView);
	      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " +
	                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
	      cm.display.input.setUneditable(gutterWrap);
	      wrap.insertBefore(gutterWrap, lineView.text);
	      if (lineView.line.gutterClass)
	        gutterWrap.className += " " + lineView.line.gutterClass;
	      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	        lineView.lineNumber = gutterWrap.appendChild(
	          elt("div", lineNumberFor(cm.options, lineN),
	              "CodeMirror-linenumber CodeMirror-gutter-elt",
	              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
	              + cm.display.lineNumInnerWidth + "px"));
	      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
	        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
	        if (found)
	          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
	                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
	      }
	    }
	  }
	
	  function updateLineWidgets(cm, lineView, dims) {
	    if (lineView.alignable) lineView.alignable = null;
	    for (var node = lineView.node.firstChild, next; node; node = next) {
	      var next = node.nextSibling;
	      if (node.className == "CodeMirror-linewidget")
	        lineView.node.removeChild(node);
	    }
	    insertLineWidgets(cm, lineView, dims);
	  }
	
	  // Build a line's DOM representation from scratch
	  function buildLineElement(cm, lineView, lineN, dims) {
	    var built = getLineContent(cm, lineView);
	    lineView.text = lineView.node = built.pre;
	    if (built.bgClass) lineView.bgClass = built.bgClass;
	    if (built.textClass) lineView.textClass = built.textClass;
	
	    updateLineClasses(lineView);
	    updateLineGutter(cm, lineView, lineN, dims);
	    insertLineWidgets(cm, lineView, dims);
	    return lineView.node;
	  }
	
	  // A lineView may contain multiple logical lines (when merged by
	  // collapsed spans). The widgets for all of them need to be drawn.
	  function insertLineWidgets(cm, lineView, dims) {
	    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
	      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
	  }
	
	  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	    if (!line.widgets) return;
	    var wrap = ensureLineWrapped(lineView);
	    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
	      if (!widget.handleMouseEvents) node.setAttribute("cm-ignore-events", "true");
	      positionLineWidget(widget, node, lineView, dims);
	      cm.display.input.setUneditable(node);
	      if (allowAbove && widget.above)
	        wrap.insertBefore(node, lineView.gutter || lineView.text);
	      else
	        wrap.appendChild(node);
	      signalLater(widget, "redraw");
	    }
	  }
	
	  function positionLineWidget(widget, node, lineView, dims) {
	    if (widget.noHScroll) {
	      (lineView.alignable || (lineView.alignable = [])).push(node);
	      var width = dims.wrapperWidth;
	      node.style.left = dims.fixedPos + "px";
	      if (!widget.coverGutter) {
	        width -= dims.gutterTotalWidth;
	        node.style.paddingLeft = dims.gutterTotalWidth + "px";
	      }
	      node.style.width = width + "px";
	    }
	    if (widget.coverGutter) {
	      node.style.zIndex = 5;
	      node.style.position = "relative";
	      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
	    }
	  }
	
	  // POSITION OBJECT
	
	  // A Pos instance represents a position within the text.
	  var Pos = CodeMirror.Pos = function(line, ch) {
	    if (!(this instanceof Pos)) return new Pos(line, ch);
	    this.line = line; this.ch = ch;
	  };
	
	  // Compare two positions, return 0 if they are the same, a negative
	  // number when a is less, and a positive number otherwise.
	  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };
	
	  function copyPos(x) {return Pos(x.line, x.ch);}
	  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
	  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }
	
	  // INPUT HANDLING
	
	  function ensureFocus(cm) {
	    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	  }
	
	  // This will be set to a {lineWise: bool, text: [string]} object, so
	  // that, when pasting, we know what kind of selections the copied
	  // text was made out of.
	  var lastCopied = null;
	
	  function applyTextInput(cm, inserted, deleted, sel, origin) {
	    var doc = cm.doc;
	    cm.display.shift = false;
	    if (!sel) sel = doc.sel;
	
	    var paste = cm.state.pasteIncoming || origin == "paste";
	    var textLines = doc.splitLines(inserted), multiPaste = null
	    // When pasing N lines into N selections, insert one line per selection
	    if (paste && sel.ranges.length > 1) {
	      if (lastCopied && lastCopied.text.join("\n") == inserted) {
	        if (sel.ranges.length % lastCopied.text.length == 0) {
	          multiPaste = [];
	          for (var i = 0; i < lastCopied.text.length; i++)
	            multiPaste.push(doc.splitLines(lastCopied.text[i]));
	        }
	      } else if (textLines.length == sel.ranges.length) {
	        multiPaste = map(textLines, function(l) { return [l]; });
	      }
	    }
	
	    // Normal behavior is to insert the new text into every selection
	    for (var i = sel.ranges.length - 1; i >= 0; i--) {
	      var range = sel.ranges[i];
	      var from = range.from(), to = range.to();
	      if (range.empty()) {
	        if (deleted && deleted > 0) // Handle deletion
	          from = Pos(from.line, from.ch - deleted);
	        else if (cm.state.overwrite && !paste) // Handle overwrite
	          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
	        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	          from = to = Pos(from.line, 0)
	      }
	      var updateInput = cm.curOp.updateInput;
	      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
	                         origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
	      makeChange(cm.doc, changeEvent);
	      signalLater(cm, "inputRead", cm, changeEvent);
	    }
	    if (inserted && !paste)
	      triggerElectric(cm, inserted);
	
	    ensureCursorVisible(cm);
	    cm.curOp.updateInput = updateInput;
	    cm.curOp.typing = true;
	    cm.state.pasteIncoming = cm.state.cutIncoming = false;
	  }
	
	  function handlePaste(e, cm) {
	    var pasted = e.clipboardData && e.clipboardData.getData("text/plain");
	    if (pasted) {
	      e.preventDefault();
	      if (!cm.isReadOnly() && !cm.options.disableInput)
	        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, "paste"); });
	      return true;
	    }
	  }
	
	  function triggerElectric(cm, inserted) {
	    // When an 'electric' character is inserted, immediately trigger a reindent
	    if (!cm.options.electricChars || !cm.options.smartIndent) return;
	    var sel = cm.doc.sel;
	
	    for (var i = sel.ranges.length - 1; i >= 0; i--) {
	      var range = sel.ranges[i];
	      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;
	      var mode = cm.getModeAt(range.head);
	      var indented = false;
	      if (mode.electricChars) {
	        for (var j = 0; j < mode.electricChars.length; j++)
	          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	            indented = indentLine(cm, range.head.line, "smart");
	            break;
	          }
	      } else if (mode.electricInput) {
	        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
	          indented = indentLine(cm, range.head.line, "smart");
	      }
	      if (indented) signalLater(cm, "electricInput", cm, range.head.line);
	    }
	  }
	
	  function copyableRanges(cm) {
	    var text = [], ranges = [];
	    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	      var line = cm.doc.sel.ranges[i].head.line;
	      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	      ranges.push(lineRange);
	      text.push(cm.getRange(lineRange.anchor, lineRange.head));
	    }
	    return {text: text, ranges: ranges};
	  }
	
	  function disableBrowserMagic(field) {
	    field.setAttribute("autocorrect", "off");
	    field.setAttribute("autocapitalize", "off");
	    field.setAttribute("spellcheck", "false");
	  }
	
	  // TEXTAREA INPUT STYLE
	
	  function TextareaInput(cm) {
	    this.cm = cm;
	    // See input.poll and input.reset
	    this.prevInput = "";
	
	    // Flag that indicates whether we expect input to appear real soon
	    // now (after some event like 'keypress' or 'input') and are
	    // polling intensively.
	    this.pollingFast = false;
	    // Self-resetting timeout for the poller
	    this.polling = new Delayed();
	    // Tracks when input.reset has punted to just putting a short
	    // string into the textarea instead of the full selection.
	    this.inaccurateSelection = false;
	    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	    this.hasSelection = false;
	    this.composing = null;
	  };
	
	  function hiddenTextarea() {
	    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	    // The textarea is kept positioned near the cursor to prevent the
	    // fact that it'll be scrolled into view on input from scrolling
	    // our fake cursor out of view. On webkit, when wrap=off, paste is
	    // very slow. So make the area wide instead.
	    if (webkit) te.style.width = "1000px";
	    else te.setAttribute("wrap", "off");
	    // If border: 0; -- iOS fails to open keyboard (issue #1287)
	    if (ios) te.style.border = "1px solid black";
	    disableBrowserMagic(te);
	    return div;
	  }
	
	  TextareaInput.prototype = copyObj({
	    init: function(display) {
	      var input = this, cm = this.cm;
	
	      // Wraps and hides input textarea
	      var div = this.wrapper = hiddenTextarea();
	      // The semihidden textarea that is focused when the editor is
	      // focused, and receives input.
	      var te = this.textarea = div.firstChild;
	      display.wrapper.insertBefore(div, display.wrapper.firstChild);
	
	      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	      if (ios) te.style.width = "0px";
	
	      on(te, "input", function() {
	        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;
	        input.poll();
	      });
	
	      on(te, "paste", function(e) {
	        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return
	
	        cm.state.pasteIncoming = true;
	        input.fastPoll();
	      });
	
	      function prepareCopyCut(e) {
	        if (signalDOMEvent(cm, e)) return
	        if (cm.somethingSelected()) {
	          lastCopied = {lineWise: false, text: cm.getSelections()};
	          if (input.inaccurateSelection) {
	            input.prevInput = "";
	            input.inaccurateSelection = false;
	            te.value = lastCopied.text.join("\n");
	            selectInput(te);
	          }
	        } else if (!cm.options.lineWiseCopyCut) {
	          return;
	        } else {
	          var ranges = copyableRanges(cm);
	          lastCopied = {lineWise: true, text: ranges.text};
	          if (e.type == "cut") {
	            cm.setSelections(ranges.ranges, null, sel_dontScroll);
	          } else {
	            input.prevInput = "";
	            te.value = ranges.text.join("\n");
	            selectInput(te);
	          }
	        }
	        if (e.type == "cut") cm.state.cutIncoming = true;
	      }
	      on(te, "cut", prepareCopyCut);
	      on(te, "copy", prepareCopyCut);
	
	      on(display.scroller, "paste", function(e) {
	        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;
	        cm.state.pasteIncoming = true;
	        input.focus();
	      });
	
	      // Prevent normal selection in the editor (we handle our own)
	      on(display.lineSpace, "selectstart", function(e) {
	        if (!eventInWidget(display, e)) e_preventDefault(e);
	      });
	
	      on(te, "compositionstart", function() {
	        var start = cm.getCursor("from");
	        if (input.composing) input.composing.range.clear()
	        input.composing = {
	          start: start,
	          range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	        };
	      });
	      on(te, "compositionend", function() {
	        if (input.composing) {
	          input.poll();
	          input.composing.range.clear();
	          input.composing = null;
	        }
	      });
	    },
	
	    prepareSelection: function() {
	      // Redraw the selection and/or cursor
	      var cm = this.cm, display = cm.display, doc = cm.doc;
	      var result = prepareSelection(cm);
	
	      // Move the hidden textarea near the cursor to prevent scrolling artifacts
	      if (cm.options.moveInputWithCursor) {
	        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                            headPos.top + lineOff.top - wrapOff.top));
	        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                             headPos.left + lineOff.left - wrapOff.left));
	      }
	
	      return result;
	    },
	
	    showSelection: function(drawn) {
	      var cm = this.cm, display = cm.display;
	      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	      if (drawn.teTop != null) {
	        this.wrapper.style.top = drawn.teTop + "px";
	        this.wrapper.style.left = drawn.teLeft + "px";
	      }
	    },
	
	    // Reset the input to correspond to the selection (or to be empty,
	    // when not typing and nothing is selected)
	    reset: function(typing) {
	      if (this.contextMenuPending) return;
	      var minimal, selected, cm = this.cm, doc = cm.doc;
	      if (cm.somethingSelected()) {
	        this.prevInput = "";
	        var range = doc.sel.primary();
	        minimal = hasCopyEvent &&
	          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
	        var content = minimal ? "-" : selected || cm.getSelection();
	        this.textarea.value = content;
	        if (cm.state.focused) selectInput(this.textarea);
	        if (ie && ie_version >= 9) this.hasSelection = content;
	      } else if (!typing) {
	        this.prevInput = this.textarea.value = "";
	        if (ie && ie_version >= 9) this.hasSelection = null;
	      }
	      this.inaccurateSelection = minimal;
	    },
	
	    getField: function() { return this.textarea; },
	
	    supportsTouch: function() { return false; },
	
	    focus: function() {
	      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	        try { this.textarea.focus(); }
	        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	      }
	    },
	
	    blur: function() { this.textarea.blur(); },
	
	    resetPosition: function() {
	      this.wrapper.style.top = this.wrapper.style.left = 0;
	    },
	
	    receivedFocus: function() { this.slowPoll(); },
	
	    // Poll for input changes, using the normal rate of polling. This
	    // runs as long as the editor is focused.
	    slowPoll: function() {
	      var input = this;
	      if (input.pollingFast) return;
	      input.polling.set(this.cm.options.pollInterval, function() {
	        input.poll();
	        if (input.cm.state.focused) input.slowPoll();
	      });
	    },
	
	    // When an event has just come in that is likely to add or change
	    // something in the input textarea, we poll faster, to ensure that
	    // the change appears on the screen quickly.
	    fastPoll: function() {
	      var missed = false, input = this;
	      input.pollingFast = true;
	      function p() {
	        var changed = input.poll();
	        if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	        else {input.pollingFast = false; input.slowPoll();}
	      }
	      input.polling.set(20, p);
	    },
	
	    // Read input from the textarea, and update the document to match.
	    // When something is selected, it is present in the textarea, and
	    // selected (unless it is huge, in which case a placeholder is
	    // used). When nothing is selected, the cursor sits after previously
	    // seen text (can be empty), which is stored in prevInput (we must
	    // not reset the textarea when typing, because that breaks IME).
	    poll: function() {
	      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	      // Since this is called a *lot*, try to bail out as cheaply as
	      // possible when it is clear that nothing happened. hasSelection
	      // will be the case when there is a lot of text in the textarea,
	      // in which case reading its value would be expensive.
	      if (this.contextMenuPending || !cm.state.focused ||
	          (hasSelection(input) && !prevInput && !this.composing) ||
	          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	        return false;
	
	      var text = input.value;
	      // If nothing changed, bail.
	      if (text == prevInput && !cm.somethingSelected()) return false;
	      // Work around nonsensical selection resetting in IE9/10, and
	      // inexplicable appearance of private area unicode characters on
	      // some key combos in Mac (#2689).
	      if (ie && ie_version >= 9 && this.hasSelection === text ||
	          mac && /[\uf700-\uf7ff]/.test(text)) {
	        cm.display.input.reset();
	        return false;
	      }
	
	      if (cm.doc.sel == cm.display.selForContextMenu) {
	        var first = text.charCodeAt(0);
	        if (first == 0x200b && !prevInput) prevInput = "\u200b";
	        if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo"); }
	      }
	      // Find the part of the input that is actually new
	      var same = 0, l = Math.min(prevInput.length, text.length);
	      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
	
	      var self = this;
	      runInOp(cm, function() {
	        applyTextInput(cm, text.slice(same), prevInput.length - same,
	                       null, self.composing ? "*compose" : null);
	
	        // Don't leave long text in the textarea, since it makes further polling slow
	        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = self.prevInput = "";
	        else self.prevInput = text;
	
	        if (self.composing) {
	          self.composing.range.clear();
	          self.composing.range = cm.markText(self.composing.start, cm.getCursor("to"),
	                                             {className: "CodeMirror-composing"});
	        }
	      });
	      return true;
	    },
	
	    ensurePolled: function() {
	      if (this.pollingFast && this.poll()) this.pollingFast = false;
	    },
	
	    onKeyPress: function() {
	      if (ie && ie_version >= 9) this.hasSelection = null;
	      this.fastPoll();
	    },
	
	    onContextMenu: function(e) {
	      var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	      if (!pos || presto) return; // Opera is difficult.
	
	      // Reset the current text selection only if the click is done outside of the selection
	      // and 'resetSelectionOnContextMenu' option is true.
	      var reset = cm.options.resetSelectionOnContextMenu;
	      if (reset && cm.doc.sel.contains(pos) == -1)
	        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
	
	      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	      input.wrapper.style.cssText = "position: absolute"
	      var wrapperBox = input.wrapper.getBoundingClientRect()
	      te.style.cssText = "position: absolute; width: 30px; height: 30px; top: " + (e.clientY - wrapperBox.top - 5) +
	        "px; left: " + (e.clientX - wrapperBox.left - 5) + "px; z-index: 1000; background: " +
	        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
	        "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)
	      display.input.focus();
	      if (webkit) window.scrollTo(null, oldScrollY);
	      display.input.reset();
	      // Adds "Select all" to context menu in FF
	      if (!cm.somethingSelected()) te.value = input.prevInput = " ";
	      input.contextMenuPending = true;
	      display.selForContextMenu = cm.doc.sel;
	      clearTimeout(display.detectingSelectAll);
	
	      // Select-all will be greyed out if there's nothing to select, so
	      // this adds a zero-width space so that we can later check whether
	      // it got selected.
	      function prepareSelectAllHack() {
	        if (te.selectionStart != null) {
	          var selected = cm.somethingSelected();
	          var extval = "\u200b" + (selected ? te.value : "");
	          te.value = "\u21da"; // Used to catch context-menu undo
	          te.value = extval;
	          input.prevInput = selected ? "" : "\u200b";
	          te.selectionStart = 1; te.selectionEnd = extval.length;
	          // Re-set this, in case some other handler touched the
	          // selection in the meantime.
	          display.selForContextMenu = cm.doc.sel;
	        }
	      }
	      function rehide() {
	        input.contextMenuPending = false;
	        input.wrapper.style.cssText = oldWrapperCSS
	        te.style.cssText = oldCSS;
	        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
	
	        // Try to detect the user choosing select-all
	        if (te.selectionStart != null) {
	          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();
	          var i = 0, poll = function() {
	            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	                te.selectionEnd > 0 && input.prevInput == "\u200b")
	              operation(cm, commands.selectAll)(cm);
	            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);
	            else display.input.reset();
	          };
	          display.detectingSelectAll = setTimeout(poll, 200);
	        }
	      }
	
	      if (ie && ie_version >= 9) prepareSelectAllHack();
	      if (captureRightClick) {
	        e_stop(e);
	        var mouseup = function() {
	          off(window, "mouseup", mouseup);
	          setTimeout(rehide, 20);
	        };
	        on(window, "mouseup", mouseup);
	      } else {
	        setTimeout(rehide, 50);
	      }
	    },
	
	    readOnlyChanged: function(val) {
	      if (!val) this.reset();
	    },
	
	    setUneditable: nothing,
	
	    needsContentAttribute: false
	  }, TextareaInput.prototype);
	
	  // CONTENTEDITABLE INPUT STYLE
	
	  function ContentEditableInput(cm) {
	    this.cm = cm;
	    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	    this.polling = new Delayed();
	    this.gracePeriod = false;
	  }
	
	  ContentEditableInput.prototype = copyObj({
	    init: function(display) {
	      var input = this, cm = input.cm;
	      var div = input.div = display.lineDiv;
	      disableBrowserMagic(div);
	
	      on(div, "paste", function(e) {
	        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);
	      })
	
	      on(div, "compositionstart", function(e) {
	        var data = e.data;
	        input.composing = {sel: cm.doc.sel, data: data, startData: data};
	        if (!data) return;
	        var prim = cm.doc.sel.primary();
	        var line = cm.getLine(prim.head.line);
	        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
	        if (found > -1 && found <= prim.head.ch)
	          input.composing.sel = simpleSelection(Pos(prim.head.line, found),
	                                                Pos(prim.head.line, found + data.length));
	      });
	      on(div, "compositionupdate", function(e) {
	        input.composing.data = e.data;
	      });
	      on(div, "compositionend", function(e) {
	        var ours = input.composing;
	        if (!ours) return;
	        if (e.data != ours.startData && !/\u200b/.test(e.data))
	          ours.data = e.data;
	        // Need a small delay to prevent other code (input event,
	        // selection polling) from doing damage when fired right after
	        // compositionend.
	        setTimeout(function() {
	          if (!ours.handled)
	            input.applyComposition(ours);
	          if (input.composing == ours)
	            input.composing = null;
	        }, 50);
	      });
	
	      on(div, "touchstart", function() {
	        input.forceCompositionEnd();
	      });
	
	      on(div, "input", function() {
	        if (input.composing) return;
	        if (cm.isReadOnly() || !input.pollContent())
	          runInOp(input.cm, function() {regChange(cm);});
	      });
	
	      function onCopyCut(e) {
	        if (signalDOMEvent(cm, e)) return
	        if (cm.somethingSelected()) {
	          lastCopied = {lineWise: false, text: cm.getSelections()};
	          if (e.type == "cut") cm.replaceSelection("", null, "cut");
	        } else if (!cm.options.lineWiseCopyCut) {
	          return;
	        } else {
	          var ranges = copyableRanges(cm);
	          lastCopied = {lineWise: true, text: ranges.text};
	          if (e.type == "cut") {
	            cm.operation(function() {
	              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	              cm.replaceSelection("", null, "cut");
	            });
	          }
	        }
	        // iOS exposes the clipboard API, but seems to discard content inserted into it
	        if (e.clipboardData && !ios) {
	          e.preventDefault();
	          e.clipboardData.clearData();
	          e.clipboardData.setData("text/plain", lastCopied.text.join("\n"));
	        } else {
	          // Old-fashioned briefly-focus-a-textarea hack
	          var kludge = hiddenTextarea(), te = kludge.firstChild;
	          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	          te.value = lastCopied.text.join("\n");
	          var hadFocus = document.activeElement;
	          selectInput(te);
	          setTimeout(function() {
	            cm.display.lineSpace.removeChild(kludge);
	            hadFocus.focus();
	          }, 50);
	        }
	      }
	      on(div, "copy", onCopyCut);
	      on(div, "cut", onCopyCut);
	    },
	
	    prepareSelection: function() {
	      var result = prepareSelection(this.cm, false);
	      result.focus = this.cm.state.focused;
	      return result;
	    },
	
	    showSelection: function(info, takeFocus) {
	      if (!info || !this.cm.display.view.length) return;
	      if (info.focus || takeFocus) this.showPrimarySelection();
	      this.showMultipleSelections(info);
	    },
	
	    showPrimarySelection: function() {
	      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
	      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
	      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
	      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
	          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
	        return;
	
	      var start = posToDOM(this.cm, prim.from());
	      var end = posToDOM(this.cm, prim.to());
	      if (!start && !end) return;
	
	      var view = this.cm.display.view;
	      var old = sel.rangeCount && sel.getRangeAt(0);
	      if (!start) {
	        start = {node: view[0].measure.map[2], offset: 0};
	      } else if (!end) { // FIXME dangerously hacky
	        var measure = view[view.length - 1].measure;
	        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
	      }
	
	      try { var rng = range(start.node, start.offset, end.offset, end.node); }
	      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	      if (rng) {
	        if (!gecko && this.cm.state.focused) {
	          sel.collapse(start.node, start.offset);
	          if (!rng.collapsed) sel.addRange(rng);
	        } else {
	          sel.removeAllRanges();
	          sel.addRange(rng);
	        }
	        if (old && sel.anchorNode == null) sel.addRange(old);
	        else if (gecko) this.startGracePeriod();
	      }
	      this.rememberSelection();
	    },
	
	    startGracePeriod: function() {
	      var input = this;
	      clearTimeout(this.gracePeriod);
	      this.gracePeriod = setTimeout(function() {
	        input.gracePeriod = false;
	        if (input.selectionChanged())
	          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });
	      }, 20);
	    },
	
	    showMultipleSelections: function(info) {
	      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	    },
	
	    rememberSelection: function() {
	      var sel = window.getSelection();
	      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	    },
	
	    selectionInEditor: function() {
	      var sel = window.getSelection();
	      if (!sel.rangeCount) return false;
	      var node = sel.getRangeAt(0).commonAncestorContainer;
	      return contains(this.div, node);
	    },
	
	    focus: function() {
	      if (this.cm.options.readOnly != "nocursor") this.div.focus();
	    },
	    blur: function() { this.div.blur(); },
	    getField: function() { return this.div; },
	
	    supportsTouch: function() { return true; },
	
	    receivedFocus: function() {
	      var input = this;
	      if (this.selectionInEditor())
	        this.pollSelection();
	      else
	        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });
	
	      function poll() {
	        if (input.cm.state.focused) {
	          input.pollSelection();
	          input.polling.set(input.cm.options.pollInterval, poll);
	        }
	      }
	      this.polling.set(this.cm.options.pollInterval, poll);
	    },
	
	    selectionChanged: function() {
	      var sel = window.getSelection();
	      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
	    },
	
	    pollSelection: function() {
	      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
	        var sel = window.getSelection(), cm = this.cm;
	        this.rememberSelection();
	        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	        if (anchor && head) runInOp(cm, function() {
	          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;
	        });
	      }
	    },
	
	    pollContent: function() {
	      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	      var from = sel.from(), to = sel.to();
	      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;
	
	      var fromIndex;
	      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	        var fromLine = lineNo(display.view[0].line);
	        var fromNode = display.view[0].node;
	      } else {
	        var fromLine = lineNo(display.view[fromIndex].line);
	        var fromNode = display.view[fromIndex - 1].node.nextSibling;
	      }
	      var toIndex = findViewIndex(cm, to.line);
	      if (toIndex == display.view.length - 1) {
	        var toLine = display.viewTo - 1;
	        var toNode = display.lineDiv.lastChild;
	      } else {
	        var toLine = lineNo(display.view[toIndex + 1].line) - 1;
	        var toNode = display.view[toIndex + 1].node.previousSibling;
	      }
	
	      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	      while (newText.length > 1 && oldText.length > 1) {
	        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	        else break;
	      }
	
	      var cutFront = 0, cutEnd = 0;
	      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	        ++cutFront;
	      var newBot = lst(newText), oldBot = lst(oldText);
	      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                               oldBot.length - (oldText.length == 1 ? cutFront : 0));
	      while (cutEnd < maxCutEnd &&
	             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	        ++cutEnd;
	
	      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
	      newText[0] = newText[0].slice(cutFront);
	
	      var chFrom = Pos(fromLine, cutFront);
	      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	        return true;
	      }
	    },
	
	    ensurePolled: function() {
	      this.forceCompositionEnd();
	    },
	    reset: function() {
	      this.forceCompositionEnd();
	    },
	    forceCompositionEnd: function() {
	      if (!this.composing || this.composing.handled) return;
	      this.applyComposition(this.composing);
	      this.composing.handled = true;
	      this.div.blur();
	      this.div.focus();
	    },
	    applyComposition: function(composing) {
	      if (this.cm.isReadOnly())
	        operation(this.cm, regChange)(this.cm)
	      else if (composing.data && composing.data != composing.startData)
	        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
	    },
	
	    setUneditable: function(node) {
	      node.contentEditable = "false"
	    },
	
	    onKeyPress: function(e) {
	      e.preventDefault();
	      if (!this.cm.isReadOnly())
	        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
	    },
	
	    readOnlyChanged: function(val) {
	      this.div.contentEditable = String(val != "nocursor")
	    },
	
	    onContextMenu: nothing,
	    resetPosition: nothing,
	
	    needsContentAttribute: true
	  }, ContentEditableInput.prototype);
	
	  function posToDOM(cm, pos) {
	    var view = findViewForLine(cm, pos.line);
	    if (!view || view.hidden) return null;
	    var line = getLine(cm.doc, pos.line);
	    var info = mapFromLineView(view, line, pos.line);
	
	    var order = getOrder(line), side = "left";
	    if (order) {
	      var partPos = getBidiPartAt(order, pos.ch);
	      side = partPos % 2 ? "right" : "left";
	    }
	    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	    result.offset = result.collapse == "right" ? result.end : result.start;
	    return result;
	  }
	
	  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }
	
	  function domToPos(cm, node, offset) {
	    var lineNode;
	    if (node == cm.display.lineDiv) {
	      lineNode = cm.display.lineDiv.childNodes[offset];
	      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
	      node = null; offset = 0;
	    } else {
	      for (lineNode = node;; lineNode = lineNode.parentNode) {
	        if (!lineNode || lineNode == cm.display.lineDiv) return null;
	        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
	      }
	    }
	    for (var i = 0; i < cm.display.view.length; i++) {
	      var lineView = cm.display.view[i];
	      if (lineView.node == lineNode)
	        return locateNodeInLineView(lineView, node, offset);
	    }
	  }
	
	  function locateNodeInLineView(lineView, node, offset) {
	    var wrapper = lineView.text.firstChild, bad = false;
	    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);
	    if (node == wrapper) {
	      bad = true;
	      node = wrapper.childNodes[offset];
	      offset = 0;
	      if (!node) {
	        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	        return badPos(Pos(lineNo(line), line.text.length), bad);
	      }
	    }
	
	    var textNode = node.nodeType == 3 ? node : null, topNode = node;
	    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	      textNode = node.firstChild;
	      if (offset) offset = textNode.nodeValue.length;
	    }
	    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;
	    var measure = lineView.measure, maps = measure.maps;
	
	    function find(textNode, topNode, offset) {
	      for (var i = -1; i < (maps ? maps.length : 0); i++) {
	        var map = i < 0 ? measure.map : maps[i];
	        for (var j = 0; j < map.length; j += 3) {
	          var curNode = map[j + 2];
	          if (curNode == textNode || curNode == topNode) {
	            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	            var ch = map[j] + offset;
	            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];
	            return Pos(line, ch);
	          }
	        }
	      }
	    }
	    var found = find(textNode, topNode, offset);
	    if (found) return badPos(found, bad);
	
	    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	      found = find(after, after.firstChild, 0);
	      if (found)
	        return badPos(Pos(found.line, found.ch - dist), bad);
	      else
	        dist += after.textContent.length;
	    }
	    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
	      found = find(before, before.firstChild, -1);
	      if (found)
	        return badPos(Pos(found.line, found.ch + dist), bad);
	      else
	        dist += after.textContent.length;
	    }
	  }
	
	  function domTextBetween(cm, from, to, fromLine, toLine) {
	    var text = "", closing = false, lineSep = cm.doc.lineSeparator();
	    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }
	    function walk(node) {
	      if (node.nodeType == 1) {
	        var cmText = node.getAttribute("cm-text");
	        if (cmText != null) {
	          if (cmText == "") cmText = node.textContent.replace(/\u200b/g, "");
	          text += cmText;
	          return;
	        }
	        var markerID = node.getAttribute("cm-marker"), range;
	        if (markerID) {
	          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	          if (found.length && (range = found[0].find()))
	            text += getBetween(cm.doc, range.from, range.to).join(lineSep);
	          return;
	        }
	        if (node.getAttribute("contenteditable") == "false") return;
	        for (var i = 0; i < node.childNodes.length; i++)
	          walk(node.childNodes[i]);
	        if (/^(pre|div|p)$/i.test(node.nodeName))
	          closing = true;
	      } else if (node.nodeType == 3) {
	        var val = node.nodeValue;
	        if (!val) return;
	        if (closing) {
	          text += lineSep;
	          closing = false;
	        }
	        text += val;
	      }
	    }
	    for (;;) {
	      walk(from);
	      if (from == to) break;
	      from = from.nextSibling;
	    }
	    return text;
	  }
	
	  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};
	
	  // SELECTION / CURSOR
	
	  // Selection objects are immutable. A new one is created every time
	  // the selection changes. A selection is one or more non-overlapping
	  // (and non-touching) ranges, sorted, and an integer that indicates
	  // which one is the primary selection (the one that's scrolled into
	  // view, that getCursor returns, etc).
	  function Selection(ranges, primIndex) {
	    this.ranges = ranges;
	    this.primIndex = primIndex;
	  }
	
	  Selection.prototype = {
	    primary: function() { return this.ranges[this.primIndex]; },
	    equals: function(other) {
	      if (other == this) return true;
	      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
	      for (var i = 0; i < this.ranges.length; i++) {
	        var here = this.ranges[i], there = other.ranges[i];
	        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
	      }
	      return true;
	    },
	    deepCopy: function() {
	      for (var out = [], i = 0; i < this.ranges.length; i++)
	        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
	      return new Selection(out, this.primIndex);
	    },
	    somethingSelected: function() {
	      for (var i = 0; i < this.ranges.length; i++)
	        if (!this.ranges[i].empty()) return true;
	      return false;
	    },
	    contains: function(pos, end) {
	      if (!end) end = pos;
	      for (var i = 0; i < this.ranges.length; i++) {
	        var range = this.ranges[i];
	        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	          return i;
	      }
	      return -1;
	    }
	  };
	
	  function Range(anchor, head) {
	    this.anchor = anchor; this.head = head;
	  }
	
	  Range.prototype = {
	    from: function() { return minPos(this.anchor, this.head); },
	    to: function() { return maxPos(this.anchor, this.head); },
	    empty: function() {
	      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
	    }
	  };
	
	  // Take an unsorted, potentially overlapping set of ranges, and
	  // build a selection out of it. 'Consumes' ranges array (modifying
	  // it).
	  function normalizeSelection(ranges, primIndex) {
	    var prim = ranges[primIndex];
	    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
	    primIndex = indexOf(ranges, prim);
	    for (var i = 1; i < ranges.length; i++) {
	      var cur = ranges[i], prev = ranges[i - 1];
	      if (cmp(prev.to(), cur.from()) >= 0) {
	        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	        if (i <= primIndex) --primIndex;
	        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	      }
	    }
	    return new Selection(ranges, primIndex);
	  }
	
	  function simpleSelection(anchor, head) {
	    return new Selection([new Range(anchor, head || anchor)], 0);
	  }
	
	  // Most of the external API clips given positions to make sure they
	  // actually exist within the document.
	  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
	  function clipPos(doc, pos) {
	    if (pos.line < doc.first) return Pos(doc.first, 0);
	    var last = doc.first + doc.size - 1;
	    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
	    return clipToLen(pos, getLine(doc, pos.line).text.length);
	  }
	  function clipToLen(pos, linelen) {
	    var ch = pos.ch;
	    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
	    else if (ch < 0) return Pos(pos.line, 0);
	    else return pos;
	  }
	  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
	  function clipPosArray(doc, array) {
	    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
	    return out;
	  }
	
	  // SELECTION UPDATES
	
	  // The 'scroll' parameter given to many of these indicated whether
	  // the new cursor position should be scrolled into view after
	  // modifying the selection.
	
	  // If shift is held or the extend flag is set, extends a range to
	  // include a given position (and optionally a second position).
	  // Otherwise, simply returns the range between the given positions.
	  // Used for cursor motion and such.
	  function extendRange(doc, range, head, other) {
	    if (doc.cm && doc.cm.display.shift || doc.extend) {
	      var anchor = range.anchor;
	      if (other) {
	        var posBefore = cmp(head, anchor) < 0;
	        if (posBefore != (cmp(other, anchor) < 0)) {
	          anchor = head;
	          head = other;
	        } else if (posBefore != (cmp(head, other) < 0)) {
	          head = other;
	        }
	      }
	      return new Range(anchor, head);
	    } else {
	      return new Range(other || head, head);
	    }
	  }
	
	  // Extend the primary selection range, discard the rest.
	  function extendSelection(doc, head, other, options) {
	    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
	  }
	
	  // Extend all selections (pos is an array of selections with length
	  // equal the number of selections)
	  function extendSelections(doc, heads, options) {
	    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
	      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
	    var newSel = normalizeSelection(out, doc.sel.primIndex);
	    setSelection(doc, newSel, options);
	  }
	
	  // Updates a single range in the selection.
	  function replaceOneSelection(doc, i, range, options) {
	    var ranges = doc.sel.ranges.slice(0);
	    ranges[i] = range;
	    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
	  }
	
	  // Reset the selection to a single range.
	  function setSimpleSelection(doc, anchor, head, options) {
	    setSelection(doc, simpleSelection(anchor, head), options);
	  }
	
	  // Give beforeSelectionChange handlers a change to influence a
	  // selection update.
	  function filterSelectionChange(doc, sel, options) {
	    var obj = {
	      ranges: sel.ranges,
	      update: function(ranges) {
	        this.ranges = [];
	        for (var i = 0; i < ranges.length; i++)
	          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                     clipPos(doc, ranges[i].head));
	      },
	      origin: options && options.origin
	    };
	    signal(doc, "beforeSelectionChange", doc, obj);
	    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
	    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
	    else return sel;
	  }
	
	  function setSelectionReplaceHistory(doc, sel, options) {
	    var done = doc.history.done, last = lst(done);
	    if (last && last.ranges) {
	      done[done.length - 1] = sel;
	      setSelectionNoUndo(doc, sel, options);
	    } else {
	      setSelection(doc, sel, options);
	    }
	  }
	
	  // Set a new selection.
	  function setSelection(doc, sel, options) {
	    setSelectionNoUndo(doc, sel, options);
	    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	  }
	
	  function setSelectionNoUndo(doc, sel, options) {
	    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	      sel = filterSelectionChange(doc, sel, options);
	
	    var bias = options && options.bias ||
	      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
	
	    if (!(options && options.scroll === false) && doc.cm)
	      ensureCursorVisible(doc.cm);
	  }
	
	  function setSelectionInner(doc, sel) {
	    if (sel.equals(doc.sel)) return;
	
	    doc.sel = sel;
	
	    if (doc.cm) {
	      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
	      signalCursorActivity(doc.cm);
	    }
	    signalLater(doc, "cursorActivity", doc);
	  }
	
	  // Verify that the selection does not partially select any atomic
	  // marked ranges.
	  function reCheckSelection(doc) {
	    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
	  }
	
	  // Return a selection that does not partially select any atomic
	  // ranges.
	  function skipAtomicInSelection(doc, sel, bias, mayClear) {
	    var out;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range = sel.ranges[i];
	      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	      if (out || newAnchor != range.anchor || newHead != range.head) {
	        if (!out) out = sel.ranges.slice(0, i);
	        out[i] = new Range(newAnchor, newHead);
	      }
	    }
	    return out ? normalizeSelection(out, sel.primIndex) : sel;
	  }
	
	  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	    var line = getLine(doc, pos.line);
	    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
	      var sp = line.markedSpans[i], m = sp.marker;
	      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	        if (mayClear) {
	          signal(m, "beforeCursorEnter");
	          if (m.explicitlyCleared) {
	            if (!line.markedSpans) break;
	            else {--i; continue;}
	          }
	        }
	        if (!m.atomic) continue;
	
	        if (oldPos) {
	          var near = m.find(dir < 0 ? 1 : -1), diff;
	          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
	            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
	          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	            return skipAtomicInner(doc, near, pos, dir, mayClear);
	        }
	
	        var far = m.find(dir < 0 ? -1 : 1);
	        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
	          far = movePos(doc, far, dir, far.line == pos.line ? line : null);
	        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
	      }
	    }
	    return pos;
	  }
	
	  // Ensure a given position is not inside an atomic range.
	  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	    var dir = bias || 1;
	    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	    if (!found) {
	      doc.cantEdit = true;
	      return Pos(doc.first, 0);
	    }
	    return found;
	  }
	
	  function movePos(doc, pos, dir, line) {
	    if (dir < 0 && pos.ch == 0) {
	      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));
	      else return null;
	    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);
	      else return null;
	    } else {
	      return new Pos(pos.line, pos.ch + dir);
	    }
	  }
	
	  // SELECTION DRAWING
	
	  function updateSelection(cm) {
	    cm.display.input.showSelection(cm.display.input.prepareSelection());
	  }
	
	  function prepareSelection(cm, primary) {
	    var doc = cm.doc, result = {};
	    var curFragment = result.cursors = document.createDocumentFragment();
	    var selFragment = result.selection = document.createDocumentFragment();
	
	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      if (primary === false && i == doc.sel.primIndex) continue;
	      var range = doc.sel.ranges[i];
	      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;
	      var collapsed = range.empty();
	      if (collapsed || cm.options.showCursorWhenSelecting)
	        drawSelectionCursor(cm, range.head, curFragment);
	      if (!collapsed)
	        drawSelectionRange(cm, range, selFragment);
	    }
	    return result;
	  }
	
	  // Draws a cursor for the given range
	  function drawSelectionCursor(cm, head, output) {
	    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
	
	    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	    cursor.style.left = pos.left + "px";
	    cursor.style.top = pos.top + "px";
	    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
	
	    if (pos.other) {
	      // Secondary cursor, shown when on a 'jump' in bi-directional text
	      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	      otherCursor.style.display = "";
	      otherCursor.style.left = pos.other.left + "px";
	      otherCursor.style.top = pos.other.top + "px";
	      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	    }
	  }
	
	  // Draws the given range as a highlighted selection
	  function drawSelectionRange(cm, range, output) {
	    var display = cm.display, doc = cm.doc;
	    var fragment = document.createDocumentFragment();
	    var padding = paddingH(cm.display), leftSide = padding.left;
	    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
	
	    function add(left, top, width, bottom) {
	      if (top < 0) top = 0;
	      top = Math.round(top);
	      bottom = Math.round(bottom);
	      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
	                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
	                               "px; height: " + (bottom - top) + "px"));
	    }
	
	    function drawForLine(line, fromArg, toArg) {
	      var lineObj = getLine(doc, line);
	      var lineLen = lineObj.text.length;
	      var start, end;
	      function coords(ch, bias) {
	        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
	      }
	
	      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
	        var leftPos = coords(from, "left"), rightPos, left, right;
	        if (from == to) {
	          rightPos = leftPos;
	          left = right = leftPos.left;
	        } else {
	          rightPos = coords(to - 1, "right");
	          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
	          left = leftPos.left;
	          right = rightPos.right;
	        }
	        if (fromArg == null && from == 0) left = leftSide;
	        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
	          add(left, leftPos.top, null, leftPos.bottom);
	          left = leftSide;
	          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
	        }
	        if (toArg == null && to == lineLen) right = rightSide;
	        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
	          start = leftPos;
	        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
	          end = rightPos;
	        if (left < leftSide + 1) left = leftSide;
	        add(left, rightPos.top, right - left, rightPos.bottom);
	      });
	      return {start: start, end: end};
	    }
	
	    var sFrom = range.from(), sTo = range.to();
	    if (sFrom.line == sTo.line) {
	      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	    } else {
	      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	      var singleVLine = visualLine(fromLine) == visualLine(toLine);
	      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	      if (singleVLine) {
	        if (leftEnd.top < rightStart.top - 2) {
	          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	        } else {
	          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	        }
	      }
	      if (leftEnd.bottom < rightStart.top)
	        add(leftSide, leftEnd.bottom, null, rightStart.top);
	    }
	
	    output.appendChild(fragment);
	  }
	
	  // Cursor-blinking
	  function restartBlink(cm) {
	    if (!cm.state.focused) return;
	    var display = cm.display;
	    clearInterval(display.blinker);
	    var on = true;
	    display.cursorDiv.style.visibility = "";
	    if (cm.options.cursorBlinkRate > 0)
	      display.blinker = setInterval(function() {
	        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
	      }, cm.options.cursorBlinkRate);
	    else if (cm.options.cursorBlinkRate < 0)
	      display.cursorDiv.style.visibility = "hidden";
	  }
	
	  // HIGHLIGHT WORKER
	
	  function startWorker(cm, time) {
	    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
	      cm.state.highlight.set(time, bind(highlightWorker, cm));
	  }
	
	  function highlightWorker(cm) {
	    var doc = cm.doc;
	    if (doc.frontier < doc.first) doc.frontier = doc.first;
	    if (doc.frontier >= cm.display.viewTo) return;
	    var end = +new Date + cm.options.workTime;
	    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
	    var changedLines = [];
	
	    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
	      if (doc.frontier >= cm.display.viewFrom) { // Visible
	        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
	        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
	        line.styles = highlighted.styles;
	        var oldCls = line.styleClasses, newCls = highlighted.classes;
	        if (newCls) line.styleClasses = newCls;
	        else if (oldCls) line.styleClasses = null;
	        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
	        if (ischange) changedLines.push(doc.frontier);
	        line.stateAfter = tooLong ? state : copyState(doc.mode, state);
	      } else {
	        if (line.text.length <= cm.options.maxHighlightLength)
	          processLine(cm, line.text, state);
	        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
	      }
	      ++doc.frontier;
	      if (+new Date > end) {
	        startWorker(cm, cm.options.workDelay);
	        return true;
	      }
	    });
	    if (changedLines.length) runInOp(cm, function() {
	      for (var i = 0; i < changedLines.length; i++)
	        regLineChange(cm, changedLines[i], "text");
	    });
	  }
	
	  // Finds the line to start with when starting a parse. Tries to
	  // find a line with a stateAfter, so that it can start with a
	  // valid state. If that fails, it returns the line with the
	  // smallest indentation, which tends to need the least context to
	  // parse correctly.
	  function findStartLine(cm, n, precise) {
	    var minindent, minline, doc = cm.doc;
	    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	    for (var search = n; search > lim; --search) {
	      if (search <= doc.first) return doc.first;
	      var line = getLine(doc, search - 1);
	      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
	      var indented = countColumn(line.text, null, cm.options.tabSize);
	      if (minline == null || minindent > indented) {
	        minline = search - 1;
	        minindent = indented;
	      }
	    }
	    return minline;
	  }
	
	  function getStateBefore(cm, n, precise) {
	    var doc = cm.doc, display = cm.display;
	    if (!doc.mode.startState) return true;
	    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
	    if (!state) state = startState(doc.mode);
	    else state = copyState(doc.mode, state);
	    doc.iter(pos, n, function(line) {
	      processLine(cm, line.text, state);
	      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
	      line.stateAfter = save ? copyState(doc.mode, state) : null;
	      ++pos;
	    });
	    if (precise) doc.frontier = pos;
	    return state;
	  }
	
	  // POSITION MEASUREMENT
	
	  function paddingTop(display) {return display.lineSpace.offsetTop;}
	  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
	  function paddingH(display) {
	    if (display.cachedPaddingH) return display.cachedPaddingH;
	    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
	    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
	    return data;
	  }
	
	  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }
	  function displayWidth(cm) {
	    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
	  }
	  function displayHeight(cm) {
	    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
	  }
	
	  // Ensure the lineView.wrapping.heights array is populated. This is
	  // an array of bottom offsets for the lines that make up a drawn
	  // line. When lineWrapping is on, there might be more than one
	  // height.
	  function ensureLineHeights(cm, lineView, rect) {
	    var wrapping = cm.options.lineWrapping;
	    var curWidth = wrapping && displayWidth(cm);
	    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	      var heights = lineView.measure.heights = [];
	      if (wrapping) {
	        lineView.measure.width = curWidth;
	        var rects = lineView.text.firstChild.getClientRects();
	        for (var i = 0; i < rects.length - 1; i++) {
	          var cur = rects[i], next = rects[i + 1];
	          if (Math.abs(cur.bottom - next.bottom) > 2)
	            heights.push((cur.bottom + next.top) / 2 - rect.top);
	        }
	      }
	      heights.push(rect.bottom - rect.top);
	    }
	  }
	
	  // Find a line map (mapping character offsets to text nodes) and a
	  // measurement cache for the given line number. (A line view might
	  // contain multiple lines when collapsed ranges are present.)
	  function mapFromLineView(lineView, line, lineN) {
	    if (lineView.line == line)
	      return {map: lineView.measure.map, cache: lineView.measure.cache};
	    for (var i = 0; i < lineView.rest.length; i++)
	      if (lineView.rest[i] == line)
	        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
	    for (var i = 0; i < lineView.rest.length; i++)
	      if (lineNo(lineView.rest[i]) > lineN)
	        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
	  }
	
	  // Render a line into the hidden node display.externalMeasured. Used
	  // when measurement is needed for a line that's not in the viewport.
	  function updateExternalMeasurement(cm, line) {
	    line = visualLine(line);
	    var lineN = lineNo(line);
	    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	    view.lineN = lineN;
	    var built = view.built = buildLineContent(cm, view);
	    view.text = built.pre;
	    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	    return view;
	  }
	
	  // Get a {top, bottom, left, right} box (in line-local coordinates)
	  // for a given character.
	  function measureChar(cm, line, ch, bias) {
	    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
	  }
	
	  // Find a line view that corresponds to the given line number.
	  function findViewForLine(cm, lineN) {
	    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	      return cm.display.view[findViewIndex(cm, lineN)];
	    var ext = cm.display.externalMeasured;
	    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	      return ext;
	  }
	
	  // Measurement can be split in two steps, the set-up work that
	  // applies to the whole line, and the measurement of the actual
	  // character. Functions like coordsChar, that need to do a lot of
	  // measurements in a row, can thus ensure that the set-up work is
	  // only done once.
	  function prepareMeasureForLine(cm, line) {
	    var lineN = lineNo(line);
	    var view = findViewForLine(cm, lineN);
	    if (view && !view.text) {
	      view = null;
	    } else if (view && view.changes) {
	      updateLineForChanges(cm, view, lineN, getDimensions(cm));
	      cm.curOp.forceUpdate = true;
	    }
	    if (!view)
	      view = updateExternalMeasurement(cm, line);
	
	    var info = mapFromLineView(view, line, lineN);
	    return {
	      line: line, view: view, rect: null,
	      map: info.map, cache: info.cache, before: info.before,
	      hasHeights: false
	    };
	  }
	
	  // Given a prepared measurement object, measures the position of an
	  // actual character (or fetches it from the cache).
	  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	    if (prepared.before) ch = -1;
	    var key = ch + (bias || ""), found;
	    if (prepared.cache.hasOwnProperty(key)) {
	      found = prepared.cache[key];
	    } else {
	      if (!prepared.rect)
	        prepared.rect = prepared.view.text.getBoundingClientRect();
	      if (!prepared.hasHeights) {
	        ensureLineHeights(cm, prepared.view, prepared.rect);
	        prepared.hasHeights = true;
	      }
	      found = measureCharInner(cm, prepared, ch, bias);
	      if (!found.bogus) prepared.cache[key] = found;
	    }
	    return {left: found.left, right: found.right,
	            top: varHeight ? found.rtop : found.top,
	            bottom: varHeight ? found.rbottom : found.bottom};
	  }
	
	  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};
	
	  function nodeAndOffsetInLineMap(map, ch, bias) {
	    var node, start, end, collapse;
	    // First, search the line map for the text node corresponding to,
	    // or closest to, the target character.
	    for (var i = 0; i < map.length; i += 3) {
	      var mStart = map[i], mEnd = map[i + 1];
	      if (ch < mStart) {
	        start = 0; end = 1;
	        collapse = "left";
	      } else if (ch < mEnd) {
	        start = ch - mStart;
	        end = start + 1;
	      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
	        end = mEnd - mStart;
	        start = end - 1;
	        if (ch >= mEnd) collapse = "right";
	      }
	      if (start != null) {
	        node = map[i + 2];
	        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	          collapse = bias;
	        if (bias == "left" && start == 0)
	          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
	            node = map[(i -= 3) + 2];
	            collapse = "left";
	          }
	        if (bias == "right" && start == mEnd - mStart)
	          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
	            node = map[(i += 3) + 2];
	            collapse = "right";
	          }
	        break;
	      }
	    }
	    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};
	  }
	
	  function getUsefulRect(rects, bias) {
	    var rect = nullRect
	    if (bias == "left") for (var i = 0; i < rects.length; i++) {
	      if ((rect = rects[i]).left != rect.right) break
	    } else for (var i = rects.length - 1; i >= 0; i--) {
	      if ((rect = rects[i]).left != rect.right) break
	    }
	    return rect
	  }
	
	  function measureCharInner(cm, prepared, ch, bias) {
	    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
	
	    var rect;
	    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;
	        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;
	        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	          rect = node.parentNode.getBoundingClientRect();
	        else
	          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)
	        if (rect.left || rect.right || start == 0) break;
	        end = start;
	        start = start - 1;
	        collapse = "right";
	      }
	      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);
	    } else { // If it is a widget, simply get the box for the whole widget.
	      if (start > 0) collapse = bias = "right";
	      var rects;
	      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	        rect = rects[bias == "right" ? rects.length - 1 : 0];
	      else
	        rect = node.getBoundingClientRect();
	    }
	    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	      var rSpan = node.parentNode.getClientRects()[0];
	      if (rSpan)
	        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
	      else
	        rect = nullRect;
	    }
	
	    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	    var mid = (rtop + rbot) / 2;
	    var heights = prepared.view.measure.heights;
	    for (var i = 0; i < heights.length - 1; i++)
	      if (mid < heights[i]) break;
	    var top = i ? heights[i - 1] : 0, bot = heights[i];
	    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                  top: top, bottom: bot};
	    if (!rect.left && !rect.right) result.bogus = true;
	    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }
	
	    return result;
	  }
	
	  // Work around problem with bounding client rects on ranges being
	  // returned incorrectly when zoomed on IE10 and below.
	  function maybeUpdateRectForZooming(measure, rect) {
	    if (!window.screen || screen.logicalXDPI == null ||
	        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	      return rect;
	    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	    return {left: rect.left * scaleX, right: rect.right * scaleX,
	            top: rect.top * scaleY, bottom: rect.bottom * scaleY};
	  }
	
	  function clearLineMeasurementCacheFor(lineView) {
	    if (lineView.measure) {
	      lineView.measure.cache = {};
	      lineView.measure.heights = null;
	      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
	        lineView.measure.caches[i] = {};
	    }
	  }
	
	  function clearLineMeasurementCache(cm) {
	    cm.display.externalMeasure = null;
	    removeChildren(cm.display.lineMeasure);
	    for (var i = 0; i < cm.display.view.length; i++)
	      clearLineMeasurementCacheFor(cm.display.view[i]);
	  }
	
	  function clearCaches(cm) {
	    clearLineMeasurementCache(cm);
	    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
	    cm.display.lineNumChars = null;
	  }
	
	  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
	  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }
	
	  // Converts a {top, bottom, left, right} box from line-local
	  // coordinates into another coordinate system. Context may be one of
	  // "line", "div" (display.lineDiv), "local"/null (editor), "window",
	  // or "page".
	  function intoCoordSystem(cm, lineObj, rect, context) {
	    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
	      var size = widgetHeight(lineObj.widgets[i]);
	      rect.top += size; rect.bottom += size;
	    }
	    if (context == "line") return rect;
	    if (!context) context = "local";
	    var yOff = heightAtLine(lineObj);
	    if (context == "local") yOff += paddingTop(cm.display);
	    else yOff -= cm.display.viewOffset;
	    if (context == "page" || context == "window") {
	      var lOff = cm.display.lineSpace.getBoundingClientRect();
	      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	      rect.left += xOff; rect.right += xOff;
	    }
	    rect.top += yOff; rect.bottom += yOff;
	    return rect;
	  }
	
	  // Coverts a box from "div" coords to another coordinate system.
	  // Context may be "window", "page", "div", or "local"/null.
	  function fromCoordSystem(cm, coords, context) {
	    if (context == "div") return coords;
	    var left = coords.left, top = coords.top;
	    // First move into "page" coordinate system
	    if (context == "page") {
	      left -= pageScrollX();
	      top -= pageScrollY();
	    } else if (context == "local" || !context) {
	      var localBox = cm.display.sizer.getBoundingClientRect();
	      left += localBox.left;
	      top += localBox.top;
	    }
	
	    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
	  }
	
	  function charCoords(cm, pos, context, lineObj, bias) {
	    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
	    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
	  }
	
	  // Returns a box for a given cursor position, which may have an
	  // 'other' property containing the position of the secondary cursor
	  // on a bidi boundary.
	  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	    lineObj = lineObj || getLine(cm.doc, pos.line);
	    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
	    function get(ch, right) {
	      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	      if (right) m.left = m.right; else m.right = m.left;
	      return intoCoordSystem(cm, lineObj, m, context);
	    }
	    function getBidi(ch, partPos) {
	      var part = order[partPos], right = part.level % 2;
	      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
	        part = order[--partPos];
	        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
	        right = true;
	      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
	        part = order[++partPos];
	        ch = bidiLeft(part) - part.level % 2;
	        right = false;
	      }
	      if (right && ch == part.to && ch > part.from) return get(ch - 1);
	      return get(ch, right);
	    }
	    var order = getOrder(lineObj), ch = pos.ch;
	    if (!order) return get(ch);
	    var partPos = getBidiPartAt(order, ch);
	    var val = getBidi(ch, partPos);
	    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
	    return val;
	  }
	
	  // Used to cheaply estimate the coordinates for a position. Used for
	  // intermediate scroll updates.
	  function estimateCoords(cm, pos) {
	    var left = 0, pos = clipPos(cm.doc, pos);
	    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
	    var lineObj = getLine(cm.doc, pos.line);
	    var top = heightAtLine(lineObj) + paddingTop(cm.display);
	    return {left: left, right: left, top: top, bottom: top + lineObj.height};
	  }
	
	  // Positions returned by coordsChar contain some extra information.
	  // xRel is the relative x position of the input coordinates compared
	  // to the found position (so xRel > 0 means the coordinates are to
	  // the right of the character position, for example). When outside
	  // is true, that means the coordinates lie outside the line's
	  // vertical range.
	  function PosWithInfo(line, ch, outside, xRel) {
	    var pos = Pos(line, ch);
	    pos.xRel = xRel;
	    if (outside) pos.outside = true;
	    return pos;
	  }
	
	  // Compute the character position closest to the given coordinates.
	  // Input must be lineSpace-local ("div" coordinate system).
	  function coordsChar(cm, x, y) {
	    var doc = cm.doc;
	    y += cm.display.viewOffset;
	    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
	    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	    if (lineN > last)
	      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
	    if (x < 0) x = 0;
	
	    var lineObj = getLine(doc, lineN);
	    for (;;) {
	      var found = coordsCharInner(cm, lineObj, lineN, x, y);
	      var merged = collapsedSpanAtEnd(lineObj);
	      var mergedPos = merged && merged.find(0, true);
	      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	        lineN = lineNo(lineObj = mergedPos.to.line);
	      else
	        return found;
	    }
	  }
	
	  function coordsCharInner(cm, lineObj, lineNo, x, y) {
	    var innerOff = y - heightAtLine(lineObj);
	    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
	    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
	
	    function getX(ch) {
	      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
	      wrongLine = true;
	      if (innerOff > sp.bottom) return sp.left - adjust;
	      else if (innerOff < sp.top) return sp.left + adjust;
	      else wrongLine = false;
	      return sp.left;
	    }
	
	    var bidi = getOrder(lineObj), dist = lineObj.text.length;
	    var from = lineLeft(lineObj), to = lineRight(lineObj);
	    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
	
	    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
	    // Do a binary search between these bounds.
	    for (;;) {
	      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
	        var ch = x < fromX || x - fromX <= toX - x ? from : to;
	        var outside = ch == from ? fromOutside : toOutside
	        var xDiff = x - (ch == from ? fromX : toX);
	        // This is a kludge to handle the case where the coordinates
	        // are after a line-wrapped line. We should replace it with a
	        // more general handling of cursor positions around line
	        // breaks. (Issue #4078)
	        if (toOutside && !bidi && !/\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&
	            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {
	          var charSize = measureCharPrepared(cm, preparedMeasure, ch, "right");
	          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {
	            outside = false
	            ch++
	            xDiff = x - charSize.right
	          }
	        }
	        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
	        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
	        return pos;
	      }
	      var step = Math.ceil(dist / 2), middle = from + step;
	      if (bidi) {
	        middle = from;
	        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
	      }
	      var middleX = getX(middle);
	      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
	      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
	    }
	  }
	
	  var measureText;
	  // Compute the default text height.
	  function textHeight(display) {
	    if (display.cachedTextHeight != null) return display.cachedTextHeight;
	    if (measureText == null) {
	      measureText = elt("pre");
	      // Measure a bunch of lines, for browsers that compute
	      // fractional heights.
	      for (var i = 0; i < 49; ++i) {
	        measureText.appendChild(document.createTextNode("x"));
	        measureText.appendChild(elt("br"));
	      }
	      measureText.appendChild(document.createTextNode("x"));
	    }
	    removeChildrenAndAdd(display.measure, measureText);
	    var height = measureText.offsetHeight / 50;
	    if (height > 3) display.cachedTextHeight = height;
	    removeChildren(display.measure);
	    return height || 1;
	  }
	
	  // Compute the default character width.
	  function charWidth(display) {
	    if (display.cachedCharWidth != null) return display.cachedCharWidth;
	    var anchor = elt("span", "xxxxxxxxxx");
	    var pre = elt("pre", [anchor]);
	    removeChildrenAndAdd(display.measure, pre);
	    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	    if (width > 2) display.cachedCharWidth = width;
	    return width || 10;
	  }
	
	  // OPERATIONS
	
	  // Operations are used to wrap a series of changes to the editor
	  // state in such a way that each change won't have to update the
	  // cursor and display (which would be awkward, slow, and
	  // error-prone). Instead, display updates are batched and then all
	  // combined and executed at once.
	
	  var operationGroup = null;
	
	  var nextOpId = 0;
	  // Start a new operation.
	  function startOperation(cm) {
	    cm.curOp = {
	      cm: cm,
	      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	      startHeight: cm.doc.height, // Used to detect need to update scrollbar
	      forceUpdate: false,      // Used to force a redraw
	      updateInput: null,       // Whether to reset the input textarea
	      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	      changeObjs: null,        // Accumulated changes, for firing change events
	      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	      selectionChanged: false, // Whether the selection needs to be redrawn
	      updateMaxLine: false,    // Set when the widest line needs to be determined anew
	      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	      scrollToPos: null,       // Used to scroll to a specific position
	      focus: false,
	      id: ++nextOpId           // Unique ID
	    };
	    if (operationGroup) {
	      operationGroup.ops.push(cm.curOp);
	    } else {
	      cm.curOp.ownsGroup = operationGroup = {
	        ops: [cm.curOp],
	        delayedCallbacks: []
	      };
	    }
	  }
	
	  function fireCallbacksForOps(group) {
	    // Calls delayed callbacks and cursorActivity handlers until no
	    // new ones appear
	    var callbacks = group.delayedCallbacks, i = 0;
	    do {
	      for (; i < callbacks.length; i++)
	        callbacks[i].call(null);
	      for (var j = 0; j < group.ops.length; j++) {
	        var op = group.ops[j];
	        if (op.cursorActivityHandlers)
	          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
	      }
	    } while (i < callbacks.length);
	  }
	
	  // Finish an operation, updating the display and signalling delayed events
	  function endOperation(cm) {
	    var op = cm.curOp, group = op.ownsGroup;
	    if (!group) return;
	
	    try { fireCallbacksForOps(group); }
	    finally {
	      operationGroup = null;
	      for (var i = 0; i < group.ops.length; i++)
	        group.ops[i].cm.curOp = null;
	      endOperations(group);
	    }
	  }
	
	  // The DOM updates done when an operation finishes are batched so
	  // that the minimum number of relayouts are required.
	  function endOperations(group) {
	    var ops = group.ops;
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_R1(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
	      endOperation_W1(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_R2(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)
	      endOperation_W2(ops[i]);
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      endOperation_finish(ops[i]);
	  }
	
	  function endOperation_R1(op) {
	    var cm = op.cm, display = cm.display;
	    maybeClipScrollbars(cm);
	    if (op.updateMaxLine) findMaxLine(cm);
	
	    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                         op.scrollToPos.to.line >= display.viewTo) ||
	      display.maxLineChanged && cm.options.lineWrapping;
	    op.update = op.mustUpdate &&
	      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	  }
	
	  function endOperation_W1(op) {
	    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	  }
	
	  function endOperation_R2(op) {
	    var cm = op.cm, display = cm.display;
	    if (op.updatedDisplay) updateHeightsInViewport(cm);
	
	    op.barMeasure = measureForScrollbars(cm);
	
	    // If the max line changed since it was last measured, measure it,
	    // and ensure the document's width matches it.
	    // updateDisplay_W2 will use these properties to do the actual resizing
	    if (display.maxLineChanged && !cm.options.lineWrapping) {
	      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	      cm.display.sizerWidth = op.adjustWidthTo;
	      op.barMeasure.scrollWidth =
	        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	    }
	
	    if (op.updatedDisplay || op.selectionChanged)
	      op.preparedSelection = display.input.prepareSelection(op.focus);
	  }
	
	  function endOperation_W2(op) {
	    var cm = op.cm;
	
	    if (op.adjustWidthTo != null) {
	      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	      if (op.maxScrollLeft < cm.doc.scrollLeft)
	        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
	      cm.display.maxLineChanged = false;
	    }
	
	    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())
	    if (op.preparedSelection)
	      cm.display.input.showSelection(op.preparedSelection, takeFocus);
	    if (op.updatedDisplay || op.startHeight != cm.doc.height)
	      updateScrollbars(cm, op.barMeasure);
	    if (op.updatedDisplay)
	      setDocumentHeight(cm, op.barMeasure);
	
	    if (op.selectionChanged) restartBlink(cm);
	
	    if (cm.state.focused && op.updateInput)
	      cm.display.input.reset(op.typing);
	    if (takeFocus) ensureFocus(op.cm);
	  }
	
	  function endOperation_finish(op) {
	    var cm = op.cm, display = cm.display, doc = cm.doc;
	
	    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);
	
	    // Abort mouse wheel delta measurement, when scrolling explicitly
	    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	      display.wheelStartX = display.wheelStartY = null;
	
	    // Propagate the scroll position to the actual DOM scroller
	    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
	      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
	      display.scrollbars.setScrollTop(doc.scrollTop);
	      display.scroller.scrollTop = doc.scrollTop;
	    }
	    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
	      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
	      display.scrollbars.setScrollLeft(doc.scrollLeft);
	      display.scroller.scrollLeft = doc.scrollLeft;
	      alignHorizontally(cm);
	    }
	    // If we need to scroll a specific position into view, do so.
	    if (op.scrollToPos) {
	      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
	    }
	
	    // Fire events for markers that are hidden/unidden by editing or
	    // undoing
	    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	    if (hidden) for (var i = 0; i < hidden.length; ++i)
	      if (!hidden[i].lines.length) signal(hidden[i], "hide");
	    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
	      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");
	
	    if (display.wrapper.offsetHeight)
	      doc.scrollTop = cm.display.scroller.scrollTop;
	
	    // Fire change events, and delayed event handlers
	    if (op.changeObjs)
	      signal(cm, "changes", cm, op.changeObjs);
	    if (op.update)
	      op.update.finish();
	  }
	
	  // Run the given function in an operation
	  function runInOp(cm, f) {
	    if (cm.curOp) return f();
	    startOperation(cm);
	    try { return f(); }
	    finally { endOperation(cm); }
	  }
	  // Wraps a function in an operation. Returns the wrapped function.
	  function operation(cm, f) {
	    return function() {
	      if (cm.curOp) return f.apply(cm, arguments);
	      startOperation(cm);
	      try { return f.apply(cm, arguments); }
	      finally { endOperation(cm); }
	    };
	  }
	  // Used to add methods to editor and doc instances, wrapping them in
	  // operations.
	  function methodOp(f) {
	    return function() {
	      if (this.curOp) return f.apply(this, arguments);
	      startOperation(this);
	      try { return f.apply(this, arguments); }
	      finally { endOperation(this); }
	    };
	  }
	  function docMethodOp(f) {
	    return function() {
	      var cm = this.cm;
	      if (!cm || cm.curOp) return f.apply(this, arguments);
	      startOperation(cm);
	      try { return f.apply(this, arguments); }
	      finally { endOperation(cm); }
	    };
	  }
	
	  // VIEW TRACKING
	
	  // These objects are used to represent the visible (currently drawn)
	  // part of the document. A LineView may correspond to multiple
	  // logical lines, if those are connected by collapsed ranges.
	  function LineView(doc, line, lineN) {
	    // The starting line
	    this.line = line;
	    // Continuing lines, if any
	    this.rest = visualLineContinued(line);
	    // Number of logical lines in this visual line
	    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	    this.node = this.text = null;
	    this.hidden = lineIsHidden(doc, line);
	  }
	
	  // Create a range of LineView objects for the given lines.
	  function buildViewArray(cm, from, to) {
	    var array = [], nextPos;
	    for (var pos = from; pos < to; pos = nextPos) {
	      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	      nextPos = pos + view.size;
	      array.push(view);
	    }
	    return array;
	  }
	
	  // Updates the display.view data structure for a given change to the
	  // document. From and to are in pre-change coordinates. Lendiff is
	  // the amount of lines added or subtracted by the change. This is
	  // used for changes that span multiple lines, or change the way
	  // lines are divided into visual lines. regLineChange (below)
	  // registers single-line changes.
	  function regChange(cm, from, to, lendiff) {
	    if (from == null) from = cm.doc.first;
	    if (to == null) to = cm.doc.first + cm.doc.size;
	    if (!lendiff) lendiff = 0;
	
	    var display = cm.display;
	    if (lendiff && to < display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers > from))
	      display.updateLineNumbers = from;
	
	    cm.curOp.viewChanged = true;
	
	    if (from >= display.viewTo) { // Change after
	      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	        resetView(cm);
	    } else if (to <= display.viewFrom) { // Change before
	      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	        resetView(cm);
	      } else {
	        display.viewFrom += lendiff;
	        display.viewTo += lendiff;
	      }
	    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	      resetView(cm);
	    } else if (from <= display.viewFrom) { // Top overlap
	      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cut) {
	        display.view = display.view.slice(cut.index);
	        display.viewFrom = cut.lineN;
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    } else if (to >= display.viewTo) { // Bottom overlap
	      var cut = viewCuttingPoint(cm, from, from, -1);
	      if (cut) {
	        display.view = display.view.slice(0, cut.index);
	        display.viewTo = cut.lineN;
	      } else {
	        resetView(cm);
	      }
	    } else { // Gap in the middle
	      var cutTop = viewCuttingPoint(cm, from, from, -1);
	      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cutTop && cutBot) {
	        display.view = display.view.slice(0, cutTop.index)
	          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	          .concat(display.view.slice(cutBot.index));
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    }
	
	    var ext = display.externalMeasured;
	    if (ext) {
	      if (to < ext.lineN)
	        ext.lineN += lendiff;
	      else if (from < ext.lineN + ext.size)
	        display.externalMeasured = null;
	    }
	  }
	
	  // Register a change to a single line. Type must be one of "text",
	  // "gutter", "class", "widget"
	  function regLineChange(cm, line, type) {
	    cm.curOp.viewChanged = true;
	    var display = cm.display, ext = cm.display.externalMeasured;
	    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	      display.externalMeasured = null;
	
	    if (line < display.viewFrom || line >= display.viewTo) return;
	    var lineView = display.view[findViewIndex(cm, line)];
	    if (lineView.node == null) return;
	    var arr = lineView.changes || (lineView.changes = []);
	    if (indexOf(arr, type) == -1) arr.push(type);
	  }
	
	  // Clear the view.
	  function resetView(cm) {
	    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	    cm.display.view = [];
	    cm.display.viewOffset = 0;
	  }
	
	  // Find the view element corresponding to a given line. Return null
	  // when the line isn't visible.
	  function findViewIndex(cm, n) {
	    if (n >= cm.display.viewTo) return null;
	    n -= cm.display.viewFrom;
	    if (n < 0) return null;
	    var view = cm.display.view;
	    for (var i = 0; i < view.length; i++) {
	      n -= view[i].size;
	      if (n < 0) return i;
	    }
	  }
	
	  function viewCuttingPoint(cm, oldN, newN, dir) {
	    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	      return {index: index, lineN: newN};
	    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
	      n += view[i].size;
	    if (n != oldN) {
	      if (dir > 0) {
	        if (index == view.length - 1) return null;
	        diff = (n + view[index].size) - oldN;
	        index++;
	      } else {
	        diff = n - oldN;
	      }
	      oldN += diff; newN += diff;
	    }
	    while (visualLineNo(cm.doc, newN) != newN) {
	      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
	      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	      index += dir;
	    }
	    return {index: index, lineN: newN};
	  }
	
	  // Force the view to cover a given range, adding empty view element
	  // or clipping off existing ones as needed.
	  function adjustView(cm, from, to) {
	    var display = cm.display, view = display.view;
	    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	      display.view = buildViewArray(cm, from, to);
	      display.viewFrom = from;
	    } else {
	      if (display.viewFrom > from)
	        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
	      else if (display.viewFrom < from)
	        display.view = display.view.slice(findViewIndex(cm, from));
	      display.viewFrom = from;
	      if (display.viewTo < to)
	        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
	      else if (display.viewTo > to)
	        display.view = display.view.slice(0, findViewIndex(cm, to));
	    }
	    display.viewTo = to;
	  }
	
	  // Count the number of lines in the view whose DOM representation is
	  // out of date (or nonexistent).
	  function countDirtyView(cm) {
	    var view = cm.display.view, dirty = 0;
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
	    }
	    return dirty;
	  }
	
	  // EVENT HANDLERS
	
	  // Attach the necessary event handlers when initializing the editor
	  function registerEventHandlers(cm) {
	    var d = cm.display;
	    on(d.scroller, "mousedown", operation(cm, onMouseDown));
	    // Older IE's will not fire a second mousedown for a double click
	    if (ie && ie_version < 11)
	      on(d.scroller, "dblclick", operation(cm, function(e) {
	        if (signalDOMEvent(cm, e)) return;
	        var pos = posFromMouse(cm, e);
	        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
	        e_preventDefault(e);
	        var word = cm.findWordAt(pos);
	        extendSelection(cm.doc, word.anchor, word.head);
	      }));
	    else
	      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
	    // Some browsers fire contextmenu *after* opening the menu, at
	    // which point we can't mess with it anymore. Context menu is
	    // handled in onMouseDown for these browsers.
	    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});
	
	    // Used to suppress mouse event handling when a touch happens
	    var touchFinished, prevTouch = {end: 0};
	    function finishTouch() {
	      if (d.activeTouch) {
	        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);
	        prevTouch = d.activeTouch;
	        prevTouch.end = +new Date;
	      }
	    };
	    function isMouseLikeTouchEvent(e) {
	      if (e.touches.length != 1) return false;
	      var touch = e.touches[0];
	      return touch.radiusX <= 1 && touch.radiusY <= 1;
	    }
	    function farAway(touch, other) {
	      if (other.left == null) return true;
	      var dx = other.left - touch.left, dy = other.top - touch.top;
	      return dx * dx + dy * dy > 20 * 20;
	    }
	    on(d.scroller, "touchstart", function(e) {
	      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
	        clearTimeout(touchFinished);
	        var now = +new Date;
	        d.activeTouch = {start: now, moved: false,
	                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
	        if (e.touches.length == 1) {
	          d.activeTouch.left = e.touches[0].pageX;
	          d.activeTouch.top = e.touches[0].pageY;
	        }
	      }
	    });
	    on(d.scroller, "touchmove", function() {
	      if (d.activeTouch) d.activeTouch.moved = true;
	    });
	    on(d.scroller, "touchend", function(e) {
	      var touch = d.activeTouch;
	      if (touch && !eventInWidget(d, e) && touch.left != null &&
	          !touch.moved && new Date - touch.start < 300) {
	        var pos = cm.coordsChar(d.activeTouch, "page"), range;
	        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	          range = new Range(pos, pos);
	        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	          range = cm.findWordAt(pos);
	        else // Triple tap
	          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
	        cm.setSelection(range.anchor, range.head);
	        cm.focus();
	        e_preventDefault(e);
	      }
	      finishTouch();
	    });
	    on(d.scroller, "touchcancel", finishTouch);
	
	    // Sync scrolling between fake scrollbars and real scrollable
	    // area, ensure viewport is updated when scrolling.
	    on(d.scroller, "scroll", function() {
	      if (d.scroller.clientHeight) {
	        setScrollTop(cm, d.scroller.scrollTop);
	        setScrollLeft(cm, d.scroller.scrollLeft, true);
	        signal(cm, "scroll", cm);
	      }
	    });
	
	    // Listen to wheel events in order to try and update the viewport on time.
	    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
	    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});
	
	    // Prevent wrapper from ever scrolling
	    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });
	
	    d.dragFunctions = {
	      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},
	      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	      start: function(e){onDragStart(cm, e);},
	      drop: operation(cm, onDrop),
	      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	    };
	
	    var inp = d.input.getField();
	    on(inp, "keyup", function(e) { onKeyUp.call(cm, e); });
	    on(inp, "keydown", operation(cm, onKeyDown));
	    on(inp, "keypress", operation(cm, onKeyPress));
	    on(inp, "focus", bind(onFocus, cm));
	    on(inp, "blur", bind(onBlur, cm));
	  }
	
	  function dragDropChanged(cm, value, old) {
	    var wasOn = old && old != CodeMirror.Init;
	    if (!value != !wasOn) {
	      var funcs = cm.display.dragFunctions;
	      var toggle = value ? on : off;
	      toggle(cm.display.scroller, "dragstart", funcs.start);
	      toggle(cm.display.scroller, "dragenter", funcs.enter);
	      toggle(cm.display.scroller, "dragover", funcs.over);
	      toggle(cm.display.scroller, "dragleave", funcs.leave);
	      toggle(cm.display.scroller, "drop", funcs.drop);
	    }
	  }
	
	  // Called when the window resizes
	  function onResize(cm) {
	    var d = cm.display;
	    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	      return;
	    // Might be a text scaling operation, clear size caches.
	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	    d.scrollbarsClipped = false;
	    cm.setSize();
	  }
	
	  // MOUSE EVENTS
	
	  // Return true when the given mouse event happened in a widget
	  function eventInWidget(display, e) {
	    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	          (n.parentNode == display.sizer && n != display.mover))
	        return true;
	    }
	  }
	
	  // Given a mouse event, find the corresponding position. If liberal
	  // is false, it checks whether a gutter or scrollbar was clicked,
	  // and returns null if it was. forRect is used by rectangular
	  // selections, and tries to estimate a character position even for
	  // coordinates beyond the right of the text.
	  function posFromMouse(cm, e, liberal, forRect) {
	    var display = cm.display;
	    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") return null;
	
	    var x, y, space = display.lineSpace.getBoundingClientRect();
	    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	    try { x = e.clientX - space.left; y = e.clientY - space.top; }
	    catch (e) { return null; }
	    var coords = coordsChar(cm, x, y), line;
	    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	    }
	    return coords;
	  }
	
	  // A mouse down can be a single click, double click, triple click,
	  // start of selection drag, start of text drag, new cursor
	  // (ctrl-click), rectangle drag (alt-drag), or xwin
	  // middle-click-paste. Or it might be a click on something we should
	  // not interfere with, such as a scrollbar or widget.
	  function onMouseDown(e) {
	    var cm = this, display = cm.display;
	    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;
	    display.shift = e.shiftKey;
	
	    if (eventInWidget(display, e)) {
	      if (!webkit) {
	        // Briefly turn off draggability, to allow widgets to do
	        // normal dragging things.
	        display.scroller.draggable = false;
	        setTimeout(function(){display.scroller.draggable = true;}, 100);
	      }
	      return;
	    }
	    if (clickInGutter(cm, e)) return;
	    var start = posFromMouse(cm, e);
	    window.focus();
	
	    switch (e_button(e)) {
	    case 1:
	      // #3261: make sure, that we're not starting a second selection
	      if (cm.state.selectingText)
	        cm.state.selectingText(e);
	      else if (start)
	        leftButtonDown(cm, e, start);
	      else if (e_target(e) == display.scroller)
	        e_preventDefault(e);
	      break;
	    case 2:
	      if (webkit) cm.state.lastMiddleDown = +new Date;
	      if (start) extendSelection(cm.doc, start);
	      setTimeout(function() {display.input.focus();}, 20);
	      e_preventDefault(e);
	      break;
	    case 3:
	      if (captureRightClick) onContextMenu(cm, e);
	      else delayBlurEvent(cm);
	      break;
	    }
	  }
	
	  var lastClick, lastDoubleClick;
	  function leftButtonDown(cm, e, start) {
	    if (ie) setTimeout(bind(ensureFocus, cm), 0);
	    else cm.curOp.focus = activeElt();
	
	    var now = +new Date, type;
	    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
	      type = "triple";
	    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
	      type = "double";
	      lastDoubleClick = {time: now, pos: start};
	    } else {
	      type = "single";
	      lastClick = {time: now, pos: start};
	    }
	
	    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
	    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	        type == "single" && (contained = sel.contains(start)) > -1 &&
	        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
	        (cmp(contained.to(), start) > 0 || start.xRel < 0))
	      leftButtonStartDrag(cm, e, start, modifier);
	    else
	      leftButtonSelect(cm, e, start, type, modifier);
	  }
	
	  // Start a text drag. When it ends, see if any dragging actually
	  // happen, and treat as a click if it didn't.
	  function leftButtonStartDrag(cm, e, start, modifier) {
	    var display = cm.display, startTime = +new Date;
	    var dragEnd = operation(cm, function(e2) {
	      if (webkit) display.scroller.draggable = false;
	      cm.state.draggingText = false;
	      off(document, "mouseup", dragEnd);
	      off(display.scroller, "drop", dragEnd);
	      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
	        e_preventDefault(e2);
	        if (!modifier && +new Date - 200 < startTime)
	          extendSelection(cm.doc, start);
	        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	        if (webkit || ie && ie_version == 9)
	          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);
	        else
	          display.input.focus();
	      }
	    });
	    // Let the drag handler handle this.
	    if (webkit) display.scroller.draggable = true;
	    cm.state.draggingText = dragEnd;
	    dragEnd.copy = mac ? e.altKey : e.ctrlKey
	    // IE's approach to draggable
	    if (display.scroller.dragDrop) display.scroller.dragDrop();
	    on(document, "mouseup", dragEnd);
	    on(display.scroller, "drop", dragEnd);
	  }
	
	  // Normal selection, as opposed to text dragging.
	  function leftButtonSelect(cm, e, start, type, addNew) {
	    var display = cm.display, doc = cm.doc;
	    e_preventDefault(e);
	
	    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	    if (addNew && !e.shiftKey) {
	      ourIndex = doc.sel.contains(start);
	      if (ourIndex > -1)
	        ourRange = ranges[ourIndex];
	      else
	        ourRange = new Range(start, start);
	    } else {
	      ourRange = doc.sel.primary();
	      ourIndex = doc.sel.primIndex;
	    }
	
	    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
	      type = "rect";
	      if (!addNew) ourRange = new Range(start, start);
	      start = posFromMouse(cm, e, true, true);
	      ourIndex = -1;
	    } else if (type == "double") {
	      var word = cm.findWordAt(start);
	      if (cm.display.shift || doc.extend)
	        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
	      else
	        ourRange = word;
	    } else if (type == "triple") {
	      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
	      if (cm.display.shift || doc.extend)
	        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
	      else
	        ourRange = line;
	    } else {
	      ourRange = extendRange(doc, ourRange, start);
	    }
	
	    if (!addNew) {
	      ourIndex = 0;
	      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	      startSel = doc.sel;
	    } else if (ourIndex == -1) {
	      ourIndex = ranges.length;
	      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                   {scroll: false, origin: "*mouse"});
	    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
	      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                   {scroll: false, origin: "*mouse"});
	      startSel = doc.sel;
	    } else {
	      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	    }
	
	    var lastPos = start;
	    function extendTo(pos) {
	      if (cmp(lastPos, pos) == 0) return;
	      lastPos = pos;
	
	      if (type == "rect") {
	        var ranges = [], tabSize = cm.options.tabSize;
	        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	             line <= end; line++) {
	          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	          if (left == right)
	            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
	          else if (text.length > leftPos)
	            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
	        }
	        if (!ranges.length) ranges.push(new Range(start, start));
	        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                     {origin: "*mouse", scroll: false});
	        cm.scrollIntoView(pos);
	      } else {
	        var oldRange = ourRange;
	        var anchor = oldRange.anchor, head = pos;
	        if (type != "single") {
	          if (type == "double")
	            var range = cm.findWordAt(pos);
	          else
	            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
	          if (cmp(range.anchor, anchor) > 0) {
	            head = range.head;
	            anchor = minPos(oldRange.from(), range.anchor);
	          } else {
	            head = range.anchor;
	            anchor = maxPos(oldRange.to(), range.head);
	          }
	        }
	        var ranges = startSel.ranges.slice(0);
	        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
	        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
	      }
	    }
	
	    var editorSize = display.wrapper.getBoundingClientRect();
	    // Used to ensure timeout re-tries don't fire when another extend
	    // happened in the meantime (clearTimeout isn't reliable -- at
	    // least on Chrome, the timeouts still happen even when cleared,
	    // if the clear happens after their scheduled firing time).
	    var counter = 0;
	
	    function extend(e) {
	      var curCount = ++counter;
	      var cur = posFromMouse(cm, e, true, type == "rect");
	      if (!cur) return;
	      if (cmp(cur, lastPos) != 0) {
	        cm.curOp.focus = activeElt();
	        extendTo(cur);
	        var visible = visibleLines(display, doc);
	        if (cur.line >= visible.to || cur.line < visible.from)
	          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
	      } else {
	        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	        if (outside) setTimeout(operation(cm, function() {
	          if (counter != curCount) return;
	          display.scroller.scrollTop += outside;
	          extend(e);
	        }), 50);
	      }
	    }
	
	    function done(e) {
	      cm.state.selectingText = false;
	      counter = Infinity;
	      e_preventDefault(e);
	      display.input.focus();
	      off(document, "mousemove", move);
	      off(document, "mouseup", up);
	      doc.history.lastSelOrigin = null;
	    }
	
	    var move = operation(cm, function(e) {
	      if (!e_button(e)) done(e);
	      else extend(e);
	    });
	    var up = operation(cm, done);
	    cm.state.selectingText = up;
	    on(document, "mousemove", move);
	    on(document, "mouseup", up);
	  }
	
	  // Determines whether an event happened in the gutter, and fires the
	  // handlers for the corresponding event.
	  function gutterEvent(cm, e, type, prevent) {
	    try { var mX = e.clientX, mY = e.clientY; }
	    catch(e) { return false; }
	    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
	    if (prevent) e_preventDefault(e);
	
	    var display = cm.display;
	    var lineBox = display.lineDiv.getBoundingClientRect();
	
	    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
	    mY -= lineBox.top - display.viewOffset;
	
	    for (var i = 0; i < cm.options.gutters.length; ++i) {
	      var g = display.gutters.childNodes[i];
	      if (g && g.getBoundingClientRect().right >= mX) {
	        var line = lineAtHeight(cm.doc, mY);
	        var gutter = cm.options.gutters[i];
	        signal(cm, type, cm, line, gutter, e);
	        return e_defaultPrevented(e);
	      }
	    }
	  }
	
	  function clickInGutter(cm, e) {
	    return gutterEvent(cm, e, "gutterClick", true);
	  }
	
	  // Kludge to work around strange IE behavior where it'll sometimes
	  // re-fire a series of drag-related events right after the drop (#1551)
	  var lastDrop = 0;
	
	  function onDrop(e) {
	    var cm = this;
	    clearDragCursor(cm);
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	      return;
	    e_preventDefault(e);
	    if (ie) lastDrop = +new Date;
	    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	    if (!pos || cm.isReadOnly()) return;
	    // Might be a file drop, in which case we simply extract the text
	    // and insert it.
	    if (files && files.length && window.FileReader && window.File) {
	      var n = files.length, text = Array(n), read = 0;
	      var loadFile = function(file, i) {
	        if (cm.options.allowDropFileTypes &&
	            indexOf(cm.options.allowDropFileTypes, file.type) == -1)
	          return;
	
	        var reader = new FileReader;
	        reader.onload = operation(cm, function() {
	          var content = reader.result;
	          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) content = "";
	          text[i] = content;
	          if (++read == n) {
	            pos = clipPos(cm.doc, pos);
	            var change = {from: pos, to: pos,
	                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
	                          origin: "paste"};
	            makeChange(cm.doc, change);
	            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
	          }
	        });
	        reader.readAsText(file);
	      };
	      for (var i = 0; i < n; ++i) loadFile(files[i], i);
	    } else { // Normal drop
	      // Don't do a replace if the drop happened inside of the selected text.
	      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	        cm.state.draggingText(e);
	        // Ensure the editor is re-focused
	        setTimeout(function() {cm.display.input.focus();}, 20);
	        return;
	      }
	      try {
	        var text = e.dataTransfer.getData("Text");
	        if (text) {
	          if (cm.state.draggingText && !cm.state.draggingText.copy)
	            var selected = cm.listSelections();
	          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	          if (selected) for (var i = 0; i < selected.length; ++i)
	            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
	          cm.replaceSelection(text, "around", "paste");
	          cm.display.input.focus();
	        }
	      }
	      catch(e){}
	    }
	  }
	
	  function onDragStart(cm, e) {
	    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;
	
	    e.dataTransfer.setData("Text", cm.getSelection());
	    e.dataTransfer.effectAllowed = "copyMove"
	
	    // Use dummy image instead of default browsers image.
	    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	    if (e.dataTransfer.setDragImage && !safari) {
	      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	      if (presto) {
	        img.width = img.height = 1;
	        cm.display.wrapper.appendChild(img);
	        // Force a relayout, or Opera won't use our image for some obscure reason
	        img._top = img.offsetTop;
	      }
	      e.dataTransfer.setDragImage(img, 0, 0);
	      if (presto) img.parentNode.removeChild(img);
	    }
	  }
	
	  function onDragOver(cm, e) {
	    var pos = posFromMouse(cm, e);
	    if (!pos) return;
	    var frag = document.createDocumentFragment();
	    drawSelectionCursor(cm, pos, frag);
	    if (!cm.display.dragCursor) {
	      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	    }
	    removeChildrenAndAdd(cm.display.dragCursor, frag);
	  }
	
	  function clearDragCursor(cm) {
	    if (cm.display.dragCursor) {
	      cm.display.lineSpace.removeChild(cm.display.dragCursor);
	      cm.display.dragCursor = null;
	    }
	  }
	
	  // SCROLL EVENTS
	
	  // Sync the scrollable area and scrollbars, ensure the viewport
	  // covers the visible area.
	  function setScrollTop(cm, val) {
	    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
	    cm.doc.scrollTop = val;
	    if (!gecko) updateDisplaySimple(cm, {top: val});
	    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
	    cm.display.scrollbars.setScrollTop(val);
	    if (gecko) updateDisplaySimple(cm);
	    startWorker(cm, 100);
	  }
	  // Sync scroller and scrollbar, ensure the gutter elements are
	  // aligned.
	  function setScrollLeft(cm, val, isScroller) {
	    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
	    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
	    cm.doc.scrollLeft = val;
	    alignHorizontally(cm);
	    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
	    cm.display.scrollbars.setScrollLeft(val);
	  }
	
	  // Since the delta values reported on mouse wheel events are
	  // unstandardized between browsers and even browser versions, and
	  // generally horribly unpredictable, this code starts by measuring
	  // the scroll effect that the first few mouse wheel events have,
	  // and, from that, detects the way it can convert deltas to pixel
	  // offsets afterwards.
	  //
	  // The reason we want to know the amount a wheel event will scroll
	  // is that it gives us a chance to update the display before the
	  // actual scrolling happens, reducing flickering.
	
	  var wheelSamples = 0, wheelPixelsPerUnit = null;
	  // Fill in a browser-detected starting value on browsers where we
	  // know one. These don't have to be accurate -- the result of them
	  // being wrong would just be a slight flicker on the first wheel
	  // scroll (if it is large enough).
	  if (ie) wheelPixelsPerUnit = -.53;
	  else if (gecko) wheelPixelsPerUnit = 15;
	  else if (chrome) wheelPixelsPerUnit = -.7;
	  else if (safari) wheelPixelsPerUnit = -1/3;
	
	  var wheelEventDelta = function(e) {
	    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
	    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
	    else if (dy == null) dy = e.wheelDelta;
	    return {x: dx, y: dy};
	  };
	  CodeMirror.wheelEventPixels = function(e) {
	    var delta = wheelEventDelta(e);
	    delta.x *= wheelPixelsPerUnit;
	    delta.y *= wheelPixelsPerUnit;
	    return delta;
	  };
	
	  function onScrollWheel(cm, e) {
	    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
	
	    var display = cm.display, scroll = display.scroller;
	    // Quit if there's nothing to scroll here
	    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	    if (!(dx && canScrollX || dy && canScrollY)) return;
	
	    // Webkit browsers on OS X abort momentum scrolls when the target
	    // of the scroll event is removed from the scrollable element.
	    // This hack (see related code in patchDisplay) makes sure the
	    // element is kept around.
	    if (dy && mac && webkit) {
	      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	        for (var i = 0; i < view.length; i++) {
	          if (view[i].node == cur) {
	            cm.display.currentWheelTarget = cur;
	            break outer;
	          }
	        }
	      }
	    }
	
	    // On some browsers, horizontal scrolling will cause redraws to
	    // happen before the gutter has been realigned, causing it to
	    // wriggle around in a most unseemly way. When we have an
	    // estimated pixels/delta value, we just handle horizontal
	    // scrolling entirely here. It'll be slightly off from native, but
	    // better than glitching out.
	    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	      if (dy && canScrollY)
	        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
	      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
	      // Only prevent default scrolling if vertical scrolling is
	      // actually possible. Otherwise, it causes vertical scroll
	      // jitter on OSX trackpads when deltaX is small and deltaY
	      // is large (issue #3579)
	      if (!dy || (dy && canScrollY))
	        e_preventDefault(e);
	      display.wheelStartX = null; // Abort measurement, if in progress
	      return;
	    }
	
	    // 'Project' the visible viewport to cover the area that is being
	    // scrolled into view (if we know enough to estimate it).
	    if (dy && wheelPixelsPerUnit != null) {
	      var pixels = dy * wheelPixelsPerUnit;
	      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	      if (pixels < 0) top = Math.max(0, top + pixels - 50);
	      else bot = Math.min(cm.doc.height, bot + pixels + 50);
	      updateDisplaySimple(cm, {top: top, bottom: bot});
	    }
	
	    if (wheelSamples < 20) {
	      if (display.wheelStartX == null) {
	        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	        display.wheelDX = dx; display.wheelDY = dy;
	        setTimeout(function() {
	          if (display.wheelStartX == null) return;
	          var movedX = scroll.scrollLeft - display.wheelStartX;
	          var movedY = scroll.scrollTop - display.wheelStartY;
	          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	            (movedX && display.wheelDX && movedX / display.wheelDX);
	          display.wheelStartX = display.wheelStartY = null;
	          if (!sample) return;
	          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	          ++wheelSamples;
	        }, 200);
	      } else {
	        display.wheelDX += dx; display.wheelDY += dy;
	      }
	    }
	  }
	
	  // KEY EVENTS
	
	  // Run a handler that was bound to a key.
	  function doHandleBinding(cm, bound, dropShift) {
	    if (typeof bound == "string") {
	      bound = commands[bound];
	      if (!bound) return false;
	    }
	    // Ensure previous input has been read, so that the handler sees a
	    // consistent view of the document
	    cm.display.input.ensurePolled();
	    var prevShift = cm.display.shift, done = false;
	    try {
	      if (cm.isReadOnly()) cm.state.suppressEdits = true;
	      if (dropShift) cm.display.shift = false;
	      done = bound(cm) != Pass;
	    } finally {
	      cm.display.shift = prevShift;
	      cm.state.suppressEdits = false;
	    }
	    return done;
	  }
	
	  function lookupKeyForEditor(cm, name, handle) {
	    for (var i = 0; i < cm.state.keyMaps.length; i++) {
	      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	      if (result) return result;
	    }
	    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	      || lookupKey(name, cm.options.keyMap, handle, cm);
	  }
	
	  var stopSeq = new Delayed;
	  function dispatchKey(cm, name, e, handle) {
	    var seq = cm.state.keySeq;
	    if (seq) {
	      if (isModifierKey(name)) return "handled";
	      stopSeq.set(50, function() {
	        if (cm.state.keySeq == seq) {
	          cm.state.keySeq = null;
	          cm.display.input.reset();
	        }
	      });
	      name = seq + " " + name;
	    }
	    var result = lookupKeyForEditor(cm, name, handle);
	
	    if (result == "multi")
	      cm.state.keySeq = name;
	    if (result == "handled")
	      signalLater(cm, "keyHandled", cm, name, e);
	
	    if (result == "handled" || result == "multi") {
	      e_preventDefault(e);
	      restartBlink(cm);
	    }
	
	    if (seq && !result && /\'$/.test(name)) {
	      e_preventDefault(e);
	      return true;
	    }
	    return !!result;
	  }
	
	  // Handle a key from the keydown event.
	  function handleKeyBinding(cm, e) {
	    var name = keyName(e, true);
	    if (!name) return false;
	
	    if (e.shiftKey && !cm.state.keySeq) {
	      // First try to resolve full name (including 'Shift-'). Failing
	      // that, see if there is a cursor-motion command (starting with
	      // 'go') bound to the keyname without 'Shift-'.
	      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
	          || dispatchKey(cm, name, e, function(b) {
	               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	                 return doHandleBinding(cm, b);
	             });
	    } else {
	      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
	    }
	  }
	
	  // Handle a key from the keypress event
	  function handleCharBinding(cm, e, ch) {
	    return dispatchKey(cm, "'" + ch + "'", e,
	                       function(b) { return doHandleBinding(cm, b, true); });
	  }
	
	  var lastStoppedKey = null;
	  function onKeyDown(e) {
	    var cm = this;
	    cm.curOp.focus = activeElt();
	    if (signalDOMEvent(cm, e)) return;
	    // IE does strange things with escape.
	    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
	    var code = e.keyCode;
	    cm.display.shift = code == 16 || e.shiftKey;
	    var handled = handleKeyBinding(cm, e);
	    if (presto) {
	      lastStoppedKey = handled ? code : null;
	      // Opera has no cut event... we try to at least catch the key combo
	      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	        cm.replaceSelection("", null, "cut");
	    }
	
	    // Turn mouse into crosshair when Alt is held on Mac.
	    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	      showCrossHair(cm);
	  }
	
	  function showCrossHair(cm) {
	    var lineDiv = cm.display.lineDiv;
	    addClass(lineDiv, "CodeMirror-crosshair");
	
	    function up(e) {
	      if (e.keyCode == 18 || !e.altKey) {
	        rmClass(lineDiv, "CodeMirror-crosshair");
	        off(document, "keyup", up);
	        off(document, "mouseover", up);
	      }
	    }
	    on(document, "keyup", up);
	    on(document, "mouseover", up);
	  }
	
	  function onKeyUp(e) {
	    if (e.keyCode == 16) this.doc.sel.shift = false;
	    signalDOMEvent(this, e);
	  }
	
	  function onKeyPress(e) {
	    var cm = this;
	    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
	    var keyCode = e.keyCode, charCode = e.charCode;
	    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
	    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
	    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	    if (handleCharBinding(cm, e, ch)) return;
	    cm.display.input.onKeyPress(e);
	  }
	
	  // FOCUS/BLUR EVENTS
	
	  function delayBlurEvent(cm) {
	    cm.state.delayingBlurEvent = true;
	    setTimeout(function() {
	      if (cm.state.delayingBlurEvent) {
	        cm.state.delayingBlurEvent = false;
	        onBlur(cm);
	      }
	    }, 100);
	  }
	
	  function onFocus(cm) {
	    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;
	
	    if (cm.options.readOnly == "nocursor") return;
	    if (!cm.state.focused) {
	      signal(cm, "focus", cm);
	      cm.state.focused = true;
	      addClass(cm.display.wrapper, "CodeMirror-focused");
	      // This test prevents this from firing when a context
	      // menu is closed (since the input reset would kill the
	      // select-all detection hack)
	      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	        cm.display.input.reset();
	        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
	      }
	      cm.display.input.receivedFocus();
	    }
	    restartBlink(cm);
	  }
	  function onBlur(cm) {
	    if (cm.state.delayingBlurEvent) return;
	
	    if (cm.state.focused) {
	      signal(cm, "blur", cm);
	      cm.state.focused = false;
	      rmClass(cm.display.wrapper, "CodeMirror-focused");
	    }
	    clearInterval(cm.display.blinker);
	    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
	  }
	
	  // CONTEXT MENU HANDLING
	
	  // To make the context menu work, we need to briefly unhide the
	  // textarea (making it as unobtrusive as possible) to let the
	  // right-click take effect on it.
	  function onContextMenu(cm, e) {
	    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
	    if (signalDOMEvent(cm, e, "contextmenu")) return;
	    cm.display.input.onContextMenu(e);
	  }
	
	  function contextMenuInGutter(cm, e) {
	    if (!hasHandler(cm, "gutterContextMenu")) return false;
	    return gutterEvent(cm, e, "gutterContextMenu", false);
	  }
	
	  // UPDATING
	
	  // Compute the position of the end of a change (its 'to' property
	  // refers to the pre-change end).
	  var changeEnd = CodeMirror.changeEnd = function(change) {
	    if (!change.text) return change.to;
	    return Pos(change.from.line + change.text.length - 1,
	               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
	  };
	
	  // Adjust a position to refer to the post-change position of the
	  // same text, or the end of the change if the change covers it.
	  function adjustForChange(pos, change) {
	    if (cmp(pos, change.from) < 0) return pos;
	    if (cmp(pos, change.to) <= 0) return changeEnd(change);
	
	    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
	    return Pos(line, ch);
	  }
	
	  function computeSelAfterChange(doc, change) {
	    var out = [];
	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      var range = doc.sel.ranges[i];
	      out.push(new Range(adjustForChange(range.anchor, change),
	                         adjustForChange(range.head, change)));
	    }
	    return normalizeSelection(out, doc.sel.primIndex);
	  }
	
	  function offsetPos(pos, old, nw) {
	    if (pos.line == old.line)
	      return Pos(nw.line, pos.ch - old.ch + nw.ch);
	    else
	      return Pos(nw.line + (pos.line - old.line), pos.ch);
	  }
	
	  // Used by replaceSelections to allow moving the selection to the
	  // start or around the replaced test. Hint may be "start" or "around".
	  function computeReplacedSel(doc, changes, hint) {
	    var out = [];
	    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	    for (var i = 0; i < changes.length; i++) {
	      var change = changes[i];
	      var from = offsetPos(change.from, oldPrev, newPrev);
	      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	      oldPrev = change.to;
	      newPrev = to;
	      if (hint == "around") {
	        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	        out[i] = new Range(inv ? to : from, inv ? from : to);
	      } else {
	        out[i] = new Range(from, from);
	      }
	    }
	    return new Selection(out, doc.sel.primIndex);
	  }
	
	  // Allow "beforeChange" event handlers to influence a change
	  function filterChange(doc, change, update) {
	    var obj = {
	      canceled: false,
	      from: change.from,
	      to: change.to,
	      text: change.text,
	      origin: change.origin,
	      cancel: function() { this.canceled = true; }
	    };
	    if (update) obj.update = function(from, to, text, origin) {
	      if (from) this.from = clipPos(doc, from);
	      if (to) this.to = clipPos(doc, to);
	      if (text) this.text = text;
	      if (origin !== undefined) this.origin = origin;
	    };
	    signal(doc, "beforeChange", doc, obj);
	    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);
	
	    if (obj.canceled) return null;
	    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
	  }
	
	  // Apply a change to a document, and add it to the document's
	  // history, and propagating it to all linked documents.
	  function makeChange(doc, change, ignoreReadOnly) {
	    if (doc.cm) {
	      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
	      if (doc.cm.state.suppressEdits) return;
	    }
	
	    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	      change = filterChange(doc, change, true);
	      if (!change) return;
	    }
	
	    // Possibly split or suppress the update based on the presence
	    // of read-only spans in its range.
	    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	    if (split) {
	      for (var i = split.length - 1; i >= 0; --i)
	        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
	    } else {
	      makeChangeInner(doc, change);
	    }
	  }
	
	  function makeChangeInner(doc, change) {
	    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
	    var selAfter = computeSelAfterChange(doc, change);
	    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
	
	    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	    var rebased = [];
	
	    linkedDocs(doc, function(doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	    });
	  }
	
	  // Revert a change stored in a document's history.
	  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;
	
	    var hist = doc.history, event, selAfter = doc.sel;
	    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
	
	    // Verify that there is a useable event (so that ctrl-z won't
	    // needlessly clear selection events)
	    for (var i = 0; i < source.length; i++) {
	      event = source[i];
	      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	        break;
	    }
	    if (i == source.length) return;
	    hist.lastOrigin = hist.lastSelOrigin = null;
	
	    for (;;) {
	      event = source.pop();
	      if (event.ranges) {
	        pushSelectionToHistory(event, dest);
	        if (allowSelectionOnly && !event.equals(doc.sel)) {
	          setSelection(doc, event, {clearRedo: false});
	          return;
	        }
	        selAfter = event;
	      }
	      else break;
	    }
	
	    // Build up a reverse change object to add to the opposite history
	    // stack (redo when undoing, and vice versa).
	    var antiChanges = [];
	    pushSelectionToHistory(selAfter, dest);
	    dest.push({changes: antiChanges, generation: hist.generation});
	    hist.generation = event.generation || ++hist.maxGeneration;
	
	    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
	
	    for (var i = event.changes.length - 1; i >= 0; --i) {
	      var change = event.changes[i];
	      change.origin = type;
	      if (filter && !filterChange(doc, change, false)) {
	        source.length = 0;
	        return;
	      }
	
	      antiChanges.push(historyChangeFromChange(doc, change));
	
	      var after = i ? computeSelAfterChange(doc, change) : lst(source);
	      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
	      var rebased = [];
	
	      // Propagate to the linked documents
	      linkedDocs(doc, function(doc, sharedHist) {
	        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	          rebaseHist(doc.history, change);
	          rebased.push(doc.history);
	        }
	        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	      });
	    }
	  }
	
	  // Sub-views need their line numbers shifted when text is added
	  // above or below them in the parent document.
	  function shiftDoc(doc, distance) {
	    if (distance == 0) return;
	    doc.first += distance;
	    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
	      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
	                       Pos(range.head.line + distance, range.head.ch));
	    }), doc.sel.primIndex);
	    if (doc.cm) {
	      regChange(doc.cm, doc.first, doc.first - distance, distance);
	      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	        regLineChange(doc.cm, l, "gutter");
	    }
	  }
	
	  // More lower-level change function, handling only a single document
	  // (not linked ones).
	  function makeChangeSingleDoc(doc, change, selAfter, spans) {
	    if (doc.cm && !doc.cm.curOp)
	      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
	
	    if (change.to.line < doc.first) {
	      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	      return;
	    }
	    if (change.from.line > doc.lastLine()) return;
	
	    // Clip the change to the size of this doc
	    if (change.from.line < doc.first) {
	      var shift = change.text.length - 1 - (doc.first - change.from.line);
	      shiftDoc(doc, shift);
	      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	                text: [lst(change.text)], origin: change.origin};
	    }
	    var last = doc.lastLine();
	    if (change.to.line > last) {
	      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	                text: [change.text[0]], origin: change.origin};
	    }
	
	    change.removed = getBetween(doc, change.from, change.to);
	
	    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
	    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
	    else updateDoc(doc, change, spans);
	    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	  }
	
	  // Handle the interaction of a change to a document with the editor
	  // that this document is part of.
	  function makeChangeSingleDocInEditor(cm, change, spans) {
	    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
	
	    var recomputeMaxLength = false, checkWidthStart = from.line;
	    if (!cm.options.lineWrapping) {
	      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	      doc.iter(checkWidthStart, to.line + 1, function(line) {
	        if (line == display.maxLine) {
	          recomputeMaxLength = true;
	          return true;
	        }
	      });
	    }
	
	    if (doc.sel.contains(change.from, change.to) > -1)
	      signalCursorActivity(cm);
	
	    updateDoc(doc, change, spans, estimateHeight(cm));
	
	    if (!cm.options.lineWrapping) {
	      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
	        var len = lineLength(line);
	        if (len > display.maxLineLength) {
	          display.maxLine = line;
	          display.maxLineLength = len;
	          display.maxLineChanged = true;
	          recomputeMaxLength = false;
	        }
	      });
	      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
	    }
	
	    // Adjust frontier, schedule worker
	    doc.frontier = Math.min(doc.frontier, from.line);
	    startWorker(cm, 400);
	
	    var lendiff = change.text.length - (to.line - from.line) - 1;
	    // Remember that these lines changed, for updating the display
	    if (change.full)
	      regChange(cm);
	    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	      regLineChange(cm, from.line, "text");
	    else
	      regChange(cm, from.line, to.line + 1, lendiff);
	
	    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	    if (changeHandler || changesHandler) {
	      var obj = {
	        from: from, to: to,
	        text: change.text,
	        removed: change.removed,
	        origin: change.origin
	      };
	      if (changeHandler) signalLater(cm, "change", cm, obj);
	      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
	    }
	    cm.display.selForContextMenu = null;
	  }
	
	  function replaceRange(doc, code, from, to, origin) {
	    if (!to) to = from;
	    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
	    if (typeof code == "string") code = doc.splitLines(code);
	    makeChange(doc, {from: from, to: to, text: code, origin: origin});
	  }
	
	  // SCROLLING THINGS INTO VIEW
	
	  // If an editor sits on the top or bottom of the window, partially
	  // scrolled out of view, this ensures that the cursor is visible.
	  function maybeScrollWindow(cm, coords) {
	    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;
	
	    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	    if (coords.top + box.top < 0) doScroll = true;
	    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
	    if (doScroll != null && !phantom) {
	      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
	                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
	                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
	                           coords.left + "px; width: 2px;");
	      cm.display.lineSpace.appendChild(scrollNode);
	      scrollNode.scrollIntoView(doScroll);
	      cm.display.lineSpace.removeChild(scrollNode);
	    }
	  }
	
	  // Scroll a given position into view (immediately), verifying that
	  // it actually became visible (as line heights are accurately
	  // measured, the position of something may 'drift' during drawing).
	  function scrollPosIntoView(cm, pos, end, margin) {
	    if (margin == null) margin = 0;
	    for (var limit = 0; limit < 5; limit++) {
	      var changed = false, coords = cursorCoords(cm, pos);
	      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
	                                         Math.min(coords.top, endCoords.top) - margin,
	                                         Math.max(coords.left, endCoords.left),
	                                         Math.max(coords.bottom, endCoords.bottom) + margin);
	      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	      if (scrollPos.scrollTop != null) {
	        setScrollTop(cm, scrollPos.scrollTop);
	        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
	      }
	      if (scrollPos.scrollLeft != null) {
	        setScrollLeft(cm, scrollPos.scrollLeft);
	        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
	      }
	      if (!changed) break;
	    }
	    return coords;
	  }
	
	  // Scroll a given set of coordinates into view (immediately).
	  function scrollIntoView(cm, x1, y1, x2, y2) {
	    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
	    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
	    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
	  }
	
	  // Calculate a new scroll position needed to scroll the given
	  // rectangle into view. Returns an object with scrollTop and
	  // scrollLeft properties. When these are undefined, the
	  // vertical/horizontal position does not need to be adjusted.
	  function calculateScrollPos(cm, x1, y1, x2, y2) {
	    var display = cm.display, snapMargin = textHeight(cm.display);
	    if (y1 < 0) y1 = 0;
	    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	    var screen = displayHeight(cm), result = {};
	    if (y2 - y1 > screen) y2 = y1 + screen;
	    var docBottom = cm.doc.height + paddingVert(display);
	    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
	    if (y1 < screentop) {
	      result.scrollTop = atTop ? 0 : y1;
	    } else if (y2 > screentop + screen) {
	      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
	      if (newTop != screentop) result.scrollTop = newTop;
	    }
	
	    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	    var tooWide = x2 - x1 > screenw;
	    if (tooWide) x2 = x1 + screenw;
	    if (x1 < 10)
	      result.scrollLeft = 0;
	    else if (x1 < screenleft)
	      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
	    else if (x2 > screenw + screenleft - 3)
	      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
	    return result;
	  }
	
	  // Store a relative adjustment to the scroll position in the current
	  // operation (to be applied when the operation finishes).
	  function addToScrollPos(cm, left, top) {
	    if (left != null || top != null) resolveScrollToPos(cm);
	    if (left != null)
	      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
	    if (top != null)
	      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	  }
	
	  // Make sure that at the end of the operation the current cursor is
	  // shown.
	  function ensureCursorVisible(cm) {
	    resolveScrollToPos(cm);
	    var cur = cm.getCursor(), from = cur, to = cur;
	    if (!cm.options.lineWrapping) {
	      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
	      to = Pos(cur.line, cur.ch + 1);
	    }
	    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
	  }
	
	  // When an operation has its scrollToPos property set, and another
	  // scroll action is applied before the end of the operation, this
	  // 'simulates' scrolling that position into view in a cheap way, so
	  // that the effect of intermediate scroll commands is not ignored.
	  function resolveScrollToPos(cm) {
	    var range = cm.curOp.scrollToPos;
	    if (range) {
	      cm.curOp.scrollToPos = null;
	      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
	      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
	                                    Math.min(from.top, to.top) - range.margin,
	                                    Math.max(from.right, to.right),
	                                    Math.max(from.bottom, to.bottom) + range.margin);
	      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	    }
	  }
	
	  // API UTILITIES
	
	  // Indent the given line. The how parameter can be "smart",
	  // "add"/null, "subtract", or "prev". When aggressive is false
	  // (typically set to true for forced single-line indents), empty
	  // lines are not indented, and places where the mode returns Pass
	  // are left alone.
	  function indentLine(cm, n, how, aggressive) {
	    var doc = cm.doc, state;
	    if (how == null) how = "add";
	    if (how == "smart") {
	      // Fall back to "prev" when the mode doesn't have an indentation
	      // method.
	      if (!doc.mode.indent) how = "prev";
	      else state = getStateBefore(cm, n);
	    }
	
	    var tabSize = cm.options.tabSize;
	    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	    if (line.stateAfter) line.stateAfter = null;
	    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	    if (!aggressive && !/\S/.test(line.text)) {
	      indentation = 0;
	      how = "not";
	    } else if (how == "smart") {
	      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	      if (indentation == Pass || indentation > 150) {
	        if (!aggressive) return;
	        how = "prev";
	      }
	    }
	    if (how == "prev") {
	      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
	      else indentation = 0;
	    } else if (how == "add") {
	      indentation = curSpace + cm.options.indentUnit;
	    } else if (how == "subtract") {
	      indentation = curSpace - cm.options.indentUnit;
	    } else if (typeof how == "number") {
	      indentation = curSpace + how;
	    }
	    indentation = Math.max(0, indentation);
	
	    var indentString = "", pos = 0;
	    if (cm.options.indentWithTabs)
	      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
	    if (pos < indentation) indentString += spaceStr(indentation - pos);
	
	    if (indentString != curSpaceString) {
	      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	      line.stateAfter = null;
	      return true;
	    } else {
	      // Ensure that, if the cursor was in the whitespace at the start
	      // of the line, it is moved to the end of that space.
	      for (var i = 0; i < doc.sel.ranges.length; i++) {
	        var range = doc.sel.ranges[i];
	        if (range.head.line == n && range.head.ch < curSpaceString.length) {
	          var pos = Pos(n, curSpaceString.length);
	          replaceOneSelection(doc, i, new Range(pos, pos));
	          break;
	        }
	      }
	    }
	  }
	
	  // Utility for applying a change to a line by handle or number,
	  // returning the number and optionally registering the line as
	  // changed.
	  function changeLine(doc, handle, changeType, op) {
	    var no = handle, line = handle;
	    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
	    else no = lineNo(handle);
	    if (no == null) return null;
	    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
	    return line;
	  }
	
	  // Helper for deleting text near the selection(s), used to implement
	  // backspace, delete, and similar functionality.
	  function deleteNearSelection(cm, compute) {
	    var ranges = cm.doc.sel.ranges, kill = [];
	    // Build up a set of ranges to kill first, merging overlapping
	    // ranges.
	    for (var i = 0; i < ranges.length; i++) {
	      var toKill = compute(ranges[i]);
	      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	        var replaced = kill.pop();
	        if (cmp(replaced.from, toKill.from) < 0) {
	          toKill.from = replaced.from;
	          break;
	        }
	      }
	      kill.push(toKill);
	    }
	    // Next, remove those actual ranges.
	    runInOp(cm, function() {
	      for (var i = kill.length - 1; i >= 0; i--)
	        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
	      ensureCursorVisible(cm);
	    });
	  }
	
	  // Used for horizontal relative motion. Dir is -1 or 1 (left or
	  // right), unit can be "char", "column" (like char, but doesn't
	  // cross line boundaries), "word" (across next word), or "group" (to
	  // the start of next group of word or non-word-non-whitespace
	  // chars). The visually param controls whether, in right-to-left
	  // text, direction 1 means to move towards the next index in the
	  // string, or towards the character to the right of the current
	  // position. The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosH(doc, pos, dir, unit, visually) {
	    var line = pos.line, ch = pos.ch, origDir = dir;
	    var lineObj = getLine(doc, line);
	    function findNextLine() {
	      var l = line + dir;
	      if (l < doc.first || l >= doc.first + doc.size) return false
	      line = l;
	      return lineObj = getLine(doc, l);
	    }
	    function moveOnce(boundToLine) {
	      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
	      if (next == null) {
	        if (!boundToLine && findNextLine()) {
	          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
	          else ch = dir < 0 ? lineObj.text.length : 0;
	        } else return false
	      } else ch = next;
	      return true;
	    }
	
	    if (unit == "char") {
	      moveOnce()
	    } else if (unit == "column") {
	      moveOnce(true)
	    } else if (unit == "word" || unit == "group") {
	      var sawType = null, group = unit == "group";
	      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	      for (var first = true;; first = false) {
	        if (dir < 0 && !moveOnce(!first)) break;
	        var cur = lineObj.text.charAt(ch) || "\n";
	        var type = isWordChar(cur, helper) ? "w"
	          : group && cur == "\n" ? "n"
	          : !group || /\s/.test(cur) ? null
	          : "p";
	        if (group && !first && !type) type = "s";
	        if (sawType && sawType != type) {
	          if (dir < 0) {dir = 1; moveOnce();}
	          break;
	        }
	
	        if (type) sawType = type;
	        if (dir > 0 && !moveOnce(!first)) break;
	      }
	    }
	    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);
	    if (!cmp(pos, result)) result.hitSide = true;
	    return result;
	  }
	
	  // For relative vertical movement. Dir may be -1 or 1. Unit can be
	  // "page" or "line". The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosV(cm, pos, dir, unit) {
	    var doc = cm.doc, x = pos.left, y;
	    if (unit == "page") {
	      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
	    } else if (unit == "line") {
	      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	    }
	    for (;;) {
	      var target = coordsChar(cm, x, y);
	      if (!target.outside) break;
	      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
	      y += dir * 5;
	    }
	    return target;
	  }
	
	  // EDITOR METHODS
	
	  // The publicly visible API. Note that methodOp(f) means
	  // 'wrap f in an operation, performed on its `this` parameter'.
	
	  // This is not the complete set of editor methods. Most of the
	  // methods defined on the Doc type are also injected into
	  // CodeMirror.prototype, for backwards compatibility and
	  // convenience.
	
	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); this.display.input.focus();},
	
	    setOption: function(option, value) {
	      var options = this.options, old = options[option];
	      if (options[option] == value && option != "mode") return;
	      options[option] = value;
	      if (optionHandlers.hasOwnProperty(option))
	        operation(this, optionHandlers[option])(this, value, old);
	    },
	
	    getOption: function(option) {return this.options[option];},
	    getDoc: function() {return this.doc;},
	
	    addKeyMap: function(map, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
	    },
	    removeKeyMap: function(map) {
	      var maps = this.state.keyMaps;
	      for (var i = 0; i < maps.length; ++i)
	        if (maps[i] == map || maps[i].name == map) {
	          maps.splice(i, 1);
	          return true;
	        }
	    },
	
	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	      if (mode.startState) throw new Error("Overlays may not be stateful.");
	      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
	      this.state.modeGen++;
	      regChange(this);
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var overlays = this.state.overlays;
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec;
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1);
	          this.state.modeGen++;
	          regChange(this);
	          return;
	        }
	      }
	    }),
	
	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
	        else dir = dir ? "add" : "subtract";
	      }
	      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
	    }),
	    indentSelection: methodOp(function(how) {
	      var ranges = this.doc.sel.ranges, end = -1;
	      for (var i = 0; i < ranges.length; i++) {
	        var range = ranges[i];
	        if (!range.empty()) {
	          var from = range.from(), to = range.to();
	          var start = Math.max(end, from.line);
	          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	          for (var j = start; j < end; ++j)
	            indentLine(this, j, how);
	          var newRanges = this.doc.sel.ranges;
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
	        } else if (range.head.line > end) {
	          indentLine(this, range.head.line, how, true);
	          end = range.head.line;
	          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
	        }
	      }
	    }),
	
	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise);
	    },
	
	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true);
	    },
	
	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos);
	      var styles = getLineStyles(this, getLine(this.doc, pos.line));
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	      var type;
	      if (ch == 0) type = styles[2];
	      else for (;;) {
	        var mid = (before + after) >> 1;
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
	        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
	        else { type = styles[mid * 2 + 2]; break; }
	      }
	      var cut = type ? type.indexOf("cm-overlay ") : -1;
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
	    },
	
	    getModeAt: function(pos) {
	      var mode = this.doc.mode;
	      if (!mode.innerMode) return mode;
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
	    },
	
	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0];
	    },
	
	    getHelpers: function(pos, type) {
	      var found = [];
	      if (!helpers.hasOwnProperty(type)) return found;
	      var help = helpers[type], mode = this.getModeAt(pos);
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) found.push(help[mode[type]]);
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]];
	          if (val) found.push(val);
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType]);
	      } else if (help[mode.name]) {
	        found.push(help[mode.name]);
	      }
	      for (var i = 0; i < help._global.length; i++) {
	        var cur = help._global[i];
	        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
	          found.push(cur.val);
	      }
	      return found;
	    },
	
	    getStateAfter: function(line, precise) {
	      var doc = this.doc;
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	      return getStateBefore(this, line + 1, precise);
	    },
	
	    cursorCoords: function(start, mode) {
	      var pos, range = this.doc.sel.primary();
	      if (start == null) pos = range.head;
	      else if (typeof start == "object") pos = clipPos(this.doc, start);
	      else pos = start ? range.from() : range.to();
	      return cursorCoords(this, pos, mode || "page");
	    },
	
	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page");
	    },
	
	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page");
	      return coordsChar(this, coords.left, coords.top);
	    },
	
	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	      return lineAtHeight(this.doc, height + this.display.viewOffset);
	    },
	    heightAtLine: function(line, mode) {
	      var end = false, lineObj;
	      if (typeof line == "number") {
	        var last = this.doc.first + this.doc.size - 1;
	        if (line < this.doc.first) line = this.doc.first;
	        else if (line > last) { line = last; end = true; }
	        lineObj = getLine(this.doc, line);
	      } else {
	        lineObj = line;
	      }
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0);
	    },
	
	    defaultTextHeight: function() { return textHeight(this.display); },
	    defaultCharWidth: function() { return charWidth(this.display); },
	
	    setGutterMarker: methodOp(function(line, gutterID, value) {
	      return changeLine(this.doc, line, "gutter", function(line) {
	        var markers = line.gutterMarkers || (line.gutterMarkers = {});
	        markers[gutterID] = value;
	        if (!value && isEmpty(markers)) line.gutterMarkers = null;
	        return true;
	      });
	    }),
	
	    clearGutter: methodOp(function(gutterID) {
	      var cm = this, doc = cm.doc, i = doc.first;
	      doc.iter(function(line) {
	        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	          line.gutterMarkers[gutterID] = null;
	          regLineChange(cm, i, "gutter");
	          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
	        }
	        ++i;
	      });
	    }),
	
	    lineInfo: function(line) {
	      if (typeof line == "number") {
	        if (!isLine(this.doc, line)) return null;
	        var n = line;
	        line = getLine(this.doc, line);
	        if (!line) return null;
	      } else {
	        var n = lineNo(line);
	        if (n == null) return null;
	      }
	      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	              widgets: line.widgets};
	    },
	
	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},
	
	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display;
	      pos = cursorCoords(this, clipPos(this.doc, pos));
	      var top = pos.bottom, left = pos.left;
	      node.style.position = "absolute";
	      node.setAttribute("cm-ignore-events", "true");
	      this.display.input.setUneditable(node);
	      display.sizer.appendChild(node);
	      if (vert == "over") {
	        top = pos.top;
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          top = pos.top - node.offsetHeight;
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          top = pos.bottom;
	        if (left + node.offsetWidth > hspace)
	          left = hspace - node.offsetWidth;
	      }
	      node.style.top = top + "px";
	      node.style.left = node.style.right = "";
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth;
	        node.style.right = "0px";
	      } else {
	        if (horiz == "left") left = 0;
	        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
	        node.style.left = left + "px";
	      }
	      if (scroll)
	        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
	    },
	
	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,
	
	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        return commands[cmd].call(null, this);
	    },
	
	    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),
	
	    findPosH: function(from, amount, unit, visually) {
	      var dir = 1;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
	        cur = findPosH(this.doc, cur, dir, unit, visually);
	        if (cur.hitSide) break;
	      }
	      return cur;
	    },
	
	    moveH: methodOp(function(dir, unit) {
	      var cm = this;
	      cm.extendSelectionsBy(function(range) {
	        if (cm.display.shift || cm.doc.extend || range.empty())
	          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
	        else
	          return dir < 0 ? range.from() : range.to();
	      }, sel_move);
	    }),
	
	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc;
	      if (sel.somethingSelected())
	        doc.replaceSelection("", null, "+delete");
	      else
	        deleteNearSelection(this, function(range) {
	          var other = findPosH(doc, range.head, dir, unit, false);
	          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
	        });
	    }),
	
	    findPosV: function(from, amount, unit, goalColumn) {
	      var dir = 1, x = goalColumn;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
	        var coords = cursorCoords(this, cur, "div");
	        if (x == null) x = coords.left;
	        else coords.left = x;
	        cur = findPosV(this, coords, dir, unit);
	        if (cur.hitSide) break;
	      }
	      return cur;
	    },
	
	    moveV: methodOp(function(dir, unit) {
	      var cm = this, doc = this.doc, goals = [];
	      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
	      doc.extendSelectionsBy(function(range) {
	        if (collapse)
	          return dir < 0 ? range.from() : range.to();
	        var headPos = cursorCoords(cm, range.head, "div");
	        if (range.goalColumn != null) headPos.left = range.goalColumn;
	        goals.push(headPos.left);
	        var pos = findPosV(cm, headPos, dir, unit);
	        if (unit == "page" && range == doc.sel.primary())
	          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
	        return pos;
	      }, sel_move);
	      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
	        doc.sel.ranges[i].goalColumn = goals[i];
	    }),
	
	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text;
	      var start = pos.ch, end = pos.ch;
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars");
	        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
	        var startChar = line.charAt(start);
	        var check = isWordChar(startChar, helper)
	          ? function(ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
	          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
	        while (start > 0 && check(line.charAt(start - 1))) --start;
	        while (end < line.length && check(line.charAt(end))) ++end;
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end));
	    },
	
	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) return;
	      if (this.state.overwrite = !this.state.overwrite)
	        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
	      else
	        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
	
	      signal(this, "overwriteToggle", this, this.state.overwrite);
	    },
	    hasFocus: function() { return this.display.input.getField() == activeElt(); },
	    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },
	
	    scrollTo: methodOp(function(x, y) {
	      if (x != null || y != null) resolveScrollToPos(this);
	      if (x != null) this.curOp.scrollLeft = x;
	      if (y != null) this.curOp.scrollTop = y;
	    }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller;
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
	    },
	
	    scrollIntoView: methodOp(function(range, margin) {
	      if (range == null) {
	        range = {from: this.doc.sel.primary().head, to: null};
	        if (margin == null) margin = this.options.cursorScrollMargin;
	      } else if (typeof range == "number") {
	        range = {from: Pos(range, 0), to: null};
	      } else if (range.from == null) {
	        range = {from: range, to: null};
	      }
	      if (!range.to) range.to = range.from;
	      range.margin = margin || 0;
	
	      if (range.from.line != null) {
	        resolveScrollToPos(this);
	        this.curOp.scrollToPos = range;
	      } else {
	        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
	                                      Math.min(range.from.top, range.to.top) - range.margin,
	                                      Math.max(range.from.right, range.to.right),
	                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
	        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
	      }
	    }),
	
	    setSize: methodOp(function(width, height) {
	      var cm = this;
	      function interpret(val) {
	        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
	      }
	      if (width != null) cm.display.wrapper.style.width = interpret(width);
	      if (height != null) cm.display.wrapper.style.height = interpret(height);
	      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
	      var lineNo = cm.display.viewFrom;
	      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
	        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
	          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
	        ++lineNo;
	      });
	      cm.curOp.forceUpdate = true;
	      signal(cm, "refresh", this);
	    }),
	
	    operation: function(f){return runInOp(this, f);},
	
	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight;
	      regChange(this);
	      this.curOp.forceUpdate = true;
	      clearCaches(this);
	      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
	      updateGutterSpace(this);
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        estimateLineHeights(this);
	      signal(this, "refresh", this);
	    }),
	
	    swapDoc: methodOp(function(doc) {
	      var old = this.doc;
	      old.cm = null;
	      attachDoc(this, doc);
	      clearCaches(this);
	      this.display.input.reset();
	      this.scrollTo(doc.scrollLeft, doc.scrollTop);
	      this.curOp.forceScroll = true;
	      signalLater(this, "swapDoc", this, old);
	      return old;
	    }),
	
	    getInputField: function(){return this.display.input.getField();},
	    getWrapperElement: function(){return this.display.wrapper;},
	    getScrollerElement: function(){return this.display.scroller;},
	    getGutterElement: function(){return this.display.gutters;}
	  };
	  eventMixin(CodeMirror);
	
	  // OPTION DEFAULTS
	
	  // The default configuration options.
	  var defaults = CodeMirror.defaults = {};
	  // Functions to run when options are changed.
	  var optionHandlers = CodeMirror.optionHandlers = {};
	
	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt;
	    if (handle) optionHandlers[name] =
	      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
	  }
	
	  // Passed to option handlers when there is no old value.
	  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};
	
	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function(cm, val) {
	    cm.setValue(val);
	  }, true);
	  option("mode", null, function(cm, val) {
	    cm.doc.modeOption = val;
	    loadMode(cm);
	  }, true);
	
	  option("indentUnit", 2, loadMode, true);
	  option("indentWithTabs", false);
	  option("smartIndent", true);
	  option("tabSize", 4, function(cm) {
	    resetModeState(cm);
	    clearCaches(cm);
	    regChange(cm);
	  }, true);
	  option("lineSeparator", null, function(cm, val) {
	    cm.doc.lineSep = val;
	    if (!val) return;
	    var newBreaks = [], lineNo = cm.doc.first;
	    cm.doc.iter(function(line) {
	      for (var pos = 0;;) {
	        var found = line.text.indexOf(val, pos);
	        if (found == -1) break;
	        pos = found + val.length;
	        newBreaks.push(Pos(lineNo, found));
	      }
	      lineNo++;
	    });
	    for (var i = newBreaks.length - 1; i >= 0; i--)
	      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
	  });
	  option("specialChars", /[\u0000-\u001f\u007f\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
	    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	    if (old != CodeMirror.Init) cm.refresh();
	  });
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
	  option("electricChars", true);
	  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
	    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
	  }, true);
	  option("rtlMoveVisually", !windows);
	  option("wholeLineUpdateBefore", true);
	
	  option("theme", "default", function(cm) {
	    themeChanged(cm);
	    guttersChanged(cm);
	  }, true);
	  option("keyMap", "default", function(cm, val, old) {
	    var next = getKeyMap(val);
	    var prev = old != CodeMirror.Init && getKeyMap(old);
	    if (prev && prev.detach) prev.detach(cm, next);
	    if (next.attach) next.attach(cm, prev || null);
	  });
	  option("extraKeys", null);
	
	  option("lineWrapping", false, wrappingChanged, true);
	  option("gutters", [], function(cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("fixedGutter", true, function(cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	    cm.refresh();
	  }, true);
	  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
	  option("scrollbarStyle", "native", function(cm) {
	    initScrollbars(cm);
	    updateScrollbars(cm);
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	  }, true);
	  option("lineNumbers", false, function(cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("firstLineNumber", 1, guttersChanged, true);
	  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
	  option("showCursorWhenSelecting", false, updateSelection, true);
	
	  option("resetSelectionOnContextMenu", true);
	  option("lineWiseCopyCut", true);
	
	  option("readOnly", false, function(cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm);
	      cm.display.input.blur();
	      cm.display.disabled = true;
	    } else {
	      cm.display.disabled = false;
	    }
	    cm.display.input.readOnlyChanged(val)
	  });
	  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
	  option("dragDrop", true, dragDropChanged);
	  option("allowDropFileTypes", null);
	
	  option("cursorBlinkRate", 530);
	  option("cursorScrollMargin", 0);
	  option("cursorHeight", 1, updateSelection, true);
	  option("singleCursorHeightPerLine", true, updateSelection, true);
	  option("workTime", 100);
	  option("workDelay", 100);
	  option("flattenSpans", true, resetModeState, true);
	  option("addModeClass", false, resetModeState, true);
	  option("pollInterval", 100);
	  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
	  option("historyEventDelay", 1250);
	  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
	  option("maxHighlightLength", 10000, resetModeState, true);
	  option("moveInputWithCursor", true, function(cm, val) {
	    if (!val) cm.display.input.resetPosition();
	  });
	
	  option("tabindex", null, function(cm, val) {
	    cm.display.input.getField().tabIndex = val || "";
	  });
	  option("autofocus", null);
	
	  // MODE DEFINITION AND QUERYING
	
	  // Known modes, by name and by MIME
	  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
	
	  // Extra arguments are stored as the mode's dependencies, which is
	  // used by (legacy) mechanisms like loadmode.js to automatically
	  // load a mode. (Preferred mechanism is the require/define calls.)
	  CodeMirror.defineMode = function(name, mode) {
	    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
	    if (arguments.length > 2)
	      mode.dependencies = Array.prototype.slice.call(arguments, 2);
	    modes[name] = mode;
	  };
	
	  CodeMirror.defineMIME = function(mime, spec) {
	    mimeModes[mime] = spec;
	  };
	
	  // Given a MIME type, a {name, ...options} config object, or a name
	  // string, return a mode config object.
	  CodeMirror.resolveMode = function(spec) {
	    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	      spec = mimeModes[spec];
	    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	      var found = mimeModes[spec.name];
	      if (typeof found == "string") found = {name: found};
	      spec = createObj(found, spec);
	      spec.name = found.name;
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	      return CodeMirror.resolveMode("application/xml");
	    }
	    if (typeof spec == "string") return {name: spec};
	    else return spec || {name: "null"};
	  };
	
	  // Given a mode spec (anything that resolveMode accepts), find and
	  // initialize an actual mode object.
	  CodeMirror.getMode = function(options, spec) {
	    var spec = CodeMirror.resolveMode(spec);
	    var mfactory = modes[spec.name];
	    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
	    var modeObj = mfactory(options, spec);
	    if (modeExtensions.hasOwnProperty(spec.name)) {
	      var exts = modeExtensions[spec.name];
	      for (var prop in exts) {
	        if (!exts.hasOwnProperty(prop)) continue;
	        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
	        modeObj[prop] = exts[prop];
	      }
	    }
	    modeObj.name = spec.name;
	    if (spec.helperType) modeObj.helperType = spec.helperType;
	    if (spec.modeProps) for (var prop in spec.modeProps)
	      modeObj[prop] = spec.modeProps[prop];
	
	    return modeObj;
	  };
	
	  // Minimal default mode.
	  CodeMirror.defineMode("null", function() {
	    return {token: function(stream) {stream.skipToEnd();}};
	  });
	  CodeMirror.defineMIME("text/plain", "null");
	
	  // This can be used to attach properties to mode objects from
	  // outside the actual mode definition.
	  var modeExtensions = CodeMirror.modeExtensions = {};
	  CodeMirror.extendMode = function(mode, properties) {
	    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	    copyObj(properties, exts);
	  };
	
	  // EXTENSIONS
	
	  CodeMirror.defineExtension = function(name, func) {
	    CodeMirror.prototype[name] = func;
	  };
	  CodeMirror.defineDocExtension = function(name, func) {
	    Doc.prototype[name] = func;
	  };
	  CodeMirror.defineOption = option;
	
	  var initHooks = [];
	  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};
	
	  var helpers = CodeMirror.helpers = {};
	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
	    helpers[type][name] = value;
	  };
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value);
	    helpers[type]._global.push({pred: predicate, val: value});
	  };
	
	  // MODE STATE HANDLING
	
	  // Utility functions for working with state. Exported because nested
	  // modes need to do this for their inner modes.
	
	  var copyState = CodeMirror.copyState = function(mode, state) {
	    if (state === true) return state;
	    if (mode.copyState) return mode.copyState(state);
	    var nstate = {};
	    for (var n in state) {
	      var val = state[n];
	      if (val instanceof Array) val = val.concat([]);
	      nstate[n] = val;
	    }
	    return nstate;
	  };
	
	  var startState = CodeMirror.startState = function(mode, a1, a2) {
	    return mode.startState ? mode.startState(a1, a2) : true;
	  };
	
	  // Given a mode and a state (for that mode), find the inner mode and
	  // state at the position that the state refers to.
	  CodeMirror.innerMode = function(mode, state) {
	    while (mode.innerMode) {
	      var info = mode.innerMode(state);
	      if (!info || info.mode == mode) break;
	      state = info.state;
	      mode = info.mode;
	    }
	    return info || {mode: mode, state: state};
	  };
	
	  // STANDARD COMMANDS
	
	  // Commands are parameter-less actions that can be performed on an
	  // editor, mostly used for keybindings.
	  var commands = CodeMirror.commands = {
	    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
	    singleSelection: function(cm) {
	      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
	    },
	    killLine: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        if (range.empty()) {
	          var len = getLine(cm.doc, range.head.line).text.length;
	          if (range.head.ch == len && range.head.line < cm.lastLine())
	            return {from: range.head, to: Pos(range.head.line + 1, 0)};
	          else
	            return {from: range.head, to: Pos(range.head.line, len)};
	        } else {
	          return {from: range.from(), to: range.to()};
	        }
	      });
	    },
	    deleteLine: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        return {from: Pos(range.from().line, 0),
	                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
	      });
	    },
	    delLineLeft: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        return {from: Pos(range.from().line, 0), to: range.from()};
	      });
	    },
	    delWrappedLineLeft: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	        return {from: leftPos, to: range.from()};
	      });
	    },
	    delWrappedLineRight: function(cm) {
	      deleteNearSelection(cm, function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	        return {from: range.from(), to: rightPos };
	      });
	    },
	    undo: function(cm) {cm.undo();},
	    redo: function(cm) {cm.redo();},
	    undoSelection: function(cm) {cm.undoSelection();},
	    redoSelection: function(cm) {cm.redoSelection();},
	    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
	    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
	    goLineStart: function(cm) {
	      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
	                            {origin: "+move", bias: 1});
	    },
	    goLineStartSmart: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        return lineStartSmart(cm, range.head);
	      }, {origin: "+move", bias: 1});
	    },
	    goLineEnd: function(cm) {
	      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
	                            {origin: "+move", bias: -1});
	    },
	    goLineRight: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	      }, sel_move);
	    },
	    goLineLeft: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        return cm.coordsChar({left: 0, top: top}, "div");
	      }, sel_move);
	    },
	    goLineLeftSmart: function(cm) {
	      cm.extendSelectionsBy(function(range) {
	        var top = cm.charCoords(range.head, "div").top + 5;
	        var pos = cm.coordsChar({left: 0, top: top}, "div");
	        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
	        return pos;
	      }, sel_move);
	    },
	    goLineUp: function(cm) {cm.moveV(-1, "line");},
	    goLineDown: function(cm) {cm.moveV(1, "line");},
	    goPageUp: function(cm) {cm.moveV(-1, "page");},
	    goPageDown: function(cm) {cm.moveV(1, "page");},
	    goCharLeft: function(cm) {cm.moveH(-1, "char");},
	    goCharRight: function(cm) {cm.moveH(1, "char");},
	    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
	    goColumnRight: function(cm) {cm.moveH(1, "column");},
	    goWordLeft: function(cm) {cm.moveH(-1, "word");},
	    goGroupRight: function(cm) {cm.moveH(1, "group");},
	    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
	    goWordRight: function(cm) {cm.moveH(1, "word");},
	    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
	    delCharAfter: function(cm) {cm.deleteH(1, "char");},
	    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
	    delWordAfter: function(cm) {cm.deleteH(1, "word");},
	    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
	    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
	    indentAuto: function(cm) {cm.indentSelection("smart");},
	    indentMore: function(cm) {cm.indentSelection("add");},
	    indentLess: function(cm) {cm.indentSelection("subtract");},
	    insertTab: function(cm) {cm.replaceSelection("\t");},
	    insertSoftTab: function(cm) {
	      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	      for (var i = 0; i < ranges.length; i++) {
	        var pos = ranges[i].from();
	        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	        spaces.push(spaceStr(tabSize - col % tabSize));
	      }
	      cm.replaceSelections(spaces);
	    },
	    defaultTab: function(cm) {
	      if (cm.somethingSelected()) cm.indentSelection("add");
	      else cm.execCommand("insertTab");
	    },
	    transposeChars: function(cm) {
	      runInOp(cm, function() {
	        var ranges = cm.listSelections(), newSel = [];
	        for (var i = 0; i < ranges.length; i++) {
	          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	          if (line) {
	            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
	            if (cur.ch > 0) {
	              cur = new Pos(cur.line, cur.ch + 1);
	              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
	            } else if (cur.line > cm.doc.first) {
	              var prev = getLine(cm.doc, cur.line - 1).text;
	              if (prev)
	                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                                prev.charAt(prev.length - 1),
	                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
	            }
	          }
	          newSel.push(new Range(cur, cur));
	        }
	        cm.setSelections(newSel);
	      });
	    },
	    newlineAndIndent: function(cm) {
	      runInOp(cm, function() {
	        var len = cm.listSelections().length;
	        for (var i = 0; i < len; i++) {
	          var range = cm.listSelections()[i];
	          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
	          cm.indentLine(range.from().line + 1, null, true);
	        }
	        ensureCursorVisible(cm);
	      });
	    },
	    openLine: function(cm) {cm.replaceSelection("\n", "start")},
	    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
	  };
	
	
	  // STANDARD KEYMAPS
	
	  var keyMap = CodeMirror.keyMap = {};
	
	  keyMap.basic = {
	    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	    "Esc": "singleSelection"
	  };
	  // Note that the save and find-related commands aren't defined by
	  // default. User code or addons can define them. Unknown commands
	  // are simply ignored.
	  keyMap.pcDefault = {
	    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	    fallthrough: "basic"
	  };
	  // Very basic readline/emacs-style bindings, which are standard on Mac.
	  keyMap.emacsy = {
	    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	    "Ctrl-O": "openLine"
	  };
	  keyMap.macDefault = {
	    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	    fallthrough: ["basic", "emacsy"]
	  };
	  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
	
	  // KEYMAP DISPATCH
	
	  function normalizeKeyName(name) {
	    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
	    var alt, ctrl, shift, cmd;
	    for (var i = 0; i < parts.length - 1; i++) {
	      var mod = parts[i];
	      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
	      else if (/^a(lt)?$/i.test(mod)) alt = true;
	      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
	      else if (/^s(hift)$/i.test(mod)) shift = true;
	      else throw new Error("Unrecognized modifier name: " + mod);
	    }
	    if (alt) name = "Alt-" + name;
	    if (ctrl) name = "Ctrl-" + name;
	    if (cmd) name = "Cmd-" + name;
	    if (shift) name = "Shift-" + name;
	    return name;
	  }
	
	  // This is a kludge to keep keymaps mostly working as raw objects
	  // (backwards compatibility) while at the same time support features
	  // like normalization and multi-stroke key bindings. It compiles a
	  // new normalized keymap, and then updates the old object to reflect
	  // this.
	  CodeMirror.normalizeKeyMap = function(keymap) {
	    var copy = {};
	    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
	      var value = keymap[keyname];
	      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
	      if (value == "...") { delete keymap[keyname]; continue; }
	
	      var keys = map(keyname.split(" "), normalizeKeyName);
	      for (var i = 0; i < keys.length; i++) {
	        var val, name;
	        if (i == keys.length - 1) {
	          name = keys.join(" ");
	          val = value;
	        } else {
	          name = keys.slice(0, i + 1).join(" ");
	          val = "...";
	        }
	        var prev = copy[name];
	        if (!prev) copy[name] = val;
	        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
	      }
	      delete keymap[keyname];
	    }
	    for (var prop in copy) keymap[prop] = copy[prop];
	    return keymap;
	  };
	
	  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
	    map = getKeyMap(map);
	    var found = map.call ? map.call(key, context) : map[key];
	    if (found === false) return "nothing";
	    if (found === "...") return "multi";
	    if (found != null && handle(found)) return "handled";
	
	    if (map.fallthrough) {
	      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
	        return lookupKey(key, map.fallthrough, handle, context);
	      for (var i = 0; i < map.fallthrough.length; i++) {
	        var result = lookupKey(key, map.fallthrough[i], handle, context);
	        if (result) return result;
	      }
	    }
	  };
	
	  // Modifier key presses don't count as 'real' key presses for the
	  // purpose of keymap fallthrough.
	  var isModifierKey = CodeMirror.isModifierKey = function(value) {
	    var name = typeof value == "string" ? value : keyNames[value.keyCode];
	    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
	  };
	
	  // Look up the name of a key as indicated by an event object.
	  var keyName = CodeMirror.keyName = function(event, noShift) {
	    if (presto && event.keyCode == 34 && event["char"]) return false;
	    var base = keyNames[event.keyCode], name = base;
	    if (name == null || event.altGraphKey) return false;
	    if (event.altKey && base != "Alt") name = "Alt-" + name;
	    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
	    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
	    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
	    return name;
	  };
	
	  function getKeyMap(val) {
	    return typeof val == "string" ? keyMap[val] : val;
	  }
	
	  // FROMTEXTAREA
	
	  CodeMirror.fromTextArea = function(textarea, options) {
	    options = options ? copyObj(options) : {};
	    options.value = textarea.value;
	    if (!options.tabindex && textarea.tabIndex)
	      options.tabindex = textarea.tabIndex;
	    if (!options.placeholder && textarea.placeholder)
	      options.placeholder = textarea.placeholder;
	    // Set autofocus to true if this textarea is focused, or if it has
	    // autofocus and no other element is focused.
	    if (options.autofocus == null) {
	      var hasFocus = activeElt();
	      options.autofocus = hasFocus == textarea ||
	        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	    }
	
	    function save() {textarea.value = cm.getValue();}
	    if (textarea.form) {
	      on(textarea.form, "submit", save);
	      // Deplorable hack to make the submit method do the right thing.
	      if (!options.leaveSubmitMethodAlone) {
	        var form = textarea.form, realSubmit = form.submit;
	        try {
	          var wrappedSubmit = form.submit = function() {
	            save();
	            form.submit = realSubmit;
	            form.submit();
	            form.submit = wrappedSubmit;
	          };
	        } catch(e) {}
	      }
	    }
	
	    options.finishInit = function(cm) {
	      cm.save = save;
	      cm.getTextArea = function() { return textarea; };
	      cm.toTextArea = function() {
	        cm.toTextArea = isNaN; // Prevent this from being ran twice
	        save();
	        textarea.parentNode.removeChild(cm.getWrapperElement());
	        textarea.style.display = "";
	        if (textarea.form) {
	          off(textarea.form, "submit", save);
	          if (typeof textarea.form.submit == "function")
	            textarea.form.submit = realSubmit;
	        }
	      };
	    };
	
	    textarea.style.display = "none";
	    var cm = CodeMirror(function(node) {
	      textarea.parentNode.insertBefore(node, textarea.nextSibling);
	    }, options);
	    return cm;
	  };
	
	  // STRING STREAM
	
	  // Fed to the mode parsers, provides helper functions to make
	  // parsers more succinct.
	
	  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
	    this.pos = this.start = 0;
	    this.string = string;
	    this.tabSize = tabSize || 8;
	    this.lastColumnPos = this.lastColumnValue = 0;
	    this.lineStart = 0;
	  };
	
	  StringStream.prototype = {
	    eol: function() {return this.pos >= this.string.length;},
	    sol: function() {return this.pos == this.lineStart;},
	    peek: function() {return this.string.charAt(this.pos) || undefined;},
	    next: function() {
	      if (this.pos < this.string.length)
	        return this.string.charAt(this.pos++);
	    },
	    eat: function(match) {
	      var ch = this.string.charAt(this.pos);
	      if (typeof match == "string") var ok = ch == match;
	      else var ok = ch && (match.test ? match.test(ch) : match(ch));
	      if (ok) {++this.pos; return ch;}
	    },
	    eatWhile: function(match) {
	      var start = this.pos;
	      while (this.eat(match)){}
	      return this.pos > start;
	    },
	    eatSpace: function() {
	      var start = this.pos;
	      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
	      return this.pos > start;
	    },
	    skipToEnd: function() {this.pos = this.string.length;},
	    skipTo: function(ch) {
	      var found = this.string.indexOf(ch, this.pos);
	      if (found > -1) {this.pos = found; return true;}
	    },
	    backUp: function(n) {this.pos -= n;},
	    column: function() {
	      if (this.lastColumnPos < this.start) {
	        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	        this.lastColumnPos = this.start;
	      }
	      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    },
	    indentation: function() {
	      return countColumn(this.string, null, this.tabSize) -
	        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
	    },
	    match: function(pattern, consume, caseInsensitive) {
	      if (typeof pattern == "string") {
	        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
	        var substr = this.string.substr(this.pos, pattern.length);
	        if (cased(substr) == cased(pattern)) {
	          if (consume !== false) this.pos += pattern.length;
	          return true;
	        }
	      } else {
	        var match = this.string.slice(this.pos).match(pattern);
	        if (match && match.index > 0) return null;
	        if (match && consume !== false) this.pos += match[0].length;
	        return match;
	      }
	    },
	    current: function(){return this.string.slice(this.start, this.pos);},
	    hideFirstChars: function(n, inner) {
	      this.lineStart += n;
	      try { return inner(); }
	      finally { this.lineStart -= n; }
	    }
	  };
	
	  // TEXTMARKERS
	
	  // Created with markText and setBookmark methods. A TextMarker is a
	  // handle that can be used to clear or find a marked position in the
	  // document. Line objects hold arrays (markedSpans) containing
	  // {from, to, marker} object pointing to such marker objects, and
	  // indicating that such a marker is present on that line. Multiple
	  // lines may point to the same marker when it spans across lines.
	  // The spans will have null for their from/to properties when the
	  // marker continues beyond the start/end of the line. Markers have
	  // links back to the lines they currently touch.
	
	  var nextMarkerId = 0;
	
	  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
	    this.lines = [];
	    this.type = type;
	    this.doc = doc;
	    this.id = ++nextMarkerId;
	  };
	  eventMixin(TextMarker);
	
	  // Clear the marker.
	  TextMarker.prototype.clear = function() {
	    if (this.explicitlyCleared) return;
	    var cm = this.doc.cm, withOp = cm && !cm.curOp;
	    if (withOp) startOperation(cm);
	    if (hasHandler(this, "clear")) {
	      var found = this.find();
	      if (found) signalLater(this, "clear", found.from, found.to);
	    }
	    var min = null, max = null;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
	      else if (cm) {
	        if (span.to != null) max = lineNo(line);
	        if (span.from != null) min = lineNo(line);
	      }
	      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
	        updateLineHeight(line, textHeight(cm.display));
	    }
	    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
	      var visual = visualLine(this.lines[i]), len = lineLength(visual);
	      if (len > cm.display.maxLineLength) {
	        cm.display.maxLine = visual;
	        cm.display.maxLineLength = len;
	        cm.display.maxLineChanged = true;
	      }
	    }
	
	    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
	    this.lines.length = 0;
	    this.explicitlyCleared = true;
	    if (this.atomic && this.doc.cantEdit) {
	      this.doc.cantEdit = false;
	      if (cm) reCheckSelection(cm.doc);
	    }
	    if (cm) signalLater(cm, "markerCleared", cm, this);
	    if (withOp) endOperation(cm);
	    if (this.parent) this.parent.clear();
	  };
	
	  // Find the position of the marker in the document. Returns a {from,
	  // to} object by default. Side can be passed to get a specific side
	  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	  // Pos objects returned contain a line object, rather than a line
	  // number (used to prevent looking up the same line twice).
	  TextMarker.prototype.find = function(side, lineObj) {
	    if (side == null && this.type == "bookmark") side = 1;
	    var from, to;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (span.from != null) {
	        from = Pos(lineObj ? line : lineNo(line), span.from);
	        if (side == -1) return from;
	      }
	      if (span.to != null) {
	        to = Pos(lineObj ? line : lineNo(line), span.to);
	        if (side == 1) return to;
	      }
	    }
	    return from && {from: from, to: to};
	  };
	
	  // Signals that the marker's widget changed, and surrounding layout
	  // should be recomputed.
	  TextMarker.prototype.changed = function() {
	    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	    if (!pos || !cm) return;
	    runInOp(cm, function() {
	      var line = pos.line, lineN = lineNo(pos.line);
	      var view = findViewForLine(cm, lineN);
	      if (view) {
	        clearLineMeasurementCacheFor(view);
	        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	      }
	      cm.curOp.updateMaxLine = true;
	      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	        var oldHeight = widget.height;
	        widget.height = null;
	        var dHeight = widgetHeight(widget) - oldHeight;
	        if (dHeight)
	          updateLineHeight(line, line.height + dHeight);
	      }
	    });
	  };
	
	  TextMarker.prototype.attachLine = function(line) {
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
	    }
	    this.lines.push(line);
	  };
	  TextMarker.prototype.detachLine = function(line) {
	    this.lines.splice(indexOf(this.lines, line), 1);
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	    }
	  };
	
	  // Collapsed markers have unique ids, in order to be able to order
	  // them, which is needed for uniquely determining an outer marker
	  // when they overlap (they may nest, but not partially overlap).
	  var nextMarkerId = 0;
	
	  // Create a marker, wire it up to the right lines, and
	  function markText(doc, from, to, options, type) {
	    // Shared markers (across linked documents) are handled separately
	    // (markTextShared will call out to this again, once per
	    // document).
	    if (options && options.shared) return markTextShared(doc, from, to, options, type);
	    // Ensure we are in an operation.
	    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);
	
	    var marker = new TextMarker(doc, type), diff = cmp(from, to);
	    if (options) copyObj(options, marker, false);
	    // Don't connect empty markers unless clearWhenEmpty is false
	    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	      return marker;
	    if (marker.replacedWith) {
	      // Showing up as a widget implies collapsed (widget replaces text)
	      marker.collapsed = true;
	      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
	      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
	      if (options.insertLeft) marker.widgetNode.insertLeft = true;
	    }
	    if (marker.collapsed) {
	      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	        throw new Error("Inserting collapsed marker partially overlapping an existing one");
	      sawCollapsedSpans = true;
	    }
	
	    if (marker.addToHistory)
	      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);
	
	    var curLine = from.line, cm = doc.cm, updateMaxLine;
	    doc.iter(curLine, to.line + 1, function(line) {
	      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	        updateMaxLine = true;
	      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
	      addMarkedSpan(line, new MarkedSpan(marker,
	                                         curLine == from.line ? from.ch : null,
	                                         curLine == to.line ? to.ch : null));
	      ++curLine;
	    });
	    // lineIsHidden depends on the presence of the spans, so needs a second pass
	    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
	      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
	    });
	
	    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });
	
	    if (marker.readOnly) {
	      sawReadOnlySpans = true;
	      if (doc.history.done.length || doc.history.undone.length)
	        doc.clearHistory();
	    }
	    if (marker.collapsed) {
	      marker.id = ++nextMarkerId;
	      marker.atomic = true;
	    }
	    if (cm) {
	      // Sync editor state
	      if (updateMaxLine) cm.curOp.updateMaxLine = true;
	      if (marker.collapsed)
	        regChange(cm, from.line, to.line + 1);
	      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
	      if (marker.atomic) reCheckSelection(cm.doc);
	      signalLater(cm, "markerAdded", cm, marker);
	    }
	    return marker;
	  }
	
	  // SHARED TEXTMARKERS
	
	  // A shared marker spans multiple linked documents. It is
	  // implemented as a meta-marker-object controlling multiple normal
	  // markers.
	  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
	    this.markers = markers;
	    this.primary = primary;
	    for (var i = 0; i < markers.length; ++i)
	      markers[i].parent = this;
	  };
	  eventMixin(SharedTextMarker);
	
	  SharedTextMarker.prototype.clear = function() {
	    if (this.explicitlyCleared) return;
	    this.explicitlyCleared = true;
	    for (var i = 0; i < this.markers.length; ++i)
	      this.markers[i].clear();
	    signalLater(this, "clear");
	  };
	  SharedTextMarker.prototype.find = function(side, lineObj) {
	    return this.primary.find(side, lineObj);
	  };
	
	  function markTextShared(doc, from, to, options, type) {
	    options = copyObj(options);
	    options.shared = false;
	    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	    var widget = options.widgetNode;
	    linkedDocs(doc, function(doc) {
	      if (widget) options.widgetNode = widget.cloneNode(true);
	      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	      for (var i = 0; i < doc.linked.length; ++i)
	        if (doc.linked[i].isParent) return;
	      primary = lst(markers);
	    });
	    return new SharedTextMarker(markers, primary);
	  }
	
	  function findSharedMarkers(doc) {
	    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
	                         function(m) { return m.parent; });
	  }
	
	  function copySharedMarkers(doc, markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], pos = marker.find();
	      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	      if (cmp(mFrom, mTo)) {
	        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	        marker.markers.push(subMark);
	        subMark.parent = marker;
	      }
	    }
	  }
	
	  function detachSharedMarkers(markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], linked = [marker.primary.doc];;
	      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
	      for (var j = 0; j < marker.markers.length; j++) {
	        var subMarker = marker.markers[j];
	        if (indexOf(linked, subMarker.doc) == -1) {
	          subMarker.parent = null;
	          marker.markers.splice(j--, 1);
	        }
	      }
	    }
	  }
	
	  // TEXTMARKER SPANS
	
	  function MarkedSpan(marker, from, to) {
	    this.marker = marker;
	    this.from = from; this.to = to;
	  }
	
	  // Search an array of spans for a span matching the given marker.
	  function getMarkedSpanFor(spans, marker) {
	    if (spans) for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.marker == marker) return span;
	    }
	  }
	  // Remove a span from an array, returning undefined if no spans are
	  // left (we don't store arrays for lines without spans).
	  function removeMarkedSpan(spans, span) {
	    for (var r, i = 0; i < spans.length; ++i)
	      if (spans[i] != span) (r || (r = [])).push(spans[i]);
	    return r;
	  }
	  // Add a span to a line.
	  function addMarkedSpan(line, span) {
	    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	    span.marker.attachLine(line);
	  }
	
	  // Used for the algorithm that adjusts markers for a change in the
	  // document. These functions cut an array of spans at a given
	  // character position, returning an array of remaining chunks (or
	  // undefined if nothing remains).
	  function markedSpansBefore(old, startCh, isInsert) {
	    if (old) for (var i = 0, nw; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
	        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	      }
	    }
	    return nw;
	  }
	  function markedSpansAfter(old, endCh, isInsert) {
	    if (old) for (var i = 0, nw; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
	        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                              span.to == null ? null : span.to - endCh));
	      }
	    }
	    return nw;
	  }
	
	  // Given a change object, compute the new set of marker spans that
	  // cover the line in which the change took place. Removes spans
	  // entirely within the change, reconnects spans belonging to the
	  // same marker that appear on both sides of the change, and cuts off
	  // spans partially within the change. Returns an array of span
	  // arrays with one element for each line in (after) the change.
	  function stretchSpansOverChange(doc, change) {
	    if (change.full) return null;
	    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	    if (!oldFirst && !oldLast) return null;
	
	    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	    // Get the spans that 'stick out' on both sides
	    var first = markedSpansBefore(oldFirst, startCh, isInsert);
	    var last = markedSpansAfter(oldLast, endCh, isInsert);
	
	    // Next, merge those two ends
	    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	    if (first) {
	      // Fix up .to properties of first
	      for (var i = 0; i < first.length; ++i) {
	        var span = first[i];
	        if (span.to == null) {
	          var found = getMarkedSpanFor(last, span.marker);
	          if (!found) span.to = startCh;
	          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
	        }
	      }
	    }
	    if (last) {
	      // Fix up .from in last (or move them into first in case of sameLine)
	      for (var i = 0; i < last.length; ++i) {
	        var span = last[i];
	        if (span.to != null) span.to += offset;
	        if (span.from == null) {
	          var found = getMarkedSpanFor(first, span.marker);
	          if (!found) {
	            span.from = offset;
	            if (sameLine) (first || (first = [])).push(span);
	          }
	        } else {
	          span.from += offset;
	          if (sameLine) (first || (first = [])).push(span);
	        }
	      }
	    }
	    // Make sure we didn't create any zero-length spans
	    if (first) first = clearEmptySpans(first);
	    if (last && last != first) last = clearEmptySpans(last);
	
	    var newMarkers = [first];
	    if (!sameLine) {
	      // Fill gap with whole-line-spans
	      var gap = change.text.length - 2, gapMarkers;
	      if (gap > 0 && first)
	        for (var i = 0; i < first.length; ++i)
	          if (first[i].to == null)
	            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
	      for (var i = 0; i < gap; ++i)
	        newMarkers.push(gapMarkers);
	      newMarkers.push(last);
	    }
	    return newMarkers;
	  }
	
	  // Remove spans that are empty and don't have a clearWhenEmpty
	  // option of false.
	  function clearEmptySpans(spans) {
	    for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	        spans.splice(i--, 1);
	    }
	    if (!spans.length) return null;
	    return spans;
	  }
	
	  // Used for un/re-doing changes from the history. Combines the
	  // result of computing the existing spans with the set of spans that
	  // existed in the history (so that deleting around a span and then
	  // undoing brings back the span).
	  function mergeOldSpans(doc, change) {
	    var old = getOldSpans(doc, change);
	    var stretched = stretchSpansOverChange(doc, change);
	    if (!old) return stretched;
	    if (!stretched) return old;
	
	    for (var i = 0; i < old.length; ++i) {
	      var oldCur = old[i], stretchCur = stretched[i];
	      if (oldCur && stretchCur) {
	        spans: for (var j = 0; j < stretchCur.length; ++j) {
	          var span = stretchCur[j];
	          for (var k = 0; k < oldCur.length; ++k)
	            if (oldCur[k].marker == span.marker) continue spans;
	          oldCur.push(span);
	        }
	      } else if (stretchCur) {
	        old[i] = stretchCur;
	      }
	    }
	    return old;
	  }
	
	  // Used to 'clip' out readOnly ranges when making a change.
	  function removeReadOnlyRanges(doc, from, to) {
	    var markers = null;
	    doc.iter(from.line, to.line + 1, function(line) {
	      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
	        var mark = line.markedSpans[i].marker;
	        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	          (markers || (markers = [])).push(mark);
	      }
	    });
	    if (!markers) return null;
	    var parts = [{from: from, to: to}];
	    for (var i = 0; i < markers.length; ++i) {
	      var mk = markers[i], m = mk.find(0);
	      for (var j = 0; j < parts.length; ++j) {
	        var p = parts[j];
	        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
	        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	          newParts.push({from: p.from, to: m.from});
	        if (dto > 0 || !mk.inclusiveRight && !dto)
	          newParts.push({from: m.to, to: p.to});
	        parts.splice.apply(parts, newParts);
	        j += newParts.length - 1;
	      }
	    }
	    return parts;
	  }
	
	  // Connect or disconnect spans from a line.
	  function detachMarkedSpans(line) {
	    var spans = line.markedSpans;
	    if (!spans) return;
	    for (var i = 0; i < spans.length; ++i)
	      spans[i].marker.detachLine(line);
	    line.markedSpans = null;
	  }
	  function attachMarkedSpans(line, spans) {
	    if (!spans) return;
	    for (var i = 0; i < spans.length; ++i)
	      spans[i].marker.attachLine(line);
	    line.markedSpans = spans;
	  }
	
	  // Helpers used when computing which overlapping collapsed span
	  // counts as the larger one.
	  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
	  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }
	
	  // Returns a number indicating which of two overlapping collapsed
	  // spans is larger (and thus includes the other). Falls back to
	  // comparing ids when the spans cover exactly the same range.
	  function compareCollapsedMarkers(a, b) {
	    var lenDiff = a.lines.length - b.lines.length;
	    if (lenDiff != 0) return lenDiff;
	    var aPos = a.find(), bPos = b.find();
	    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	    if (fromCmp) return -fromCmp;
	    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	    if (toCmp) return toCmp;
	    return b.id - a.id;
	  }
	
	  // Find out whether a line ends or starts in a collapsed span. If
	  // so, return the marker for that span.
	  function collapsedSpanAtSide(line, start) {
	    var sps = sawCollapsedSpans && line.markedSpans, found;
	    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	        found = sp.marker;
	    }
	    return found;
	  }
	  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
	  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }
	
	  // Test whether there exists a collapsed span that partially
	  // overlaps (covers the start or end, but not both) of a new span.
	  // Such overlap is not allowed.
	  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
	    var line = getLine(doc, lineNo);
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) for (var i = 0; i < sps.length; ++i) {
	      var sp = sps[i];
	      if (!sp.marker.collapsed) continue;
	      var found = sp.marker.find(0);
	      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
	      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	        return true;
	    }
	  }
	
	  // A visual line is a line as drawn on the screen. Folding, for
	  // example, can cause multiple logical lines to appear on the same
	  // visual line. This finds the start of the visual line that the
	  // given line is part of (usually that is the line itself).
	  function visualLine(line) {
	    var merged;
	    while (merged = collapsedSpanAtStart(line))
	      line = merged.find(-1, true).line;
	    return line;
	  }
	
	  // Returns an array of logical lines that continue the visual line
	  // started by the argument, or undefined if there are no such lines.
	  function visualLineContinued(line) {
	    var merged, lines;
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line;
	      (lines || (lines = [])).push(line);
	    }
	    return lines;
	  }
	
	  // Get the line number of the start of the visual line that the
	  // given line number is part of.
	  function visualLineNo(doc, lineN) {
	    var line = getLine(doc, lineN), vis = visualLine(line);
	    if (line == vis) return lineN;
	    return lineNo(vis);
	  }
	  // Get the line number of the start of the next visual line after
	  // the given line.
	  function visualLineEndNo(doc, lineN) {
	    if (lineN > doc.lastLine()) return lineN;
	    var line = getLine(doc, lineN), merged;
	    if (!lineIsHidden(doc, line)) return lineN;
	    while (merged = collapsedSpanAtEnd(line))
	      line = merged.find(1, true).line;
	    return lineNo(line) + 1;
	  }
	
	  // Compute whether a line is hidden. Lines count as hidden when they
	  // are part of a visual line that starts with another line, or when
	  // they are entirely covered by collapsed, non-widget span.
	  function lineIsHidden(doc, line) {
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (!sp.marker.collapsed) continue;
	      if (sp.from == null) return true;
	      if (sp.marker.widgetNode) continue;
	      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	        return true;
	    }
	  }
	  function lineIsHiddenInner(doc, line, span) {
	    if (span.to == null) {
	      var end = span.marker.find(1, true);
	      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
	    }
	    if (span.marker.inclusiveRight && span.to == line.text.length)
	      return true;
	    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
	      sp = line.markedSpans[i];
	      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	          (sp.to == null || sp.to != span.from) &&
	          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	          lineIsHiddenInner(doc, line, sp)) return true;
	    }
	  }
	
	  // LINE WIDGETS
	
	  // Line widgets are block elements displayed above or below a line.
	
	  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
	    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
	      this[opt] = options[opt];
	    this.doc = doc;
	    this.node = node;
	  };
	  eventMixin(LineWidget);
	
	  function adjustScrollWhenAboveVisible(cm, line, diff) {
	    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	      addToScrollPos(cm, null, diff);
	  }
	
	  LineWidget.prototype.clear = function() {
	    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	    if (no == null || !ws) return;
	    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
	    if (!ws.length) line.widgets = null;
	    var height = widgetHeight(this);
	    updateLineHeight(line, Math.max(0, line.height - height));
	    if (cm) runInOp(cm, function() {
	      adjustScrollWhenAboveVisible(cm, line, -height);
	      regLineChange(cm, no, "widget");
	    });
	  };
	  LineWidget.prototype.changed = function() {
	    var oldH = this.height, cm = this.doc.cm, line = this.line;
	    this.height = null;
	    var diff = widgetHeight(this) - oldH;
	    if (!diff) return;
	    updateLineHeight(line, line.height + diff);
	    if (cm) runInOp(cm, function() {
	      cm.curOp.forceUpdate = true;
	      adjustScrollWhenAboveVisible(cm, line, diff);
	    });
	  };
	
	  function widgetHeight(widget) {
	    if (widget.height != null) return widget.height;
	    var cm = widget.doc.cm;
	    if (!cm) return 0;
	    if (!contains(document.body, widget.node)) {
	      var parentStyle = "position: relative;";
	      if (widget.coverGutter)
	        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
	      if (widget.noHScroll)
	        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
	      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	    }
	    return widget.height = widget.node.parentNode.offsetHeight;
	  }
	
	  function addLineWidget(doc, handle, node, options) {
	    var widget = new LineWidget(doc, node, options);
	    var cm = doc.cm;
	    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
	    changeLine(doc, handle, "widget", function(line) {
	      var widgets = line.widgets || (line.widgets = []);
	      if (widget.insertAt == null) widgets.push(widget);
	      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
	      widget.line = line;
	      if (cm && !lineIsHidden(doc, line)) {
	        var aboveVisible = heightAtLine(line) < doc.scrollTop;
	        updateLineHeight(line, line.height + widgetHeight(widget));
	        if (aboveVisible) addToScrollPos(cm, null, widget.height);
	        cm.curOp.forceUpdate = true;
	      }
	      return true;
	    });
	    return widget;
	  }
	
	  // LINE DATA STRUCTURE
	
	  // Line objects. These hold state related to a line, including
	  // highlighting info (the styles array).
	  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
	    this.text = text;
	    attachMarkedSpans(this, markedSpans);
	    this.height = estimateHeight ? estimateHeight(this) : 1;
	  };
	  eventMixin(Line);
	  Line.prototype.lineNo = function() { return lineNo(this); };
	
	  // Change the content (text, markers) of a line. Automatically
	  // invalidates cached information and tries to re-estimate the
	  // line's height.
	  function updateLine(line, text, markedSpans, estimateHeight) {
	    line.text = text;
	    if (line.stateAfter) line.stateAfter = null;
	    if (line.styles) line.styles = null;
	    if (line.order != null) line.order = null;
	    detachMarkedSpans(line);
	    attachMarkedSpans(line, markedSpans);
	    var estHeight = estimateHeight ? estimateHeight(line) : 1;
	    if (estHeight != line.height) updateLineHeight(line, estHeight);
	  }
	
	  // Detach a line from the document tree and its markers.
	  function cleanUpLine(line) {
	    line.parent = null;
	    detachMarkedSpans(line);
	  }
	
	  function extractLineClasses(type, output) {
	    if (type) for (;;) {
	      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	      if (!lineClass) break;
	      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	      var prop = lineClass[1] ? "bgClass" : "textClass";
	      if (output[prop] == null)
	        output[prop] = lineClass[2];
	      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	        output[prop] += " " + lineClass[2];
	    }
	    return type;
	  }
	
	  function callBlankLine(mode, state) {
	    if (mode.blankLine) return mode.blankLine(state);
	    if (!mode.innerMode) return;
	    var inner = CodeMirror.innerMode(mode, state);
	    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
	  }
	
	  function readToken(mode, stream, state, inner) {
	    for (var i = 0; i < 10; i++) {
	      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
	      var style = mode.token(stream, state);
	      if (stream.pos > stream.start) return style;
	    }
	    throw new Error("Mode " + mode.name + " failed to advance stream.");
	  }
	
	  // Utility for getTokenAt and getLineTokens
	  function takeToken(cm, pos, precise, asArray) {
	    function getObj(copy) {
	      return {start: stream.start, end: stream.pos,
	              string: stream.current(),
	              type: style || null,
	              state: copy ? copyState(doc.mode, state) : state};
	    }
	
	    var doc = cm.doc, mode = doc.mode, style;
	    pos = clipPos(doc, pos);
	    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
	    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
	    if (asArray) tokens = [];
	    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	      stream.start = stream.pos;
	      style = readToken(mode, stream, state);
	      if (asArray) tokens.push(getObj(true));
	    }
	    return asArray ? tokens : getObj();
	  }
	
	  // Run the given mode's parser over a line, calling f for each token.
	  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
	    var flattenSpans = mode.flattenSpans;
	    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
	    var curStart = 0, curStyle = null;
	    var stream = new StringStream(text, cm.options.tabSize), style;
	    var inner = cm.options.addModeClass && [null];
	    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
	    while (!stream.eol()) {
	      if (stream.pos > cm.options.maxHighlightLength) {
	        flattenSpans = false;
	        if (forceToEnd) processLine(cm, text, state, stream.pos);
	        stream.pos = text.length;
	        style = null;
	      } else {
	        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
	      }
	      if (inner) {
	        var mName = inner[0].name;
	        if (mName) style = "m-" + (style ? mName + " " + style : mName);
	      }
	      if (!flattenSpans || curStyle != style) {
	        while (curStart < stream.start) {
	          curStart = Math.min(stream.start, curStart + 50000);
	          f(curStart, curStyle);
	        }
	        curStyle = style;
	      }
	      stream.start = stream.pos;
	    }
	    while (curStart < stream.pos) {
	      // Webkit seems to refuse to render text nodes longer than 57444 characters
	      var pos = Math.min(stream.pos, curStart + 50000);
	      f(pos, curStyle);
	      curStart = pos;
	    }
	  }
	
	  // Compute a style array (an array starting with a mode generation
	  // -- for invalidation -- followed by pairs of end positions and
	  // style strings), which is used to highlight the tokens on the
	  // line.
	  function highlightLine(cm, line, state, forceToEnd) {
	    // A styles array always starts with a number identifying the
	    // mode/overlays that it is based on (for easy invalidation).
	    var st = [cm.state.modeGen], lineClasses = {};
	    // Compute the base array of styles
	    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
	      st.push(end, style);
	    }, lineClasses, forceToEnd);
	
	    // Run overlays, adjust style array.
	    for (var o = 0; o < cm.state.overlays.length; ++o) {
	      var overlay = cm.state.overlays[o], i = 1, at = 0;
	      runMode(cm, line.text, overlay.mode, true, function(end, style) {
	        var start = i;
	        // Ensure there's a token end at the current position, and that i points at it
	        while (at < end) {
	          var i_end = st[i];
	          if (i_end > end)
	            st.splice(i, 1, end, st[i+1], i_end);
	          i += 2;
	          at = Math.min(end, i_end);
	        }
	        if (!style) return;
	        if (overlay.opaque) {
	          st.splice(start, i - start, end, "cm-overlay " + style);
	          i = start + 2;
	        } else {
	          for (; start < i; start += 2) {
	            var cur = st[start+1];
	            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
	          }
	        }
	      }, lineClasses);
	    }
	
	    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
	  }
	
	  function getLineStyles(cm, line, updateFrontier) {
	    if (!line.styles || line.styles[0] != cm.state.modeGen) {
	      var state = getStateBefore(cm, lineNo(line));
	      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
	      line.stateAfter = state;
	      line.styles = result.styles;
	      if (result.classes) line.styleClasses = result.classes;
	      else if (line.styleClasses) line.styleClasses = null;
	      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
	    }
	    return line.styles;
	  }
	
	  // Lightweight form of highlight -- proceed over this line and
	  // update state, but don't save a style array. Used for lines that
	  // aren't currently visible.
	  function processLine(cm, text, state, startAt) {
	    var mode = cm.doc.mode;
	    var stream = new StringStream(text, cm.options.tabSize);
	    stream.start = stream.pos = startAt || 0;
	    if (text == "") callBlankLine(mode, state);
	    while (!stream.eol()) {
	      readToken(mode, stream, state);
	      stream.start = stream.pos;
	    }
	  }
	
	  // Convert a style as returned by a mode (either null, or a string
	  // containing one or more styles) to a CSS style. This is cached,
	  // and also looks for line-wide styles.
	  var styleToClassCache = {}, styleToClassCacheWithMode = {};
	  function interpretTokenStyle(style, options) {
	    if (!style || /^\s*$/.test(style)) return null;
	    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	    return cache[style] ||
	      (cache[style] = style.replace(/\S+/g, "cm-$&"));
	  }
	
	  // Render the DOM representation of the text of a line. Also builds
	  // up a 'line map', which points at the DOM nodes that represent
	  // specific stretches of text, and is used by the measuring code.
	  // The returned object contains the DOM node, this map, and
	  // information about line-wide styles that were set by the mode.
	  function buildLineContent(cm, lineView) {
	    // The padding-right forces the element to have a 'border', which
	    // is needed on Webkit to be able to get line-level bounding
	    // rectangles for it (in measureChar).
	    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
	    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
	                   col: 0, pos: 0, cm: cm,
	                   trailingSpace: false,
	                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
	    lineView.measure = {};
	
	    // Iterate over the logical lines that make up this visual line.
	    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	      var line = i ? lineView.rest[i - 1] : lineView.line, order;
	      builder.pos = 0;
	      builder.addToken = buildToken;
	      // Optionally wire in some hacks into the token-rendering
	      // algorithm, to deal with browser quirks.
	      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
	        builder.addToken = buildTokenBadBidi(builder.addToken, order);
	      builder.map = [];
	      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	      if (line.styleClasses) {
	        if (line.styleClasses.bgClass)
	          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
	        if (line.styleClasses.textClass)
	          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
	      }
	
	      // Ensure at least a single node is present, for measuring.
	      if (builder.map.length == 0)
	        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
	
	      // Store the map and a cache object for the current logical line
	      if (i == 0) {
	        lineView.measure.map = builder.map;
	        lineView.measure.cache = {};
	      } else {
	        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
	        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
	      }
	    }
	
	    // See issue #2901
	    if (webkit) {
	      var last = builder.content.lastChild
	      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	        builder.content.className = "cm-tab-wrap-hack";
	    }
	
	    signal(cm, "renderLine", cm, lineView.line, builder.pre);
	    if (builder.pre.className)
	      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
	
	    return builder;
	  }
	
	  function defaultSpecialCharPlaceholder(ch) {
	    var token = elt("span", "\u2022", "cm-invalidchar");
	    token.title = "\\u" + ch.charCodeAt(0).toString(16);
	    token.setAttribute("aria-label", token.title);
	    return token;
	  }
	
	  // Build up the DOM representation for a single token, and add it to
	  // the line map. Takes care to render special characters separately.
	  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	    if (!text) return;
	    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
	    var special = builder.cm.state.specialChars, mustWrap = false;
	    if (!special.test(text)) {
	      builder.col += text.length;
	      var content = document.createTextNode(displayText);
	      builder.map.push(builder.pos, builder.pos + text.length, content);
	      if (ie && ie_version < 9) mustWrap = true;
	      builder.pos += text.length;
	    } else {
	      var content = document.createDocumentFragment(), pos = 0;
	      while (true) {
	        special.lastIndex = pos;
	        var m = special.exec(text);
	        var skipped = m ? m.index - pos : text.length - pos;
	        if (skipped) {
	          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
	          else content.appendChild(txt);
	          builder.map.push(builder.pos, builder.pos + skipped, txt);
	          builder.col += skipped;
	          builder.pos += skipped;
	        }
	        if (!m) break;
	        pos += skipped + 1;
	        if (m[0] == "\t") {
	          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	          txt.setAttribute("role", "presentation");
	          txt.setAttribute("cm-text", "\t");
	          builder.col += tabWidth;
	        } else if (m[0] == "\r" || m[0] == "\n") {
	          var txt = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	          txt.setAttribute("cm-text", m[0]);
	          builder.col += 1;
	        } else {
	          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
	          txt.setAttribute("cm-text", m[0]);
	          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
	          else content.appendChild(txt);
	          builder.col += 1;
	        }
	        builder.map.push(builder.pos, builder.pos + 1, txt);
	        builder.pos++;
	      }
	    }
	    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
	    if (style || startStyle || endStyle || mustWrap || css) {
	      var fullStyle = style || "";
	      if (startStyle) fullStyle += startStyle;
	      if (endStyle) fullStyle += endStyle;
	      var token = elt("span", [content], fullStyle, css);
	      if (title) token.title = title;
	      return builder.content.appendChild(token);
	    }
	    builder.content.appendChild(content);
	  }
	
	  function splitSpaces(text, trailingBefore) {
	    if (text.length > 1 && !/  /.test(text)) return text
	    var spaceBefore = trailingBefore, result = ""
	    for (var i = 0; i < text.length; i++) {
	      var ch = text.charAt(i)
	      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	        ch = "\u00a0"
	      result += ch
	      spaceBefore = ch == " "
	    }
	    return result
	  }
	
	  // Work around nonsense dimensions being reported for stretches of
	  // right-to-left text.
	  function buildTokenBadBidi(inner, order) {
	    return function(builder, text, style, startStyle, endStyle, title, css) {
	      style = style ? style + " cm-force-border" : "cm-force-border";
	      var start = builder.pos, end = start + text.length;
	      for (;;) {
	        // Find the part that overlaps with the start of this text
	        for (var i = 0; i < order.length; i++) {
	          var part = order[i];
	          if (part.to > start && part.from <= start) break;
	        }
	        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
	        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
	        startStyle = null;
	        text = text.slice(part.to - start);
	        start = part.to;
	      }
	    };
	  }
	
	  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	    var widget = !ignoreWidget && marker.widgetNode;
	    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
	    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	      if (!widget)
	        widget = builder.content.appendChild(document.createElement("span"));
	      widget.setAttribute("cm-marker", marker.id);
	    }
	    if (widget) {
	      builder.cm.display.input.setUneditable(widget);
	      builder.content.appendChild(widget);
	    }
	    builder.pos += size;
	    builder.trailingSpace = false
	  }
	
	  // Outputs a number of spans to make up a line, taking highlighting
	  // and marked text into account.
	  function insertLineContent(line, builder, styles) {
	    var spans = line.markedSpans, allText = line.text, at = 0;
	    if (!spans) {
	      for (var i = 1; i < styles.length; i+=2)
	        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
	      return;
	    }
	
	    var len = allText.length, pos = 0, i = 1, text = "", style, css;
	    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
	    for (;;) {
	      if (nextChange == pos) { // Update current marker set
	        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
	        collapsed = null; nextChange = Infinity;
	        var foundBookmarks = [], endStyles
	        for (var j = 0; j < spans.length; ++j) {
	          var sp = spans[j], m = sp.marker;
	          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	            foundBookmarks.push(m);
	          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	              nextChange = sp.to;
	              spanEndStyle = "";
	            }
	            if (m.className) spanStyle += " " + m.className;
	            if (m.css) css = (css ? css + ";" : "") + m.css;
	            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
	            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)
	            if (m.title && !title) title = m.title;
	            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	              collapsed = sp;
	          } else if (sp.from > pos && nextChange > sp.from) {
	            nextChange = sp.from;
	          }
	        }
	        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)
	          if (endStyles[j + 1] == nextChange) spanEndStyle += " " + endStyles[j]
	
	        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)
	          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
	        if (collapsed && (collapsed.from || 0) == pos) {
	          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                             collapsed.marker, collapsed.from == null);
	          if (collapsed.to == null) return;
	          if (collapsed.to == pos) collapsed = false;
	        }
	      }
	      if (pos >= len) break;
	
	      var upto = Math.min(len, nextChange);
	      while (true) {
	        if (text) {
	          var end = pos + text.length;
	          if (!collapsed) {
	            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
	          }
	          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
	          pos = end;
	          spanStartStyle = "";
	        }
	        text = allText.slice(at, at = styles[i++]);
	        style = interpretTokenStyle(styles[i++], builder.cm.options);
	      }
	    }
	  }
	
	  // DOCUMENT DATA STRUCTURE
	
	  // By default, updates that start and end at the beginning of a line
	  // are treated specially, in order to make the association of line
	  // widgets and marker elements with the text behave more intuitive.
	  function isWholeLineUpdate(doc, change) {
	    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
	  }
	
	  // Perform a change on the document data structure.
	  function updateDoc(doc, change, markedSpans, estimateHeight) {
	    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
	    function update(line, text, spans) {
	      updateLine(line, text, spans, estimateHeight);
	      signalLater(line, "change", line, change);
	    }
	    function linesFor(start, end) {
	      for (var i = start, result = []; i < end; ++i)
	        result.push(new Line(text[i], spansFor(i), estimateHeight));
	      return result;
	    }
	
	    var from = change.from, to = change.to, text = change.text;
	    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
	
	    // Adjust the line structure
	    if (change.full) {
	      doc.insert(0, linesFor(0, text.length));
	      doc.remove(text.length, doc.size - text.length);
	    } else if (isWholeLineUpdate(doc, change)) {
	      // This is a whole-line replace. Treated specially to make
	      // sure line objects move the way they are supposed to.
	      var added = linesFor(0, text.length - 1);
	      update(lastLine, lastLine.text, lastSpans);
	      if (nlines) doc.remove(from.line, nlines);
	      if (added.length) doc.insert(from.line, added);
	    } else if (firstLine == lastLine) {
	      if (text.length == 1) {
	        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	      } else {
	        var added = linesFor(1, text.length - 1);
	        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
	        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	        doc.insert(from.line + 1, added);
	      }
	    } else if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	      doc.remove(from.line + 1, nlines);
	    } else {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	      var added = linesFor(1, text.length - 1);
	      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
	      doc.insert(from.line + 1, added);
	    }
	
	    signalLater(doc, "change", doc, change);
	  }
	
	  // The document is represented as a BTree consisting of leaves, with
	  // chunk of lines in them, and branches, with up to ten leaves or
	  // other branch nodes below them. The top node is always a branch
	  // node, and is the document object itself (meaning it has
	  // additional methods and properties).
	  //
	  // All nodes have parent links. The tree is used both to go from
	  // line numbers to line objects, and to go from objects to numbers.
	  // It also indexes by height, and is used to convert between height
	  // and line object, and to find the total height of the document.
	  //
	  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
	
	  function LeafChunk(lines) {
	    this.lines = lines;
	    this.parent = null;
	    for (var i = 0, height = 0; i < lines.length; ++i) {
	      lines[i].parent = this;
	      height += lines[i].height;
	    }
	    this.height = height;
	  }
	
	  LeafChunk.prototype = {
	    chunkSize: function() { return this.lines.length; },
	    // Remove the n lines at offset 'at'.
	    removeInner: function(at, n) {
	      for (var i = at, e = at + n; i < e; ++i) {
	        var line = this.lines[i];
	        this.height -= line.height;
	        cleanUpLine(line);
	        signalLater(line, "delete");
	      }
	      this.lines.splice(at, n);
	    },
	    // Helper used to collapse a small branch into a single leaf.
	    collapse: function(lines) {
	      lines.push.apply(lines, this.lines);
	    },
	    // Insert the given array of lines at offset 'at', count them as
	    // having the given height.
	    insertInner: function(at, lines, height) {
	      this.height += height;
	      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
	    },
	    // Used to iterate over a part of the tree.
	    iterN: function(at, n, op) {
	      for (var e = at + n; at < e; ++at)
	        if (op(this.lines[at])) return true;
	    }
	  };
	
	  function BranchChunk(children) {
	    this.children = children;
	    var size = 0, height = 0;
	    for (var i = 0; i < children.length; ++i) {
	      var ch = children[i];
	      size += ch.chunkSize(); height += ch.height;
	      ch.parent = this;
	    }
	    this.size = size;
	    this.height = height;
	    this.parent = null;
	  }
	
	  BranchChunk.prototype = {
	    chunkSize: function() { return this.size; },
	    removeInner: function(at, n) {
	      this.size -= n;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var rm = Math.min(n, sz - at), oldHeight = child.height;
	          child.removeInner(at, rm);
	          this.height -= oldHeight - child.height;
	          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
	          if ((n -= rm) == 0) break;
	          at = 0;
	        } else at -= sz;
	      }
	      // If the result is smaller than 25 lines, ensure that it is a
	      // single leaf node.
	      if (this.size - n < 25 &&
	          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	        var lines = [];
	        this.collapse(lines);
	        this.children = [new LeafChunk(lines)];
	        this.children[0].parent = this;
	      }
	    },
	    collapse: function(lines) {
	      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
	    },
	    insertInner: function(at, lines, height) {
	      this.size += lines.length;
	      this.height += height;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at <= sz) {
	          child.insertInner(at, lines, height);
	          if (child.lines && child.lines.length > 50) {
	            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	            var remaining = child.lines.length % 25 + 25
	            for (var pos = remaining; pos < child.lines.length;) {
	              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	              child.height -= leaf.height;
	              this.children.splice(++i, 0, leaf);
	              leaf.parent = this;
	            }
	            child.lines = child.lines.slice(0, remaining);
	            this.maybeSpill();
	          }
	          break;
	        }
	        at -= sz;
	      }
	    },
	    // When a node has grown, check whether it should be split.
	    maybeSpill: function() {
	      if (this.children.length <= 10) return;
	      var me = this;
	      do {
	        var spilled = me.children.splice(me.children.length - 5, 5);
	        var sibling = new BranchChunk(spilled);
	        if (!me.parent) { // Become the parent node
	          var copy = new BranchChunk(me.children);
	          copy.parent = me;
	          me.children = [copy, sibling];
	          me = copy;
	       } else {
	          me.size -= sibling.size;
	          me.height -= sibling.height;
	          var myIndex = indexOf(me.parent.children, me);
	          me.parent.children.splice(myIndex + 1, 0, sibling);
	        }
	        sibling.parent = me.parent;
	      } while (me.children.length > 10);
	      me.parent.maybeSpill();
	    },
	    iterN: function(at, n, op) {
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var used = Math.min(n, sz - at);
	          if (child.iterN(at, used, op)) return true;
	          if ((n -= used) == 0) break;
	          at = 0;
	        } else at -= sz;
	      }
	    }
	  };
	
	  var nextDocId = 0;
	  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
	    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
	    if (firstLine == null) firstLine = 0;
	
	    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	    this.first = firstLine;
	    this.scrollTop = this.scrollLeft = 0;
	    this.cantEdit = false;
	    this.cleanGeneration = 1;
	    this.frontier = firstLine;
	    var start = Pos(firstLine, 0);
	    this.sel = simpleSelection(start);
	    this.history = new History(null);
	    this.id = ++nextDocId;
	    this.modeOption = mode;
	    this.lineSep = lineSep;
	    this.extend = false;
	
	    if (typeof text == "string") text = this.splitLines(text);
	    updateDoc(this, {from: start, to: start, text: text});
	    setSelection(this, simpleSelection(start), sel_dontScroll);
	  };
	
	  Doc.prototype = createObj(BranchChunk.prototype, {
	    constructor: Doc,
	    // Iterate over the document. Supports two forms -- with only one
	    // argument, it calls that for each line in the document. With
	    // three, it iterates over the range given by the first two (with
	    // the second being non-inclusive).
	    iter: function(from, to, op) {
	      if (op) this.iterN(from - this.first, to - from, op);
	      else this.iterN(this.first, this.first + this.size, from);
	    },
	
	    // Non-public interface for adding and removing lines.
	    insert: function(at, lines) {
	      var height = 0;
	      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
	      this.insertInner(at - this.first, lines, height);
	    },
	    remove: function(at, n) { this.removeInner(at - this.first, n); },
	
	    // From here, the methods are part of the public interface. Most
	    // are also available from CodeMirror (editor) instances.
	
	    getValue: function(lineSep) {
	      var lines = getLines(this, this.first, this.first + this.size);
	      if (lineSep === false) return lines;
	      return lines.join(lineSep || this.lineSeparator());
	    },
	    setValue: docMethodOp(function(code) {
	      var top = Pos(this.first, 0), last = this.first + this.size - 1;
	      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                        text: this.splitLines(code), origin: "setValue", full: true}, true);
	      setSelection(this, simpleSelection(top));
	    }),
	    replaceRange: function(code, from, to, origin) {
	      from = clipPos(this, from);
	      to = to ? clipPos(this, to) : from;
	      replaceRange(this, code, from, to, origin);
	    },
	    getRange: function(from, to, lineSep) {
	      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	      if (lineSep === false) return lines;
	      return lines.join(lineSep || this.lineSeparator());
	    },
	
	    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},
	
	    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
	    getLineNumber: function(line) {return lineNo(line);},
	
	    getLineHandleVisualStart: function(line) {
	      if (typeof line == "number") line = getLine(this, line);
	      return visualLine(line);
	    },
	
	    lineCount: function() {return this.size;},
	    firstLine: function() {return this.first;},
	    lastLine: function() {return this.first + this.size - 1;},
	
	    clipPos: function(pos) {return clipPos(this, pos);},
	
	    getCursor: function(start) {
	      var range = this.sel.primary(), pos;
	      if (start == null || start == "head") pos = range.head;
	      else if (start == "anchor") pos = range.anchor;
	      else if (start == "end" || start == "to" || start === false) pos = range.to();
	      else pos = range.from();
	      return pos;
	    },
	    listSelections: function() { return this.sel.ranges; },
	    somethingSelected: function() {return this.sel.somethingSelected();},
	
	    setCursor: docMethodOp(function(line, ch, options) {
	      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	    }),
	    setSelection: docMethodOp(function(anchor, head, options) {
	      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	    }),
	    extendSelection: docMethodOp(function(head, other, options) {
	      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	    }),
	    extendSelections: docMethodOp(function(heads, options) {
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    extendSelectionsBy: docMethodOp(function(f, options) {
	      var heads = map(this.sel.ranges, f);
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    setSelections: docMethodOp(function(ranges, primary, options) {
	      if (!ranges.length) return;
	      for (var i = 0, out = []; i < ranges.length; i++)
	        out[i] = new Range(clipPos(this, ranges[i].anchor),
	                           clipPos(this, ranges[i].head));
	      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
	      setSelection(this, normalizeSelection(out, primary), options);
	    }),
	    addSelection: docMethodOp(function(anchor, head, options) {
	      var ranges = this.sel.ranges.slice(0);
	      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
	    }),
	
	    getSelection: function(lineSep) {
	      var ranges = this.sel.ranges, lines;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        lines = lines ? lines.concat(sel) : sel;
	      }
	      if (lineSep === false) return lines;
	      else return lines.join(lineSep || this.lineSeparator());
	    },
	    getSelections: function(lineSep) {
	      var parts = [], ranges = this.sel.ranges;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
	        parts[i] = sel;
	      }
	      return parts;
	    },
	    replaceSelection: function(code, collapse, origin) {
	      var dup = [];
	      for (var i = 0; i < this.sel.ranges.length; i++)
	        dup[i] = code;
	      this.replaceSelections(dup, collapse, origin || "+input");
	    },
	    replaceSelections: docMethodOp(function(code, collapse, origin) {
	      var changes = [], sel = this.sel;
	      for (var i = 0; i < sel.ranges.length; i++) {
	        var range = sel.ranges[i];
	        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
	      }
	      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	      for (var i = changes.length - 1; i >= 0; i--)
	        makeChange(this, changes[i]);
	      if (newSel) setSelectionReplaceHistory(this, newSel);
	      else if (this.cm) ensureCursorVisible(this.cm);
	    }),
	    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),
	
	    setExtending: function(val) {this.extend = val;},
	    getExtending: function() {return this.extend;},
	
	    historySize: function() {
	      var hist = this.history, done = 0, undone = 0;
	      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
	      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
	      return {undo: done, redo: undone};
	    },
	    clearHistory: function() {this.history = new History(this.history.maxGeneration);},
	
	    markClean: function() {
	      this.cleanGeneration = this.changeGeneration(true);
	    },
	    changeGeneration: function(forceSplit) {
	      if (forceSplit)
	        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
	      return this.history.generation;
	    },
	    isClean: function (gen) {
	      return this.history.generation == (gen || this.cleanGeneration);
	    },
	
	    getHistory: function() {
	      return {done: copyHistoryArray(this.history.done),
	              undone: copyHistoryArray(this.history.undone)};
	    },
	    setHistory: function(histData) {
	      var hist = this.history = new History(this.history.maxGeneration);
	      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	    },
	
	    addLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        if (!line[prop]) line[prop] = cls;
	        else if (classTest(cls).test(line[prop])) return false;
	        else line[prop] += " " + cls;
	        return true;
	      });
	    }),
	    removeLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        var cur = line[prop];
	        if (!cur) return false;
	        else if (cls == null) line[prop] = null;
	        else {
	          var found = cur.match(classTest(cls));
	          if (!found) return false;
	          var end = found.index + found[0].length;
	          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	        }
	        return true;
	      });
	    }),
	
	    addLineWidget: docMethodOp(function(handle, node, options) {
	      return addLineWidget(this, handle, node, options);
	    }),
	    removeLineWidget: function(widget) { widget.clear(); },
	
	    markText: function(from, to, options) {
	      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
	    },
	    setBookmark: function(pos, options) {
	      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                      insertLeft: options && options.insertLeft,
	                      clearWhenEmpty: false, shared: options && options.shared,
	                      handleMouseEvents: options && options.handleMouseEvents};
	      pos = clipPos(this, pos);
	      return markText(this, pos, pos, realOpts, "bookmark");
	    },
	    findMarksAt: function(pos) {
	      pos = clipPos(this, pos);
	      var markers = [], spans = getLine(this, pos.line).markedSpans;
	      if (spans) for (var i = 0; i < spans.length; ++i) {
	        var span = spans[i];
	        if ((span.from == null || span.from <= pos.ch) &&
	            (span.to == null || span.to >= pos.ch))
	          markers.push(span.marker.parent || span.marker);
	      }
	      return markers;
	    },
	    findMarks: function(from, to, filter) {
	      from = clipPos(this, from); to = clipPos(this, to);
	      var found = [], lineNo = from.line;
	      this.iter(from.line, to.line + 1, function(line) {
	        var spans = line.markedSpans;
	        if (spans) for (var i = 0; i < spans.length; i++) {
	          var span = spans[i];
	          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
	                span.from == null && lineNo != from.line ||
	                span.from != null && lineNo == to.line && span.from >= to.ch) &&
	              (!filter || filter(span.marker)))
	            found.push(span.marker.parent || span.marker);
	        }
	        ++lineNo;
	      });
	      return found;
	    },
	    getAllMarks: function() {
	      var markers = [];
	      this.iter(function(line) {
	        var sps = line.markedSpans;
	        if (sps) for (var i = 0; i < sps.length; ++i)
	          if (sps[i].from != null) markers.push(sps[i].marker);
	      });
	      return markers;
	    },
	
	    posFromIndex: function(off) {
	      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
	      this.iter(function(line) {
	        var sz = line.text.length + sepSize;
	        if (sz > off) { ch = off; return true; }
	        off -= sz;
	        ++lineNo;
	      });
	      return clipPos(this, Pos(lineNo, ch));
	    },
	    indexFromPos: function (coords) {
	      coords = clipPos(this, coords);
	      var index = coords.ch;
	      if (coords.line < this.first || coords.ch < 0) return 0;
	      var sepSize = this.lineSeparator().length;
	      this.iter(this.first, coords.line, function (line) {
	        index += line.text.length + sepSize;
	      });
	      return index;
	    },
	
	    copy: function(copyHistory) {
	      var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                        this.modeOption, this.first, this.lineSep);
	      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	      doc.sel = this.sel;
	      doc.extend = false;
	      if (copyHistory) {
	        doc.history.undoDepth = this.history.undoDepth;
	        doc.setHistory(this.getHistory());
	      }
	      return doc;
	    },
	
	    linkedDoc: function(options) {
	      if (!options) options = {};
	      var from = this.first, to = this.first + this.size;
	      if (options.from != null && options.from > from) from = options.from;
	      if (options.to != null && options.to < to) to = options.to;
	      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
	      if (options.sharedHist) copy.history = this.history;
	      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	      copySharedMarkers(copy, findSharedMarkers(this));
	      return copy;
	    },
	    unlinkDoc: function(other) {
	      if (other instanceof CodeMirror) other = other.doc;
	      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
	        var link = this.linked[i];
	        if (link.doc != other) continue;
	        this.linked.splice(i, 1);
	        other.unlinkDoc(this);
	        detachSharedMarkers(findSharedMarkers(this));
	        break;
	      }
	      // If the histories were shared, split them again
	      if (other.history == this.history) {
	        var splitIds = [other.id];
	        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
	        other.history = new History(null);
	        other.history.done = copyHistoryArray(this.history.done, splitIds);
	        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	      }
	    },
	    iterLinkedDocs: function(f) {linkedDocs(this, f);},
	
	    getMode: function() {return this.mode;},
	    getEditor: function() {return this.cm;},
	
	    splitLines: function(str) {
	      if (this.lineSep) return str.split(this.lineSep);
	      return splitLinesAuto(str);
	    },
	    lineSeparator: function() { return this.lineSep || "\n"; }
	  });
	
	  // Public alias.
	  Doc.prototype.eachLine = Doc.prototype.iter;
	
	  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
	  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	    CodeMirror.prototype[prop] = (function(method) {
	      return function() {return method.apply(this.doc, arguments);};
	    })(Doc.prototype[prop]);
	
	  eventMixin(Doc);
	
	  // Call f for all linked documents.
	  function linkedDocs(doc, f, sharedHistOnly) {
	    function propagate(doc, skip, sharedHist) {
	      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
	        var rel = doc.linked[i];
	        if (rel.doc == skip) continue;
	        var shared = sharedHist && rel.sharedHist;
	        if (sharedHistOnly && !shared) continue;
	        f(rel.doc, shared);
	        propagate(rel.doc, doc, shared);
	      }
	    }
	    propagate(doc, null, true);
	  }
	
	  // Attach a document to an editor.
	  function attachDoc(cm, doc) {
	    if (doc.cm) throw new Error("This document is already in use.");
	    cm.doc = doc;
	    doc.cm = cm;
	    estimateLineHeights(cm);
	    loadMode(cm);
	    if (!cm.options.lineWrapping) findMaxLine(cm);
	    cm.options.mode = doc.modeOption;
	    regChange(cm);
	  }
	
	  // LINE UTILITIES
	
	  // Find the line object corresponding to the given line number.
	  function getLine(doc, n) {
	    n -= doc.first;
	    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
	    for (var chunk = doc; !chunk.lines;) {
	      for (var i = 0;; ++i) {
	        var child = chunk.children[i], sz = child.chunkSize();
	        if (n < sz) { chunk = child; break; }
	        n -= sz;
	      }
	    }
	    return chunk.lines[n];
	  }
	
	  // Get the part of a document between two positions, as an array of
	  // strings.
	  function getBetween(doc, start, end) {
	    var out = [], n = start.line;
	    doc.iter(start.line, end.line + 1, function(line) {
	      var text = line.text;
	      if (n == end.line) text = text.slice(0, end.ch);
	      if (n == start.line) text = text.slice(start.ch);
	      out.push(text);
	      ++n;
	    });
	    return out;
	  }
	  // Get the lines between from and to, as array of strings.
	  function getLines(doc, from, to) {
	    var out = [];
	    doc.iter(from, to, function(line) { out.push(line.text); });
	    return out;
	  }
	
	  // Update the height of a line, propagating the height change
	  // upwards to parent nodes.
	  function updateLineHeight(line, height) {
	    var diff = height - line.height;
	    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
	  }
	
	  // Given a line object, find its line number by walking up through
	  // its parent links.
	  function lineNo(line) {
	    if (line.parent == null) return null;
	    var cur = line.parent, no = indexOf(cur.lines, line);
	    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	      for (var i = 0;; ++i) {
	        if (chunk.children[i] == cur) break;
	        no += chunk.children[i].chunkSize();
	      }
	    }
	    return no + cur.first;
	  }
	
	  // Find the line at the given vertical position, using the height
	  // information in the document tree.
	  function lineAtHeight(chunk, h) {
	    var n = chunk.first;
	    outer: do {
	      for (var i = 0; i < chunk.children.length; ++i) {
	        var child = chunk.children[i], ch = child.height;
	        if (h < ch) { chunk = child; continue outer; }
	        h -= ch;
	        n += child.chunkSize();
	      }
	      return n;
	    } while (!chunk.lines);
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i], lh = line.height;
	      if (h < lh) break;
	      h -= lh;
	    }
	    return n + i;
	  }
	
	
	  // Find the height above the given line.
	  function heightAtLine(lineObj) {
	    lineObj = visualLine(lineObj);
	
	    var h = 0, chunk = lineObj.parent;
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i];
	      if (line == lineObj) break;
	      else h += line.height;
	    }
	    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	      for (var i = 0; i < p.children.length; ++i) {
	        var cur = p.children[i];
	        if (cur == chunk) break;
	        else h += cur.height;
	      }
	    }
	    return h;
	  }
	
	  // Get the bidi ordering for the given line (and cache it). Returns
	  // false for lines that are fully left-to-right, and an array of
	  // BidiSpan objects otherwise.
	  function getOrder(line) {
	    var order = line.order;
	    if (order == null) order = line.order = bidiOrdering(line.text);
	    return order;
	  }
	
	  // HISTORY
	
	  function History(startGen) {
	    // Arrays of change events and selections. Doing something adds an
	    // event to done and clears undo. Undoing moves events from done
	    // to undone, redoing moves them in the other direction.
	    this.done = []; this.undone = [];
	    this.undoDepth = Infinity;
	    // Used to track when changes can be merged into a single undo
	    // event
	    this.lastModTime = this.lastSelTime = 0;
	    this.lastOp = this.lastSelOp = null;
	    this.lastOrigin = this.lastSelOrigin = null;
	    // Used by the isClean() method
	    this.generation = this.maxGeneration = startGen || 1;
	  }
	
	  // Create a history change event from an updateDoc-style change
	  // object.
	  function historyChangeFromChange(doc, change) {
	    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
	    return histChange;
	  }
	
	  // Pop all selection events off the end of a history array. Stop at
	  // a change event.
	  function clearSelectionEvents(array) {
	    while (array.length) {
	      var last = lst(array);
	      if (last.ranges) array.pop();
	      else break;
	    }
	  }
	
	  // Find the top change event in the history. Pop off selection
	  // events that are in the way.
	  function lastChangeEvent(hist, force) {
	    if (force) {
	      clearSelectionEvents(hist.done);
	      return lst(hist.done);
	    } else if (hist.done.length && !lst(hist.done).ranges) {
	      return lst(hist.done);
	    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	      hist.done.pop();
	      return lst(hist.done);
	    }
	  }
	
	  // Register a change in the history. Merges changes that are within
	  // a single operation, ore are close together with an origin that
	  // allows merging (starting with "+") into a single event.
	  function addChangeToHistory(doc, change, selAfter, opId) {
	    var hist = doc.history;
	    hist.undone.length = 0;
	    var time = +new Date, cur;
	
	    if ((hist.lastOp == opId ||
	         hist.lastOrigin == change.origin && change.origin &&
	         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
	          change.origin.charAt(0) == "*")) &&
	        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	      // Merge this change into the last event
	      var last = lst(cur.changes);
	      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	        // Optimized case for simple insertion -- don't want to add
	        // new changesets for every character typed
	        last.to = changeEnd(change);
	      } else {
	        // Add new sub-event
	        cur.changes.push(historyChangeFromChange(doc, change));
	      }
	    } else {
	      // Can not be merged, start a new event.
	      var before = lst(hist.done);
	      if (!before || !before.ranges)
	        pushSelectionToHistory(doc.sel, hist.done);
	      cur = {changes: [historyChangeFromChange(doc, change)],
	             generation: hist.generation};
	      hist.done.push(cur);
	      while (hist.done.length > hist.undoDepth) {
	        hist.done.shift();
	        if (!hist.done[0].ranges) hist.done.shift();
	      }
	    }
	    hist.done.push(selAfter);
	    hist.generation = ++hist.maxGeneration;
	    hist.lastModTime = hist.lastSelTime = time;
	    hist.lastOp = hist.lastSelOp = opId;
	    hist.lastOrigin = hist.lastSelOrigin = change.origin;
	
	    if (!last) signal(doc, "historyAdded");
	  }
	
	  function selectionEventCanBeMerged(doc, origin, prev, sel) {
	    var ch = origin.charAt(0);
	    return ch == "*" ||
	      ch == "+" &&
	      prev.ranges.length == sel.ranges.length &&
	      prev.somethingSelected() == sel.somethingSelected() &&
	      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
	  }
	
	  // Called whenever the selection changes, sets the new selection as
	  // the pending selection in the history, and pushes the old pending
	  // selection into the 'done' array when it was significantly
	  // different (in number of selected ranges, emptiness, or time).
	  function addSelectionToHistory(doc, sel, opId, options) {
	    var hist = doc.history, origin = options && options.origin;
	
	    // A new event is started when the previous origin does not match
	    // the current, or the origins don't allow matching. Origins
	    // starting with * are always merged, those starting with + are
	    // merged when similar and close together in time.
	    if (opId == hist.lastSelOp ||
	        (origin && hist.lastSelOrigin == origin &&
	         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	      hist.done[hist.done.length - 1] = sel;
	    else
	      pushSelectionToHistory(sel, hist.done);
	
	    hist.lastSelTime = +new Date;
	    hist.lastSelOrigin = origin;
	    hist.lastSelOp = opId;
	    if (options && options.clearRedo !== false)
	      clearSelectionEvents(hist.undone);
	  }
	
	  function pushSelectionToHistory(sel, dest) {
	    var top = lst(dest);
	    if (!(top && top.ranges && top.equals(sel)))
	      dest.push(sel);
	  }
	
	  // Used to store marked span information in the history.
	  function attachLocalSpans(doc, change, from, to) {
	    var existing = change["spans_" + doc.id], n = 0;
	    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
	      if (line.markedSpans)
	        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
	      ++n;
	    });
	  }
	
	  // When un/re-doing restores text containing marked spans, those
	  // that have been explicitly cleared should not be restored.
	  function removeClearedSpans(spans) {
	    if (!spans) return null;
	    for (var i = 0, out; i < spans.length; ++i) {
	      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
	      else if (out) out.push(spans[i]);
	    }
	    return !out ? spans : out.length ? out : null;
	  }
	
	  // Retrieve and filter the old marked spans stored in a change event.
	  function getOldSpans(doc, change) {
	    var found = change["spans_" + doc.id];
	    if (!found) return null;
	    for (var i = 0, nw = []; i < change.text.length; ++i)
	      nw.push(removeClearedSpans(found[i]));
	    return nw;
	  }
	
	  // Used both to provide a JSON-safe object in .getHistory, and, when
	  // detaching a document, to split the history in two
	  function copyHistoryArray(events, newGroup, instantiateSel) {
	    for (var i = 0, copy = []; i < events.length; ++i) {
	      var event = events[i];
	      if (event.ranges) {
	        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	        continue;
	      }
	      var changes = event.changes, newChanges = [];
	      copy.push({changes: newChanges});
	      for (var j = 0; j < changes.length; ++j) {
	        var change = changes[j], m;
	        newChanges.push({from: change.from, to: change.to, text: change.text});
	        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
	          if (indexOf(newGroup, Number(m[1])) > -1) {
	            lst(newChanges)[prop] = change[prop];
	            delete change[prop];
	          }
	        }
	      }
	    }
	    return copy;
	  }
	
	  // Rebasing/resetting history to deal with externally-sourced changes
	
	  function rebaseHistSelSingle(pos, from, to, diff) {
	    if (to < pos.line) {
	      pos.line += diff;
	    } else if (from < pos.line) {
	      pos.line = from;
	      pos.ch = 0;
	    }
	  }
	
	  // Tries to rebase an array of history events given a change in the
	  // document. If the change touches the same lines as the event, the
	  // event, and everything 'behind' it, is discarded. If the change is
	  // before the event, the event's positions are updated. Uses a
	  // copy-on-write scheme for the positions, to avoid having to
	  // reallocate them all on every rebase, but also avoid problems with
	  // shared position objects being unsafely updated.
	  function rebaseHistArray(array, from, to, diff) {
	    for (var i = 0; i < array.length; ++i) {
	      var sub = array[i], ok = true;
	      if (sub.ranges) {
	        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	        for (var j = 0; j < sub.ranges.length; j++) {
	          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	        }
	        continue;
	      }
	      for (var j = 0; j < sub.changes.length; ++j) {
	        var cur = sub.changes[j];
	        if (to < cur.from.line) {
	          cur.from = Pos(cur.from.line + diff, cur.from.ch);
	          cur.to = Pos(cur.to.line + diff, cur.to.ch);
	        } else if (from <= cur.to.line) {
	          ok = false;
	          break;
	        }
	      }
	      if (!ok) {
	        array.splice(0, i + 1);
	        i = 0;
	      }
	    }
	  }
	
	  function rebaseHist(hist, change) {
	    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	    rebaseHistArray(hist.done, from, to, diff);
	    rebaseHistArray(hist.undone, from, to, diff);
	  }
	
	  // EVENT UTILITIES
	
	  // Due to the fact that we still support jurassic IE versions, some
	  // compatibility wrappers are needed.
	
	  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
	    if (e.preventDefault) e.preventDefault();
	    else e.returnValue = false;
	  };
	  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
	    if (e.stopPropagation) e.stopPropagation();
	    else e.cancelBubble = true;
	  };
	  function e_defaultPrevented(e) {
	    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
	  }
	  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};
	
	  function e_target(e) {return e.target || e.srcElement;}
	  function e_button(e) {
	    var b = e.which;
	    if (b == null) {
	      if (e.button & 1) b = 1;
	      else if (e.button & 2) b = 3;
	      else if (e.button & 4) b = 2;
	    }
	    if (mac && e.ctrlKey && b == 1) b = 3;
	    return b;
	  }
	
	  // EVENT HANDLING
	
	  // Lightweight event framework. on/off also work on DOM nodes,
	  // registering native DOM handlers.
	
	  var on = CodeMirror.on = function(emitter, type, f) {
	    if (emitter.addEventListener)
	      emitter.addEventListener(type, f, false);
	    else if (emitter.attachEvent)
	      emitter.attachEvent("on" + type, f);
	    else {
	      var map = emitter._handlers || (emitter._handlers = {});
	      var arr = map[type] || (map[type] = []);
	      arr.push(f);
	    }
	  };
	
	  var noHandlers = []
	  function getHandlers(emitter, type, copy) {
	    var arr = emitter._handlers && emitter._handlers[type]
	    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers
	    else return arr || noHandlers
	  }
	
	  var off = CodeMirror.off = function(emitter, type, f) {
	    if (emitter.removeEventListener)
	      emitter.removeEventListener(type, f, false);
	    else if (emitter.detachEvent)
	      emitter.detachEvent("on" + type, f);
	    else {
	      var handlers = getHandlers(emitter, type, false)
	      for (var i = 0; i < handlers.length; ++i)
	        if (handlers[i] == f) { handlers.splice(i, 1); break; }
	    }
	  };
	
	  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
	    var handlers = getHandlers(emitter, type, true)
	    if (!handlers.length) return;
	    var args = Array.prototype.slice.call(arguments, 2);
	    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
	  };
	
	  var orphanDelayedCallbacks = null;
	
	  // Often, we want to signal events at a point where we are in the
	  // middle of some work, but don't want the handler to start calling
	  // other methods on the editor, which might be in an inconsistent
	  // state or simply not expect any other events to happen.
	  // signalLater looks whether there are any handlers, and schedules
	  // them to be executed when the last operation ends, or, if no
	  // operation is active, when a timeout fires.
	  function signalLater(emitter, type /*, values...*/) {
	    var arr = getHandlers(emitter, type, false)
	    if (!arr.length) return;
	    var args = Array.prototype.slice.call(arguments, 2), list;
	    if (operationGroup) {
	      list = operationGroup.delayedCallbacks;
	    } else if (orphanDelayedCallbacks) {
	      list = orphanDelayedCallbacks;
	    } else {
	      list = orphanDelayedCallbacks = [];
	      setTimeout(fireOrphanDelayed, 0);
	    }
	    function bnd(f) {return function(){f.apply(null, args);};};
	    for (var i = 0; i < arr.length; ++i)
	      list.push(bnd(arr[i]));
	  }
	
	  function fireOrphanDelayed() {
	    var delayed = orphanDelayedCallbacks;
	    orphanDelayedCallbacks = null;
	    for (var i = 0; i < delayed.length; ++i) delayed[i]();
	  }
	
	  // The DOM events that CodeMirror handles can be overridden by
	  // registering a (non-DOM) handler on the editor for the event name,
	  // and preventDefault-ing the event in that handler.
	  function signalDOMEvent(cm, e, override) {
	    if (typeof e == "string")
	      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};
	    signal(cm, override || e.type, cm, e);
	    return e_defaultPrevented(e) || e.codemirrorIgnore;
	  }
	
	  function signalCursorActivity(cm) {
	    var arr = cm._handlers && cm._handlers.cursorActivity;
	    if (!arr) return;
	    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
	      set.push(arr[i]);
	  }
	
	  function hasHandler(emitter, type) {
	    return getHandlers(emitter, type).length > 0
	  }
	
	  // Add on and off methods to a constructor's prototype, to make
	  // registering events on such objects more convenient.
	  function eventMixin(ctor) {
	    ctor.prototype.on = function(type, f) {on(this, type, f);};
	    ctor.prototype.off = function(type, f) {off(this, type, f);};
	  }
	
	  // MISC UTILITIES
	
	  // Number of pixels added to scroller and sizer to hide scrollbar
	  var scrollerGap = 30;
	
	  // Returned or thrown by various protocols to signal 'I'm not
	  // handling this'.
	  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};
	
	  // Reused option objects for setSelection & friends
	  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};
	
	  function Delayed() {this.id = null;}
	  Delayed.prototype.set = function(ms, f) {
	    clearTimeout(this.id);
	    this.id = setTimeout(f, ms);
	  };
	
	  // Counts the column offset in a string, taking tabs into account.
	  // Used mostly to find indentation.
	  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
	    if (end == null) {
	      end = string.search(/[^\s\u00a0]/);
	      if (end == -1) end = string.length;
	    }
	    for (var i = startIndex || 0, n = startValue || 0;;) {
	      var nextTab = string.indexOf("\t", i);
	      if (nextTab < 0 || nextTab >= end)
	        return n + (end - i);
	      n += nextTab - i;
	      n += tabSize - (n % tabSize);
	      i = nextTab + 1;
	    }
	  };
	
	  // The inverse of countColumn -- find the offset that corresponds to
	  // a particular column.
	  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {
	    for (var pos = 0, col = 0;;) {
	      var nextTab = string.indexOf("\t", pos);
	      if (nextTab == -1) nextTab = string.length;
	      var skipped = nextTab - pos;
	      if (nextTab == string.length || col + skipped >= goal)
	        return pos + Math.min(skipped, goal - col);
	      col += nextTab - pos;
	      col += tabSize - (col % tabSize);
	      pos = nextTab + 1;
	      if (col >= goal) return pos;
	    }
	  }
	
	  var spaceStrs = [""];
	  function spaceStr(n) {
	    while (spaceStrs.length <= n)
	      spaceStrs.push(lst(spaceStrs) + " ");
	    return spaceStrs[n];
	  }
	
	  function lst(arr) { return arr[arr.length-1]; }
	
	  var selectInput = function(node) { node.select(); };
	  if (ios) // Mobile Safari apparently has a bug where select() is broken.
	    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
	  else if (ie) // Suppress mysterious IE10 errors
	    selectInput = function(node) { try { node.select(); } catch(_e) {} };
	
	  function indexOf(array, elt) {
	    for (var i = 0; i < array.length; ++i)
	      if (array[i] == elt) return i;
	    return -1;
	  }
	  function map(array, f) {
	    var out = [];
	    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
	    return out;
	  }
	
	  function nothing() {}
	
	  function createObj(base, props) {
	    var inst;
	    if (Object.create) {
	      inst = Object.create(base);
	    } else {
	      nothing.prototype = base;
	      inst = new nothing();
	    }
	    if (props) copyObj(props, inst);
	    return inst;
	  };
	
	  function copyObj(obj, target, overwrite) {
	    if (!target) target = {};
	    for (var prop in obj)
	      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	        target[prop] = obj[prop];
	    return target;
	  }
	
	  function bind(f) {
	    var args = Array.prototype.slice.call(arguments, 1);
	    return function(){return f.apply(null, args);};
	  }
	
	  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {
	    return /\w/.test(ch) || ch > "\x80" &&
	      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
	  };
	  function isWordChar(ch, helper) {
	    if (!helper) return isWordCharBasic(ch);
	    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) return true;
	    return helper.test(ch);
	  }
	
	  function isEmpty(obj) {
	    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
	    return true;
	  }
	
	  // Extending unicode characters. A series of a non-extending char +
	  // any number of extending chars is treated as a single unit as far
	  // as editing and measuring is concerned. This is not fully correct,
	  // since some scripts/fonts/browsers also treat other configurations
	  // of code points as a group.
	  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }
	
	  // DOM UTILITIES
	
	  function elt(tag, content, className, style) {
	    var e = document.createElement(tag);
	    if (className) e.className = className;
	    if (style) e.style.cssText = style;
	    if (typeof content == "string") e.appendChild(document.createTextNode(content));
	    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
	    return e;
	  }
	
	  var range;
	  if (document.createRange) range = function(node, start, end, endNode) {
	    var r = document.createRange();
	    r.setEnd(endNode || node, end);
	    r.setStart(node, start);
	    return r;
	  };
	  else range = function(node, start, end) {
	    var r = document.body.createTextRange();
	    try { r.moveToElementText(node.parentNode); }
	    catch(e) { return r; }
	    r.collapse(true);
	    r.moveEnd("character", end);
	    r.moveStart("character", start);
	    return r;
	  };
	
	  function removeChildren(e) {
	    for (var count = e.childNodes.length; count > 0; --count)
	      e.removeChild(e.firstChild);
	    return e;
	  }
	
	  function removeChildrenAndAdd(parent, e) {
	    return removeChildren(parent).appendChild(e);
	  }
	
	  var contains = CodeMirror.contains = function(parent, child) {
	    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	      child = child.parentNode;
	    if (parent.contains)
	      return parent.contains(child);
	    do {
	      if (child.nodeType == 11) child = child.host;
	      if (child == parent) return true;
	    } while (child = child.parentNode);
	  };
	
	  function activeElt() {
	    var activeElement = document.activeElement;
	    while (activeElement && activeElement.root && activeElement.root.activeElement)
	      activeElement = activeElement.root.activeElement;
	    return activeElement;
	  }
	  // Older versions of IE throws unspecified error when touching
	  // document.activeElement in some cases (during loading, in iframe)
	  if (ie && ie_version < 11) activeElt = function() {
	    try { return document.activeElement; }
	    catch(e) { return document.body; }
	  };
	
	  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*"); }
	  var rmClass = CodeMirror.rmClass = function(node, cls) {
	    var current = node.className;
	    var match = classTest(cls).exec(current);
	    if (match) {
	      var after = current.slice(match.index + match[0].length);
	      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	    }
	  };
	  var addClass = CodeMirror.addClass = function(node, cls) {
	    var current = node.className;
	    if (!classTest(cls).test(current)) node.className += (current ? " " : "") + cls;
	  };
	  function joinClasses(a, b) {
	    var as = a.split(" ");
	    for (var i = 0; i < as.length; i++)
	      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
	    return b;
	  }
	
	  // WINDOW-WIDE EVENTS
	
	  // These must be handled carefully, because naively registering a
	  // handler for each editor will cause the editors to never be
	  // garbage collected.
	
	  function forEachCodeMirror(f) {
	    if (!document.body.getElementsByClassName) return;
	    var byClass = document.body.getElementsByClassName("CodeMirror");
	    for (var i = 0; i < byClass.length; i++) {
	      var cm = byClass[i].CodeMirror;
	      if (cm) f(cm);
	    }
	  }
	
	  var globalsRegistered = false;
	  function ensureGlobalHandlers() {
	    if (globalsRegistered) return;
	    registerGlobalHandlers();
	    globalsRegistered = true;
	  }
	  function registerGlobalHandlers() {
	    // When the window resizes, we need to refresh active editors.
	    var resizeTimer;
	    on(window, "resize", function() {
	      if (resizeTimer == null) resizeTimer = setTimeout(function() {
	        resizeTimer = null;
	        forEachCodeMirror(onResize);
	      }, 100);
	    });
	    // When the window loses focus, we want to show the editor as blurred
	    on(window, "blur", function() {
	      forEachCodeMirror(onBlur);
	    });
	  }
	
	  // FEATURE DETECTION
	
	  // Detect drag-and-drop
	  var dragAndDrop = function() {
	    // There is *some* kind of drag-and-drop support in IE6-8, but I
	    // couldn't get it to work yet.
	    if (ie && ie_version < 9) return false;
	    var div = elt('div');
	    return "draggable" in div || "dragDrop" in div;
	  }();
	
	  var zwspSupported;
	  function zeroWidthElement(measure) {
	    if (zwspSupported == null) {
	      var test = elt("span", "\u200b");
	      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	      if (measure.firstChild.offsetHeight != 0)
	        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
	    }
	    var node = zwspSupported ? elt("span", "\u200b") :
	      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	    node.setAttribute("cm-text", "");
	    return node;
	  }
	
	  // Feature-detect IE's crummy client rect reporting for bidi text
	  var badBidiRects;
	  function hasBadBidiRects(measure) {
	    if (badBidiRects != null) return badBidiRects;
	    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	    var r0 = range(txt, 0, 1).getBoundingClientRect();
	    var r1 = range(txt, 1, 2).getBoundingClientRect();
	    removeChildren(measure);
	    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)
	    return badBidiRects = (r1.right - r0.right < 3);
	  }
	
	  // See if "".split is the broken IE version, if so, provide an
	  // alternative way to split lines.
	  var splitLinesAuto = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
	    var pos = 0, result = [], l = string.length;
	    while (pos <= l) {
	      var nl = string.indexOf("\n", pos);
	      if (nl == -1) nl = string.length;
	      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	      var rt = line.indexOf("\r");
	      if (rt != -1) {
	        result.push(line.slice(0, rt));
	        pos += rt + 1;
	      } else {
	        result.push(line);
	        pos = nl + 1;
	      }
	    }
	    return result;
	  } : function(string){return string.split(/\r\n?|\n/);};
	
	  var hasSelection = window.getSelection ? function(te) {
	    try { return te.selectionStart != te.selectionEnd; }
	    catch(e) { return false; }
	  } : function(te) {
	    try {var range = te.ownerDocument.selection.createRange();}
	    catch(e) {}
	    if (!range || range.parentElement() != te) return false;
	    return range.compareEndPoints("StartToEnd", range) != 0;
	  };
	
	  var hasCopyEvent = (function() {
	    var e = elt("div");
	    if ("oncopy" in e) return true;
	    e.setAttribute("oncopy", "return;");
	    return typeof e.oncopy == "function";
	  })();
	
	  var badZoomedRects = null;
	  function hasBadZoomedRects(measure) {
	    if (badZoomedRects != null) return badZoomedRects;
	    var node = removeChildrenAndAdd(measure, elt("span", "x"));
	    var normal = node.getBoundingClientRect();
	    var fromRange = range(node, 0, 1).getBoundingClientRect();
	    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
	  }
	
	  // KEY NAMES
	
	  var keyNames = CodeMirror.keyNames = {
	    3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
	    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	  };
	  (function() {
	    // Number keys
	    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
	    // Alphabetic keys
	    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
	    // Function keys
	    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
	  })();
	
	  // BIDI HELPERS
	
	  function iterateBidiSections(order, from, to, f) {
	    if (!order) return f(from, to, "ltr");
	    var found = false;
	    for (var i = 0; i < order.length; ++i) {
	      var part = order[i];
	      if (part.from < to && part.to > from || from == to && part.to == from) {
	        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
	        found = true;
	      }
	    }
	    if (!found) f(from, to, "ltr");
	  }
	
	  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
	  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }
	
	  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
	  function lineRight(line) {
	    var order = getOrder(line);
	    if (!order) return line.text.length;
	    return bidiRight(lst(order));
	  }
	
	  function lineStart(cm, lineN) {
	    var line = getLine(cm.doc, lineN);
	    var visual = visualLine(line);
	    if (visual != line) lineN = lineNo(visual);
	    var order = getOrder(visual);
	    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
	    return Pos(lineN, ch);
	  }
	  function lineEnd(cm, lineN) {
	    var merged, line = getLine(cm.doc, lineN);
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line;
	      lineN = null;
	    }
	    var order = getOrder(line);
	    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
	    return Pos(lineN == null ? lineNo(line) : lineN, ch);
	  }
	  function lineStartSmart(cm, pos) {
	    var start = lineStart(cm, pos.line);
	    var line = getLine(cm.doc, start.line);
	    var order = getOrder(line);
	    if (!order || order[0].level == 0) {
	      var firstNonWS = Math.max(0, line.text.search(/\S/));
	      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	      return Pos(start.line, inWS ? 0 : firstNonWS);
	    }
	    return start;
	  }
	
	  function compareBidiLevel(order, a, b) {
	    var linedir = order[0].level;
	    if (a == linedir) return true;
	    if (b == linedir) return false;
	    return a < b;
	  }
	  var bidiOther;
	  function getBidiPartAt(order, pos) {
	    bidiOther = null;
	    for (var i = 0, found; i < order.length; ++i) {
	      var cur = order[i];
	      if (cur.from < pos && cur.to > pos) return i;
	      if ((cur.from == pos || cur.to == pos)) {
	        if (found == null) {
	          found = i;
	        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
	          if (cur.from != cur.to) bidiOther = found;
	          return i;
	        } else {
	          if (cur.from != cur.to) bidiOther = i;
	          return found;
	        }
	      }
	    }
	    return found;
	  }
	
	  function moveInLine(line, pos, dir, byUnit) {
	    if (!byUnit) return pos + dir;
	    do pos += dir;
	    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
	    return pos;
	  }
	
	  // This is needed in order to move 'visually' through bi-directional
	  // text -- i.e., pressing left should make the cursor go left, even
	  // when in RTL text. The tricky part is the 'jumps', where RTL and
	  // LTR text touch each other. This often requires the cursor offset
	  // to move more than one unit, in order to visually move one unit.
	  function moveVisually(line, start, dir, byUnit) {
	    var bidi = getOrder(line);
	    if (!bidi) return moveLogically(line, start, dir, byUnit);
	    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
	    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
	
	    for (;;) {
	      if (target > part.from && target < part.to) return target;
	      if (target == part.from || target == part.to) {
	        if (getBidiPartAt(bidi, target) == pos) return target;
	        part = bidi[pos += dir];
	        return (dir > 0) == part.level % 2 ? part.to : part.from;
	      } else {
	        part = bidi[pos += dir];
	        if (!part) return null;
	        if ((dir > 0) == part.level % 2)
	          target = moveInLine(line, part.to, -1, byUnit);
	        else
	          target = moveInLine(line, part.from, 1, byUnit);
	      }
	    }
	  }
	
	  function moveLogically(line, start, dir, byUnit) {
	    var target = start + dir;
	    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
	    return target < 0 || target > line.text.length ? null : target;
	  }
	
	  // Bidirectional ordering algorithm
	  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	  // that this (partially) implements.
	
	  // One-char codes used for character types:
	  // L (L):   Left-to-Right
	  // R (R):   Right-to-Left
	  // r (AL):  Right-to-Left Arabic
	  // 1 (EN):  European Number
	  // + (ES):  European Number Separator
	  // % (ET):  European Number Terminator
	  // n (AN):  Arabic Number
	  // , (CS):  Common Number Separator
	  // m (NSM): Non-Spacing Mark
	  // b (BN):  Boundary Neutral
	  // s (B):   Paragraph Separator
	  // t (S):   Segment Separator
	  // w (WS):  Whitespace
	  // N (ON):  Other Neutrals
	
	  // Returns null if characters are ordered as they appear
	  // (left-to-right), or an array of sections ({from, to, level}
	  // objects) in the order in which they occur visually.
	  var bidiOrdering = (function() {
	    // Character types for codepoints 0 to 0xff
	    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	    // Character types for codepoints 0x600 to 0x6ff
	    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
	    function charType(code) {
	      if (code <= 0xf7) return lowTypes.charAt(code);
	      else if (0x590 <= code && code <= 0x5f4) return "R";
	      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
	      else if (0x6ee <= code && code <= 0x8ac) return "r";
	      else if (0x2000 <= code && code <= 0x200b) return "w";
	      else if (code == 0x200c) return "b";
	      else return "L";
	    }
	
	    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
	    // Browsers seem to always treat the boundaries of block elements as being L.
	    var outerType = "L";
	
	    function BidiSpan(level, from, to) {
	      this.level = level;
	      this.from = from; this.to = to;
	    }
	
	    return function(str) {
	      if (!bidiRE.test(str)) return false;
	      var len = str.length, types = [];
	      for (var i = 0, type; i < len; ++i)
	        types.push(type = charType(str.charCodeAt(i)));
	
	      // W1. Examine each non-spacing mark (NSM) in the level run, and
	      // change the type of the NSM to the type of the previous
	      // character. If the NSM is at the start of the level run, it will
	      // get the type of sor.
	      for (var i = 0, prev = outerType; i < len; ++i) {
	        var type = types[i];
	        if (type == "m") types[i] = prev;
	        else prev = type;
	      }
	
	      // W2. Search backwards from each instance of a European number
	      // until the first strong type (R, L, AL, or sor) is found. If an
	      // AL is found, change the type of the European number to Arabic
	      // number.
	      // W3. Change all ALs to R.
	      for (var i = 0, cur = outerType; i < len; ++i) {
	        var type = types[i];
	        if (type == "1" && cur == "r") types[i] = "n";
	        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
	      }
	
	      // W4. A single European separator between two European numbers
	      // changes to a European number. A single common separator between
	      // two numbers of the same type changes to that type.
	      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
	        var type = types[i];
	        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
	        else if (type == "," && prev == types[i+1] &&
	                 (prev == "1" || prev == "n")) types[i] = prev;
	        prev = type;
	      }
	
	      // W5. A sequence of European terminators adjacent to European
	      // numbers changes to all European numbers.
	      // W6. Otherwise, separators and terminators change to Other
	      // Neutral.
	      for (var i = 0; i < len; ++i) {
	        var type = types[i];
	        if (type == ",") types[i] = "N";
	        else if (type == "%") {
	          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
	          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	          for (var j = i; j < end; ++j) types[j] = replace;
	          i = end - 1;
	        }
	      }
	
	      // W7. Search backwards from each instance of a European number
	      // until the first strong type (R, L, or sor) is found. If an L is
	      // found, then change the type of the European number to L.
	      for (var i = 0, cur = outerType; i < len; ++i) {
	        var type = types[i];
	        if (cur == "L" && type == "1") types[i] = "L";
	        else if (isStrong.test(type)) cur = type;
	      }
	
	      // N1. A sequence of neutrals takes the direction of the
	      // surrounding strong text if the text on both sides has the same
	      // direction. European and Arabic numbers act as if they were R in
	      // terms of their influence on neutrals. Start-of-level-run (sor)
	      // and end-of-level-run (eor) are used at level run boundaries.
	      // N2. Any remaining neutrals take the embedding direction.
	      for (var i = 0; i < len; ++i) {
	        if (isNeutral.test(types[i])) {
	          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
	          var before = (i ? types[i-1] : outerType) == "L";
	          var after = (end < len ? types[end] : outerType) == "L";
	          var replace = before || after ? "L" : "R";
	          for (var j = i; j < end; ++j) types[j] = replace;
	          i = end - 1;
	        }
	      }
	
	      // Here we depart from the documented algorithm, in order to avoid
	      // building up an actual levels array. Since there are only three
	      // levels (0, 1, 2) in an implementation that doesn't take
	      // explicit embedding into account, we can build up the order on
	      // the fly, without following the level-based algorithm.
	      var order = [], m;
	      for (var i = 0; i < len;) {
	        if (countsAsLeft.test(types[i])) {
	          var start = i;
	          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
	          order.push(new BidiSpan(0, start, i));
	        } else {
	          var pos = i, at = order.length;
	          for (++i; i < len && types[i] != "L"; ++i) {}
	          for (var j = pos; j < i;) {
	            if (countsAsNum.test(types[j])) {
	              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
	              var nstart = j;
	              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
	              order.splice(at, 0, new BidiSpan(2, nstart, j));
	              pos = j;
	            } else ++j;
	          }
	          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
	        }
	      }
	      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	        order[0].from = m[0].length;
	        order.unshift(new BidiSpan(0, 0, m[0].length));
	      }
	      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	        lst(order).to -= m[0].length;
	        order.push(new BidiSpan(0, len - m[0].length, len));
	      }
	      if (order[0].level == 2)
	        order.unshift(new BidiSpan(1, order[0].to, order[0].to));
	      if (order[0].level != lst(order).level)
	        order.push(new BidiSpan(order[0].level, len, len));
	
	      return order;
	    };
	  })();
	
	  // THE END
	
	  CodeMirror.version = "5.17.0";
	
	  return CodeMirror;
	});
	
})
/** END DEFINE BLOCK for codemirror@5.17.0/lib/codemirror.js **/


/** START DEFINE BLOCK for codemirror@5.17.0/mode/meta.js **/
jupyter.define('codemirror@5.17.0/mode/meta.js', function (module, exports, __jupyter_require__) {
	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__jupyter_require__('codemirror@5.17.0/lib/codemirror.js'));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  CodeMirror.modeInfo = [
	    {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
	    {name: "PGP", mimes: ["application/pgp", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["pgp"]},
	    {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
	    {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
	    {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
	    {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h"]},
	    {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
	    {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]},
	    {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"]},
	    {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
	    {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
	    {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
	    {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/},
	    {name: "CoffeeScript", mime: "text/x-coffeescript", mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
	    {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
	    {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
	    {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
	    {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
	    {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
	    {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
	    {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
	    {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
	    {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
	    {name: "Django", mime: "text/x-django", mode: "django"},
	    {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
	    {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
	    {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
	    {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
	    {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
	    {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
	    {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
	    {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
	    {name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
	    {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
	    {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
	    {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
	    {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
	    {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
	    {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"]},
	    {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
	    {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
	    {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
	    {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i},
	    {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
	    {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"]},
	    {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
	    {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
	    {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
	    {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
	    {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
	    {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
	    {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm"], alias: ["xhtml"]},
	    {name: "HTTP", mime: "message/http", mode: "http"},
	    {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
	    {name: "Jade", mime: "text/x-jade", mode: "jade", ext: ["jade"]},
	    {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
	    {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
	    {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
	     mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
	    {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
	    {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
	    {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
	    {name: "Jinja2", mime: "null", mode: "jinja2"},
	    {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]},
	    {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
	    {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
	    {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
	    {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
	    {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
	    {name: "mIRC", mime: "text/mirc", mode: "mirc"},
	    {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
	    {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"]},
	    {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
	    {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
	    {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
	    {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
	    {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
	    {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
	    {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
	    {name: "NTriples", mime: "text/n-triples", mode: "ntriples", ext: ["nt"]},
	    {name: "Objective C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"]},
	    {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
	    {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
	    {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
	    {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
	    {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
	    {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
	    {name: "PHP", mime: "application/x-httpd-php", mode: "php", ext: ["php", "php3", "php4", "php5", "phtml"]},
	    {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
	    {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
	    {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
	    {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
	    {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
	    {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
	    {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
	    {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
	    {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
	    {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r"], alias: ["rscript"]},
	    {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
	    {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
	    {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
	    {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
	    {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
	    {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
	    {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
	    {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
	    {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
	    {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
	    {name: "Shell", mime: "text/x-sh", mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
	    {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
	    {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
	    {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
	    {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
	    {name: "Solr", mime: "text/x-solr", mode: "solr"},
	    {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
	    {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
	    {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
	    {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
	    {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
	    {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
	    {name: "sTeX", mime: "text/x-stex", mode: "stex"},
	    {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx"], alias: ["tex"]},
	    {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v"]},
	    {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
	    {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
	    {name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
	    {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
	    {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
	    {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
	    {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
	    {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
	    {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
	    {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
	    {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
	    {name: "Twig", mime: "text/x-twig", mode: "twig"},
	    {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
	    {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
	    {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
	    {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
	    {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
	    {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
	    {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd"], alias: ["rss", "wsdl", "xsd"]},
	    {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
	    {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
	    {name: "YAML", mime: "text/x-yaml", mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
	    {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
	    {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
	    {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
	    {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]}
	  ];
	  // Ensure all modes have a mime property for backwards compatibility
	  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	    var info = CodeMirror.modeInfo[i];
	    if (info.mimes) info.mime = info.mimes[0];
	  }
	
	  CodeMirror.findModeByMIME = function(mime) {
	    mime = mime.toLowerCase();
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.mime == mime) return info;
	      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
	        if (info.mimes[j] == mime) return info;
	    }
	  };
	
	  CodeMirror.findModeByExtension = function(ext) {
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.ext) for (var j = 0; j < info.ext.length; j++)
	        if (info.ext[j] == ext) return info;
	    }
	  };
	
	  CodeMirror.findModeByFileName = function(filename) {
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.file && info.file.test(filename)) return info;
	    }
	    var dot = filename.lastIndexOf(".");
	    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
	    if (ext) return CodeMirror.findModeByExtension(ext);
	  };
	
	  CodeMirror.findModeByName = function(name) {
	    name = name.toLowerCase();
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.name.toLowerCase() == name) return info;
	      if (info.alias) for (var j = 0; j < info.alias.length; j++)
	        if (info.alias[j].toLowerCase() == name) return info;
	    }
	  };
	});
	
})
/** END DEFINE BLOCK for codemirror@5.17.0/mode/meta.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/core/signaling.js **/
jupyter.define('phosphor@0.6.1/lib/core/signaling.js', function (module, exports, __jupyter_require__) {
	/* WEBPACK VAR INJECTION */(function(setImmediate) {/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	"use strict";
	/**
	 * Define a signal property on a prototype object.
	 *
	 * @param target - The prototype for the class of interest.
	 *
	 * @param name - The name of the signal property.
	 *
	 * #### Notes
	 * The defined signal property is read-only.
	 *
	 * #### Example
	 * ```typescript
	 * class SomeClass {
	 *   valueChanged: ISignal<SomeClass, number>;
	 * }
	 *
	 * defineSignal(SomeClass.prototype, 'valueChanged');
	 */
	function defineSignal(target, name) {
	    var token = Object.freeze({});
	    Object.defineProperty(target, name, {
	        get: function () { return new Signal(this, token); }
	    });
	}
	exports.defineSignal = defineSignal;
	/**
	 * Remove all connections where the given object is the sender.
	 *
	 * @param sender - The sender object of interest.
	 *
	 * #### Example
	 * ```typescript
	 * disconnectSender(someObject);
	 * ```
	 */
	function disconnectSender(sender) {
	    // If there are no receivers, there is nothing to do.
	    var receiverList = senderData.get(sender);
	    if (receiverList === void 0) {
	        return;
	    }
	    // Clear the connections and schedule a cleanup of the
	    // receiver's corresponding list of sender connections.
	    for (var i = 0, n = receiverList.length; i < n; ++i) {
	        var conn = receiverList[i];
	        var senderList = receiverData.get(conn.thisArg || conn.slot);
	        scheduleCleanup(senderList);
	        conn.token = null;
	    }
	    // Schedule a cleanup of the receiver list.
	    scheduleCleanup(receiverList);
	}
	exports.disconnectSender = disconnectSender;
	/**
	 * Remove all connections where the given object is the receiver.
	 *
	 * @param receiver - The receiver object of interest.
	 *
	 * #### Notes
	 * If a `thisArg` is provided when connecting a signal, that object
	 * is considered the receiver. Otherwise, the `callback` is used as
	 * the receiver.
	 *
	 * #### Example
	 * ```typescript
	 * // disconnect a regular object receiver
	 * disconnectReceiver(myObject);
	 *
	 * // disconnect a plain callback receiver
	 * disconnectReceiver(myCallback);
	 * ```
	 */
	function disconnectReceiver(receiver) {
	    // If there are no senders, there is nothing to do.
	    var senderList = receiverData.get(receiver);
	    if (senderList === void 0) {
	        return;
	    }
	    // Clear the connections and schedule a cleanup of the
	    // senders's corresponding list of receiver connections.
	    for (var i = 0, n = senderList.length; i < n; ++i) {
	        var conn = senderList[i];
	        var receiverList = senderData.get(conn.sender);
	        scheduleCleanup(receiverList);
	        conn.token = null;
	    }
	    // Schedule a cleanup of the sender list.
	    scheduleCleanup(senderList);
	}
	exports.disconnectReceiver = disconnectReceiver;
	/**
	 * Clear all signal data associated with the given object.
	 *
	 * @param obj - The object for which the signal data should be cleared.
	 *
	 * #### Notes
	 * This removes all signal connections where the object is used as
	 * either the sender or the receiver.
	 *
	 * #### Example
	 * ```typescript
	 * clearSignalData(someObject);
	 * ```
	 */
	function clearSignalData(obj) {
	    disconnectSender(obj);
	    disconnectReceiver(obj);
	}
	exports.clearSignalData = clearSignalData;
	/**
	 * A concrete implementation of `ISignal`.
	 */
	var Signal = (function () {
	    /**
	     * Construct a new signal.
	     *
	     * @param sender - The object which owns the signal.
	     *
	     * @param token - The unique token identifying the signal.
	     */
	    function Signal(sender, token) {
	        this._sender = sender;
	        this._token = token;
	    }
	    /**
	     * Connect a slot to the signal.
	     *
	     * @param slot - The slot to invoke when the signal is emitted.
	     *
	     * @param thisArg - The `this` context for the slot. If provided,
	     *   this must be a non-primitive object.
	     *
	     * @returns `true` if the connection succeeds, `false` otherwise.
	     */
	    Signal.prototype.connect = function (slot, thisArg) {
	        return connect(this._sender, this._token, slot, thisArg);
	    };
	    /**
	     * Disconnect a slot from the signal.
	     *
	     * @param slot - The slot to disconnect from the signal.
	     *
	     * @param thisArg - The `this` context for the slot. If provided,
	     *   this must be a non-primitive object.
	     *
	     * @returns `true` if the connection is removed, `false` otherwise.
	     */
	    Signal.prototype.disconnect = function (slot, thisArg) {
	        return disconnect(this._sender, this._token, slot, thisArg);
	    };
	    /**
	     * Emit the signal and invoke the connected slots.
	     *
	     * @param args - The args to pass to the connected slots.
	     */
	    Signal.prototype.emit = function (args) {
	        emit(this._sender, this._token, args);
	    };
	    return Signal;
	}());
	/**
	 * A weak mapping of sender to list of receiver connections.
	 */
	var senderData = new WeakMap();
	/**
	 * A weak mapping of receiver to list of sender connections.
	 */
	var receiverData = new WeakMap();
	/**
	 * A set of connection lists which are pending cleanup.
	 */
	var dirtySet = new Set();
	/**
	 * A local reference to an event loop callback.
	 */
	var defer = (function () {
	    var ok = typeof requestAnimationFrame === 'function';
	    return ok ? requestAnimationFrame : setImmediate;
	})();
	/**
	 * Connect a slot to a signal.
	 *
	 * @param sender - The object emitting the signal.
	 *
	 * @param token - The unique token for the signal.
	 *
	 * @param slot - The slot to connect to the signal.
	 *
	 * @param thisArg - The `this` context for the slot.
	 *
	 * @returns `true` if the connection succeeds, `false` otherwise.
	 *
	 * #### Notes
	 * Signal connections are unique. If a connection already exists for
	 * the given `slot` and `thisArg`, this function returns `false`.
	 *
	 * A newly connected slot will not be invoked until the next time the
	 * signal is emitted, even if the slot is connected while the signal
	 * is dispatching.
	 */
	function connect(sender, token, slot, thisArg) {
	    // Coerce a `null` thisArg to `undefined`.
	    thisArg = thisArg || void 0;
	    // Ensure the sender's receiver list is created.
	    var receiverList = senderData.get(sender);
	    if (receiverList === void 0) {
	        receiverList = [];
	        senderData.set(sender, receiverList);
	    }
	    // Bail if a matching connection already exists.
	    if (findConnection(receiverList, token, slot, thisArg) !== null) {
	        return false;
	    }
	    // Ensure the receiver's sender list is created.
	    var receiver = thisArg || slot;
	    var senderList = receiverData.get(receiver);
	    if (senderList === void 0) {
	        senderList = [];
	        receiverData.set(receiver, senderList);
	    }
	    // Create a new connection and add it to the end of each list.
	    var connection = { sender: sender, token: token, slot: slot, thisArg: thisArg };
	    receiverList.push(connection);
	    senderList.push(connection);
	    // Indicate a successful connection.
	    return true;
	}
	/**
	 * Disconnect a slot from a signal.
	 *
	 * @param sender - The object emitting the signal.
	 *
	 * @param token - The unique token for the signal.
	 *
	 * @param slot - The slot to disconnect from the signal.
	 *
	 * @param thisArg - The `this` context for the slot.
	 *
	 * @returns `true` if the connection is removed, `false` otherwise.
	 *
	 * #### Notes
	 * If no connection exists for the given `slot` and `thisArg`, this
	 * function returns `false`.
	 *
	 * A disconnected slot will no longer be invoked, even if the slot
	 * is disconnected while the signal is dispatching.
	 */
	function disconnect(sender, token, slot, thisArg) {
	    // Coerce a `null` thisArg to `undefined`.
	    thisArg = thisArg || void 0;
	    // Lookup the list of receivers, and bail if none exist.
	    var receiverList = senderData.get(sender);
	    if (receiverList === void 0) {
	        return false;
	    }
	    // Bail if no matching connection exits.
	    var conn = findConnection(receiverList, token, slot, thisArg);
	    if (conn === null) {
	        return false;
	    }
	    // Lookup the list of senders, which is now known to exist.
	    var senderList = receiverData.get(thisArg || slot);
	    // Clear the connection and schedule list cleanup.
	    conn.token = null;
	    scheduleCleanup(receiverList);
	    scheduleCleanup(senderList);
	    // Indicate a successful disconnection.
	    return true;
	}
	/**
	 * Emit a signal and invoke the connected slots.
	 *
	 * @param sender - The object emitting the signal.
	 *
	 * @param token - The unique token for the signal.
	 *
	 * @param args - The args to pass to the connected slots.
	 *
	 * #### Notes
	 * Connected slots are invoked synchronously, in the order in which
	 * they are connected.
	 *
	 * Exceptions thrown by connected slots will be caught and logged.
	 */
	function emit(sender, token, args) {
	    // If there are no receivers, there is nothing to do.
	    var receiverList = senderData.get(sender);
	    if (receiverList === void 0) {
	        return;
	    }
	    // Invoke the connections which match the given token.
	    for (var i = 0, n = receiverList.length; i < n; ++i) {
	        var conn = receiverList[i];
	        if (conn.token === token) {
	            invokeSlot(conn, args);
	        }
	    }
	}
	/**
	 * Safely invoke a non-empty connection.
	 *
	 * @param conn - The connection of interest
	 *
	 * @param args - The arguments to pass to the slot.
	 *
	 * #### Notes
	 * Any exception thrown by the slot will be caught and logged.
	 */
	function invokeSlot(conn, args) {
	    try {
	        conn.slot.call(conn.thisArg, conn.sender, args);
	    }
	    catch (err) {
	        console.error(err);
	    }
	}
	/**
	 * Find a connection which matches the given parameters.
	 *
	 * @param list - The list of connections to search.
	 *
	 * @param token - The unique token for the signal.
	 *
	 * @param slot - The slot of interest.
	 *
	 * @param thisArg - The `this` context for the slot.
	 *
	 * @returns The first connection which matches the supplied parameters,
	 *   or null if no matching connection is found.
	 */
	function findConnection(list, token, slot, thisArg) {
	    for (var i = 0, n = list.length; i < n; ++i) {
	        var conn = list[i];
	        if (conn.token === token &&
	            conn.slot === slot &&
	            conn.thisArg === thisArg) {
	            return conn;
	        }
	    }
	    return null;
	}
	/**
	 * Schedule a cleanup of a connection list.
	 *
	 * @param list - The list of connections to cleanup.
	 *
	 * #### Notes
	 * This will add the list to the dirty set and schedule a deferred
	 * cleanup of the list contents. On cleanup, any connection with a
	 * null token will be removed from the array.
	 */
	function scheduleCleanup(list) {
	    if (dirtySet.size === 0) {
	        defer(cleanupDirtySet);
	    }
	    dirtySet.add(list);
	}
	/**
	 * Cleanup the connection lists in the dirty set.
	 *
	 * #### Notes
	 * This function should only be invoked asynchronously, when the stack
	 * frame is guaranteed to not be on the path of a signal dispatch.
	 */
	function cleanupDirtySet() {
	    dirtySet.forEach(cleanupList);
	    dirtySet.clear();
	}
	/**
	 * Cleanup the dirty connections in a connection list.
	 *
	 * @param list - The list of connection to cleanup.
	 *
	 * #### Notes
	 * This will remove any connection with a null token from the list,
	 * while retaining the relative order of the other connections.
	 *
	 * This function should only be invoked asynchronously, when the stack
	 * frame is guaranteed to not be on the path of a signal dispatch.
	 */
	function cleanupList(list) {
	    var count = 0;
	    for (var i = 0, n = list.length; i < n; ++i) {
	        var conn = list[i];
	        if (conn.token === null) {
	            count++;
	        }
	        else {
	            list[i - count] = conn;
	        }
	    }
	    list.length -= count;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __jupyter_require__('timers-browserify@1.4.2/main.js').setImmediate))
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/core/signaling.js **/


/** START DEFINE BLOCK for timers-browserify@1.4.2/main.js **/
jupyter.define('timers-browserify@1.4.2/main.js', function (module, exports, __jupyter_require__) {
	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __jupyter_require__('process@~0.11.0/browser.js').nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __jupyter_require__('timers-browserify@1.4.2/main.js').setImmediate, __jupyter_require__('timers-browserify@1.4.2/main.js').clearImmediate))
})
/** END DEFINE BLOCK for timers-browserify@1.4.2/main.js **/


/** START DEFINE BLOCK for process@0.11.9/browser.js **/
jupyter.define('process@0.11.9/browser.js', function (module, exports, __jupyter_require__) {
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };
	
})
/** END DEFINE BLOCK for process@0.11.9/browser.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/kernelactions.js **/
jupyter.define('jupyterlab@0.4.1/lib/docregistry/kernelactions.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	var dialog_1 = __jupyter_require__('jupyterlab@~0.4.1/lib/dialog/index.js');
	/**
	 * Restart a kernel after presenting a dialog.
	 *
	 * @param kernel - The kernel to restart.
	 *
	 * @param host - The optional host element for the dialog.
	 *
	 * @returns A promise that resolves to `true` the user elects to restart.
	 *
	 * #### Notes
	 * This is a no-op if there is no kernel.
	 */
	function restartKernel(kernel, host) {
	    if (!kernel) {
	        return Promise.resolve(false);
	    }
	    return dialog_1.showDialog({
	        title: 'Restart Kernel?',
	        body: 'Do you want to restart the current kernel? All variables will be lost.'
	    }).then(function (result) {
	        if (result.text === 'OK') {
	            return kernel.restart().then(function () { return true; });
	        }
	        else {
	            return false;
	        }
	    });
	}
	exports.restartKernel = restartKernel;
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/kernelactions.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/dialog/index.js **/
jupyter.define('jupyterlab@0.4.1/lib/dialog/index.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	/**
	 * The class name added to dialog instances.
	 */
	var DIALOG_CLASS = 'jp-Dialog';
	/**
	 * The class name added to dialog content node.
	 */
	var CONTENT_CLASS = 'jp-Dialog-content';
	/**
	 * The class name added to dialog header node.
	 */
	var HEADER_CLASS = 'jp-Dialog-header';
	/**
	 * The class name added to dialog title node.
	 */
	var TITLE_CLASS = 'jp-Dialog-title';
	/**
	 * The class name added to dialog body node.
	 */
	var BODY_CLASS = 'jp-Dialog-body';
	/**
	 * The class name added to a dialog body content node.
	 */
	var BODY_CONTENT_CLASS = 'jp-Dialog-bodyContent';
	/**
	 * The class name added to a dialog content node.
	 */
	var FOOTER_CLASS = 'jp-Dialog-footer';
	/**
	 * The class name added to a dialog button node.
	 */
	var BUTTON_CLASS = 'jp-Dialog-button';
	/**
	 * The class name added to a dialog button icon node.
	 */
	var BUTTON_ICON_CLASS = 'jp-Dialog-buttonIcon';
	/**
	 * The class name added to a dialog button text node.
	 */
	var BUTTON_TEXT_CLASS = 'jp-Dialog-buttonText';
	/*
	 * The class name added to dialog Confirm buttons.
	 */
	var OK_BUTTON_CLASS = 'jp-Dialog-okButton';
	/**
	 * The class name added to dialog Cancel buttons.
	 */
	var CANCEL_BUTTON_CLASS = 'jp-Dialog-cancelButton';
	/**
	 * The class name added to dialog input field wrappers.
	 */
	var INPUT_WRAPPER_CLASS = 'jp-Dialog-inputWrapper';
	/**
	 * The class name added to dialog input fields.
	 */
	var INPUT_CLASS = 'jp-Dialog-input';
	/**
	 * The class name added to dialog select wrappers.
	 */
	var SELECT_WRAPPER_CLASS = 'jp-Dialog-selectWrapper';
	/**
	 * The class name added to dialog select nodes.
	 */
	var SELECT_CLASS = 'jp-Dialog-select';
	/**
	 * A default confirmation button.
	 */
	exports.okButton = {
	    text: 'OK',
	    className: OK_BUTTON_CLASS
	};
	/**
	 * A default cancel button.
	 */
	exports.cancelButton = {
	    text: 'CANCEL',
	    className: CANCEL_BUTTON_CLASS
	};
	/**
	 * Create a dialog and show it.
	 *
	 * @param options - The dialog setup options.
	 *
	 * @returns The button item that was selected.
	 */
	function showDialog(options) {
	    options = options || {};
	    var host = options.host || document.body;
	    options.host = host;
	    options.body = options.body || '';
	    exports.okButton.text = options.okText ? options.okText : 'OK';
	    var buttons = options.buttons || [exports.cancelButton, exports.okButton];
	    var buttonNodes = buttons.map(createButton);
	    var dialog = createDialog(options, buttonNodes);
	    host.appendChild(dialog);
	    // Focus the ok button if given.
	    var index = buttons.indexOf(exports.okButton);
	    if (index !== -1) {
	        buttonNodes[index].focus();
	    }
	    return new Promise(function (resolve, reject) {
	        buttonNodes.map(function (node) {
	            node.addEventListener('click', function (evt) {
	                if (node.contains(evt.target)) {
	                    host.removeChild(dialog);
	                    var button = buttons[buttonNodes.indexOf(node)];
	                    resolve(button);
	                }
	            });
	        });
	        dialog.addEventListener('keydown', function (evt) {
	            // Check for escape key
	            if (evt.keyCode === 27) {
	                host.removeChild(dialog);
	                resolve(exports.cancelButton);
	            }
	        }, true);
	        dialog.addEventListener('contextmenu', function (evt) {
	            evt.preventDefault();
	            evt.stopPropagation();
	        }, true);
	    });
	}
	exports.showDialog = showDialog;
	/**
	 * Create the dialog node.
	 */
	function createDialog(options, buttonNodes) {
	    // Create the dialog nodes (except for the buttons).
	    var node = document.createElement('div');
	    var content = document.createElement('div');
	    var header = document.createElement('div');
	    var body = document.createElement('div');
	    var footer = document.createElement('div');
	    var title = document.createElement('span');
	    node.className = DIALOG_CLASS;
	    content.className = CONTENT_CLASS;
	    header.className = HEADER_CLASS;
	    body.className = BODY_CLASS;
	    footer.className = FOOTER_CLASS;
	    title.className = TITLE_CLASS;
	    node.appendChild(content);
	    content.appendChild(header);
	    content.appendChild(body);
	    content.appendChild(footer);
	    header.appendChild(title);
	    // Populate the nodes.
	    title.textContent = options.title || '';
	    var child;
	    if (typeof options.body === 'string') {
	        child = document.createElement('span');
	        child.innerHTML = options.body;
	    }
	    else if (options.body) {
	        child = options.body;
	        switch (child.tagName) {
	            case 'INPUT':
	                child = wrapInput(child);
	                break;
	            case 'SELECT':
	                child = wrapSelect(child);
	                break;
	            default:
	                child = styleElements(child);
	                break;
	        }
	    }
	    child.classList.add(BODY_CONTENT_CLASS);
	    body.appendChild(child);
	    buttonNodes.map(function (buttonNode) { footer.appendChild(buttonNode); });
	    return node;
	}
	/**
	 * Style the child elements of a parent element.
	 */
	function styleElements(element) {
	    for (var i = 0; i < element.children.length; i++) {
	        var child = element.children[i];
	        var next = child.nextSibling;
	        switch (child.tagName) {
	            case 'INPUT':
	                child = wrapInput(child);
	                element.insertBefore(child, next);
	                break;
	            case 'SELECT':
	                child = wrapSelect(child);
	                element.insertBefore(child, next);
	                break;
	            default:
	                break;
	        }
	    }
	    return element;
	}
	/**
	 * Create a node for a button item.
	 */
	function createButton(item) {
	    var button = document.createElement('button');
	    button.className = BUTTON_CLASS;
	    button.tabIndex = -1;
	    if (item.className) {
	        button.classList.add(item.className);
	    }
	    var icon = document.createElement('span');
	    icon.className = BUTTON_ICON_CLASS;
	    if (item.icon) {
	        icon.classList.add(item.icon);
	    }
	    var text = document.createElement('span');
	    text.className = BUTTON_TEXT_CLASS;
	    text.textContent = item.text;
	    button.appendChild(icon);
	    button.appendChild(text);
	    return button;
	}
	/**
	 * Wrap and style an input node.
	 */
	function wrapInput(input) {
	    var wrapper = document.createElement('div');
	    wrapper.className = INPUT_WRAPPER_CLASS;
	    wrapper.appendChild(input);
	    input.classList.add(INPUT_CLASS);
	    return wrapper;
	}
	/**
	 * Wrap and style a select node.
	 */
	function wrapSelect(select) {
	    var wrapper = document.createElement('div');
	    wrapper.className = SELECT_WRAPPER_CLASS;
	    wrapper.appendChild(select);
	    select.classList.add(SELECT_CLASS);
	    return wrapper;
	}
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/dialog/index.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/kernelselector.js **/
jupyter.define('jupyterlab@0.4.1/lib/docregistry/kernelselector.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	var dialog_1 = __jupyter_require__('jupyterlab@~0.4.1/lib/dialog/index.js');
	/**
	 * Bring up a dialog to select a kernel.
	 */
	function selectKernel(options) {
	    var specs = options.specs, kernel = options.kernel, sessions = options.sessions, preferredLanguage = options.preferredLanguage;
	    // Create the dialog body.
	    var body = document.createElement('div');
	    var text = document.createElement('pre');
	    text.textContent = "Select kernel for\n\"" + options.name + "\"";
	    body.appendChild(text);
	    if (kernel) {
	        var displayName = specs.kernelspecs[kernel.name].spec.display_name;
	        text.textContent += "\nCurrent: " + displayName;
	        text.title = ("Kernel Name: " + displayName + "\n") +
	            ("Kernel Id: " + kernel.id);
	    }
	    var selector = document.createElement('select');
	    body.appendChild(selector);
	    // Get the current sessions, populate the kernels, and show the dialog.
	    populateKernels(selector, { specs: specs, sessions: sessions, preferredLanguage: preferredLanguage });
	    return dialog_1.showDialog({
	        title: 'Select Kernel',
	        body: body,
	        okText: 'SELECT'
	    }).then(function (result) {
	        // Change the kernel if a kernel was selected.
	        if (result.text === 'SELECT') {
	            return JSON.parse(selector.value);
	        }
	        return void 0;
	    });
	}
	exports.selectKernel = selectKernel;
	/**
	 * Change the kernel on a context.
	 */
	function selectKernelForContext(context, host) {
	    return context.listSessions().then(function (sessions) {
	        var options = {
	            name: context.path.split('/').pop(),
	            specs: context.kernelspecs,
	            sessions: sessions,
	            preferredLanguage: context.model.defaultKernelLanguage,
	            kernel: context.kernel.model,
	            host: host
	        };
	        return selectKernel(options);
	    }).then(function (kernel) {
	        if (kernel) {
	            context.changeKernel(kernel);
	        }
	    });
	}
	exports.selectKernelForContext = selectKernelForContext;
	/**
	 * Get the appropriate kernel name.
	 */
	function findKernel(kernelName, language, specs) {
	    if (kernelName === 'unknown') {
	        return specs.default;
	    }
	    // Look for an exact match.
	    for (var specName in specs.kernelspecs) {
	        if (specName === kernelName) {
	            return kernelName;
	        }
	    }
	    // Next try to match the language name.
	    if (language === 'unknown') {
	        return specs.default;
	    }
	    for (var specName in specs.kernelspecs) {
	        var kernelLanguage = specs.kernelspecs[specName].spec.language;
	        if (language === kernelLanguage) {
	            console.log('No exact match found for ' + specName +
	                ', using kernel ' + specName + ' that matches ' +
	                'language=' + language);
	            return specName;
	        }
	    }
	    // Finally, use the default kernel.
	    if (kernelName) {
	        console.log(("No matching kernel found for " + kernelName + ", ") +
	            ("using default kernel " + specs.default));
	    }
	    return specs.default;
	}
	exports.findKernel = findKernel;
	/**
	 * Populate a kernel dropdown list.
	 *
	 * @param node - The host node.
	 *
	 * @param options - The options used to populate the kernels.
	 *
	 * #### Notes
	 * Populates the list with separated sections:
	 *   - Kernels matching the preferred language (display names).
	 *   - "None" signifying no kernel.
	 *   - The remaining kernels.
	 *   - Sessions matching the preferred language (file names).
	 *   - The remaining sessions.
	 * If no preferred language is given or no kernels are found using
	 * the preferred language, the default kernel is used in the first
	 * section.  Kernels are sorted by display name.  Sessions display the
	 * base name of the file with an ellipsis overflow and a tooltip with
	 * the explicit session information.
	 */
	function populateKernels(node, options) {
	    // Clear any existing options.
	    while (node.firstChild) {
	        node.removeChild(node.firstChild);
	    }
	    var maxLength = 10;
	    var preferredKernel = options.preferredKernel, preferredLanguage = options.preferredLanguage, sessions = options.sessions, specs = options.specs;
	    // Create mappings of display names and languages for kernel name.
	    var displayNames = Object.create(null);
	    var languages = Object.create(null);
	    var modes = Object.create(null);
	    for (var name_1 in specs.kernelspecs) {
	        var spec = specs.kernelspecs[name_1].spec;
	        displayNames[name_1] = spec.display_name;
	        maxLength = Math.max(maxLength, displayNames[name_1].length);
	        languages[name_1] = spec.language;
	        modes[name_1] = spec.codemirror_mode;
	    }
	    // Handle a kernel by name.
	    var names = [];
	    if (preferredKernel && preferredKernel in specs.kernelspecs) {
	        names.push(name);
	    }
	    // Handle a preferred kernel language in order of display name.
	    if (preferredLanguage) {
	        for (var name_2 in specs.kernelspecs) {
	            if (languages[name_2] === preferredLanguage ||
	                modes[name_2] === preferredLanguage) {
	                names.push(name_2);
	            }
	        }
	        names.sort(function (a, b) { return displayNames[a].localeCompare(displayNames[b]); });
	        for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
	            var name_3 = names_1[_i];
	            node.appendChild(optionForName(name_3, displayNames[name_3]));
	        }
	    }
	    // Use the default kernel if no preferred language or none were found.
	    if (!names.length) {
	        var name_4 = specs.default;
	        node.appendChild(optionForName(name_4, displayNames[name_4]));
	    }
	    // Add a separator.
	    node.appendChild(createSeparatorOption(maxLength));
	    // Add the option to have no kernel.
	    var option = document.createElement('option');
	    option.text = 'None';
	    option.value = 'null';
	    node.appendChild(option);
	    node.appendChild(createSeparatorOption(maxLength));
	    // Add the rest of the kernel names in alphabetical order.
	    var otherNames = [];
	    for (var name_5 in specs.kernelspecs) {
	        if (names.indexOf(name_5) !== -1) {
	            continue;
	        }
	        otherNames.push(name_5);
	    }
	    otherNames.sort(function (a, b) { return displayNames[a].localeCompare(displayNames[b]); });
	    for (var _a = 0, otherNames_1 = otherNames; _a < otherNames_1.length; _a++) {
	        var name_6 = otherNames_1[_a];
	        node.appendChild(optionForName(name_6, displayNames[name_6]));
	    }
	    // Add a separator option if there were any other names.
	    if (otherNames.length) {
	        node.appendChild(createSeparatorOption(maxLength));
	    }
	    // Add the sessions using the preferred language first.
	    var matchingSessions = [];
	    if (preferredLanguage) {
	        for (var _b = 0, sessions_1 = sessions; _b < sessions_1.length; _b++) {
	            var session = sessions_1[_b];
	            if (languages[session.kernel.name] === preferredLanguage) {
	                matchingSessions.push(session);
	            }
	        }
	        if (matchingSessions) {
	            matchingSessions.sort(function (a, b) {
	                return a.notebook.path.localeCompare(b.notebook.path);
	            });
	            for (var _c = 0, matchingSessions_1 = matchingSessions; _c < matchingSessions_1.length; _c++) {
	                var session = matchingSessions_1[_c];
	                var name_7 = displayNames[session.kernel.name];
	                node.appendChild(optionForSession(session, name_7, maxLength));
	            }
	            node.appendChild(createSeparatorOption(maxLength));
	        }
	    }
	    // Add the other remaining sessions.
	    var otherSessions = [];
	    for (var _d = 0, sessions_2 = sessions; _d < sessions_2.length; _d++) {
	        var session = sessions_2[_d];
	        if (matchingSessions.indexOf(session) === -1) {
	            otherSessions.push(session);
	        }
	    }
	    if (otherSessions) {
	        otherSessions.sort(function (a, b) {
	            return a.notebook.path.localeCompare(b.notebook.path);
	        });
	        for (var _e = 0, otherSessions_1 = otherSessions; _e < otherSessions_1.length; _e++) {
	            var session = otherSessions_1[_e];
	            var name_8 = displayNames[session.kernel.name];
	            node.appendChild(optionForSession(session, name_8, maxLength));
	        }
	    }
	    node.selectedIndex = 0;
	}
	exports.populateKernels = populateKernels;
	/**
	 * Create a separator option.
	 */
	function createSeparatorOption(length) {
	    var option = document.createElement('option');
	    option.disabled = true;
	    option.text = Array(length).join('─');
	    return option;
	}
	/**
	 * Create an option element for a kernel name.
	 */
	function optionForName(name, displayName) {
	    var option = document.createElement('option');
	    option.text = displayName;
	    option.value = JSON.stringify({ name: name });
	    return option;
	}
	/**
	 * Create an option element for a session.
	 */
	function optionForSession(session, displayName, maxLength) {
	    var option = document.createElement('option');
	    var sessionName = session.notebook.path.split('/').pop();
	    if (sessionName.length > maxLength) {
	        sessionName = sessionName.slice(0, maxLength - 3) + '...';
	    }
	    option.text = sessionName;
	    option.value = JSON.stringify({ id: session.kernel.id });
	    option.title = ("Path: " + session.notebook.path + "\n") +
	        ("Kernel Name: " + displayName + "\n") +
	        ("Kernel Id: " + session.kernel.id);
	    return option;
	}
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/kernelselector.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/registry.js **/
jupyter.define('jupyterlab@0.4.1/lib/docregistry/registry.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	var disposable_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/disposable.js');
	var signaling_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/signaling.js');
	var token_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/token.js');
	/* tslint:disable */
	/**
	 * The document registry token.
	 */
	exports.IDocumentRegistry = new token_1.Token('jupyter.services.document-registry');
	/**
	 * The document registry.
	 */
	var DocumentRegistry = (function () {
	    function DocumentRegistry() {
	        this._modelFactories = Object.create(null);
	        this._widgetFactories = Object.create(null);
	        this._defaultWidgetFactory = '';
	        this._defaultWidgetFactories = Object.create(null);
	        this._widgetFactoryExtensions = Object.create(null);
	        this._fileTypes = [];
	        this._creators = [];
	        this._extenders = Object.create(null);
	    }
	    Object.defineProperty(DocumentRegistry.prototype, "isDisposed", {
	        /**
	         * Get whether the document registry has been disposed.
	         */
	        get: function () {
	            return this._widgetFactories === null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the resources held by the document registery.
	     */
	    DocumentRegistry.prototype.dispose = function () {
	        if (this.isDisposed) {
	            return;
	        }
	        for (var modelName in this._modelFactories) {
	            this._modelFactories[modelName].dispose();
	        }
	        this._modelFactories = null;
	        for (var widgetName in this._widgetFactories) {
	            this._widgetFactories[widgetName].factory.dispose();
	        }
	        this._widgetFactories = null;
	        this._fileTypes = null;
	        this._creators = null;
	        this._extenders = null;
	    };
	    /**
	     * Add a widget factory to the registry.
	     *
	     * @param factory - The factory instance to register.
	     *
	     * @param options - The options used to register the factory.
	     *
	     * @returns A disposable which will unregister the factory.
	     *
	     * #### Notes
	     * If a factory with the given `'displayName'` is already registered,
	     * a warning will be logged, and this will be a no-op.
	     * If `'*'` is given as a default extension, the factory will be registered
	     * as the global default.
	     * If an extension or global default is already registered, this factory
	     * will override the existing default.
	     */
	    DocumentRegistry.prototype.addWidgetFactory = function (factory, options) {
	        var _this = this;
	        var name = options.displayName.toLowerCase();
	        if (this._widgetFactories[name]) {
	            console.warn("Duplicate registered factory " + name);
	            return new disposable_1.DisposableDelegate(null);
	        }
	        var record = Private.createRecord(factory, options);
	        this._widgetFactories[name] = record;
	        for (var _i = 0, _a = record.defaultFor; _i < _a.length; _i++) {
	            var ext = _a[_i];
	            if (record.fileExtensions.indexOf(ext) === -1) {
	                continue;
	            }
	            if (ext === '*') {
	                this._defaultWidgetFactory = name;
	            }
	            else {
	                this._defaultWidgetFactories[ext] = name;
	            }
	        }
	        // For convenience, store a mapping of ext -> name
	        for (var _b = 0, _c = record.fileExtensions; _b < _c.length; _b++) {
	            var ext = _c[_b];
	            if (!this._widgetFactoryExtensions[ext]) {
	                this._widgetFactoryExtensions[ext] = new Set();
	            }
	            this._widgetFactoryExtensions[ext].add(name);
	        }
	        this.changed.emit({
	            type: 'widgetFactory',
	            name: name,
	            change: 'added'
	        });
	        return new disposable_1.DisposableDelegate(function () {
	            delete _this._widgetFactories[name];
	            if (_this._defaultWidgetFactory === name) {
	                _this._defaultWidgetFactory = '';
	            }
	            for (var _i = 0, _a = Object.keys(_this._defaultWidgetFactories); _i < _a.length; _i++) {
	                var ext = _a[_i];
	                if (_this._defaultWidgetFactories[ext] === name) {
	                    delete _this._defaultWidgetFactories[ext];
	                }
	            }
	            for (var _b = 0, _c = Object.keys(_this._widgetFactoryExtensions); _b < _c.length; _b++) {
	                var ext = _c[_b];
	                _this._widgetFactoryExtensions[ext].delete(name);
	                if (_this._widgetFactoryExtensions[ext].size === 0) {
	                    delete _this._widgetFactoryExtensions[ext];
	                }
	            }
	            _this.changed.emit({
	                type: 'widgetFactory',
	                name: name,
	                change: 'removed'
	            });
	        });
	    };
	    /**
	     * Add a model factory to the registry.
	     *
	     * @param factory - The factory instance.
	     *
	     * @returns A disposable which will unregister the factory.
	     *
	     * #### Notes
	     * If a factory with the given `name` is already registered, or
	     * the given factory is already registered, a warning will be logged
	     * and this will be a no-op.
	     */
	    DocumentRegistry.prototype.addModelFactory = function (factory) {
	        var _this = this;
	        var name = factory.name.toLowerCase();
	        if (this._modelFactories[name]) {
	            console.warn("Duplicate registered factory " + name);
	            return new disposable_1.DisposableDelegate(null);
	        }
	        this._modelFactories[name] = factory;
	        this.changed.emit({
	            type: 'modelFactory',
	            name: name,
	            change: 'added'
	        });
	        return new disposable_1.DisposableDelegate(function () {
	            delete _this._modelFactories[name];
	            _this.changed.emit({
	                type: 'modelFactory',
	                name: name,
	                change: 'removed'
	            });
	        });
	    };
	    /**
	     * Add a widget extension to the registry.
	     *
	     * @param widgetName - The name of the widget factory.
	     *
	     * @param extension - A widget extension.
	     *
	     * @returns A disposable which will unregister the extension.
	     *
	     * #### Notes
	     * If the extension is already registered for the given
	     * widget name, a warning will be logged and this will be a no-op.
	     */
	    DocumentRegistry.prototype.addWidgetExtension = function (widgetName, extension) {
	        var _this = this;
	        widgetName = widgetName.toLowerCase();
	        if (!(widgetName in this._extenders)) {
	            this._extenders[widgetName] = [];
	        }
	        var extenders = this._extenders[widgetName];
	        var index = extenders.indexOf(extension);
	        if (index !== -1) {
	            console.warn("Duplicate registered extension for " + widgetName);
	            return new disposable_1.DisposableDelegate(null);
	        }
	        this._extenders[widgetName].push(extension);
	        this.changed.emit({
	            type: 'widgetExtension',
	            name: null,
	            change: 'added'
	        });
	        return new disposable_1.DisposableDelegate(function () {
	            index = _this._extenders[widgetName].indexOf(extension);
	            _this._extenders[widgetName].splice(index, 1);
	            _this.changed.emit({
	                type: 'widgetExtension',
	                name: null,
	                change: 'removed'
	            });
	        });
	    };
	    /**
	     * Add a file type to the document registry.
	     *
	     * @params fileType - The file type object to register.
	     *
	     * @returns A disposable which will unregister the command.
	     *
	     * #### Notes
	     * These are used to populate the "Create New" dialog.
	     * If the file type with the same name is already registered, a warning will
	     * be logged and this will be a no-op.
	     */
	    DocumentRegistry.prototype.addFileType = function (fileType) {
	        var _this = this;
	        for (var _i = 0, _a = this._fileTypes; _i < _a.length; _i++) {
	            var fType = _a[_i];
	            if (fType.name.toLowerCase() === fileType.name.toLowerCase()) {
	                console.warn("Duplicate registered file types for " + fType.name);
	                return new disposable_1.DisposableDelegate(null);
	            }
	        }
	        fileType.extension = Private.normalizeExtension(fileType.extension);
	        this._fileTypes.push(fileType);
	        this._fileTypes.sort(function (a, b) { return a.name.localeCompare(b.name); });
	        this.changed.emit({
	            type: 'fileType',
	            name: fileType.name,
	            change: 'added'
	        });
	        return new disposable_1.DisposableDelegate(function () {
	            var index = _this._fileTypes.indexOf(fileType);
	            _this._fileTypes.splice(index, 1);
	            _this.changed.emit({
	                type: 'fileType',
	                name: fileType.name,
	                change: 'removed'
	            });
	        });
	    };
	    /**
	     * Add a creator to the registry.
	     *
	     * @params creator - The file creator object to register.
	     *
	     * @params after - The optional item name to insert after.
	     *
	     * @returns A disposable which will unregister the creator.
	     *
	     * #### Notes
	     * If a creator of the same name is already registered,
	     * a warning will be logged and this will be a no-op.
	     * If `after` is not given or not already registered, it will be moved
	     * to the end.
	     */
	    DocumentRegistry.prototype.addCreator = function (creator, after) {
	        var _this = this;
	        for (var _i = 0, _a = this._creators; _i < _a.length; _i++) {
	            var c = _a[_i];
	            if (c.name.toLowerCase() === creator.name.toLowerCase()) {
	                console.warn("Duplicate registered file creator named " + creator.name);
	                return new disposable_1.DisposableDelegate(null);
	            }
	        }
	        var added = false;
	        if (after) {
	            for (var _b = 0, _c = this._creators; _b < _c.length; _b++) {
	                var existing = _c[_b];
	                if (existing.name.toLowerCase() === after.toLowerCase()) {
	                    var index = this._creators.indexOf(existing);
	                    this._creators.splice(index, 0, creator);
	                    added = true;
	                    break;
	                }
	            }
	        }
	        if (!added) {
	            this._creators.push(creator);
	        }
	        this.changed.emit({
	            type: 'fileCreator',
	            name: creator.name,
	            change: 'added'
	        });
	        return new disposable_1.DisposableDelegate(function () {
	            var index = _this._creators.indexOf(creator);
	            _this._creators.splice(index, 1);
	            _this.changed.emit({
	                type: 'fileCreator',
	                name: creator.name,
	                change: 'removed'
	            });
	        });
	    };
	    /**
	     * List the names of the valid registered widget factories.
	     *
	     * @param ext - An optional file extension to filter the results.
	     *
	     * @returns A new array of registered widget factory names.
	     *
	     * #### Notes
	     * Only the widget factories whose associated model factory have
	     * been registered will be returned.
	     * The first item in the list is considered the default. The returned list
	     * has widget factories in the following order:
	     * - extension-specific default factory
	     * - global default factory
	     * - all other extension-specific factories
	     * - all other global factories
	     */
	    DocumentRegistry.prototype.listWidgetFactories = function (ext) {
	        var _this = this;
	        if (ext === void 0) { ext = '*'; }
	        var factories = new Set();
	        ext = Private.normalizeExtension(ext);
	        // Start with the extension-specific default factory.
	        if (ext.length > 1) {
	            if (ext in this._defaultWidgetFactories) {
	                factories.add(this._defaultWidgetFactories[ext]);
	            }
	        }
	        // Add the global default factory.
	        if (this._defaultWidgetFactory) {
	            factories.add(this._defaultWidgetFactory);
	        }
	        // Add the extension-specific factories in registration order.
	        if (ext.length > 1) {
	            if (ext in this._widgetFactoryExtensions) {
	                this._widgetFactoryExtensions[ext].forEach(function (n) { factories.add(n); });
	            }
	        }
	        // Add the rest of the global factories, in registration order.
	        if ('*' in this._widgetFactoryExtensions) {
	            this._widgetFactoryExtensions['*'].forEach(function (n) { factories.add(n); });
	        }
	        // Construct the return list, checking to make sure the corresponding
	        // model factories are registered.
	        var factoryList = [];
	        factories.forEach(function (name) {
	            if (_this._widgetFactories[name].modelName in _this._modelFactories) {
	                name = _this._widgetFactories[name].displayName;
	                factoryList.push(name);
	            }
	        });
	        return factoryList;
	    };
	    /**
	     * Return the name of the default widget factory for a given extension.
	     *
	     * @param ext - An optional file extension.
	     *
	     * @returns The default widget factory name for the extension (if given) or the global default.
	     */
	    DocumentRegistry.prototype.defaultWidgetFactory = function (ext) {
	        if (ext === void 0) { ext = '*'; }
	        var widgets = this.listWidgetFactories(ext);
	        return widgets ? widgets[0] : void 0;
	    };
	    /**
	     * List the names of the registered model factories.
	     *
	     * @returns A new array of registered model factory names.
	     */
	    DocumentRegistry.prototype.listModelFactories = function () {
	        return Object.keys(this._modelFactories);
	    };
	    /**
	     * Get a list of file types that have been registered.
	     *
	     * @returns A new array of registered file type objects.
	     */
	    DocumentRegistry.prototype.listFileTypes = function () {
	        return this._fileTypes.slice();
	    };
	    /**
	     * Get an ordered list of the file creators that have been registered.
	     *
	     * @returns A new array of registered file creator objects.
	     */
	    DocumentRegistry.prototype.listCreators = function () {
	        return this._creators.slice();
	    };
	    /**
	     * Get a file type by name.
	     */
	    DocumentRegistry.prototype.getFileType = function (name) {
	        name = name.toLowerCase();
	        for (var i = 0; i < this._fileTypes.length; i++) {
	            var fileType = this._fileTypes[i];
	            if (fileType.name.toLowerCase() === name) {
	                return fileType;
	            }
	        }
	    };
	    /**
	     * Get a creator by name.
	     */
	    DocumentRegistry.prototype.getCreator = function (name) {
	        name = name.toLowerCase();
	        for (var i = 0; i < this._creators.length; i++) {
	            var creator = this._creators[i];
	            if (creator.name.toLowerCase() === name) {
	                return creator;
	            }
	        }
	    };
	    /**
	     * Get a kernel preference.
	     *
	     * @param ext - The file extension.
	     *
	     * @param widgetName - The name of the widget factory.
	     *
	     * @returns A kernel preference.
	     */
	    DocumentRegistry.prototype.getKernelPreference = function (ext, widgetName) {
	        ext = Private.normalizeExtension(ext);
	        widgetName = widgetName.toLowerCase();
	        var widgetFactoryEx = this._getWidgetFactoryEx(widgetName);
	        if (!widgetFactoryEx) {
	            return void 0;
	        }
	        var modelFactory = this.getModelFactoryFor(widgetName);
	        var language = modelFactory.preferredLanguage(ext);
	        return {
	            language: language,
	            preferKernel: widgetFactoryEx.preferKernel,
	            canStartKernel: widgetFactoryEx.canStartKernel
	        };
	    };
	    /**
	     * Get the model factory registered for a given widget factory.
	     *
	     * @param widgetName - The name of the widget factory.
	     *
	     * @returns A model factory instance.
	     */
	    DocumentRegistry.prototype.getModelFactoryFor = function (widgetName) {
	        widgetName = widgetName.toLowerCase();
	        var wFactoryEx = this._getWidgetFactoryEx(widgetName);
	        if (!wFactoryEx) {
	            return;
	        }
	        return this._modelFactories[wFactoryEx.modelName.toLowerCase()];
	    };
	    /**
	     * Get a widget factory by name.
	     *
	     * @param widgetName - The name of the widget factory.
	     *
	     * @returns A widget factory instance.
	     */
	    DocumentRegistry.prototype.getWidgetFactory = function (widgetName) {
	        widgetName = widgetName.toLowerCase();
	        var ex = this._getWidgetFactoryEx(widgetName);
	        return ex ? ex.factory : void 0;
	    };
	    /**
	     * Get the registered extensions for a given widget.
	     *
	     * @param widgetName - The name of the widget factory.
	     *
	     * @returns A new array of widget extensions.
	     */
	    DocumentRegistry.prototype.getWidgetExtensions = function (widgetName) {
	        widgetName = widgetName.toLowerCase();
	        if (!(widgetName in this._extenders)) {
	            return [];
	        }
	        return this._extenders[widgetName].slice();
	    };
	    /**
	     * Get the appropriate widget factory by name.
	     */
	    DocumentRegistry.prototype._getWidgetFactoryEx = function (widgetName) {
	        widgetName = widgetName.toLowerCase();
	        var options;
	        if (widgetName === 'default') {
	            options = this._widgetFactories[this._defaultWidgetFactory];
	        }
	        else {
	            options = this._widgetFactories[widgetName];
	        }
	        return options;
	    };
	    return DocumentRegistry;
	}());
	exports.DocumentRegistry = DocumentRegistry;
	// Define the signals for the `DocumentRegistry` class.
	signaling_1.defineSignal(DocumentRegistry.prototype, 'changed');
	/**
	 * A private namespace for DocumentRegistry data.
	 */
	var Private;
	(function (Private) {
	    /**
	     * Create a widget factory record.
	     */
	    function createRecord(factory, options) {
	        var fileExtensions = options.fileExtensions.map(function (ext) { return normalizeExtension(ext); });
	        var defaultFor = options.defaultFor || [];
	        defaultFor = defaultFor.map(function (ext) { return normalizeExtension(ext); });
	        return {
	            factory: factory,
	            fileExtensions: fileExtensions,
	            defaultFor: defaultFor,
	            displayName: options.displayName,
	            modelName: options.modelName.toLowerCase(),
	            preferKernel: !!options.preferKernel,
	            canStartKernel: !!options.canStartKernel
	        };
	    }
	    Private.createRecord = createRecord;
	    /**
	     * Normalize a file extension to be of the type `'.foo'`.
	     *
	     * Adds a leading dot if not present and converts to lower case.
	     */
	    function normalizeExtension(extension) {
	        if (extension === '*') {
	            return extension;
	        }
	        if (extension === '.*') {
	            return '*';
	        }
	        if (extension.indexOf('.') !== 0) {
	            extension = "." + extension;
	        }
	        return extension.toLowerCase();
	    }
	    Private.normalizeExtension = normalizeExtension;
	})(Private || (Private = {}));
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/docregistry/registry.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/core/disposable.js **/
jupyter.define('phosphor@0.6.1/lib/core/disposable.js', function (module, exports, __jupyter_require__) {
	"use strict";
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var iteration_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/iteration.js');
	/**
	 * A disposable object which delegates to a callback function.
	 */
	var DisposableDelegate = (function () {
	    /**
	     * Construct a new disposable delegate.
	     *
	     * @param callback - The function to invoke on dispose.
	     */
	    function DisposableDelegate(callback) {
	        this._callback = callback || null;
	    }
	    Object.defineProperty(DisposableDelegate.prototype, "isDisposed", {
	        /**
	         * Test whether the delegate has been disposed.
	         *
	         * #### Notes
	         * This is a read-only property which is always safe to access.
	         */
	        get: function () {
	            return this._callback === null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the delegate and invoke the callback function.
	     *
	     * #### Notes
	     * All calls to this method after the first will be a no-op.
	     */
	    DisposableDelegate.prototype.dispose = function () {
	        if (this._callback === null) {
	            return;
	        }
	        var callback = this._callback;
	        this._callback = null;
	        callback();
	    };
	    return DisposableDelegate;
	}());
	exports.DisposableDelegate = DisposableDelegate;
	/**
	 * An object which manages a collection of disposable items.
	 */
	var DisposableSet = (function () {
	    /**
	     * Construct a new disposable set.
	     *
	     * @param items - The initial disposable items.
	     */
	    function DisposableSet(items) {
	        var _this = this;
	        this._set = new Set();
	        if (items)
	            iteration_1.each(items, function (item) { _this._set.add(item); });
	    }
	    Object.defineProperty(DisposableSet.prototype, "isDisposed", {
	        /**
	         * Test whether the set has been disposed.
	         *
	         * #### Notes
	         * This is a read-only property which is always safe to access.
	         */
	        get: function () {
	            return this._set === null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the set and the disposable items it contains.
	     *
	     * #### Notes
	     * Items are disposed in the order they are added to the set.
	     *
	     * It is unsafe to use the set after it has been disposed.
	     *
	     * All calls to this method after the first will be a no-op.
	     */
	    DisposableSet.prototype.dispose = function () {
	        if (this._set === null) {
	            return;
	        }
	        var set = this._set;
	        this._set = null;
	        set.forEach(function (item) { item.dispose(); });
	    };
	    /**
	     * Add a disposable item to the set.
	     *
	     * @param item - The disposable item to add to the set. If the item
	     *   is already contained in the set, this is a no-op.
	     *
	     * @throws An error if the set has been disposed.
	     */
	    DisposableSet.prototype.add = function (item) {
	        if (this._set === null) {
	            throw new Error('Object is disposed');
	        }
	        this._set.add(item);
	    };
	    /**
	     * Remove a disposable item from the set.
	     *
	     * @param item - The disposable item to remove from the set. If the
	     *   item does not exist in the set, this is a no-op.
	     *
	     * @throws An error if the set has been disposed.
	     */
	    DisposableSet.prototype.remove = function (item) {
	        if (this._set === null) {
	            throw new Error('Object is disposed');
	        }
	        this._set.delete(item);
	    };
	    /**
	     * Remove all disposable items from the set.
	     *
	     * @throws An error if the set has been disposed.
	     */
	    DisposableSet.prototype.clear = function () {
	        if (this._set === null) {
	            throw new Error('Object is disposed');
	        }
	        this._set.clear();
	    };
	    return DisposableSet;
	}());
	exports.DisposableSet = DisposableSet;
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/core/disposable.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/iteration.js **/
jupyter.define('phosphor@0.6.1/lib/algorithm/iteration.js', function (module, exports, __jupyter_require__) {
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	"use strict";
	/**
	 * Create an iterator for an iterable or array-like object.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @returns A new iterator for the given object.
	 *
	 * #### Notes
	 * This function allows iteration algorithms to operate on user-defined
	 * iterable types and builtin array-like objects in a uniform fashion.
	 */
	function iter(object) {
	    var it;
	    if (typeof object.iter === 'function') {
	        it = object.iter();
	    }
	    else {
	        it = new ArrayIterator(object, 0);
	    }
	    return it;
	}
	exports.iter = iter;
	/**
	 * Create an array from an iterable of values.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @returns A new array of values from the given object.
	 */
	function toArray(object) {
	    var value;
	    var result = [];
	    var it = iter(object);
	    while ((value = it.next()) !== void 0) {
	        result[result.length] = value;
	    }
	    return result;
	}
	exports.toArray = toArray;
	/**
	 * An iterator which is always empty.
	 */
	var EmptyIterator = (function () {
	    /**
	     * Construct a new empty iterator.
	     */
	    function EmptyIterator() {
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    EmptyIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the current iterator.
	     *
	     * @returns A new independent clone of the current iterator.
	     */
	    EmptyIterator.prototype.clone = function () {
	        return new EmptyIterator();
	    };
	    /**
	     * Get the next value from the iterator.
	     *
	     * @returns Always `undefined`.
	     */
	    EmptyIterator.prototype.next = function () {
	        return void 0;
	    };
	    return EmptyIterator;
	}());
	exports.EmptyIterator = EmptyIterator;
	/**
	 * The namespace for the `EmptyIterator` class statics.
	 */
	var EmptyIterator;
	(function (EmptyIterator) {
	    /**
	     * A singleton instance of an empty iterator.
	     */
	    EmptyIterator.instance = new EmptyIterator();
	})(EmptyIterator = exports.EmptyIterator || (exports.EmptyIterator = {}));
	/**
	 * An iterator for an array-like object.
	 *
	 * #### Notes
	 * This iterator can be used for any builtin JS array-like object.
	 */
	var ArrayIterator = (function () {
	    /**
	     * Construct a new array iterator.
	     *
	     * @param source - The array-like object of interest.
	     *
	     * @param start - The starting index for iteration.
	     */
	    function ArrayIterator(source, start) {
	        this._source = source;
	        this._index = start;
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    ArrayIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the current iterator.
	     *
	     * @returns A new independent clone of the current iterator.
	     *
	     * #### Notes
	     * The source array is shared among clones.
	     */
	    ArrayIterator.prototype.clone = function () {
	        return new ArrayIterator(this._source, this._index);
	    };
	    /**
	     * Get the next value from the source array.
	     *
	     * @returns The next value from the source array, or `undefined`
	     *   if the iterator is exhausted.
	     */
	    ArrayIterator.prototype.next = function () {
	        if (this._index >= this._source.length) {
	            return void 0;
	        }
	        return this._source[this._index++];
	    };
	    return ArrayIterator;
	}());
	exports.ArrayIterator = ArrayIterator;
	/**
	 * Invoke a function for each value in an iterable.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @param fn - The callback function to invoke for each value.
	 *
	 * #### Notes
	 * Iteration cannot be terminated early.
	 */
	function each(object, fn) {
	    var value;
	    var it = iter(object);
	    while ((value = it.next()) !== void 0) {
	        fn(value);
	    }
	}
	exports.each = each;
	/**
	 * Test whether all values in an iterable satisfy a predicate.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @param fn - The predicate function to invoke for each value.
	 *
	 * @returns `true` if all values pass the test, `false` otherwise.
	 *
	 * #### Notes
	 * Iteration terminates on the first `false` predicate result.
	 */
	function every(object, fn) {
	    var value;
	    var it = iter(object);
	    while ((value = it.next()) !== void 0) {
	        if (!fn(value))
	            return false;
	    }
	    return true;
	}
	exports.every = every;
	/**
	 * Test whether any value in an iterable satisfies a predicate.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @param fn - The predicate function to invoke for each value.
	 *
	 * @returns `true` if any value passes the test, `false` otherwise.
	 *
	 * #### Notes
	 * Iteration terminates on the first `true` predicate result.
	 */
	function some(object, fn) {
	    var value;
	    var it = iter(object);
	    while ((value = it.next()) !== void 0) {
	        if (fn(value))
	            return true;
	    }
	    return false;
	}
	exports.some = some;
	function reduce(object, fn, initial) {
	    // Setup the iterator and fetch the first value.
	    var it = iter(object);
	    var first = it.next();
	    // An empty iterator and no initial value is an error.
	    if (first === void 0 && initial === void 0) {
	        throw new TypeError('Reduce of empty iterable with no initial value.');
	    }
	    // If the iterator is empty, return the initial value.
	    if (first === void 0) {
	        return initial;
	    }
	    // If the iterator has a single item and no initial value, the
	    // reducer is not invoked and the first item is the return value.
	    var second = it.next();
	    if (second === void 0 && initial === void 0) {
	        return first;
	    }
	    // If iterator has a single item and an initial value is provided,
	    // the reducer is invoked and that result is the return value.
	    if (second === void 0) {
	        return fn(initial, first);
	    }
	    // Setup the initial accumulator value.
	    var accumulator;
	    if (initial === void 0) {
	        accumulator = fn(first, second);
	    }
	    else {
	        accumulator = fn(fn(initial, first), second);
	    }
	    // Iterate the rest of the values, updating the accumulator.
	    var next;
	    while ((next = it.next()) !== void 0) {
	        accumulator = fn(accumulator, next);
	    }
	    // Return the final accumulated value.
	    return accumulator;
	}
	exports.reduce = reduce;
	/**
	 * Filter an iterable for values which pass a test.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @param fn - The predicate function to invoke for each value.
	 *
	 * @returns An iterator which yields the values which pass the test.
	 */
	function filter(object, fn) {
	    return new FilterIterator(iter(object), fn);
	}
	exports.filter = filter;
	/**
	 * An iterator which yields values which pass a test.
	 */
	var FilterIterator = (function () {
	    /**
	     * Construct a new filter iterator.
	     *
	     * @param source - The iterator of values of interest.
	     *
	     * @param fn - The predicate function to invoke for each value in
	     *   the iterator. It returns whether the value passes the test.
	     */
	    function FilterIterator(source, fn) {
	        this._source = source;
	        this._fn = fn;
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    FilterIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the current iterator.
	     *
	     * @returns A new independent clone of the current iterator.
	     *
	     * #### Notes
	     * The source iterator must be cloneable.
	     *
	     * The predicate function is shared among clones.
	     */
	    FilterIterator.prototype.clone = function () {
	        return new FilterIterator(this._source.clone(), this._fn);
	    };
	    /**
	     * Get the next value which passes the test.
	     *
	     * @returns The next value from the source iterator which passes
	     *   the predicate, or `undefined` if the iterator is exhausted.
	     */
	    FilterIterator.prototype.next = function () {
	        var value;
	        var fn = this._fn;
	        var it = this._source;
	        while ((value = it.next()) !== void 0) {
	            if (fn(value))
	                return value;
	        }
	        return void 0;
	    };
	    return FilterIterator;
	}());
	exports.FilterIterator = FilterIterator;
	/**
	 * Transform the values of an iterable with a mapping function.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @param fn - The mapping function to invoke for each value.
	 *
	 * @returns An iterator which yields the transformed values.
	 */
	function map(object, fn) {
	    return new MapIterator(iter(object), fn);
	}
	exports.map = map;
	/**
	 * An iterator which transforms values using a mapping function.
	 */
	var MapIterator = (function () {
	    /**
	     * Construct a new map iterator.
	     *
	     * @param source - The iterator of values of interest.
	     *
	     * @param fn - The mapping function to invoke for each value in the
	     *   iterator. It returns the transformed value.
	     */
	    function MapIterator(source, fn) {
	        this._source = source;
	        this._fn = fn;
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    MapIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the current iterator.
	     *
	     * @returns A new independent clone of the current iterator.
	     *
	     * #### Notes
	     * The source iterator must be cloneable.
	     *
	     * The mapping function is shared among clones.
	     */
	    MapIterator.prototype.clone = function () {
	        return new MapIterator(this._source.clone(), this._fn);
	    };
	    /**
	     * Get the next mapped value from the source iterator.
	     *
	     * @returns The next value from the source iterator transformed
	     *   by the mapper, or `undefined` if the iterator is exhausted.
	     */
	    MapIterator.prototype.next = function () {
	        var value = this._source.next();
	        if (value === void 0) {
	            return void 0;
	        }
	        return this._fn.call(void 0, value);
	    };
	    return MapIterator;
	}());
	exports.MapIterator = MapIterator;
	/**
	 * Attach an incremental index to an iterable.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @param start - The initial value of the index. The default is zero.
	 *
	 * @returns An iterator which yields `[index, value]` tuples.
	 */
	function enumerate(object, start) {
	    if (start === void 0) { start = 0; }
	    return new EnumerateIterator(iter(object), start);
	}
	exports.enumerate = enumerate;
	/**
	 * An iterator which attaches an incremental index to a source.
	 */
	var EnumerateIterator = (function () {
	    /**
	     * Construct a new enumerate iterator.
	     *
	     * @param source - The iterator of values of interest.
	     *
	     * @param start - The initial value of the index.
	     */
	    function EnumerateIterator(source, start) {
	        this._source = source;
	        this._index = start;
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    EnumerateIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the enumerate iterator.
	     *
	     * @returns A new iterator starting with the current value.
	     *
	     * #### Notes
	     * The source iterator must be cloneable.
	     */
	    EnumerateIterator.prototype.clone = function () {
	        return new EnumerateIterator(this._source.clone(), this._index);
	    };
	    /**
	     * Get the next value from the enumeration.
	     *
	     * @returns The next value from the enumeration, or `undefined` if
	     *   the iterator is exhausted.
	     */
	    EnumerateIterator.prototype.next = function () {
	        var value = this._source.next();
	        if (value === void 0) {
	            return void 0;
	        }
	        return [this._index++, value];
	    };
	    return EnumerateIterator;
	}());
	exports.EnumerateIterator = EnumerateIterator;
	/**
	 * Iterate several iterables in lockstep.
	 *
	 * @param objects - The iterables or array-like objects of interest.
	 *
	 * @returns An iterator which yields successive tuples of values where
	 *   each value is taken in turn from the provided iterables. It will
	 *   be as long as the shortest provided iterable.
	 */
	function zip() {
	    var objects = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        objects[_i - 0] = arguments[_i];
	    }
	    return new ZipIterator(objects.map(iter));
	}
	exports.zip = zip;
	/**
	 * An iterator which iterates several sources in lockstep.
	 */
	var ZipIterator = (function () {
	    /**
	     * Construct a new zip iterator.
	     *
	     * @param source - The iterators of interest.
	     */
	    function ZipIterator(source) {
	        this._source = source;
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    ZipIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the zip iterator.
	     *
	     * @returns A new iterator starting with the current value.
	     *
	     * #### Notes
	     * The source iterators must be cloneable.
	     */
	    ZipIterator.prototype.clone = function () {
	        return new ZipIterator(this._source.map(function (it) { return it.clone(); }));
	    };
	    /**
	     * Get the next zipped value from the iterator.
	     *
	     * @returns The next zipped value from the iterator, or `undefined`
	     *   when the first source iterator is exhausted.
	     */
	    ZipIterator.prototype.next = function () {
	        var iters = this._source;
	        var result = new Array(iters.length);
	        for (var i = 0, n = iters.length; i < n; ++i) {
	            var value = iters[i].next();
	            if (value === void 0) {
	                return void 0;
	            }
	            result[i] = value;
	        }
	        return result;
	    };
	    return ZipIterator;
	}());
	exports.ZipIterator = ZipIterator;
	/**
	 * Iterate over an iterable using a stepped increment.
	 *
	 * @param object - The iterable or array-like object of interest.
	 *
	 * @param step - The distance to step on each iteration. A value
	 *   of less than `1` will behave the same as a value of `1`.
	 *
	 * @returns An iterator which traverses the iterable step-wise.
	 */
	function stride(object, step) {
	    return new StrideIterator(iter(object), step);
	}
	exports.stride = stride;
	/**
	 * An iterator which traverses a source iterator step-wise.
	 */
	var StrideIterator = (function () {
	    /**
	     * Construct a new stride iterator.
	     *
	     * @param source - The iterator of values of interest.
	     *
	     * @param step - The distance to step on each iteration. A value
	     *   of less than `1` will behave the same as a value of `1`.
	     */
	    function StrideIterator(source, step) {
	        this._source = source;
	        this._step = step;
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    StrideIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the stride iterator.
	     *
	     * @returns A new iterator starting with the current value.
	     *
	     * #### Notes
	     * The source iterator must be cloneable.
	     */
	    StrideIterator.prototype.clone = function () {
	        return new StrideIterator(this._source.clone(), this._step);
	    };
	    /**
	     * Get the next stepped value from the iterator.
	     *
	     * @returns The next stepped value from the iterator, or `undefined`
	     *   when the source iterator is exhausted.
	     */
	    StrideIterator.prototype.next = function () {
	        var value = this._source.next();
	        if (value === void 0) {
	            return void 0;
	        }
	        var step = this._step;
	        while (--step > 0) {
	            this._source.next();
	        }
	        return value;
	    };
	    return StrideIterator;
	}());
	exports.StrideIterator = StrideIterator;
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/iteration.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/core/token.js **/
jupyter.define('phosphor@0.6.1/lib/core/token.js', function (module, exports, __jupyter_require__) {
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	"use strict";
	/**
	 * A runtime object which captures compile-time type information.
	 *
	 * #### Notes
	 * A token captures the compile-time type of an interface or class in
	 * an object which is useful for various type-safe runtime operations.
	 *
	 * #### Example
	 * ``` typescript
	 * interface IThing {
	 *   value: number;
	 * }
	 *
	 * const IThing = new Token<IThing>('my-module/IThing');
	 *
	 * // some runtime type registry
	 * registry.registerFactory(IThing, () => { value: 42 });
	 *
	 * // later...
	 * let thing = registry.getInstance(IThing);
	 * thing.value; // 42
	 * ```
	 */
	var Token = (function () {
	    /**
	     * Construct a new token.
	     *
	     * @param name - A human readable name for the token.
	     */
	    function Token(name) {
	        this._name = name;
	    }
	    Object.defineProperty(Token.prototype, "name", {
	        /**
	         * The human readable name for the token.
	         *
	         * #### Notes
	         * This can be useful for debugging and logging.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._name;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Token;
	}());
	exports.Token = Token;
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/core/token.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/rendermime/index.js **/
jupyter.define('jupyterlab@0.4.1/lib/rendermime/index.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	var token_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/token.js');
	/* tslint:disable */
	/**
	 * The rendermime token.
	 */
	exports.IRenderMime = new token_1.Token('jupyter.services.rendermime');
	/**
	 * A composite renderer.
	 *
	 * #### Notes
	 * When rendering a mimebundle, a mimetype is selected from the mimetypes by
	 * searching through the `this.order` list. The first mimetype found in the
	 * bundle determines the renderer that will be used.
	 *
	 * You can add a renderer by adding it to the `renderers` object and
	 * registering the mimetype in the `order` array.
	 *
	 * Untrusted bundles are handled differently from trusted ones.  Untrusted
	 * bundles will only render outputs that can be rendered "safely"
	 * (see [[RenderMime.IRenderer.isSafe]]) or can be "sanitized"
	 * (see [[RenderMime.IRenderer.isSanitizable]]).
	 */
	var RenderMime = (function () {
	    /**
	     * Construct a renderer.
	     */
	    function RenderMime(options) {
	        this._renderers = Object.create(null);
	        this._sanitizer = null;
	        for (var mime in options.renderers) {
	            this._renderers[mime] = options.renderers[mime];
	        }
	        this._order = options.order.slice();
	        this._sanitizer = options.sanitizer;
	        this._resolver = options.resolver || null;
	    }
	    Object.defineProperty(RenderMime.prototype, "order", {
	        /**
	         * The ordered list of mimetypes.
	         *
	         * #### Notes
	         * These mimetypes are searched from beginning to end, and the first matching
	         * mimetype is used.
	         */
	        get: function () {
	            return this._order.slice();
	        },
	        set: function (value) {
	            this._order = value.slice();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderMime.prototype, "resolver", {
	        /**
	         * The object used to resolve relative urls for the rendermime instance.
	         */
	        get: function () {
	            return this._resolver;
	        },
	        set: function (value) {
	            this._resolver = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Render a mimebundle.
	     *
	     * @param bundle - the mimebundle to render.
	     *
	     * @param trusted - whether the bundle is trusted.
	     *
	     * #### Notes
	     * We select the preferred mimetype in bundle based on whether the output is
	     * trusted (see [[preferredMimetype]]), and then pass a sanitizer to the
	     * renderer if the output should be sanitized.
	     */
	    RenderMime.prototype.render = function (options) {
	        var trusted = options.trusted, bundle = options.bundle, injector = options.injector;
	        var mimetype = this.preferredMimetype(bundle, trusted);
	        if (!mimetype) {
	            return void 0;
	        }
	        var rendererOptions = {
	            mimetype: mimetype,
	            source: bundle[mimetype],
	            injector: injector,
	            resolver: this._resolver,
	            sanitizer: trusted ? null : this._sanitizer
	        };
	        return this._renderers[mimetype].render(rendererOptions);
	    };
	    /**
	     * Find the preferred mimetype in a mimebundle.
	     *
	     * @param bundle - the mimebundle giving available mimetype content.
	     *
	     * @param trusted - whether the bundle is trusted.
	     *
	     * #### Notes
	     * For untrusted bundles, only select mimetypes that can be rendered
	     * "safely"  (see [[RenderMime.IRenderer.isSafe]]) or can  be "sanitized"
	     * (see [[RenderMime.IRenderer.isSanitizable]]).
	     */
	    RenderMime.prototype.preferredMimetype = function (bundle, trusted) {
	        if (trusted === void 0) { trusted = false; }
	        for (var _i = 0, _a = this.order; _i < _a.length; _i++) {
	            var m = _a[_i];
	            if (m in bundle) {
	                var renderer = this._renderers[m];
	                if (trusted || renderer.isSafe(m) || renderer.isSanitizable(m)) {
	                    return m;
	                }
	            }
	        }
	    };
	    /**
	     * Clone the rendermime instance with shallow copies of data.
	     */
	    RenderMime.prototype.clone = function () {
	        return new RenderMime({
	            renderers: this._renderers,
	            order: this.order,
	            sanitizer: this._sanitizer
	        });
	    };
	    /**
	     * Add a renderer by mimetype.
	     *
	     * @param mimetype - The mimetype of the renderer.
	     * @param renderer - The renderer instance.
	     * @param index - The optional order index.
	     *
	     * ####Notes
	     * Negative indices count from the end, so -1 refers to the penultimate index.
	     * Use the index of `.order.length` to add to the end of the render precedence list,
	     * which would make the new renderer the last choice.
	     */
	    RenderMime.prototype.addRenderer = function (mimetype, renderer, index) {
	        if (index === void 0) { index = 0; }
	        this._renderers[mimetype] = renderer;
	        this._order.splice(index, 0, mimetype);
	    };
	    /**
	     * Remove a renderer by mimetype.
	     */
	    RenderMime.prototype.removeRenderer = function (mimetype) {
	        delete this._renderers[mimetype];
	        var index = this._order.indexOf(mimetype);
	        if (index !== -1) {
	            this._order.splice(index, 1);
	        }
	    };
	    return RenderMime;
	}());
	exports.RenderMime = RenderMime;
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/rendermime/index.js **/


/** START DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/factory.js **/
jupyter.define('jupyterlab_vega@0.1.0/lib/factory.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var docregistry_1 = __jupyter_require__('jupyterlab@0.4.1/lib/docregistry/index.js');
	var widget_1 = __jupyter_require__('jupyterlab_vega@~0.1.0/lib/widget.js');
	var VegaWidgetFactory = (function (_super) {
	    __extends(VegaWidgetFactory, _super);
	    function VegaWidgetFactory() {
	        _super.apply(this, arguments);
	    }
	    VegaWidgetFactory.prototype.createNew = function (context, kernel) {
	        var widget = new widget_1.VegaWidget(context);
	        this.widgetCreated.emit(widget);
	        return widget;
	    };
	    return VegaWidgetFactory;
	}(docregistry_1.ABCWidgetFactory));
	exports.VegaWidgetFactory = VegaWidgetFactory;
	var VegaLiteWidgetFactory = (function (_super) {
	    __extends(VegaLiteWidgetFactory, _super);
	    function VegaLiteWidgetFactory() {
	        _super.apply(this, arguments);
	    }
	    VegaLiteWidgetFactory.prototype.createNew = function (context, kernel) {
	        var widget = new widget_1.VegaLiteWidget(context);
	        this.widgetCreated.emit(widget);
	        return widget;
	    };
	    return VegaLiteWidgetFactory;
	}(docregistry_1.ABCWidgetFactory));
	exports.VegaLiteWidgetFactory = VegaLiteWidgetFactory;
	
})
/** END DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/factory.js **/


/** START DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/widget.js **/
jupyter.define('jupyterlab_vega@0.1.0/lib/widget.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var panel_1 = __jupyter_require__('phosphor@0.6.1/lib/ui/panel.js');
	var activitymonitor_1 = __jupyter_require__('jupyterlab@0.4.1/lib/common/activitymonitor.js');
	var rendererwidget_1 = __jupyter_require__('jupyterlab_vega@~0.1.0/lib/rendererwidget.js');
	var BASE_VEGA_CLASS = 'jp-BaseVegaWidget';
	/**
	 * The class name added to a Vega widget.
	 */
	var VEGA_CLASS = 'jp-VegaWidget';
	/**
	 * The class name added to a VegaLite widget.
	 */
	var VEGALITE_CLASS = 'jp-VegaLiteWidget';
	var RENDER_TIMEOUT = 1000;
	var BaseVegaWidget = (function (_super) {
	    __extends(BaseVegaWidget, _super);
	    function BaseVegaWidget(context) {
	        var _this = this;
	        _super.call(this);
	        this._updateTitle = false;
	        this._updateVega = false;
	        this._monitor = null;
	        this.addClass(BASE_VEGA_CLASS);
	        this._context = context;
	        if (context.model.toJSON()) {
	            this.renderTitle();
	            this.renderVega();
	        }
	        context.pathChanged.connect(function () {
	            _this.renderTitle();
	        });
	        this._monitor = new activitymonitor_1.ActivityMonitor({
	            signal: context.model.contentChanged,
	            timeout: RENDER_TIMEOUT
	        });
	        this._monitor.activityStopped.connect(function () { _this.renderVega(); });
	        context.contentsModelChanged.connect(function () {
	            _this.renderVega();
	        });
	    }
	    /**
	     * Dispose of the resources used by the widget.
	     */
	    BaseVegaWidget.prototype.dispose = function () {
	        if (this.isDisposed) {
	            return;
	        }
	        this._context = null;
	        this._monitor.dispose();
	        _super.prototype.dispose.call(this);
	    };
	    BaseVegaWidget.prototype.onUpdateRequest = function (msg) {
	        var context = this._context;
	        if (this._updateTitle) {
	            this.title.label = context.path.split('/').pop();
	            this._updateTitle = false;
	        }
	        if (this._updateVega) {
	            var cm = context.contentsModel;
	            if (cm === null) {
	                return;
	            }
	            var layout = this.layout;
	            var sdata = context.model.toString();
	            var options = { mimetype: this.mimetype,
	                source: JSON.parse(sdata) };
	            var widget = new rendererwidget_1.RenderedVegaLite(options);
	            if (layout.widgets.length) {
	                layout.widgets.at(0).dispose();
	            }
	            layout.addWidget(widget);
	            this._updateVega = false;
	        }
	    };
	    BaseVegaWidget.prototype.renderTitle = function () {
	        this._updateTitle = true;
	        this.update();
	    };
	    BaseVegaWidget.prototype.renderVega = function () {
	        this._updateVega = true;
	        this.update();
	    };
	    return BaseVegaWidget;
	}(panel_1.Panel));
	exports.BaseVegaWidget = BaseVegaWidget;
	/**
	 * A widget for rendering Vega JSON
	 */
	var VegaWidget = (function (_super) {
	    __extends(VegaWidget, _super);
	    /**
	     * Construct a VegaWidget
	     */
	    function VegaWidget(context) {
	        _super.call(this, context);
	        this.addClass(VEGA_CLASS);
	        this.mimetype = 'application/vnd.vega+json';
	    }
	    return VegaWidget;
	}(BaseVegaWidget));
	exports.VegaWidget = VegaWidget;
	/**
	 * A widget for rendering VegaLite JSON
	 */
	var VegaLiteWidget = (function (_super) {
	    __extends(VegaLiteWidget, _super);
	    /**
	     * Construct a VegaLiteWidget
	     */
	    function VegaLiteWidget(context) {
	        _super.call(this, context);
	        this.addClass(VEGALITE_CLASS);
	        this.mimetype = 'application/vnd.vegalite+json';
	    }
	    return VegaLiteWidget;
	}(BaseVegaWidget));
	exports.VegaLiteWidget = VegaLiteWidget;
	
})
/** END DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/widget.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/ui/panel.js **/
jupyter.define('phosphor@0.6.1/lib/ui/panel.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var mutation_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/mutation.js');
	var searching_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/searching.js');
	var vector_1 = __jupyter_require__('phosphor@~0.6.1/lib/collections/vector.js');
	var messaging_1 = __jupyter_require__('phosphor@~0.6.1/lib/core/messaging.js');
	var widget_1 = __jupyter_require__('phosphor@0.6.1/lib/ui/widget.js');
	/**
	 * The class name added to Panel instances.
	 */
	var PANEL_CLASS = 'p-Panel';
	/**
	 * A simple and convenient panel widget class.
	 *
	 * #### Notes
	 * This class is suitable as a base class for implementing a variety of
	 * convenience panel widgets, but can also be used directly with CSS to
	 * arrange a collection of widgets.
	 *
	 * This class provides a convenience wrapper around a [[PanelLayout]].
	 */
	var Panel = (function (_super) {
	    __extends(Panel, _super);
	    /**
	     * Construct a new panel.
	     *
	     * @param options - The options for initializing the panel.
	     */
	    function Panel(options) {
	        if (options === void 0) { options = {}; }
	        _super.call(this);
	        this.addClass(PANEL_CLASS);
	        this.layout = Private.createLayout(options);
	    }
	    Object.defineProperty(Panel.prototype, "widgets", {
	        /**
	         * A read-only sequence of the widgets in the panel.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this.layout.widgets;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Add a widget to the end of the panel.
	     *
	     * @param widget - The widget to add to the panel.
	     *
	     * #### Notes
	     * If the is already contained in the panel, it will be moved.
	     */
	    Panel.prototype.addWidget = function (widget) {
	        this.layout.addWidget(widget);
	    };
	    /**
	     * Insert a widget at the specified index.
	     *
	     * @param index - The index at which to insert the widget.
	     *
	     * @param widget - The widget to insert into to the panel.
	     *
	     * #### Notes
	     * If the widget is already contained in the panel, it will be moved.
	     */
	    Panel.prototype.insertWidget = function (index, widget) {
	        this.layout.insertWidget(index, widget);
	    };
	    return Panel;
	}(widget_1.Widget));
	exports.Panel = Panel;
	/**
	 * A concrete layout implementation suitable for many use cases.
	 *
	 * #### Notes
	 * This class is suitable as a base class for implementing a variety of
	 * layouts, but can also be used directly with standard CSS to layout a
	 * collection of widgets.
	 */
	var PanelLayout = (function (_super) {
	    __extends(PanelLayout, _super);
	    function PanelLayout() {
	        _super.apply(this, arguments);
	        this._widgets = new vector_1.Vector();
	    }
	    /**
	     * Dispose of the resources held by the layout.
	     *
	     * #### Notes
	     * This will clear and dispose all widgets in the layout.
	     *
	     * All reimplementations should call the superclass method.
	     *
	     * This method is called automatically when the parent is disposed.
	     */
	    PanelLayout.prototype.dispose = function () {
	        while (this._widgets.length > 0) {
	            this._widgets.popBack().dispose();
	        }
	        _super.prototype.dispose.call(this);
	    };
	    Object.defineProperty(PanelLayout.prototype, "widgets", {
	        /**
	         * A read-only sequence of the widgets in the layout.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._widgets;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create an iterator over the widgets in the layout.
	     *
	     * @returns A new iterator over the widgets in the layout.
	     */
	    PanelLayout.prototype.iter = function () {
	        return this._widgets.iter();
	    };
	    /**
	     * Add a widget to the end of the layout.
	     *
	     * @param widget - The widget to add to the layout.
	     *
	     * #### Notes
	     * If the widget is already contained in the layout, it will be moved.
	     */
	    PanelLayout.prototype.addWidget = function (widget) {
	        this.insertWidget(this._widgets.length, widget);
	    };
	    /**
	     * Insert a widget into the layout at the specified index.
	     *
	     * @param index - The index at which to insert the widget.
	     *
	     * @param widget - The widget to insert into the layout.
	     *
	     * #### Notes
	     * The index will be clamped to the bounds of the widgets.
	     *
	     * If the widget is already added to the layout, it will be moved.
	     */
	    PanelLayout.prototype.insertWidget = function (index, widget) {
	        // Remove the widget from its current parent. This is a no-op
	        // if the widget's parent is already the layout parent widget.
	        widget.parent = this.parent;
	        // Look up the current index of the widget.
	        var i = searching_1.indexOf(this._widgets, widget);
	        // Clamp the insert index to the vector bounds.
	        var j = Math.max(0, Math.min(Math.floor(index), this._widgets.length));
	        // If the widget is not in the vector, insert it.
	        if (i === -1) {
	            // Insert the widget into the vector.
	            this._widgets.insert(j, widget);
	            // If the layout is parented, attach the widget to the DOM.
	            if (this.parent)
	                this.attachWidget(j, widget);
	            // There is nothing more to do.
	            return;
	        }
	        // Otherwise, the widget exists in the vector and should be moved.
	        // Adjust the index if the location is at the end of the vector.
	        if (j === this._widgets.length)
	            j--;
	        // Bail if there is no effective move.
	        if (i === j)
	            return;
	        // Move the widget to the new location.
	        mutation_1.move(this._widgets, i, j);
	        // If the layout is parented, move the widget in the DOM.
	        if (this.parent)
	            this.moveWidget(i, j, widget);
	    };
	    /**
	     * Remove a widget from the layout.
	     *
	     * @param widget - The widget to remove from the layout.
	     *
	     * @returns The index occupied by the widget, or `-1` if the widget
	     *   was not contained in the layout.
	     *
	     * #### Notes
	     * A widget is automatically removed from the layout when its `parent`
	     * is set to `null`. This method should only be invoked directly when
	     * removing a widget from a layout which has yet to be installed on a
	     * parent widget.
	     *
	     * This method does *not* modify the widget's `parent`.
	     */
	    PanelLayout.prototype.removeWidget = function (widget) {
	        var index = searching_1.indexOf(this._widgets, widget);
	        if (index !== -1)
	            this.removeWidgetAt(index);
	        return index;
	    };
	    /**
	     * Remove the widget at a given index from the layout.
	     *
	     * @param index - The index of the widget to remove.
	     *
	     * @returns The widget occupying the index, or `null` if the index
	     *   is out of range.
	     *
	     * #### Notes
	     * A widget is automatically removed from the layout when its `parent`
	     * is set to `null`. This method should only be invoked directly when
	     * removing a widget from a layout which has yet to be installed on a
	     * parent widget.
	     *
	     * This method does *not* modify the widget's `parent`.
	     */
	    PanelLayout.prototype.removeWidgetAt = function (index) {
	        // Bail if the index is out of range.
	        var i = Math.floor(index);
	        if (i < 0 || i >= this._widgets.length) {
	            return null;
	        }
	        // Remove the widget from the vector.
	        var widget = this._widgets.removeAt(i);
	        // If the layout is parented, detach the widget from the DOM.
	        if (this.parent)
	            this.detachWidget(i, widget);
	        // Return the removed widget.
	        return widget;
	    };
	    /**
	     * Attach a widget to the parent's DOM node.
	     *
	     * @param index - The current index of the widget in the layout.
	     *
	     * @param widget - The widget to attach to the parent.
	     *
	     * #### Notes
	     * This method is called automatically by the panel layout at the
	     * appropriate time. It should not be called directly by user code.
	     *
	     * The default implementation adds the widgets's node to the parent's
	     * node at the proper location, and sends an `'after-attach'` message
	     * to the widget if the parent is attached to the DOM.
	     *
	     * Subclasses may reimplement this method to control how the widget's
	     * node is added to the parent's node, but the reimplementation must
	     * send an `'after-attach'` message to the widget if the parent is
	     * attached to the DOM.
	     */
	    PanelLayout.prototype.attachWidget = function (index, widget) {
	        // Look up the next sibling reference node.
	        var ref = this.parent.node.children[index];
	        // Insert the widget's node before the sibling.
	        this.parent.node.insertBefore(widget.node, ref);
	        // Send an `'after-attach'` message if the parent is attached.
	        if (this.parent.isAttached)
	            messaging_1.sendMessage(widget, widget_1.WidgetMessage.AfterAttach);
	    };
	    /**
	     * Move a widget in the parent's DOM node.
	     *
	     * @param fromIndex - The previous index of the widget in the layout.
	     *
	     * @param toIndex - The current index of the widget in the layout.
	     *
	     * @param widget - The widget to move in the parent.
	     *
	     * #### Notes
	     * This method is called automatically by the panel layout at the
	     * appropriate time. It should not be called directly by user code.
	     *
	     * The default implementation moves the widget's node to the proper
	     * location in the parent's node and sends both a `'before-detach'`
	     * and an `'after-attach'` message to the widget if the parent is
	     * attached to the DOM.
	     *
	     * Subclasses may reimplement this method to control how the widget's
	     * node is moved in the parent's node, but the reimplementation must
	     * send both a `'before-detach'` and an `'after-attach'` message to
	     * the widget if the parent is attached to the DOM.
	     */
	    PanelLayout.prototype.moveWidget = function (fromIndex, toIndex, widget) {
	        // Send a `'before-detach'` message if the parent is attached.
	        if (this.parent.isAttached)
	            messaging_1.sendMessage(widget, widget_1.WidgetMessage.BeforeDetach);
	        // Remove the widget's node from the parent.
	        this.parent.node.removeChild(widget.node);
	        // Look up the next sibling reference node.
	        var ref = this.parent.node.children[toIndex];
	        // Insert the widget's node before the sibling.
	        this.parent.node.insertBefore(widget.node, ref);
	        // Send an `'after-attach'` message if the parent is attached.
	        if (this.parent.isAttached)
	            messaging_1.sendMessage(widget, widget_1.WidgetMessage.AfterAttach);
	    };
	    /**
	     * Detach a widget from the parent's DOM node.
	     *
	     * @param index - The previous index of the widget in the layout.
	     *
	     * @param widget - The widget to detach from the parent.
	     *
	     * #### Notes
	     * This method is called automatically by the panel layout at the
	     * appropriate time. It should not be called directly by user code.
	     *
	     * The default implementation removes the widget's node from the
	     * parent's node, and sends a `'before-detach'` message to the widget
	     * if the parent is attached to the DOM.
	     *
	     * Subclasses may reimplement this method to control how the widget's
	     * node is removed from the parent's node, but the reimplementation
	     * must send a `'before-detach'` message to the widget if the parent
	     * is attached to the DOM.
	     */
	    PanelLayout.prototype.detachWidget = function (index, widget) {
	        // Send a `'before-detach'` message if the parent is attached.
	        if (this.parent.isAttached)
	            messaging_1.sendMessage(widget, widget_1.WidgetMessage.BeforeDetach);
	        // Remove the widget's node from the parent.
	        this.parent.node.removeChild(widget.node);
	    };
	    /**
	     * A message handler invoked on a `'layout-changed'` message.
	     *
	     * #### Notes
	     * This is called when the layout is installed on its parent.
	     *
	     * The default implementation attaches all widgets to the DOM.
	     *
	     * This may be reimplemented by subclasses as needed.
	     */
	    PanelLayout.prototype.onLayoutChanged = function (msg) {
	        for (var i = 0; i < this._widgets.length; ++i) {
	            var widget = this._widgets.at(i);
	            widget.parent = this.parent;
	            this.attachWidget(i, widget);
	        }
	    };
	    /**
	     * A message handler invoked on a `'child-removed'` message.
	     *
	     * #### Notes
	     * This will remove the child widget from the layout.
	     *
	     * Subclasses should **not** typically reimplement this method.
	     */
	    PanelLayout.prototype.onChildRemoved = function (msg) {
	        this.removeWidget(msg.child);
	    };
	    return PanelLayout;
	}(widget_1.Layout));
	exports.PanelLayout = PanelLayout;
	/**
	 * The namespace for the private module data.
	 */
	var Private;
	(function (Private) {
	    /**
	     * Create a panel layout for the given panel options.
	     */
	    function createLayout(options) {
	        return options.layout || new PanelLayout();
	    }
	    Private.createLayout = createLayout;
	})(Private || (Private = {}));
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/ui/panel.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/mutation.js **/
jupyter.define('phosphor@0.6.1/lib/algorithm/mutation.js', function (module, exports, __jupyter_require__) {
	"use strict";
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var sequence_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/sequence.js');
	/**
	 * Move an element in a sequence from one index to another.
	 *
	 * @param object - The sequence or array-like object to mutate.
	 *
	 * @param fromIndex - The index of the element to move.
	 *
	 * @param toIndex - The target index of the element.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Undefined Behavior
	 * A `fromIndex` which is non-integral or out of range.
	 *
	 * A `toIndex` which is non-integral or out of range.
	 *
	 * #### Example
	 * ```typescript
	 * import { move } from 'phosphor/lib/algorithm/mutation';
	 *
	 * let data = [0, 1, 2, 3, 4];
	 * move(data, 1, 2);  // [0, 2, 1, 3, 4]
	 * move(data, 4, 2);  // [0, 2, 4, 1, 3]
	 * ```
	 */
	function move(object, fromIndex, toIndex) {
	    if (object.length <= 1 || fromIndex === toIndex) {
	        return;
	    }
	    var d = fromIndex < toIndex ? 1 : -1;
	    var seq = sequence_1.asMutableSequence(object);
	    var value = seq.at(fromIndex);
	    for (var i = fromIndex; i !== toIndex; i += d) {
	        seq.set(i, seq.at(i + d));
	    }
	    seq.set(toIndex, value);
	}
	exports.move = move;
	/**
	 * Reverse a sequence in-place subject to an optional range.
	 *
	 * @param object - The sequence or array-like object to mutate.
	 *
	 * @param first - The index of the first element of the range. This
	 *   should be `<=` the `last` index. The default is `0`.
	 *
	 * @param last - The index of the last element of the range. This
	 *   should be `>=` the `first` index. The default is `length - 1`.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Undefined Behavior
	 * A `first` index which is non-integral or out of range.
	 *
	 * A `last` index which is non-integral or out of range.
	 *
	 * #### Example
	 * ```typescript
	 * import { reverse } from 'phosphor/lib/algorithm/mutation';
	 *
	 * let data = [0, 1, 2, 3, 4];
	 * reverse(data, 1, 3);  // [0, 3, 2, 1, 4]
	 * reverse(data, 3);     // [0, 3, 2, 4, 1]
	 * reverse(data);        // [1, 4, 2, 3, 0]
	 * ```
	 */
	function reverse(object, first, last) {
	    var length = object.length;
	    if (length <= 1) {
	        return;
	    }
	    if (first === void 0) {
	        first = 0;
	    }
	    if (last === void 0) {
	        last = length - 1;
	    }
	    if (first >= last) {
	        return;
	    }
	    var seq = sequence_1.asMutableSequence(object);
	    while (first < last) {
	        var front = seq.at(first);
	        var back = seq.at(last);
	        seq.set(first++, back);
	        seq.set(last--, front);
	    }
	}
	exports.reverse = reverse;
	/**
	 * Rotate the elements of a sequence by a positive or negative amount.
	 *
	 * @param object - The sequence or array-like object to mutate.
	 *
	 * @param delta - The amount of rotation to apply to the elements. A
	 *   positive value will rotate the elements to the left. A negative
	 *   value will rotate the elements to the right.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Undefined Behavior
	 * A `delta` amount which is non-integral.
	 *
	 * #### Example
	 * ```typescript
	 * import { rotate } from 'phosphor/lib/algorithm/mutation';
	 *
	 * let data = [0, 1, 2, 3, 4];
	 * rotate(data, 2);   // [2, 3, 4, 0, 1]
	 * rotate(data, -2);  // [0, 1, 2, 3, 4]
	 * rotate(data, 10);  // [0, 1, 2, 3, 4]
	 * rotate(data, 9);   // [4, 0, 1, 2, 3]
	 * ```
	 */
	function rotate(object, delta) {
	    var length = object.length;
	    if (length <= 1) {
	        return;
	    }
	    if (delta > 0) {
	        delta = delta % length;
	    }
	    else if (delta < 0) {
	        delta = ((delta % length) + length) % length;
	    }
	    if (delta === 0) {
	        return;
	    }
	    var seq = sequence_1.asMutableSequence(object);
	    reverse(seq, 0, delta - 1);
	    reverse(seq, delta, length - 1);
	    reverse(seq, 0, length - 1);
	}
	exports.rotate = rotate;
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/mutation.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/sequence.js **/
jupyter.define('phosphor@0.6.1/lib/algorithm/sequence.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var iteration_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/iteration.js');
	/**
	 * Cast a sequence or array-like object to a sequence.
	 *
	 * @param object - The sequence or array-like object of interest.
	 *
	 * @returns A sequence for the given object.
	 *
	 * #### Notes
	 * This function allows sequence algorithms to operate on user-defined
	 * sequence types and builtin array-like objects in a uniform fashion.
	 */
	function asSequence(object) {
	    var seq;
	    if (typeof object.at === 'function') {
	        seq = object;
	    }
	    else {
	        seq = new ArraySequence(object);
	    }
	    return seq;
	}
	exports.asSequence = asSequence;
	/**
	 * Cast a mutable sequence or array-like object to a mutable sequence.
	 *
	 * @param object - The sequence or array-like object of interest.
	 *
	 * @returns A mutable sequence for the given object.
	 *
	 * #### Notes
	 * This function allows sequence algorithms to operate on user-defined
	 * sequence types and builtin array-like objects in a uniform fashion.
	 */
	function asMutableSequence(object) {
	    var seq;
	    if (typeof object.set === 'function') {
	        seq = object;
	    }
	    else {
	        seq = new MutableArraySequence(object);
	    }
	    return seq;
	}
	exports.asMutableSequence = asMutableSequence;
	/**
	 * A sequence for an array-like object.
	 *
	 * #### Notes
	 * This sequence can be used for any builtin JS array-like object.
	 */
	var ArraySequence = (function () {
	    /**
	     * Construct a new array sequence.
	     *
	     * @param source - The array-like object of interest.
	     */
	    function ArraySequence(source) {
	        this._source = source;
	    }
	    Object.defineProperty(ArraySequence.prototype, "length", {
	        /**
	         * The length of the sequence.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._source.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A new iterator which traverses the object's values.
	     */
	    ArraySequence.prototype.iter = function () {
	        return new iteration_1.ArrayIterator(this._source, 0);
	    };
	    /**
	     * Get the value at the specified index.
	     *
	     * @param index - The positive integer index of interest.
	     *
	     * @returns The value at the specified index.
	     *
	     * #### Undefined Behavior
	     * An `index` which is non-integral or out of range.
	     */
	    ArraySequence.prototype.at = function (index) {
	        return this._source[index];
	    };
	    return ArraySequence;
	}());
	exports.ArraySequence = ArraySequence;
	/**
	 * A sequence for a mutable array-like object.
	 *
	 * #### Notes
	 * This sequence can be used for any builtin JS array-like object.
	 */
	var MutableArraySequence = (function (_super) {
	    __extends(MutableArraySequence, _super);
	    function MutableArraySequence() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * Set the value at the specified index.
	     *
	     * @param index - The positive integer index of interest.
	     *
	     * @param value - The value to set at the specified index.
	     *
	     * #### Undefined Behavior
	     * An `index` which is non-integral or out of range.
	     */
	    MutableArraySequence.prototype.set = function (index, value) {
	        this._source[index] = value;
	    };
	    return MutableArraySequence;
	}(ArraySequence));
	exports.MutableArraySequence = MutableArraySequence;
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/sequence.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/searching.js **/
jupyter.define('phosphor@0.6.1/lib/algorithm/searching.js', function (module, exports, __jupyter_require__) {
	"use strict";
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var iteration_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/iteration.js');
	var sequence_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/sequence.js');
	/**
	 * Find the first value in an iterable which matches a predicate.
	 *
	 * @param object - The iterable or array-like object to search.
	 *
	 * @param fn - The predicate function to apply to the values.
	 *
	 * @returns The first matching value, or `undefined` if no matching
	 *   value is found.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Example
	 * ```typescript
	 * import { find } from 'phosphor/lib/algorithm/searching';
	 *
	 * interface IAnimal { species: string, name: string };
	 *
	 * function isCat(value: IAnimal): boolean {
	 *   return value.species === 'cat';
	 * }
	 *
	 * let data: IAnimal[] = [
	 *   { species: 'dog', name: 'spot' },
	 *   { species: 'cat', name: 'fluffy' },
	 *   { species: 'alligator', name: 'pocho' },
	 * ];
	 *
	 * find(data, isCat).name;  // 'fluffy'
	 * ```
	 */
	function find(object, fn) {
	    var value;
	    var it = iteration_1.iter(object);
	    while ((value = it.next()) !== void 0) {
	        if (fn(value)) {
	            return value;
	        }
	    }
	    return void 0;
	}
	exports.find = find;
	/**
	 * Find the minimum value in an iterable.
	 *
	 * @param object - The iterable or array-like object to search.
	 *
	 * @param fn - The 3-way comparison function to apply to the values.
	 *   It should return `< 0` if the first value is less than the second.
	 *   `0` if the values are equivalent, or `> 0` if the first value is
	 *   greater than the second.
	 *
	 * @returns The minimum value in the iterable. If multiple values are
	 *   equivalent to the minimum, the left-most value is returned. If
	 *   the iterable is empty, this returns `undefined`.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Example
	 * ```typescript
	 * import { min } from 'phosphor/lib/algorithm/searching';
	 *
	 * function numberCmp(a: number, b: number): number {
	 *   return a - b;
	 * }
	 *
	 * min([7, 4, 0, 3, 9, 4], numberCmp);  // 0
	 * ```
	 */
	function min(object, fn) {
	    var it = iteration_1.iter(object);
	    var result = it.next();
	    if (result === void 0) {
	        return void 0;
	    }
	    var value;
	    while ((value = it.next()) !== void 0) {
	        if (fn(value, result) < 0) {
	            result = value;
	        }
	    }
	    return result;
	}
	exports.min = min;
	/**
	 * Find the maximum value in an iterable.
	 *
	 * @param object - The iterable or array-like object to search.
	 *
	 * @param fn - The 3-way comparison function to apply to the values.
	 *   It should return `< 0` if the first value is less than the second.
	 *   `0` if the values are equivalent, or `> 0` if the first value is
	 *   greater than the second.
	 *
	 * @returns The maximum value in the iterable. If multiple values are
	 *   equivalent to the maximum, the left-most value is returned. If
	 *   the iterable is empty, this returns `undefined`.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Example
	 * ```typescript
	 * import { max } from 'phosphor/lib/algorithm/searching';
	 *
	 * function numberCmp(a: number, b: number): number {
	 *   return a - b;
	 * }
	 *
	 * max([7, 4, 0, 3, 9, 4], numberCmp);  // 9
	 * ```
	 */
	function max(object, fn) {
	    var it = iteration_1.iter(object);
	    var result = it.next();
	    if (result === void 0) {
	        return void 0;
	    }
	    var value;
	    while ((value = it.next()) !== void 0) {
	        if (fn(value, result) > 0) {
	            result = value;
	        }
	    }
	    return result;
	}
	exports.max = max;
	/**
	 * Find the index of the first occurrence of a value in a sequence.
	 *
	 * @param object - The sequence or array-like object to search.
	 *
	 * @param value - The value to locate in the sequence. Values are
	 *   compared using strict `===` equality.
	 *
	 * @param fromIndex - The starting index of the search. The default
	 *   value is `0`.
	 *
	 * @returns The index of the first occurrence of the value, or `-1`
	 *   if the value is not found.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Undefined Behavior
	 * A `fromIndex` which is non-integral or `< 0`.
	 *
	 * #### Example
	 * ```typescript
	 * import { indexOf } from 'phosphor/lib/algorithm/searching';
	 *
	 * let data = ['one', 'two', 'three', 'four', 'one'];
	 * indexOf(data, 'red');     // -1
	 * indexOf(data, 'one');     // 0
	 * indexOf(data, 'one', 1);  // 4
	 * indexOf(data, 'two', 2);  // -1
	 * ```
	 */
	function indexOf(object, value, fromIndex) {
	    var length = object.length;
	    if (length === 0) {
	        return -1;
	    }
	    var start;
	    if (fromIndex === void 0) {
	        start = 0;
	    }
	    else {
	        start = fromIndex;
	    }
	    var seq = sequence_1.asSequence(object);
	    for (var i = start; i < length; ++i) {
	        if (seq.at(i) === value) {
	            return i;
	        }
	    }
	    return -1;
	}
	exports.indexOf = indexOf;
	/**
	 * Find the index of the last occurrence of a value in a sequence.
	 *
	 * @param object - The sequence or array-like object to search.
	 *
	 * @param value - The value to locate in the sequence. Values are
	 *   compared using strict `===` equality.
	 *
	 * @param fromIndex - The starting index of the search. The default
	 *   value is `length - 1`.
	 *
	 * @returns The index of the last occurrence of the value, or `-1`
	 *   if the value is not found.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Undefined Behavior
	 * A `fromIndex` which is non-integral or `>= length`.
	 *
	 * #### Example
	 * ```typescript
	 * import { lastIndexOf } from 'phosphor/lib/algorithm/searching';
	 *
	 * let data = ['one', 'two', 'three', 'four', 'one'];
	 * lastIndexOf(data, 'red');     // -1
	 * lastIndexOf(data, 'one');     // 4
	 * lastIndexOf(data, 'one', 1);  // 0
	 * lastIndexOf(data, 'two', 2);  // 1
	 * ```
	 */
	function lastIndexOf(object, value, fromIndex) {
	    var length = object.length;
	    if (length === 0) {
	        return -1;
	    }
	    var start;
	    if (fromIndex === void 0) {
	        start = length - 1;
	    }
	    else {
	        start = fromIndex;
	    }
	    var seq = sequence_1.asSequence(object);
	    for (var i = start; i >= 0; --i) {
	        if (seq.at(i) === value) {
	            return i;
	        }
	    }
	    return -1;
	}
	exports.lastIndexOf = lastIndexOf;
	/**
	 * Find the index of the first value which matches a predicate.
	 *
	 * @param object - The sequence or array-like object to search.
	 *
	 * @param fn - The predicate function to apply to the values.
	 *
	 * @param fromIndex - The starting index of the search. The default
	 *   value is `0`.
	 *
	 * @returns The index of the first matching value, or `-1` if no
	 *   matching value is found.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Undefined Behavior
	 * A `fromIndex` which is non-integral or `< 0`.
	 *
	 * Modifying the length of the sequence while searching.
	 *
	 * #### Example
	 * ```typescript
	 * import { findIndex } from 'phosphor/lib/algorithm/searching';
	 *
	 * function isEven(value: number): boolean {
	 *   return value % 2 === 0;
	 * }
	 *
	 * let data = [1, 2, 3, 4, 3, 2, 1];
	 * findIndex(data, isEven);     // 1
	 * findIndex(data, isEven, 4);  // 5
	 * findIndex(data, isEven, 6);  // -1
	 * ```
	 */
	function findIndex(object, fn, fromIndex) {
	    var length = object.length;
	    if (length === 0) {
	        return -1;
	    }
	    var start;
	    if (fromIndex === void 0) {
	        start = 0;
	    }
	    else {
	        start = fromIndex;
	    }
	    var seq = sequence_1.asSequence(object);
	    for (var i = start; i < length; ++i) {
	        if (fn(seq.at(i), i)) {
	            return i;
	        }
	    }
	    return -1;
	}
	exports.findIndex = findIndex;
	/**
	 * Find the index of the last value which matches a predicate.
	 *
	 * @param object - The sequence or array-like object to search.
	 *
	 * @param fn - The predicate function to apply to the values.
	 *
	 * @param fromIndex - The starting index of the search. The default
	 *   value is `length - 1`.
	 *
	 * @returns The index of the last matching value, or `-1` if no
	 *   matching value is found.
	 *
	 * #### Complexity
	 * Linear.
	 *
	 * #### Undefined Behavior
	 * A `fromIndex` which is non-integral or `>= length`.
	 *
	 * Modifying the length of the sequence while searching.
	 *
	 * #### Example
	 * ```typescript
	 * import { findLastIndex } from 'phosphor/lib/algorithm/searching';
	 *
	 * function isEven(value: number): boolean {
	 *   return value % 2 === 0;
	 * }
	 *
	 * let data = [1, 2, 3, 4, 3, 2, 1];
	 * findLastIndex(data, isEven);     // 5
	 * findLastIndex(data, isEven, 4);  // 3
	 * findLastIndex(data, isEven, 0);  // -1
	 * ```
	 */
	function findLastIndex(object, fn, fromIndex) {
	    var length = object.length;
	    if (length === 0) {
	        return -1;
	    }
	    var start;
	    if (fromIndex === void 0) {
	        start = length - 1;
	    }
	    else {
	        start = fromIndex;
	    }
	    var seq = sequence_1.asSequence(object);
	    for (var i = start; i >= 0; --i) {
	        if (fn(seq.at(i), i)) {
	            return i;
	        }
	    }
	    return -1;
	}
	exports.findLastIndex = findLastIndex;
	/**
	 * Find the index of the first element which compares `>=` to a value.
	 *
	 * @param sequence - The sequence or array-like object to search.
	 *   It must be sorted in ascending order.
	 *
	 * @param value - The value to locate in the sequence.
	 *
	 * @param fn - The 3-way comparison function to apply to the values.
	 *   It should return `< 0` if an element is less than a value, `0` if
	 *   an element is equal to a value, or `> 0` if an element is greater
	 *   than a value.
	 *
	 * @returns The index of the first element which compares `>=` to the
	 *   value, or `length` if there is no such element.
	 *
	 * #### Complexity
	 * Logarithmic.
	 *
	 * #### Undefined Behavior
	 * A sequence which is not sorted in ascending order.
	 *
	 * Modifying the length of the sequence while searching.
	 *
	 * #### Example
	 * ```typescript
	 * import { lowerBound } from 'phosphor/lib/algorithm/searching';
	 *
	 * function numberCmp(a: number, b: number): number {
	 *   return a - b;
	 * }
	 *
	 * let data = [0, 3, 4, 7, 7, 9];
	 * lowerBound(data, 0, numberCmp);   // 0
	 * lowerBound(data, 6, numberCmp);   // 3
	 * lowerBound(data, 7, numberCmp);   // 3
	 * lowerBound(data, -1, numberCmp);  // 0
	 * lowerBound(data, 10, numberCmp);  // 6
	 * ```
	 */
	function lowerBound(object, value, fn) {
	    var n = object.length;
	    if (n === 0) {
	        return 0;
	    }
	    var begin = 0;
	    var half;
	    var middle;
	    var seq = sequence_1.asSequence(object);
	    while (n > 0) {
	        half = n / 2 | 0;
	        middle = begin + half;
	        if (fn(seq.at(middle), value) < 0) {
	            begin = middle + 1;
	            n -= half + 1;
	        }
	        else {
	            n = half;
	        }
	    }
	    return begin;
	}
	exports.lowerBound = lowerBound;
	/**
	 * Find the index of the first element which compares `>` than a value.
	 *
	 * @param sequence - The sequence or array-like object to search.
	 *   It must be sorted in ascending order.
	 *
	 * @param value - The value to locate in the sequence.
	 *
	 * @param fn - The 3-way comparison function to apply to the values.
	 *   It should return `< 0` if an element is less than a value, `0` if
	 *   an element is equal to a value, or `> 0` if an element is greater
	 *   than a value.
	 *
	 * @returns The index of the first element which compares `>` than the
	 *   value, or `length` if there is no such element.
	 *
	 * #### Complexity
	 * Logarithmic.
	 *
	 * #### Undefined Behavior
	 * A sequence which is not sorted in ascending order.
	 *
	 * Modifying the length of the sequence while searching.
	 *
	 * #### Example
	 * ```typescript
	 * import { upperBound } from 'phosphor/lib/algorithm/searching';
	 *
	 * function numberCmp(a: number, b: number): number {
	 *   return a - b;
	 * }
	 *
	 * let data = [0, 3, 4, 7, 7, 9];
	 * upperBound(data, 0, numberCmp);   // 1
	 * upperBound(data, 6, numberCmp);   // 3
	 * upperBound(data, 7, numberCmp);   // 5
	 * upperBound(data, -1, numberCmp);  // 0
	 * upperBound(data, 10, numberCmp);  // 6
	 * ```
	 */
	function upperBound(object, value, fn) {
	    var n = object.length;
	    if (n === 0) {
	        return 0;
	    }
	    var begin = 0;
	    var half;
	    var middle;
	    var seq = sequence_1.asSequence(object);
	    while (n > 0) {
	        half = n / 2 | 0;
	        middle = begin + half;
	        if (fn(seq.at(middle), value) > 0) {
	            n = half;
	        }
	        else {
	            begin = middle + 1;
	            n -= half + 1;
	        }
	    }
	    return begin;
	}
	exports.upperBound = upperBound;
	/**
	 * A namespace which holds string searching functionality.
	 */
	var StringSearch;
	(function (StringSearch) {
	    /**
	     * Compute the sum-of-squares match for the given search text.
	     *
	     * @param sourceText - The text which should be searched.
	     *
	     * @param queryText - The query text to locate in the source text.
	     *
	     * @returns The match result object, or `null` if there is no match.
	     *
	     * #### Complexity
	     * Linear on `sourceText`.
	     *
	     * #### Notes
	     * This scoring algorithm uses a sum-of-squares approach to determine
	     * the score. In order for there to be a match, all of the characters
	     * in `queryText` **must** appear in `sourceText` in order. The index
	     * of each matching character is squared and added to the score. This
	     * means that early and consecutive character matches are preferred.
	     *
	     * The character match is performed with strict equality. It is case
	     * sensitive and does not ignore whitespace. If those behaviors are
	     * required, the text should be transformed before scoring.
	     */
	    function sumOfSquares(sourceText, queryText) {
	        var score = 0;
	        var indices = new Array(queryText.length);
	        for (var i = 0, j = 0, n = queryText.length; i < n; ++i, ++j) {
	            j = sourceText.indexOf(queryText[i], j);
	            if (j === -1) {
	                return null;
	            }
	            indices[i] = j;
	            score += j * j;
	        }
	        return { score: score, indices: indices };
	    }
	    StringSearch.sumOfSquares = sumOfSquares;
	    /**
	     * Highlight the matched characters of a source string.
	     *
	     * @param source - The text which should be highlighted.
	     *
	     * @param indices - The indices of the matched characters. They must
	     *   appear in increasing order and must be in bounds of the source.
	     *
	     * @returns A string with interpolated `<mark>` tags.
	     */
	    function highlight(sourceText, indices) {
	        var k = 0;
	        var last = 0;
	        var result = '';
	        var n = indices.length;
	        while (k < n) {
	            var i = indices[k];
	            var j = indices[k];
	            while (++k < n && indices[k] === j + 1) {
	                j++;
	            }
	            var head = sourceText.slice(last, i);
	            var chunk = sourceText.slice(i, j + 1);
	            result += head + "<mark>" + chunk + "</mark>";
	            last = j + 1;
	        }
	        return result + sourceText.slice(last);
	    }
	    StringSearch.highlight = highlight;
	})(StringSearch = exports.StringSearch || (exports.StringSearch = {}));
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/algorithm/searching.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/collections/vector.js **/
jupyter.define('phosphor@0.6.1/lib/collections/vector.js', function (module, exports, __jupyter_require__) {
	"use strict";
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var iteration_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/iteration.js');
	/**
	 * A generic vector data structure.
	 */
	var Vector = (function () {
	    /**
	     * Construct a new vector.
	     *
	     * @param values - The initial values for the vector.
	     */
	    function Vector(values) {
	        var _this = this;
	        this._array = [];
	        if (values)
	            iteration_1.each(values, function (value) { _this.pushBack(value); });
	    }
	    Object.defineProperty(Vector.prototype, "isEmpty", {
	        /**
	         * Test whether the vector is empty.
	         *
	         * @returns `true` if the vector is empty, `false` otherwise.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._array.length === 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vector.prototype, "length", {
	        /**
	         * Get the length of the vector.
	         *
	         * @return The number of values in the vector.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._array.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vector.prototype, "front", {
	        /**
	         * Get the value at the front of the vector.
	         *
	         * @returns The value at the front of the vector, or `undefined` if
	         *   the vector is empty.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._array[0];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vector.prototype, "back", {
	        /**
	         * Get the value at the back of the vector.
	         *
	         * @returns The value at the back of the vector, or `undefined` if
	         *   the vector is empty.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._array[this._array.length - 1];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create an iterator over the values in the vector.
	     *
	     * @returns A new iterator starting at the front of the vector.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * No changes.
	     */
	    Vector.prototype.iter = function () {
	        return new iteration_1.ArrayIterator(this._array, 0);
	    };
	    /**
	     * Get the value at the specified index.
	     *
	     * @param index - The positive integer index of interest.
	     *
	     * @returns The value at the specified index.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * No changes.
	     *
	     * #### Undefined Behavior
	     * An `index` which is non-integral or out of range.
	     */
	    Vector.prototype.at = function (index) {
	        return this._array[index];
	    };
	    /**
	     * Set the value at the specified index.
	     *
	     * @param index - The positive integer index of interest.
	     *
	     * @param value - The value to set at the specified index.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * No changes.
	     *
	     * #### Undefined Behavior
	     * An `index` which is non-integral or out of range.
	     */
	    Vector.prototype.set = function (index, value) {
	        this._array[index] = value;
	    };
	    /**
	     * Add a value to the back of the vector.
	     *
	     * @param value - The value to add to the back of the vector.
	     *
	     * @returns The new length of the vector.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * No changes.
	     */
	    Vector.prototype.pushBack = function (value) {
	        return this._array.push(value);
	    };
	    /**
	     * Remove and return the value at the back of the vector.
	     *
	     * @returns The value at the back of the vector, or `undefined` if
	     *   the vector is empty.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * Iterators pointing at the removed value are invalidated.
	     */
	    Vector.prototype.popBack = function () {
	        return this._array.pop();
	    };
	    /**
	     * Insert a value into the vector at a specific index.
	     *
	     * @param index - The index at which to insert the value.
	     *
	     * @param value - The value to set at the specified index.
	     *
	     * @returns The new length of the vector.
	     *
	     * #### Complexity
	     * Linear.
	     *
	     * #### Iterator Validity
	     * No changes.
	     *
	     * #### Notes
	     * The `index` will be clamped to the bounds of the vector.
	     *
	     * #### Undefined Behavior
	     * An `index` which is non-integral.
	     */
	    Vector.prototype.insert = function (index, value) {
	        var array = this._array;
	        var n = array.length;
	        index = Math.max(0, Math.min(index, n));
	        for (var i = n; i > index; --i) {
	            array[i] = array[i - 1];
	        }
	        array[index] = value;
	        return n + 1;
	    };
	    /**
	     * Remove the first occurrence of a value from the vector.
	     *
	     * @param value - The value of interest.
	     *
	     * @returns The index of the removed value, or `-1` if the value
	     *   is not contained in the vector.
	     *
	     * #### Complexity
	     * Linear.
	     *
	     * #### Iterator Validity
	     * Iterators pointing at the removed value and beyond are invalidated.
	     *
	     * #### Notes
	     * Comparison is performed using strict `===` equality.
	     */
	    Vector.prototype.remove = function (value) {
	        var index = this._array.indexOf(value);
	        if (index !== -1)
	            this.removeAt(index);
	        return index;
	    };
	    /**
	     * Remove and return the value at a specific index.
	     *
	     * @param index - The index of the value of interest.
	     *
	     * @returns The value at the specified index, or `undefined` if the
	     *   index is out of range.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * Iterators pointing at the removed value and beyond are invalidated.
	     *
	     * #### Undefined Behavior
	     * An `index` which is non-integral.
	     */
	    Vector.prototype.removeAt = function (index) {
	        var array = this._array;
	        var n = array.length;
	        if (index < 0 || index >= n) {
	            return void 0;
	        }
	        var value = array[index];
	        for (var i = index + 1; i < n; ++i) {
	            array[i - 1] = array[i];
	        }
	        array.length = n - 1;
	        return value;
	    };
	    /**
	     * Remove all values from the vector.
	     *
	     * #### Complexity
	     * Linear.
	     *
	     * #### Iterator Validity
	     * All current iterators are invalidated.
	     */
	    Vector.prototype.clear = function () {
	        this._array.length = 0;
	    };
	    /**
	     * Swap the contents of the vector with the contents of another.
	     *
	     * @param other - The other vector holding the contents to swap.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * All current iterators remain valid, but will now point to the
	     * contents of the other vector involved in the swap.
	     */
	    Vector.prototype.swap = function (other) {
	        var array = other._array;
	        other._array = this._array;
	        this._array = array;
	    };
	    return Vector;
	}());
	exports.Vector = Vector;
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/collections/vector.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/core/messaging.js **/
jupyter.define('phosphor@0.6.1/lib/core/messaging.js', function (module, exports, __jupyter_require__) {
	/* WEBPACK VAR INJECTION */(function(setImmediate) {"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var iteration_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/iteration.js');
	var queue_1 = __jupyter_require__('phosphor@~0.6.1/lib/collections/queue.js');
	/**
	 * A message which can be delivered to a message handler.
	 *
	 * #### Notes
	 * This class may be subclassed to create complex message types.
	 *
	 * **See also:** [[postMessage]] and [[sendMessage]].
	 */
	var Message = (function () {
	    /**
	     * Construct a new message.
	     *
	     * @param type - The type of the message.
	     */
	    function Message(type) {
	        this._type = type;
	    }
	    Object.defineProperty(Message.prototype, "type", {
	        /**
	         * The type of the message.
	         *
	         * #### Notes
	         * This value can be used to cast the message to a derived type.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._type;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Message.prototype, "isConflatable", {
	        /**
	         * Test whether the message is conflatable.
	         *
	         * #### Notes
	         * Message conflation is an advanced topic. Most message types will
	         * not make use of this feature.
	         *
	         * If a conflatable message is posted to the event queue when another
	         * conflatable message of the same type and handler has already been
	         * posted, the `conflate()` method of the existing message will be
	         * invoked. If that method returns `true`, the new message will not
	         * be enqueued. This allows messages to be compressed, so that only
	         * a single instance of the message type is processed per cycle, no
	         * matter how many times messages of that type are posted.
	         *
	         * Custom message types may reimplement this property. The default
	         * implementation is always `false`.
	         *
	         * This is a read-only property.
	         *
	         * **See also:** [[conflateMessage]]
	         */
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Conflate this message with another message of the same `type`.
	     *
	     * @param other - A conflatable message of the same `type`.
	     *
	     * @returns `true` if the message was successfully conflated, or
	     *   `false` otherwise.
	     *
	     * #### Notes
	     * Message conflation is an advanced topic. Most message types will
	     * not make use of this feature.
	     *
	     * This method is called automatically by the message loop when the
	     * given message is posted to the handler paired with this message.
	     * This message will already be enqueued and conflatable, and the
	     * given message will have the same `type` and also be conflatable.
	     *
	     * This method should merge the state of the other message into this
	     * message as needed so that when this message is finally delivered
	     * to the handler, it receives the most up-to-date information.
	     *
	     * If this method returns `true`, it signals that the other message
	     * was successfully conflated and it will not be enqueued.
	     *
	     * If this method returns `false`, the other message will be enqueued
	     * for normal delivery.
	     *
	     * Custom message types may reimplement this method. The default
	     * implementation always returns `false`.
	     *
	     * **See also:** [[isConflatable]]
	     */
	    Message.prototype.conflate = function (other) {
	        return false;
	    };
	    return Message;
	}());
	exports.Message = Message;
	/**
	 * A convenience message class which conflates automatically.
	 *
	 * #### Notes
	 * Message conflation is an advanced topic. Most user code will not
	 * make use of this class.
	 *
	 * This message class is useful for creating message instances which
	 * should be conflated, but which have no state other than `type`.
	 *
	 * If conflation of stateful messages is required, a custom `Message`
	 * subclass should be created.
	 */
	var ConflatableMessage = (function (_super) {
	    __extends(ConflatableMessage, _super);
	    function ConflatableMessage() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ConflatableMessage.prototype, "isConflatable", {
	        /**
	         * Test whether the message is conflatable.
	         *
	         * #### Notes
	         * This property is always `true`.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Conflate this message with another message of the same `type`.
	     *
	     * #### Notes
	     * This method always returns `true`.
	     */
	    ConflatableMessage.prototype.conflate = function (other) {
	        return true;
	    };
	    return ConflatableMessage;
	}(Message));
	exports.ConflatableMessage = ConflatableMessage;
	/**
	 * Send a message to a message handler to process immediately.
	 *
	 * @param handler - The handler which should process the message.
	 *
	 * @param msg - The message to deliver to the handler.
	 *
	 * #### Notes
	 * The message will first be sent through any installed message hooks
	 * for the handler. If the message passes all hooks, it will then be
	 * delivered to the `processMessage` method of the handler.
	 *
	 * The message will not be conflated with pending posted messages.
	 *
	 * Exceptions in hooks and handlers will be caught and logged.
	 */
	function sendMessage(handler, msg) {
	    MessageLoop.sendMessage(handler, msg);
	}
	exports.sendMessage = sendMessage;
	/**
	 * Post a message to the message handler to process in the future.
	 *
	 * @param handler - The handler which should process the message.
	 *
	 * @param msg - The message to post to the handler.
	 *
	 * #### Notes
	 * The message will be conflated with the pending posted messages for
	 * the handler, if possible. If the message is not conflated, it will
	 * be queued for normal delivery on the next cycle of the event loop.
	 *
	 * Exceptions in hooks and handlers will be caught and logged.
	 */
	function postMessage(handler, msg) {
	    MessageLoop.postMessage(handler, msg);
	}
	exports.postMessage = postMessage;
	/**
	 * Install a message hook for a message handler.
	 *
	 * @param handler - The message handler of interest.
	 *
	 * @param hook - The message hook to install.
	 *
	 * #### Notes
	 * A message hook is invoked before a message is delivered to the
	 * handler. If the hook returns `false`, no other hooks will be
	 * invoked and the message will not be delivered to the handler.
	 *
	 * The most recently installed message hook is executed first.
	 *
	 * If the hook is already installed, it will be moved to the front.
	 *
	 * **See also:** [[removeMessageHook]]
	 */
	function installMessageHook(handler, hook) {
	    MessageLoop.installMessageHook(handler, hook);
	}
	exports.installMessageHook = installMessageHook;
	/**
	 * Remove an installed message hook for a message handler.
	 *
	 * @param handler - The message handler of interest.
	 *
	 * @param hook - The message hook to remove.
	 *
	 * #### Notes
	 * If the hook is not installed, this is a no-op.
	 *
	 * It is safe to call this function while the hook is executing.
	 */
	function removeMessageHook(handler, hook) {
	    MessageLoop.removeMessageHook(handler, hook);
	}
	exports.removeMessageHook = removeMessageHook;
	/**
	 * Clear all message data associated with a message handler.
	 *
	 * @param handler - The message handler of interest.
	 *
	 * #### Notes
	 * This will clear all pending messages and hooks for the handler.
	 */
	function clearMessageData(handler) {
	    MessageLoop.clearMessageData(handler);
	}
	exports.clearMessageData = clearMessageData;
	/**
	 * The namespace for the global singleton message loop.
	 */
	var MessageLoop;
	(function (MessageLoop) {
	    /**
	     * Send a message to a handler for immediate processing.
	     *
	     * This will first call all message hooks for the handler. If any
	     * hook rejects the message, the message will not be delivered.
	     */
	    function sendMessage(handler, msg) {
	        // Handle the common case of no message hooks.
	        var node = hooks.get(handler);
	        if (node === void 0) {
	            invokeHandler(handler, msg);
	            return;
	        }
	        // Run the message hooks and bail early if any hook returns false.
	        // A null hook indicates the hook was removed during dispatch.
	        for (; node !== null; node = node.next) {
	            if (node.hook !== null && !invokeHook(node.hook, handler, msg)) {
	                return;
	            }
	        }
	        // All message hooks returned true, so invoke the handler.
	        invokeHandler(handler, msg);
	    }
	    MessageLoop.sendMessage = sendMessage;
	    /**
	     * Post a message to a handler for processing in the future.
	     *
	     * This will first conflate the message, if possible. If it cannot
	     * be conflated, it will be queued for delivery on the next cycle
	     * of the event loop.
	     */
	    function postMessage(handler, msg) {
	        // Handle the common case a non-conflatable message first.
	        if (!msg.isConflatable) {
	            enqueueMessage(handler, msg);
	            return;
	        }
	        // Conflate message if possible.
	        var conflated = iteration_1.some(queue, function (posted) {
	            if (posted.handler !== handler) {
	                return false;
	            }
	            if (posted.msg.type !== msg.type) {
	                return false;
	            }
	            if (!posted.msg.isConflatable) {
	                return false;
	            }
	            return posted.msg.conflate(msg);
	        });
	        // If the message was not conflated, enqueue the message.
	        if (!conflated)
	            enqueueMessage(handler, msg);
	    }
	    MessageLoop.postMessage = postMessage;
	    /**
	     * Install a message hook for a handler.
	     *
	     * This will first remove the hook if it exists, then install the
	     * hook in front of other hooks for the handler.
	     */
	    function installMessageHook(handler, hook) {
	        // Remove the message hook if it's already installed.
	        removeMessageHook(handler, hook);
	        // Install the hook at the front of the list.
	        var next = hooks.get(handler) || null;
	        hooks.set(handler, { next: next, hook: hook });
	    }
	    MessageLoop.installMessageHook = installMessageHook;
	    /**
	     * Remove a message hook for a handler, if it exists.
	     */
	    function removeMessageHook(handler, hook) {
	        // Traverse the list and find the matching hook. If found, clear
	        // the reference to the hook and remove the node from the list.
	        // The node's next reference is *not* cleared so that dispatch
	        // may continue when the hook is removed during dispatch.
	        var prev = null;
	        var node = hooks.get(handler) || null;
	        for (; node !== null; prev = node, node = node.next) {
	            if (node.hook === hook) {
	                if (prev === null && node.next === null) {
	                    hooks.delete(handler);
	                }
	                else if (prev === null) {
	                    hooks.set(handler, node.next);
	                }
	                else {
	                    prev.next = node.next;
	                }
	                node.hook = null;
	                return;
	            }
	        }
	    }
	    MessageLoop.removeMessageHook = removeMessageHook;
	    /**
	     * Clear all message data for a handler.
	     *
	     * This will remove all message hooks and clear pending messages.
	     */
	    function clearMessageData(handler) {
	        // Clear all message hooks.
	        var node = hooks.get(handler) || null;
	        for (; node !== null; node = node.next) {
	            node.hook = null;
	        }
	        // Remove the handler from the hooks map.
	        hooks.delete(handler);
	        // Clear all pending messages.
	        iteration_1.each(queue, function (posted) {
	            if (posted.handler === handler) {
	                posted.handler = null;
	            }
	        });
	    }
	    MessageLoop.clearMessageData = clearMessageData;
	    /**
	     * The queue of posted message pairs.
	     */
	    var queue = new queue_1.Queue();
	    /**
	     * A mapping of handler to list of installed message hooks.
	     */
	    var hooks = new WeakMap();
	    /**
	     * A local reference to an event loop callback.
	     */
	    var defer = (function () {
	        var ok = typeof requestAnimationFrame === 'function';
	        return ok ? requestAnimationFrame : setImmediate;
	    })();
	    /**
	     * Whether a message loop cycle is pending.
	     */
	    var cyclePending = false;
	    /**
	     * Invoke a message hook with the specified handler and message.
	     *
	     * Returns the result of the hook, or `true` if the hook throws.
	     *
	     * Exceptions in the hook will be caught and logged.
	     */
	    function invokeHook(hook, handler, msg) {
	        var result;
	        try {
	            result = hook(handler, msg);
	        }
	        catch (err) {
	            result = true;
	            console.error(err);
	        }
	        return result;
	    }
	    /**
	     * Invoke a message handler with the specified message.
	     *
	     * Exceptions in the handler will be caught and logged.
	     */
	    function invokeHandler(handler, msg) {
	        try {
	            handler.processMessage(msg);
	        }
	        catch (err) {
	            console.error(err);
	        }
	    }
	    /**
	     * Add a message to the end of the message queue.
	     *
	     * This will automatically schedule a cycle of the loop.
	     */
	    function enqueueMessage(handler, msg) {
	        queue.pushBack({ handler: handler, msg: msg });
	        scheduleMessageLoop();
	    }
	    /**
	     * Schedule a message loop cycle to process any pending messages.
	     *
	     * This is a no-op if a loop cycle is already pending.
	     */
	    function scheduleMessageLoop() {
	        if (!cyclePending) {
	            defer(runMessageLoop);
	            cyclePending = true;
	        }
	    }
	    /**
	     * Run an iteration of the message loop.
	     *
	     * This will process all pending messages in the queue. If a message
	     * is added to the queue while the message loop is running, it will
	     * be processed on the next cycle of the loop.
	     */
	    function runMessageLoop() {
	        // Clear the pending flag so the next loop can be scheduled.
	        cyclePending = false;
	        // If the queue is empty, there is nothing else to do.
	        if (queue.isEmpty) {
	            return;
	        }
	        // Add a sentinel value to the end of the queue. The queue will
	        // only be processed up to the sentinel. Messages posted during
	        // this cycle will execute on the next cycle.
	        var sentinel = { handler: null, msg: null };
	        queue.pushBack(sentinel);
	        // Enter the message loop.
	        while (!queue.isEmpty) {
	            // Remove the first posted message in the queue.
	            var posted = queue.popFront();
	            // If the value is the sentinel, exit the loop.
	            if (posted === sentinel) {
	                return;
	            }
	            // Dispatch the message if the handler has not been cleared.
	            if (posted.handler !== null) {
	                sendMessage(posted.handler, posted.msg);
	            }
	        }
	    }
	})(MessageLoop || (MessageLoop = {}));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __jupyter_require__('timers-browserify@1.4.2/main.js').setImmediate))
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/core/messaging.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/collections/queue.js **/
jupyter.define('phosphor@0.6.1/lib/collections/queue.js', function (module, exports, __jupyter_require__) {
	"use strict";
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var iteration_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/iteration.js');
	/**
	 * A generic FIFO queue data structure.
	 */
	var Queue = (function () {
	    /**
	     * Construct a new queue.
	     *
	     * @param values - The initial values for the queue.
	     */
	    function Queue(values) {
	        var _this = this;
	        this._length = 0;
	        this._front = null;
	        this._back = null;
	        if (values)
	            iteration_1.each(values, function (value) { _this.pushBack(value); });
	    }
	    Object.defineProperty(Queue.prototype, "isEmpty", {
	        /**
	         * Test whether the queue is empty.
	         *
	         * @returns `true` if the queue is empty, `false` otherwise.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._length === 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Queue.prototype, "length", {
	        /**
	         * Get the length of the queue.
	         *
	         * @return The number of values in the queue.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Queue.prototype, "front", {
	        /**
	         * Get the value at the front of the queue.
	         *
	         * @returns The value at the front of the queue, or `undefined` if
	         *   the queue is empty.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._front ? this._front.value : void 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Queue.prototype, "back", {
	        /**
	         * Get the value at the back of the queue.
	         *
	         * @returns The value at the back of the queue, or `undefined` if
	         *   the queue is empty.
	         *
	         * #### Notes
	         * This is a read-only property.
	         *
	         * #### Complexity
	         * Constant.
	         *
	         * #### Iterator Validity
	         * No changes.
	         */
	        get: function () {
	            return this._back ? this._back.value : void 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create an iterator over the values in the queue.
	     *
	     * @returns A new iterator starting at the front of the queue.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * No changes.
	     */
	    Queue.prototype.iter = function () {
	        return new QueueIterator(this._front);
	    };
	    /**
	     * Add a value to the back of the queue.
	     *
	     * @param value - The value to add to the back of the queue.
	     *
	     * @returns The new length of the queue.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * No changes.
	     */
	    Queue.prototype.pushBack = function (value) {
	        var node = new QueueNode(value);
	        if (this._length === 0) {
	            this._front = node;
	            this._back = node;
	        }
	        else {
	            this._back.next = node;
	            this._back = node;
	        }
	        return ++this._length;
	    };
	    /**
	     * Remove and return the value at the front of the queue.
	     *
	     * @returns The value at the front of the queue, or `undefined` if
	     *   the queue is empty.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * Iterators pointing at the removed value are invalidated.
	     */
	    Queue.prototype.popFront = function () {
	        if (this._length === 0) {
	            return void 0;
	        }
	        var node = this._front;
	        if (this._length === 1) {
	            this._front = null;
	            this._back = null;
	        }
	        else {
	            this._front = node.next;
	            node.next = null;
	        }
	        this._length--;
	        return node.value;
	    };
	    /**
	     * Remove all values from the queue.
	     *
	     * #### Complexity
	     * Linear.
	     *
	     * #### Iterator Validity
	     * All current iterators are invalidated.
	     */
	    Queue.prototype.clear = function () {
	        var node = this._front;
	        while (node) {
	            var next = node.next;
	            node.next = null;
	            node = next;
	        }
	        this._length = 0;
	        this._front = null;
	        this._back = null;
	    };
	    /**
	     * Swap the contents of the queue with the contents of another.
	     *
	     * @param other - The other queue holding the contents to swap.
	     *
	     * #### Complexity
	     * Constant.
	     *
	     * #### Iterator Validity
	     * All current iterators remain valid, but will now point to the
	     * contents of the other queue involved in the swap.
	     */
	    Queue.prototype.swap = function (other) {
	        var length = other._length;
	        var front = other._front;
	        var back = other._back;
	        other._length = this._length;
	        other._front = this._front;
	        other._back = this._back;
	        this._length = length;
	        this._front = front;
	        this._back = back;
	    };
	    return Queue;
	}());
	exports.Queue = Queue;
	/**
	 * An iterator for a queue.
	 */
	var QueueIterator = (function () {
	    /**
	     * Construct a new queue iterator.
	     *
	     * @param node - The node at the front of range.
	     */
	    function QueueIterator(node) {
	        this._node = node;
	    }
	    /**
	     * Create an iterator over the object's values.
	     *
	     * @returns A reference to `this` iterator.
	     */
	    QueueIterator.prototype.iter = function () {
	        return this;
	    };
	    /**
	     * Create an independent clone of the queue iterator.
	     *
	     * @returns A new iterator starting with the current value.
	     */
	    QueueIterator.prototype.clone = function () {
	        return new QueueIterator(this._node);
	    };
	    /**
	     * Get the next value from the queue.
	     *
	     * @returns The next value from the queue, or `undefined` if the
	     *   iterator is exhausted.
	     */
	    QueueIterator.prototype.next = function () {
	        if (!this._node) {
	            return void 0;
	        }
	        var value = this._node.value;
	        this._node = this._node.next;
	        return value;
	    };
	    return QueueIterator;
	}());
	/**
	 * The node type for a queue.
	 */
	var QueueNode = (function () {
	    /**
	     * Construct a new queue node.
	     *
	     * @param value - The value for the node.
	     */
	    function QueueNode(value) {
	        /**
	         * The next node the queue.
	         */
	        this.next = null;
	        this.value = value;
	    }
	    return QueueNode;
	}());
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/collections/queue.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/ui/widget.js **/
jupyter.define('phosphor@0.6.1/lib/ui/widget.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var iteration_1 = __jupyter_require__('phosphor@~0.6.1/lib/algorithm/iteration.js');
	var messaging_1 = __jupyter_require__('phosphor@~0.6.1/lib/core/messaging.js');
	var properties_1 = __jupyter_require__('phosphor@~0.6.1/lib/core/properties.js');
	var signaling_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/signaling.js');
	var title_1 = __jupyter_require__('phosphor@~0.6.1/lib/ui/title.js');
	/**
	 * The class name added to Widget instances.
	 */
	var WIDGET_CLASS = 'p-Widget';
	/**
	 * The class name added to hidden widgets.
	 */
	var HIDDEN_CLASS = 'p-mod-hidden';
	/**
	 * The base class of the Phosphor widget hierarchy.
	 *
	 * #### Notes
	 * This class will typically be subclassed in order to create a useful
	 * widget. However, it can be used directly to host externally created
	 * content.
	 */
	var Widget = (function () {
	    /**
	     * Construct a new widget.
	     *
	     * @param options - The options for initializing the widget.
	     */
	    function Widget(options) {
	        if (options === void 0) { options = {}; }
	        this._flags = 0;
	        this._layout = null;
	        this._parent = null;
	        this._node = Private.createNode(options);
	        this.addClass(WIDGET_CLASS);
	    }
	    /**
	     * Dispose of the widget and its descendant widgets.
	     *
	     * #### Notes
	     * It is unsafe to use the widget after it has been disposed.
	     *
	     * All calls made to this method after the first are a no-op.
	     */
	    Widget.prototype.dispose = function () {
	        // Do nothing if the widget is already disposed.
	        if (this.isDisposed) {
	            return;
	        }
	        // Set the disposed flag and emit the disposed signal.
	        this.setFlag(WidgetFlag.IsDisposed);
	        this.disposed.emit(void 0);
	        // Remove or detach the widget if necessary.
	        if (this.parent) {
	            this.parent = null;
	        }
	        else if (this.isAttached) {
	            Widget.detach(this);
	        }
	        // Dispose of the widget layout.
	        if (this._layout) {
	            this._layout.dispose();
	            this._layout = null;
	        }
	        // Clear the attached data associated with the widget.
	        signaling_1.clearSignalData(this);
	        messaging_1.clearMessageData(this);
	        properties_1.clearPropertyData(this);
	        // Clear the reference to the DOM node.
	        this._node = null;
	    };
	    Object.defineProperty(Widget.prototype, "isDisposed", {
	        /**
	         * Test whether the widget has been disposed.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this.testFlag(WidgetFlag.IsDisposed);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "isAttached", {
	        /**
	         * Test whether the widget's node is attached to the DOM.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this.testFlag(WidgetFlag.IsAttached);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "isHidden", {
	        /**
	         * Test whether the widget is explicitly hidden.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this.testFlag(WidgetFlag.IsHidden);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "isVisible", {
	        /**
	         * Test whether the widget is visible.
	         *
	         * #### Notes
	         * A widget is visible when it is attached to the DOM, is not
	         * explicitly hidden, and has no explicitly hidden ancestors.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return this.testFlag(WidgetFlag.IsVisible);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "node", {
	        /**
	         * Get the DOM node owned by the widget.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._node;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "id", {
	        /**
	         * Get the id of the widget's DOM node.
	         */
	        get: function () {
	            return this._node.id;
	        },
	        /**
	         * Set the id of the widget's DOM node.
	         */
	        set: function (value) {
	            this._node.id = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "title", {
	        /**
	         * Get the title object for the widget.
	         *
	         * #### Notes
	         * The title object is used by some container widgets when displaying
	         * the widget alongside some title, such as a tab panel or side bar.
	         *
	         * Since not all widgets will use the title, it is created on demand.
	         *
	         * The `owner` property of the title is set to this widget.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return Private.titleProperty.get(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "parent", {
	        /**
	         * Get the parent of the widget.
	         *
	         * #### Notes
	         * This will be `null` if the widget does not have a parent.
	         */
	        get: function () {
	            return this._parent;
	        },
	        /**
	         * Set the parent of the widget.
	         *
	         * #### Notes
	         * Children are typically added to a widget by using a layout, which
	         * means user code will not normally set the parent widget directly.
	         *
	         * The widget will be automatically removed from its old parent.
	         *
	         * This is a no-op if there is no effective parent change.
	         */
	        set: function (value) {
	            value = value || null;
	            if (this._parent === value) {
	                return;
	            }
	            if (value && this.contains(value)) {
	                throw new Error('Invalid parent widget.');
	            }
	            if (this._parent && !this._parent.isDisposed) {
	                messaging_1.sendMessage(this._parent, new ChildMessage('child-removed', this));
	            }
	            this._parent = value;
	            if (this._parent && !this._parent.isDisposed) {
	                messaging_1.sendMessage(this._parent, new ChildMessage('child-added', this));
	            }
	            messaging_1.sendMessage(this, WidgetMessage.ParentChanged);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Widget.prototype, "layout", {
	        /**
	         * Get the layout for the widget.
	         *
	         * #### Notes
	         * This will be `null` if the widget does not have a layout.
	         */
	        get: function () {
	            return this._layout;
	        },
	        /**
	         * Set the layout for the widget.
	         *
	         * #### Notes
	         * The layout is single-use only. It cannot be set to `null` and it
	         * cannot be changed after the first assignment.
	         *
	         * The layout is disposed automatically when the widget is disposed.
	         */
	        set: function (value) {
	            value = value || null;
	            if (this._layout === value) {
	                return;
	            }
	            if (this.testFlag(WidgetFlag.DisallowLayout)) {
	                throw new Error('Cannot set widget layout.');
	            }
	            if (this._layout) {
	                throw new Error('Cannot change widget layout.');
	            }
	            if (value.parent) {
	                throw new Error('Cannot change layout parent.');
	            }
	            this._layout = value;
	            value.parent = this;
	            messaging_1.sendMessage(this, WidgetMessage.LayoutChanged);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create an iterator over the widget's children.
	     *
	     * @returns A new iterator over the children of the widget.
	     *
	     * #### Notes
	     * The widget must have a populated layout in order to have children.
	     *
	     * If a layout is not installed, the returned iterator will be empty.
	     */
	    Widget.prototype.children = function () {
	        return iteration_1.iter(this._layout || iteration_1.EmptyIterator.instance);
	    };
	    /**
	     * Test whether a widget is a descendant of this widget.
	     *
	     * @param widget - The descendant widget of interest.
	     *
	     * @returns `true` if the widget is a descendant, `false` otherwise.
	     */
	    Widget.prototype.contains = function (widget) {
	        for (; widget; widget = widget._parent) {
	            if (widget === this)
	                return true;
	        }
	        return false;
	    };
	    /**
	     * Test whether the widget's DOM node has the given class name.
	     *
	     * @param name - The class name of interest.
	     *
	     * @returns `true` if the node has the class, `false` otherwise.
	     */
	    Widget.prototype.hasClass = function (name) {
	        return this._node.classList.contains(name);
	    };
	    /**
	     * Add a class name to the widget's DOM node.
	     *
	     * @param name - The class name to add to the node.
	     *
	     * #### Notes
	     * If the class name is already added to the node, this is a no-op.
	     *
	     * The class name must not contain whitespace.
	     */
	    Widget.prototype.addClass = function (name) {
	        this._node.classList.add(name);
	    };
	    /**
	     * Remove a class name from the widget's DOM node.
	     *
	     * @param name - The class name to remove from the node.
	     *
	     * #### Notes
	     * If the class name is not yet added to the node, this is a no-op.
	     *
	     * The class name must not contain whitespace.
	     */
	    Widget.prototype.removeClass = function (name) {
	        this._node.classList.remove(name);
	    };
	    /**
	     * Toggle a class name on the widget's DOM node.
	     *
	     * @param name - The class name to toggle on the node.
	     *
	     * @param force - Whether to force add the class (`true`) or force
	     *   remove the class (`false`). If not provided, the presence of
	     *   the class will be toggled from its current state.
	     *
	     * @returns `true` if the class is now present, `false` otherwise.
	     *
	     * #### Notes
	     * The class name must not contain whitespace.
	     */
	    Widget.prototype.toggleClass = function (name, force) {
	        if (force === true) {
	            this._node.classList.add(name);
	            return true;
	        }
	        if (force === false) {
	            this._node.classList.remove(name);
	            return false;
	        }
	        return this._node.classList.toggle(name);
	    };
	    /**
	     * Post an `'update-request'` message to the widget.
	     *
	     * #### Notes
	     * This is a simple convenience method for posting the message.
	     */
	    Widget.prototype.update = function () {
	        messaging_1.postMessage(this, WidgetMessage.UpdateRequest);
	    };
	    /**
	     * Post a `'fit-request'` message to the widget.
	     *
	     * #### Notes
	     * This is a simple convenience method for posting the message.
	     */
	    Widget.prototype.fit = function () {
	        messaging_1.postMessage(this, WidgetMessage.FitRequest);
	    };
	    /**
	     * Post an `'activate-request'` message to the widget.
	     *
	     * #### Notes
	     * This is a simple convenience method for posting the message.
	     */
	    Widget.prototype.activate = function () {
	        messaging_1.postMessage(this, WidgetMessage.ActivateRequest);
	    };
	    /**
	     * Post a `'deactivate-request'` message to the widget.
	     *
	     * #### Notes
	     * This is a simple convenience method for posting the message.
	     */
	    Widget.prototype.deactivate = function () {
	        messaging_1.postMessage(this, WidgetMessage.DeactivateRequest);
	    };
	    /**
	     * Send a `'close-request'` message to the widget.
	     *
	     * #### Notes
	     * This is a simple convenience method for sending the message.
	     */
	    Widget.prototype.close = function () {
	        messaging_1.sendMessage(this, WidgetMessage.CloseRequest);
	    };
	    /**
	     * Show the widget and make it visible to its parent widget.
	     *
	     * #### Notes
	     * This causes the [[isHidden]] property to be `false`.
	     *
	     * If the widget is not explicitly hidden, this is a no-op.
	     */
	    Widget.prototype.show = function () {
	        if (!this.testFlag(WidgetFlag.IsHidden)) {
	            return;
	        }
	        this.clearFlag(WidgetFlag.IsHidden);
	        this.removeClass(HIDDEN_CLASS);
	        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
	            messaging_1.sendMessage(this, WidgetMessage.AfterShow);
	        }
	        if (this.parent) {
	            messaging_1.sendMessage(this.parent, new ChildMessage('child-shown', this));
	        }
	    };
	    /**
	     * Hide the widget and make it hidden to its parent widget.
	     *
	     * #### Notes
	     * This causes the [[isHidden]] property to be `true`.
	     *
	     * If the widget is explicitly hidden, this is a no-op.
	     */
	    Widget.prototype.hide = function () {
	        if (this.testFlag(WidgetFlag.IsHidden)) {
	            return;
	        }
	        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
	            messaging_1.sendMessage(this, WidgetMessage.BeforeHide);
	        }
	        this.setFlag(WidgetFlag.IsHidden);
	        this.addClass(HIDDEN_CLASS);
	        if (this.parent) {
	            messaging_1.sendMessage(this.parent, new ChildMessage('child-hidden', this));
	        }
	    };
	    /**
	     * Show or hide the widget according to a boolean value.
	     *
	     * @param hidden - `true` to hide the widget, or `false` to show it.
	     *
	     * #### Notes
	     * This is a convenience method for `hide()` and `show()`.
	     */
	    Widget.prototype.setHidden = function (hidden) {
	        if (hidden) {
	            this.hide();
	        }
	        else {
	            this.show();
	        }
	    };
	    /**
	     * Test whether the given widget flag is set.
	     *
	     * #### Notes
	     * This will not typically be called directly by user code.
	     */
	    Widget.prototype.testFlag = function (flag) {
	        return (this._flags & flag) !== 0;
	    };
	    /**
	     * Set the given widget flag.
	     *
	     * #### Notes
	     * This will not typically be called directly by user code.
	     */
	    Widget.prototype.setFlag = function (flag) {
	        this._flags |= flag;
	    };
	    /**
	     * Clear the given widget flag.
	     *
	     * #### Notes
	     * This will not typically be called directly by user code.
	     */
	    Widget.prototype.clearFlag = function (flag) {
	        this._flags &= ~flag;
	    };
	    /**
	     * Process a message sent to the widget.
	     *
	     * @param msg - The message sent to the widget.
	     *
	     * #### Notes
	     * Subclasses may reimplement this method as needed.
	     */
	    Widget.prototype.processMessage = function (msg) {
	        switch (msg.type) {
	            case 'resize':
	                this.notifyLayout(msg);
	                this.onResize(msg);
	                break;
	            case 'update-request':
	                this.notifyLayout(msg);
	                this.onUpdateRequest(msg);
	                break;
	            case 'after-show':
	                this.setFlag(WidgetFlag.IsVisible);
	                this.notifyLayout(msg);
	                this.onAfterShow(msg);
	                break;
	            case 'before-hide':
	                this.notifyLayout(msg);
	                this.onBeforeHide(msg);
	                this.clearFlag(WidgetFlag.IsVisible);
	                break;
	            case 'after-attach':
	                var visible = !this.isHidden && (!this.parent || this.parent.isVisible);
	                if (visible)
	                    this.setFlag(WidgetFlag.IsVisible);
	                this.setFlag(WidgetFlag.IsAttached);
	                this.notifyLayout(msg);
	                this.onAfterAttach(msg);
	                break;
	            case 'before-detach':
	                this.notifyLayout(msg);
	                this.onBeforeDetach(msg);
	                this.clearFlag(WidgetFlag.IsVisible);
	                this.clearFlag(WidgetFlag.IsAttached);
	                break;
	            case 'activate-request':
	                this.notifyLayout(msg);
	                this.onActivateRequest(msg);
	                break;
	            case 'deactivate-request':
	                this.notifyLayout(msg);
	                this.onDeactivateRequest(msg);
	                break;
	            case 'close-request':
	                this.notifyLayout(msg);
	                this.onCloseRequest(msg);
	                break;
	            case 'child-added':
	                this.notifyLayout(msg);
	                this.onChildAdded(msg);
	                break;
	            case 'child-removed':
	                this.notifyLayout(msg);
	                this.onChildRemoved(msg);
	                break;
	            default:
	                this.notifyLayout(msg);
	                break;
	        }
	    };
	    /**
	     * Invoke the message processing routine of the widget's layout.
	     *
	     * @param msg - The message to dispatch to the layout.
	     *
	     * #### Notes
	     * This is a no-op if the widget does not have a layout.
	     *
	     * This will not typically be called directly by user code.
	     */
	    Widget.prototype.notifyLayout = function (msg) {
	        if (this._layout)
	            this._layout.processParentMessage(msg);
	    };
	    /**
	     * A message handler invoked on a `'close-request'` message.
	     *
	     * #### Notes
	     * The default implementation unparents or detaches the widget.
	     */
	    Widget.prototype.onCloseRequest = function (msg) {
	        if (this.parent) {
	            this.parent = null;
	        }
	        else if (this.isAttached) {
	            Widget.detach(this);
	        }
	    };
	    /**
	     * A message handler invoked on a `'resize'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onResize = function (msg) { };
	    /**
	     * A message handler invoked on an `'update-request'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onUpdateRequest = function (msg) { };
	    /**
	     * A message handler invoked on an `'activate-request'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onActivateRequest = function (msg) { };
	    /**
	     * A message handler invoked on a `'deactivate-request'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onDeactivateRequest = function (msg) { };
	    /**
	     * A message handler invoked on an `'after-show'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onAfterShow = function (msg) { };
	    /**
	     * A message handler invoked on a `'before-hide'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onBeforeHide = function (msg) { };
	    /**
	     * A message handler invoked on an `'after-attach'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onAfterAttach = function (msg) { };
	    /**
	     * A message handler invoked on a `'before-detach'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onBeforeDetach = function (msg) { };
	    /**
	     * A message handler invoked on a `'child-added'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onChildAdded = function (msg) { };
	    /**
	     * A message handler invoked on a `'child-removed'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Widget.prototype.onChildRemoved = function (msg) { };
	    return Widget;
	}());
	exports.Widget = Widget;
	// Define the signals for the `Widget` class.
	signaling_1.defineSignal(Widget.prototype, 'disposed');
	/**
	 * The namespace for the `Widget` class statics.
	 */
	var Widget;
	(function (Widget) {
	    // TODO - should this be an instance method?
	    /**
	     * Attach a widget to a host DOM node.
	     *
	     * @param widget - The widget of interest.
	     *
	     * @param host - The DOM node to use as the widget's host.
	     *
	     * #### Notes
	     * This will throw an error if the widget is not a root widget, if
	     * the widget is already attached, or if the host is not attached
	     * to the DOM.
	     */
	    function attach(widget, host) {
	        if (widget.parent) {
	            throw new Error('Cannot attach child widget.');
	        }
	        if (widget.isAttached || document.body.contains(widget.node)) {
	            throw new Error('Widget already attached.');
	        }
	        if (!document.body.contains(host)) {
	            throw new Error('Host not attached.');
	        }
	        host.appendChild(widget.node);
	        messaging_1.sendMessage(widget, WidgetMessage.AfterAttach);
	    }
	    Widget.attach = attach;
	    // TODO - should this be an instance method?
	    /**
	     * Detach the widget from its host DOM node.
	     *
	     * @param widget - The widget of interest.
	     *
	     * #### Notes
	     * This will throw an error if the widget is not a root widget, or
	     * if the widget is not attached to the DOM.
	     */
	    function detach(widget) {
	        if (widget.parent) {
	            throw new Error('Cannot detach child widget.');
	        }
	        if (!widget.isAttached || !document.body.contains(widget.node)) {
	            throw new Error('Widget not attached.');
	        }
	        messaging_1.sendMessage(widget, WidgetMessage.BeforeDetach);
	        widget.node.parentNode.removeChild(widget.node);
	    }
	    Widget.detach = detach;
	    /**
	     * Prepare a widget for absolute layout geometry.
	     *
	     * @param widget - The widget of interest.
	     *
	     * #### Notes
	     * This sets the inline style position of the widget to `absolute`.
	     */
	    function prepareGeometry(widget) {
	        widget.node.style.position = 'absolute';
	    }
	    Widget.prepareGeometry = prepareGeometry;
	    /**
	     * Reset the layout geometry of a widget.
	     *
	     * @param widget - The widget of interest.
	     *
	     * #### Notes
	     * This clears the inline style position and geometry of the widget.
	     */
	    function resetGeometry(widget) {
	        var style = widget.node.style;
	        var rect = Private.rectProperty.get(widget);
	        rect.top = NaN;
	        rect.left = NaN;
	        rect.width = NaN;
	        rect.height = NaN;
	        style.position = '';
	        style.top = '';
	        style.left = '';
	        style.width = '';
	        style.height = '';
	    }
	    Widget.resetGeometry = resetGeometry;
	    /**
	     * Set the absolute layout geometry of a widget.
	     *
	     * @param widget - The widget of interest.
	     *
	     * @param left - The desired offset left position of the widget.
	     *
	     * @param top - The desired offset top position of the widget.
	     *
	     * @param width - The desired offset width of the widget.
	     *
	     * @param height - The desired offset height of the widget.
	     *
	     * #### Notes
	     * All dimensions are assumed to be pixels with coordinates relative
	     * to the origin of the widget's offset parent.
	     *
	     * The widget's node is assumed to be position `absolute`.
	     *
	     * If the widget is resized from its previous size, a `ResizeMessage`
	     * will be automatically sent to the widget.
	     */
	    function setGeometry(widget, left, top, width, height) {
	        var resized = false;
	        var style = widget.node.style;
	        var rect = Private.rectProperty.get(widget);
	        if (rect.top !== top) {
	            rect.top = top;
	            style.top = top + "px";
	        }
	        if (rect.left !== left) {
	            rect.left = left;
	            style.left = left + "px";
	        }
	        if (rect.width !== width) {
	            resized = true;
	            rect.width = width;
	            style.width = width + "px";
	        }
	        if (rect.height !== height) {
	            resized = true;
	            rect.height = height;
	            style.height = height + "px";
	        }
	        if (resized) {
	            messaging_1.sendMessage(widget, new ResizeMessage(width, height));
	        }
	    }
	    Widget.setGeometry = setGeometry;
	})(Widget = exports.Widget || (exports.Widget = {}));
	/**
	 * An abstract base class for creating Phosphor layouts.
	 *
	 * #### Notes
	 * A layout is used to add widgets to a parent and to arrange those
	 * widgets within the parent's DOM node.
	 *
	 * This class implements the base functionality which is required of
	 * nearly all layouts. It must be subclassed in order to be useful.
	 *
	 * Notably, this class does not define a uniform interface for adding
	 * widgets to the layout. A subclass should define that API in a way
	 * which is meaningful for its intended use.
	 */
	var Layout = (function () {
	    function Layout() {
	        this._disposed = false;
	        this._parent = null;
	    }
	    /**
	     * Dispose of the resources held by the layout.
	     *
	     * #### Notes
	     * This should be reimplemented to clear and dispose of the widgets.
	     *
	     * All reimplementations should call the superclass method.
	     *
	     * This method is called automatically when the parent is disposed.
	     */
	    Layout.prototype.dispose = function () {
	        this._disposed = true;
	        this._parent = null;
	        signaling_1.clearSignalData(this);
	        properties_1.clearPropertyData(this);
	    };
	    Object.defineProperty(Layout.prototype, "isDisposed", {
	        /**
	         * Test whether the layout is disposed.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._disposed;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Layout.prototype, "parent", {
	        /**
	         * Get the parent widget of the layout.
	         */
	        get: function () {
	            return this._parent;
	        },
	        /**
	         * Set the parent widget of the layout.
	         *
	         * #### Notes
	         * This is set automatically when installing the layout on the parent
	         * widget. The parent widget should not be set directly by user code.
	         */
	        set: function (value) {
	            if (!value) {
	                throw new Error('Cannot set parent widget to null.');
	            }
	            if (this._parent === value) {
	                return;
	            }
	            if (this._parent) {
	                throw new Error('Cannot change parent widget.');
	            }
	            if (value.layout !== this) {
	                throw new Error('Invalid parent widget.');
	            }
	            this._parent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Process a message sent to the parent widget.
	     *
	     * @param msg - The message sent to the parent widget.
	     *
	     * #### Notes
	     * This method is called by the parent widget to process a message.
	     *
	     * Subclasses may reimplement this method as needed.
	     */
	    Layout.prototype.processParentMessage = function (msg) {
	        switch (msg.type) {
	            case 'resize':
	                this.onResize(msg);
	                break;
	            case 'update-request':
	                this.onUpdateRequest(msg);
	                break;
	            case 'fit-request':
	                this.onFitRequest(msg);
	                break;
	            case 'after-show':
	                this.onAfterShow(msg);
	                break;
	            case 'before-hide':
	                this.onBeforeHide(msg);
	                break;
	            case 'after-attach':
	                this.onAfterAttach(msg);
	                break;
	            case 'before-detach':
	                this.onBeforeDetach(msg);
	                break;
	            case 'child-removed':
	                this.onChildRemoved(msg);
	                break;
	            case 'child-shown':
	                this.onChildShown(msg);
	                break;
	            case 'child-hidden':
	                this.onChildHidden(msg);
	                break;
	            case 'layout-changed':
	                this.onLayoutChanged(msg);
	                break;
	        }
	    };
	    /**
	     * A message handler invoked on a `'resize'` message.
	     *
	     * #### Notes
	     * The layout should ensure that its widgets are resized according
	     * to the specified layout space, and that they are sent a `'resize'`
	     * message if appropriate.
	     *
	     * The default implementation of this method sends an `UnknownSize`
	     * resize message to all widgets.
	     *
	     * This may be reimplemented by subclasses as needed.
	     */
	    Layout.prototype.onResize = function (msg) {
	        iteration_1.each(this, function (widget) { messaging_1.sendMessage(widget, ResizeMessage.UnknownSize); });
	    };
	    /**
	     * A message handler invoked on an `'update-request'` message.
	     *
	     * #### Notes
	     * The layout should ensure that its widgets are resized according
	     * to the available layout space, and that they are sent a `'resize'`
	     * message if appropriate.
	     *
	     * The default implementation of this method sends an `UnknownSize`
	     * resize message to all widgets.
	     *
	     * This may be reimplemented by subclasses as needed.
	     */
	    Layout.prototype.onUpdateRequest = function (msg) {
	        iteration_1.each(this, function (widget) { messaging_1.sendMessage(widget, ResizeMessage.UnknownSize); });
	    };
	    /**
	     * A message handler invoked on an `'after-attach'` message.
	     *
	     * #### Notes
	     * The default implementation of this method forwards the message
	     * to all widgets. It assumes all widget nodes are attached to the
	     * parent widget node.
	     *
	     * This may be reimplemented by subclasses as needed.
	     */
	    Layout.prototype.onAfterAttach = function (msg) {
	        iteration_1.each(this, function (widget) { messaging_1.sendMessage(widget, msg); });
	    };
	    /**
	     * A message handler invoked on a `'before-detach'` message.
	     *
	     * #### Notes
	     * The default implementation of this method forwards the message
	     * to all widgets. It assumes all widget nodes are attached to the
	     * parent widget node.
	     *
	     * This may be reimplemented by subclasses as needed.
	     */
	    Layout.prototype.onBeforeDetach = function (msg) {
	        iteration_1.each(this, function (widget) { messaging_1.sendMessage(widget, msg); });
	    };
	    /**
	     * A message handler invoked on an `'after-show'` message.
	     *
	     * #### Notes
	     * The default implementation of this method forwards the message to
	     * all non-hidden widgets. It assumes all widget nodes are attached
	     * to the parent widget node.
	     *
	     * This may be reimplemented by subclasses as needed.
	     */
	    Layout.prototype.onAfterShow = function (msg) {
	        iteration_1.each(this, function (widget) { if (!widget.isHidden)
	            messaging_1.sendMessage(widget, msg); });
	    };
	    /**
	     * A message handler invoked on a `'before-hide'` message.
	     *
	     * #### Notes
	     * The default implementation of this method forwards the message to
	     * all non-hidden widgets. It assumes all widget nodes are attached
	     * to the parent widget node.
	     *
	     * This may be reimplemented by subclasses as needed.
	     */
	    Layout.prototype.onBeforeHide = function (msg) {
	        iteration_1.each(this, function (widget) { if (!widget.isHidden)
	            messaging_1.sendMessage(widget, msg); });
	    };
	    /**
	     * A message handler invoked on a `'fit-request'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Layout.prototype.onFitRequest = function (msg) { };
	    /**
	     * A message handler invoked on a `'child-shown'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Layout.prototype.onChildShown = function (msg) { };
	    /**
	     * A message handler invoked on a `'child-hidden'` message.
	     *
	     * #### Notes
	     * The default implementation of this handler is a no-op.
	     */
	    Layout.prototype.onChildHidden = function (msg) { };
	    return Layout;
	}());
	exports.Layout = Layout;
	// TODO should this be in the Widget namespace?
	/**
	 * An enum of widget bit flags.
	 */
	(function (WidgetFlag) {
	    /**
	     * The widget has been disposed.
	     */
	    WidgetFlag[WidgetFlag["IsDisposed"] = 1] = "IsDisposed";
	    /**
	     * The widget is attached to the DOM.
	     */
	    WidgetFlag[WidgetFlag["IsAttached"] = 2] = "IsAttached";
	    /**
	     * The widget is hidden.
	     */
	    WidgetFlag[WidgetFlag["IsHidden"] = 4] = "IsHidden";
	    /**
	     * The widget is visible.
	     */
	    WidgetFlag[WidgetFlag["IsVisible"] = 8] = "IsVisible";
	    /**
	     * A layout cannot be set on the widget.
	     */
	    WidgetFlag[WidgetFlag["DisallowLayout"] = 16] = "DisallowLayout";
	})(exports.WidgetFlag || (exports.WidgetFlag = {}));
	var WidgetFlag = exports.WidgetFlag;
	// TODO should this be in the Widget namespace?
	/**
	 * A collection of stateless messages related to widgets.
	 */
	var WidgetMessage;
	(function (WidgetMessage) {
	    /**
	     * A singleton `'after-show'` message.
	     *
	     * #### Notes
	     * This message is sent to a widget after it becomes visible.
	     *
	     * This message is **not** sent when the widget is being attached.
	     */
	    WidgetMessage.AfterShow = new messaging_1.Message('after-show');
	    /**
	     * A singleton `'before-hide'` message.
	     *
	     * #### Notes
	     * This message is sent to a widget before it becomes not-visible.
	     *
	     * This message is **not** sent when the widget is being detached.
	     */
	    WidgetMessage.BeforeHide = new messaging_1.Message('before-hide');
	    /**
	     * A singleton `'after-attach'` message.
	     *
	     * #### Notes
	     * This message is sent to a widget after it is attached.
	     */
	    WidgetMessage.AfterAttach = new messaging_1.Message('after-attach');
	    /**
	     * A singleton `'before-detach'` message.
	     *
	     * #### Notes
	     * This message is sent to a widget before it is detached.
	     */
	    WidgetMessage.BeforeDetach = new messaging_1.Message('before-detach');
	    /**
	     * A singleton `'parent-changed'` message.
	     *
	     * #### Notes
	     * This message is sent to a widget when its parent has changed.
	     */
	    WidgetMessage.ParentChanged = new messaging_1.Message('parent-changed');
	    /**
	     * A singleton `'layout-changed'` message.
	     *
	     * #### Notes
	     * This message is sent to a widget when its layout has changed.
	     */
	    WidgetMessage.LayoutChanged = new messaging_1.Message('layout-changed');
	    /**
	     * A singleton conflatable `'update-request'` message.
	     *
	     * #### Notes
	     * This message can be dispatched to supporting widgets in order to
	     * update their content based on the current widget state. Not all
	     * widgets will respond to messages of this type.
	     *
	     * For widgets with a layout, this message will inform the layout to
	     * update the position and size of its child widgets.
	     */
	    WidgetMessage.UpdateRequest = new messaging_1.ConflatableMessage('update-request');
	    /**
	     * A singleton conflatable `'fit-request'` message.
	     *
	     * #### Notes
	     * For widgets with a layout, this message will inform the layout to
	     * recalculate its size constraints to fit the space requirements of
	     * its child widgets, and to update their position and size. Not all
	     * layouts will respond to messages of this type.
	     */
	    WidgetMessage.FitRequest = new messaging_1.ConflatableMessage('fit-request');
	    /**
	     * A singleton conflatable `'activate-request'` message.
	     *
	     * #### Notes
	     * This message should be dispatched to a widget when it should
	     * perform the actions necessary to activate the widget, which
	     * may include focusing its node or descendant node.
	     */
	    WidgetMessage.ActivateRequest = new messaging_1.ConflatableMessage('activate-request');
	    /**
	     * A singleton conflatable `'deactivate-request'` message.
	     *
	     * #### Notes
	     * This message should be dispatched to a widget when it should
	     * perform the actions necessary to decactivate the widget, which
	     * may include blurring its node or descendant node.
	     */
	    WidgetMessage.DeactivateRequest = new messaging_1.ConflatableMessage('deactivate-request');
	    /**
	     * A singleton conflatable `'close-request'` message.
	     *
	     * #### Notes
	     * This message should be dispatched to a widget when it should close
	     * and remove itself from the widget hierarchy.
	     */
	    WidgetMessage.CloseRequest = new messaging_1.ConflatableMessage('close-request');
	})(WidgetMessage = exports.WidgetMessage || (exports.WidgetMessage = {}));
	// TODO should this be in the Widget namespace?
	/**
	 * A message class for child related messages.
	 */
	var ChildMessage = (function (_super) {
	    __extends(ChildMessage, _super);
	    /**
	     * Construct a new child message.
	     *
	     * @param type - The message type.
	     *
	     * @param child - The child widget for the message.
	     */
	    function ChildMessage(type, child) {
	        _super.call(this, type);
	        this._child = child;
	    }
	    Object.defineProperty(ChildMessage.prototype, "child", {
	        /**
	         * The child widget for the message.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._child;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ChildMessage;
	}(messaging_1.Message));
	exports.ChildMessage = ChildMessage;
	// TODO should this be in the Widget namespace?
	/**
	 * A message class for `'resize'` messages.
	 */
	var ResizeMessage = (function (_super) {
	    __extends(ResizeMessage, _super);
	    /**
	     * Construct a new resize message.
	     *
	     * @param width - The **offset width** of the widget, or `-1` if
	     *   the width is not known.
	     *
	     * @param height - The **offset height** of the widget, or `-1` if
	     *   the height is not known.
	     */
	    function ResizeMessage(width, height) {
	        _super.call(this, 'resize');
	        this._width = width;
	        this._height = height;
	    }
	    Object.defineProperty(ResizeMessage.prototype, "width", {
	        /**
	         * The offset width of the widget.
	         *
	         * #### Notes
	         * This will be `-1` if the width is unknown.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResizeMessage.prototype, "height", {
	        /**
	         * The offset height of the widget.
	         *
	         * #### Notes
	         * This will be `-1` if the height is unknown.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ResizeMessage;
	}(messaging_1.Message));
	exports.ResizeMessage = ResizeMessage;
	/**
	 * The namespace for the `ResizeMessage` class statics.
	 */
	var ResizeMessage;
	(function (ResizeMessage) {
	    /**
	     * A singleton `'resize'` message with an unknown size.
	     */
	    ResizeMessage.UnknownSize = new ResizeMessage(-1, -1);
	})(ResizeMessage = exports.ResizeMessage || (exports.ResizeMessage = {}));
	/**
	 * The namespace for the private module data.
	 */
	var Private;
	(function (Private) {
	    /**
	     * A property descriptor for a widget absolute geometry rect.
	     */
	    Private.rectProperty = new properties_1.AttachedProperty({
	        name: 'rect',
	        create: function () { return ({ top: NaN, left: NaN, width: NaN, height: NaN }); },
	    });
	    /**
	     * An attached property for the widget title object.
	     */
	    Private.titleProperty = new properties_1.AttachedProperty({
	        name: 'title',
	        create: function (owner) { return new title_1.Title({ owner: owner }); },
	    });
	    /**
	     * Create a DOM node for the given widget options.
	     */
	    function createNode(options) {
	        return options.node || document.createElement('div');
	    }
	    Private.createNode = createNode;
	})(Private || (Private = {}));
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/ui/widget.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/core/properties.js **/
jupyter.define('phosphor@0.6.1/lib/core/properties.js', function (module, exports, __jupyter_require__) {
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	"use strict";
	/**
	 * A class which attaches a value to an external object.
	 *
	 * #### Notes
	 * Attached properties are used to extend the state of an object with
	 * semantic data from an unrelated class. They also encapsulate value
	 * creation, coercion, and notification.
	 *
	 * Because attached property values are stored in a hash table, which
	 * in turn is stored in a WeakMap keyed on the owner object, there is
	 * non-trivial storage overhead involved in their use. The pattern is
	 * therefore best used for the storage of rare data.
	 */
	var AttachedProperty = (function () {
	    /**
	     * Construct a new attached property.
	     *
	     * @param options - The options for initializing the property.
	     */
	    function AttachedProperty(options) {
	        this._pid = nextPID();
	        this._name = options.name;
	        this._value = options.value;
	        this._create = options.create;
	        this._coerce = options.coerce;
	        this._compare = options.compare;
	        this._changed = options.changed;
	    }
	    Object.defineProperty(AttachedProperty.prototype, "name", {
	        /**
	         * Get the human readable name for the property.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._name;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Get the current value of the property for a given owner.
	     *
	     * @param owner - The property owner of interest.
	     *
	     * @returns The current value of the property.
	     *
	     * #### Notes
	     * If the value has not yet been set, the default value will be
	     * computed and assigned as the current value of the property.
	     */
	    AttachedProperty.prototype.get = function (owner) {
	        var value;
	        var map = ensureMap(owner);
	        if (this._pid in map) {
	            value = map[this._pid];
	        }
	        else {
	            value = map[this._pid] = this._createValue(owner);
	        }
	        return value;
	    };
	    /**
	     * Set the current value of the property for a given owner.
	     *
	     * @param owner - The property owner of interest.
	     *
	     * @param value - The value for the property.
	     *
	     * #### Notes
	     * If the value has not yet been set, the default value will be
	     * computed and used as the previous value for the comparison.
	     */
	    AttachedProperty.prototype.set = function (owner, value) {
	        var oldValue;
	        var map = ensureMap(owner);
	        if (this._pid in map) {
	            oldValue = map[this._pid];
	        }
	        else {
	            oldValue = map[this._pid] = this._createValue(owner);
	        }
	        var newValue = this._coerceValue(owner, value);
	        this._maybeNotify(owner, oldValue, map[this._pid] = newValue);
	    };
	    /**
	     * Explicitly coerce the current property value for a given owner.
	     *
	     * @param owner - The property owner of interest.
	     *
	     * #### Notes
	     * If the value has not yet been set, the default value will be
	     * computed and used as the previous value for the comparison.
	     */
	    AttachedProperty.prototype.coerce = function (owner) {
	        var oldValue;
	        var map = ensureMap(owner);
	        if (this._pid in map) {
	            oldValue = map[this._pid];
	        }
	        else {
	            oldValue = map[this._pid] = this._createValue(owner);
	        }
	        var newValue = this._coerceValue(owner, oldValue);
	        this._maybeNotify(owner, oldValue, map[this._pid] = newValue);
	    };
	    /**
	     * Get or create the default value for the given owner.
	     */
	    AttachedProperty.prototype._createValue = function (owner) {
	        var create = this._create;
	        return create ? create(owner) : this._value;
	    };
	    /**
	     * Coerce the value for the given owner.
	     */
	    AttachedProperty.prototype._coerceValue = function (owner, value) {
	        var coerce = this._coerce;
	        return coerce ? coerce(owner, value) : value;
	    };
	    /**
	     * Compare the old value and new value for equality.
	     */
	    AttachedProperty.prototype._compareValue = function (oldValue, newValue) {
	        var compare = this._compare;
	        return compare ? compare(oldValue, newValue) : oldValue === newValue;
	    };
	    /**
	     * Run the change notification if the given values are different.
	     */
	    AttachedProperty.prototype._maybeNotify = function (owner, oldValue, newValue) {
	        if (!this._changed || this._compareValue(oldValue, newValue)) {
	            return;
	        }
	        this._changed.call(void 0, owner, oldValue, newValue);
	    };
	    return AttachedProperty;
	}());
	exports.AttachedProperty = AttachedProperty;
	/**
	 * Clear the stored property data for the given property owner.
	 *
	 * @param owner - The property owner of interest.
	 *
	 * #### Notes
	 * This will clear all property values for the owner, but it will
	 * **not** run the change notification for any of the properties.
	 */
	function clearPropertyData(owner) {
	    ownerData.delete(owner);
	}
	exports.clearPropertyData = clearPropertyData;
	/**
	 * A weak mapping of property owner to property map.
	 */
	var ownerData = new WeakMap();
	/**
	 * A function which computes successive unique property ids.
	 */
	var nextPID = (function () {
	    var id = 0;
	    return function () {
	        var rand = Math.random();
	        var stem = ("" + rand).slice(2);
	        return "pid-" + stem + "-" + id++;
	    };
	})();
	/**
	 * Lookup the data map for the property owner.
	 *
	 * This will create the map if one does not already exist.
	 */
	function ensureMap(owner) {
	    var map = ownerData.get(owner);
	    if (map !== void 0)
	        return map;
	    map = Object.create(null);
	    ownerData.set(owner, map);
	    return map;
	}
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/core/properties.js **/


/** START DEFINE BLOCK for phosphor@0.6.1/lib/ui/title.js **/
jupyter.define('phosphor@0.6.1/lib/ui/title.js', function (module, exports, __jupyter_require__) {
	"use strict";
	/*-----------------------------------------------------------------------------
	| Copyright (c) 2014-2016, PhosphorJS Contributors
	|
	| Distributed under the terms of the BSD 3-Clause License.
	|
	| The full license is in the file LICENSE, distributed with this software.
	|----------------------------------------------------------------------------*/
	var signaling_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/signaling.js');
	/**
	 * An object which holds data related to a widget's title.
	 *
	 * #### Notes
	 * A title object is intended to hold the data necessary to display a
	 * header for a particular widget. A common example is the `TabPanel`,
	 * which uses the widget title to populate the tab for a child widget.
	 */
	var Title = (function () {
	    /**
	     * Construct a new title.
	     *
	     * @param options - The options for initializing the title.
	     */
	    function Title(options) {
	        if (options === void 0) { options = {}; }
	        this._label = '';
	        this._icon = '';
	        this._caption = '';
	        this._mnemonic = -1;
	        this._className = '';
	        this._closable = false;
	        this._owner = null;
	        if (options.owner !== void 0) {
	            this._owner = options.owner;
	        }
	        if (options.label !== void 0) {
	            this._label = options.label;
	        }
	        if (options.mnemonic !== void 0) {
	            this._mnemonic = options.mnemonic;
	        }
	        if (options.icon !== void 0) {
	            this._icon = options.icon;
	        }
	        if (options.caption !== void 0) {
	            this._caption = options.caption;
	        }
	        if (options.closable !== void 0) {
	            this._closable = options.closable;
	        }
	        if (options.className !== void 0) {
	            this._className = options.className;
	        }
	    }
	    Object.defineProperty(Title.prototype, "owner", {
	        /**
	         * Get the object which owns the title.
	         *
	         * #### Notes
	         * This will be `null` if the title has no owner.
	         *
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._owner;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Title.prototype, "label", {
	        /**
	         * Get the label for the title.
	         *
	         * #### Notes
	         * The default value is an empty string.
	         */
	        get: function () {
	            return this._label;
	        },
	        /**
	         * Set the label for the title.
	         */
	        set: function (value) {
	            if (this._label === value) {
	                return;
	            }
	            this._label = value;
	            this.changed.emit(void 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Title.prototype, "mnemonic", {
	        /**
	         * Get the mnemonic index for the title.
	         *
	         * #### Notes
	         * The default value is `-1`.
	         */
	        get: function () {
	            return this._mnemonic;
	        },
	        /**
	         * Set the mnemonic index for the title.
	         */
	        set: function (value) {
	            if (this._mnemonic === value) {
	                return;
	            }
	            this._mnemonic = value;
	            this.changed.emit(void 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Title.prototype, "icon", {
	        /**
	         * Get the icon class name for the title.
	         *
	         * #### Notes
	         * The default value is an empty string.
	         */
	        get: function () {
	            return this._icon;
	        },
	        /**
	         * Set the icon class name for the title.
	         *
	         * #### Notes
	         * Multiple class names can be separated with whitespace.
	         */
	        set: function (value) {
	            if (this._icon === value) {
	                return;
	            }
	            this._icon = value;
	            this.changed.emit(void 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Title.prototype, "caption", {
	        /**
	         * Get the caption for the title.
	         *
	         * #### Notes
	         * The default value is an empty string.
	         */
	        get: function () {
	            return this._caption;
	        },
	        /**
	         * Set the caption for the title.
	         */
	        set: function (value) {
	            if (this._caption === value) {
	                return;
	            }
	            this._caption = value;
	            this.changed.emit(void 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Title.prototype, "className", {
	        /**
	         * Get the extra class name for the title.
	         *
	         * #### Notes
	         * The default value is an empty string.
	         */
	        get: function () {
	            return this._className;
	        },
	        /**
	         * Set the extra class name for the title.
	         *
	         * #### Notes
	         * Multiple class names can be separated with whitespace.
	         */
	        set: function (value) {
	            if (this._className === value) {
	                return;
	            }
	            this._className = value;
	            this.changed.emit(void 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Title.prototype, "closable", {
	        /**
	         * Get the closable state for the title.
	         *
	         * #### Notes
	         * The default value is `false`.
	         */
	        get: function () {
	            return this._closable;
	        },
	        /**
	         * Set the closable state for the title.
	         *
	         * #### Notes
	         * This controls the presence of a close icon when applicable.
	         */
	        set: function (value) {
	            if (this._closable === value) {
	                return;
	            }
	            this._closable = value;
	            this.changed.emit(void 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Title;
	}());
	exports.Title = Title;
	// Define the signals for the `Title` class.
	signaling_1.defineSignal(Title.prototype, 'changed');
	
})
/** END DEFINE BLOCK for phosphor@0.6.1/lib/ui/title.js **/


/** START DEFINE BLOCK for jupyterlab@0.4.1/lib/common/activitymonitor.js **/
jupyter.define('jupyterlab@0.4.1/lib/common/activitymonitor.js', function (module, exports, __jupyter_require__) {
	// Copyright (c) Jupyter Development Team.
	// Distributed under the terms of the Modified BSD License.
	"use strict";
	var signaling_1 = __jupyter_require__('phosphor@^0.6.1/lib/core/signaling.js');
	/**
	 * A class that monitors activity on a signal.
	 */
	var ActivityMonitor = (function () {
	    /**
	     * Construct a new activity monitor.
	     */
	    function ActivityMonitor(options) {
	        this._timer = -1;
	        this._timeout = -1;
	        this._sender = null;
	        this._args = null;
	        this._isDisposed = false;
	        options.signal.connect(this._onSignalFired, this);
	        this._timeout = options.timeout || 1000;
	    }
	    Object.defineProperty(ActivityMonitor.prototype, "timeout", {
	        /**
	         * The timeout associated with the monitor, in milliseconds.
	         */
	        get: function () {
	            return this._timeout;
	        },
	        set: function (value) {
	            this._timeout = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ActivityMonitor.prototype, "isDisposed", {
	        /**
	         * Test whether the monitor has been disposed.
	         *
	         * #### Notes
	         * This is a read-only property.
	         */
	        get: function () {
	            return this._isDisposed;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the resources used by the activity monitor.
	     */
	    ActivityMonitor.prototype.dispose = function () {
	        if (this._isDisposed) {
	            return;
	        }
	        this._isDisposed = true;
	        signaling_1.clearSignalData(this);
	    };
	    /**
	     * A signal handler for the monitored signal.
	     */
	    ActivityMonitor.prototype._onSignalFired = function (sender, args) {
	        var _this = this;
	        clearTimeout(this._timer);
	        this._sender = sender;
	        this._args = args;
	        this._timer = setTimeout(function () {
	            _this.activityStopped.emit({
	                sender: _this._sender,
	                args: _this._args
	            });
	            _this._sender = null;
	            _this._args = null;
	        }, this._timeout);
	    };
	    return ActivityMonitor;
	}());
	exports.ActivityMonitor = ActivityMonitor;
	// Define the signals for the `ActivityMonitor` class.
	signaling_1.defineSignal(ActivityMonitor.prototype, 'activityStopped');
	
})
/** END DEFINE BLOCK for jupyterlab@0.4.1/lib/common/activitymonitor.js **/


/** START DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/rendererwidget.js **/
jupyter.define('jupyterlab_vega@0.1.0/lib/rendererwidget.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var widget_1 = __jupyter_require__('phosphor@0.6.1/lib/ui/widget.js');
	var embed = __jupyter_require__('vega-embed@^2.2.0/src/embed.js');
	var VEGA_COMMON = 'jp-RenderedVegaCommon';
	var VEGA_CLASS = 'jp-RenderedVega';
	var VEGALITE_CLASS = 'jp-RenderedVegaLite';
	var DEFAULT_WIDTH = 400;
	var DEFAULT_HEIGHT = 400 / 1.5;
	/**
	 * A widget for displaying HTML and rendering math.
	 */
	var RenderedVegaBase = (function (_super) {
	    __extends(RenderedVegaBase, _super);
	    function RenderedVegaBase(options) {
	        _super.call(this);
	        this._source = null;
	        this.addClass(VEGA_COMMON);
	        this._source = options.source;
	        this._injector = options.injector;
	    }
	    RenderedVegaBase.prototype.onAfterAttach = function (msg) {
	        this._renderVega();
	    };
	    RenderedVegaBase.prototype._renderVega = function () {
	        var spec = this._source;
	        if (this._vegaEmbedMode === "vega-lite") {
	            spec['config'] = spec['config'] || {};
	            spec['config']['cell'] = spec['config']['cell'] || {};
	            spec['config']['cell']['width'] = spec['config']['cell']['width'] || DEFAULT_WIDTH;
	            spec['config']['cell']['height'] = spec['config']['cell']['height'] || DEFAULT_HEIGHT;
	        }
	        var embedSpec = {
	            mode: this._vegaEmbedMode,
	            spec: spec
	        };
	        embed(this.node, embedSpec, function (error, result) {
	            // This is copied out for now as there is a bug in JupyterLab
	            // that triggers and infinite rendering loop when this is done.
	            // let imageData = result.view.toImageURL();
	            // imageData = imageData.split(',')[1];
	            // this._injector('image/png', imageData);
	        });
	    };
	    return RenderedVegaBase;
	}(widget_1.Widget));
	exports.RenderedVegaBase = RenderedVegaBase;
	var RenderedVega = (function (_super) {
	    __extends(RenderedVega, _super);
	    function RenderedVega(options) {
	        _super.call(this, options);
	        this.addClass(VEGA_CLASS);
	        this._vegaEmbedMode = 'vega';
	    }
	    return RenderedVega;
	}(RenderedVegaBase));
	exports.RenderedVega = RenderedVega;
	var RenderedVegaLite = (function (_super) {
	    __extends(RenderedVegaLite, _super);
	    function RenderedVegaLite(options) {
	        _super.call(this, options);
	        this.addClass(VEGALITE_CLASS);
	        this._vegaEmbedMode = 'vega-lite';
	    }
	    return RenderedVegaLite;
	}(RenderedVegaBase));
	exports.RenderedVegaLite = RenderedVegaLite;
	
})
/** END DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/rendererwidget.js **/


/** START DEFINE BLOCK for vega-embed@2.2.0/src/embed.js **/
jupyter.define('vega-embed@2.2.0/src/embed.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    vg = __jupyter_require__('vega@2.6.3/index.js'),
	    vl = __jupyter_require__('vega-lite@1.2.0/src/vl.js'),
	    parameter = __jupyter_require__('vega-embed@~2.2.0/src/parameter.js'),
	    post = __jupyter_require__('vega-embed@~2.2.0/src/post.js');
	
	var config = {
	  // URL for loading specs into editor
	  editor_url: 'http://vega.github.io/vega-editor/',
	
	  // HTML to inject within view source head element
	  source_header: '',
	
	  // HTML to inject before view source closing body tag
	  source_footer: ''
	};
	
	var MODES = {
	  'vega':      'vega',
	  'vega-lite': 'vega-lite'
	};
	
	var PREPROCESSOR = {
	  'vega':      function(vgjson) { return vgjson; },
	  'vega-lite': function(vljson) { return vl.compile(vljson).spec; }
	};
	
	function load(url, arg, prop, el, callback) {
	  vg.util.load({url: url}, function(err, data) {
	    var opt;
	    if (err || !data) {
	      console.error(err || ('No data found at ' + url));
	    } else {
	      // marshal embedding spec and restart
	      if (!arg) { // Loading embed spec from URL
	        opt = JSON.parse(data);
	      } else {  // Loading vg/vl spec or config from URL
	        opt = vg.util.extend({}, arg);
	        opt[prop] = prop === 'source' ? data : JSON.parse(data);
	      }
	      embed(el, opt, callback);
	    }
	  });
	}
	
	// Embed a Vega visualization component in a web page.
	// el: DOM element in which to place component (DOM node or CSS selector)
	// opt: Embedding specification (parsed JSON or URL string)
	// callback: invoked with the generated Vega View instance
	function embed(el, opt, callback) {
	  var cb = callback || function(){},
	      params = [], source, spec, mode, config;
	
	  try {
	    // Load the visualization specification.
	    if (vg.util.isString(opt)) {
	      return load(opt, null, null, el, callback);
	    } else if (opt.source) {
	      source = opt.source;
	      spec = JSON.parse(source);
	    } else if (opt.spec) {
	      spec = opt.spec;
	      source = JSON.stringify(spec, null, 2);
	    } else if (opt.url) {
	      return load(opt.url, opt, 'source', el, callback);
	    } else {
	      spec = opt;
	      source = JSON.stringify(spec, null, 2);
	      opt = {spec: spec, actions: false};
	    }
	    mode = MODES[opt.mode] || MODES.vega;
	    spec = PREPROCESSOR[mode](spec);
	
	    // Load Vega theme/configuration.
	    if (vg.util.isString(opt.config)) {
	      return load(opt.config, opt, 'config', el, callback);
	    } else if (opt.config) {
	      config = opt.config;
	    }
	
	    // ensure container div has class 'vega-embed'
	    var div = d3.select(el)
	      .classed('vega-embed', true)
	      .html(''); // clear container
	
	    // handle parameters
	    if (opt.parameters) {
	      var elp = opt.parameter_el ? d3.select(opt.parameter_el) : div;
	      var pdiv = elp.append('div')
	        .attr('class', 'vega-params');
	      params = opt.parameters.map(function(p) {
	        return parameter.init(pdiv, p, spec);
	      });
	    }
	  } catch (err) { cb(err); }
	
	  vg.parse.spec(spec, config, function(error, chart) {
	    if (error) { cb(error); return; }
	    try {
	      var renderer = opt.renderer || 'canvas',
	          actions  = opt.actions || {};
	
	      var view = chart({
	        el: el,
	        data: opt.data || undefined,
	        renderer: renderer
	      });
	
	      if (opt.actions !== false) {
	        // add child div to house action links
	        var ctrl = div.append('div')
	          .attr('class', 'vega-actions');
	
	        // add 'Export' action
	        if (actions.export !== false) {
	          var ext = (renderer==='canvas' ? 'png' : 'svg');
	          ctrl.append('a')
	            .text('Export as ' + ext.toUpperCase())
	            .attr('href', '#')
	            .attr('target', '_blank')
	            .attr('download', (spec.name || 'vega') + '.' + ext)
	            .on('mousedown', function() {
	              this.href = view.toImageURL(ext);
	              d3.event.preventDefault();
	            });
	        }
	
	        // add 'View Source' action
	        if (actions.source !== false) {
	          ctrl.append('a')
	            .text('View Source')
	            .attr('href', '#')
	            .on('click', function() {
	              viewSource(source);
	              d3.event.preventDefault();
	            });
	        }
	
	        // add 'Open in Vega Editor' action
	        if (actions.editor !== false) {
	          ctrl.append('a')
	            .text('Open in Vega Editor')
	            .attr('href', '#')
	            .on('click', function() {
	              post(window, embed.config.editor_url, {spec: source, mode: mode});
	              d3.event.preventDefault();
	            });
	        }
	      }
	
	      // bind all parameter elements
	      params.forEach(function(p) { parameter.bind(p, view); });
	
	      // initialize and return visualization
	      view.update();
	      cb(null, {view: view, spec: spec});
	    } catch (err) { cb(err); }
	  });
	}
	
	function viewSource(source) {
	  var header = '<html><head>' + config.source_header + '</head>' + '<body><pre><code class="json">';
	  var footer = '</code></pre>' + config.source_footer + '</body></html>';
	  var win = window.open('');
	  win.document.write(header + source + footer);
	  win.document.title = 'Vega JSON Source';
	}
	
	// make config externally visible
	embed.config = config;
	
	module.exports = embed;
	
})
/** END DEFINE BLOCK for vega-embed@2.2.0/src/embed.js **/


/** START DEFINE BLOCK for d3@3.5.17/d3.js **/
jupyter.define('d3@3.5.17/d3.js', function (module, exports, __jupyter_require__) {
	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.17"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.transpose = function(matrix) {
	    if (!(n = matrix.length)) return [];
	    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
	      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
	        row[j] = matrix[j][i];
	      }
	    }
	    return transpose;
	  };
	  function d3_transposeLength(d) {
	    return d.length;
	  }
	  d3.zip = function() {
	    return d3.transpose(arguments);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: d3_nsXhtml,
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (node = group[i]) {
	            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
	              exitNodes[i] = node;
	            } else {
	              nodeByKeyValue.set(keyValue, node);
	            }
	            keyValues[i] = keyValue;
	          }
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = d3_array(nodes);
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
	    if (d2 < ε2) {
	      S = Math.log(w1 / w0) / ρ;
	      i = function(t) {
	        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
	      };
	    } else {
	      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	      S = (r1 - r0) / ρ;
	      i = function(t) {
	        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
	      };
	    }
	    i.duration = S * 1e3;
	    return i;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: null
	      };
	      scaleTo(+_);
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      }), center0 = null;
	    }
	    function mousedowned() {
	      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
	      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }
	
	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format)) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function() {
	    d3_timer.apply(this, arguments);
	  };
	  function d3_timer(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	    return timer;
	  }
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now(), timer = d3_timer_queueHead;
	    while (timer) {
	      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
	      timer = timer.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.c) {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      } else {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value = +value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;
	
	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;
	
	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;
	
	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();
	
	       case "c":
	        exponent = false;
	
	       case "d":
	        integer = true;
	        precision = 0;
	        break;
	
	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
	          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * π;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var λ00, φ00, λ0, cosφ0, sinφ0;
	    d3_geo_area.point = function(λ, φ) {
	      d3_geo_area.point = nextPoint;
	      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
	      sinφ0 = Math.sin(φ);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      φ = φ * d3_radians / 2 + π / 4;
	      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(λ00, φ00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
	  }
	  d3.geo.bounds = function() {
	    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dλSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
	        range[0] = λ0, range[1] = λ1;
	      }
	    };
	    function point(λ, φ) {
	      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
	      if (φ < φ0) φ0 = φ;
	      if (φ > φ1) φ1 = φ;
	    }
	    function linePoint(λ, φ) {
	      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
	        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = inflection[1] * d3_degrees;
	          if (φi > φ1) φ1 = φi;
	        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = -inflection[1] * d3_degrees;
	          if (φi < φ0) φ0 = φi;
	        } else {
	          if (φ < φ0) φ0 = φ;
	          if (φ > φ1) φ1 = φ;
	        }
	        if (antimeridian) {
	          if (λ < λ_) {
	            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	          } else {
	            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	          }
	        } else {
	          if (λ1 >= λ0) {
	            if (λ < λ0) λ0 = λ;
	            if (λ > λ1) λ1 = λ;
	          } else {
	            if (λ > λ_) {
	              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	            } else {
	              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	            }
	          }
	        }
	      } else {
	        point(λ, φ);
	      }
	      p0 = p, λ_ = λ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = λ0, range[1] = λ1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(λ, φ) {
	      if (p0) {
	        var dλ = λ - λ_;
	        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
	      } else λ__ = λ, φ__ = φ;
	      d3_geo_area.point(λ, φ);
	      linePoint(λ, φ);
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(λ__, φ__);
	      d3_geo_area.lineEnd();
	      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
	      range[0] = λ0, range[1] = λ1;
	      p0 = null;
	    }
	    function angle(λ0, λ1) {
	      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      φ1 = λ1 = -(λ0 = φ0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, dλ;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < ε2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < ε2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(λ, φ) {
	    λ *= d3_radians;
	    var cosφ = Math.cos(φ *= d3_radians);
	    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var λ00, φ00, x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ00 = λ, φ00 = φ;
	      d3_geo_centroid.point = nextPoint;
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(λ00, φ00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(λ, φ) {
	        var point = rotate(λ, φ);
	        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
	      }
	      function pointLine(λ, φ) {
	        var point = rotate(λ, φ);
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(λ, φ) {
	        ring.push([ λ, φ ]);
	        var point = rotate(λ, φ);
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(λ, φ) {
	        line.push([ λ, φ ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(λ1, φ1) {
	        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
	        if (abs(dλ - π) < ε) {
	          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          listener.point(λ1, φ0);
	          clean = 0;
	        } else if (sλ0 !== sλ1 && dλ >= π) {
	          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
	          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
	          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          clean = 0;
	        }
	        listener.point(λ0 = λ1, φ0 = φ1);
	        sλ0 = sλ1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        λ0 = φ0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
	    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var φ;
	    if (from == null) {
	      φ = direction * halfπ;
	      listener.point(-π, φ);
	      listener.point(0, φ);
	      listener.point(π, φ);
	      listener.point(π, 0);
	      listener.point(π, -φ);
	      listener.point(0, -φ);
	      listener.point(-π, -φ);
	      listener.point(-π, 0);
	      listener.point(-π, φ);
	    } else if (abs(from[0] - to[0]) > ε) {
	      var s = from[0] < to[0] ? π : -π;
	      φ = direction * s / 2;
	      listener.point(-s, φ);
	      listener.point(0, φ);
	      listener.point(s, φ);
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
	        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
	        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
	        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
	      }
	    }
	    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
	    function visible(λ, φ) {
	      return Math.cos(λ) * Math.cos(φ) > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(λ, φ) {
	          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ε;
	              point1[1] += ε;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
	      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
	      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
	      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
	      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(λ, φ) {
	      var r = smallRadius ? radius : π - radius, code = 0;
	      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
	      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
	      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(φ0, φ1) {
	    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
	    function forward(λ, φ) {
	      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
	      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = ρ0 - y;
	      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, τ);
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(λ, φ) {
	        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(λ, φ) {
	        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * δ2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(δ2);
	      maxDepth = (δ2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + δx, δy - x[1] * k ];
	    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + δx, δy - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
	      λ = _[0] % 360 * d3_radians;
	      φ = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
	      δλ = _[0] % 360 * d3_radians;
	      δφ = _[1] % 360 * d3_radians;
	      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
	      var center = project(λ, φ);
	      δx = x - center[0] * k;
	      δy = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(λ, φ) {
	    return [ λ, φ ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(λ, φ) {
	    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(δλ, δφ, δγ) {
	    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotationλ(δλ) {
	    return function(λ, φ) {
	      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	    };
	  }
	  function d3_geo_rotationλ(δλ) {
	    var rotation = d3_geo_forwardRotationλ(δλ);
	    rotation.invert = d3_geo_forwardRotationλ(-δλ);
	    return rotation;
	  }
	  function d3_geo_rotationφγ(δφ, δγ) {
	    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	    function rotation(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
	      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
	    }
	    rotation.invert = function(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
	      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * τ;
	      } else {
	        from = radius + direction * τ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ε;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ε;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - ε, dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - ε, dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var λ0, sinφ0, cosφ0;
	    d3_geo_length.point = function(λ, φ) {
	      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(λ, φ) {
	      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
	      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(λ, φ) {
	      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
	      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	    }
	    azimuthal.invert = function(x, y) {
	      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
	    return Math.sqrt(2 / (1 + cosλcosφ));
	  }, function(ρ) {
	    return 2 * Math.asin(ρ / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
	    var c = Math.acos(cosλcosφ);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), t = function(φ) {
	      return Math.tan(π / 4 + φ / 2);
	    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(λ, φ) {
	      if (F > 0) {
	        if (φ < -halfπ + ε) φ = -halfπ + ε;
	      } else {
	        if (φ > halfπ - ε) φ = halfπ - ε;
	      }
	      var ρ = F / Math.pow(t(φ), n);
	      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
	      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
	    if (abs(n) < ε) return d3_geo_equirectangular;
	    function forward(λ, φ) {
	      var ρ = G - φ;
	      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = G - y;
	      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / cosλcosφ;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(λ, φ) {
	    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k = π * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / (1 + cosλcosφ);
	  }, function(ρ) {
	    return 2 * Math.atan(ρ);
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(λ, φ) {
	    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ε) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ε) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -ε) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -ε) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
	            x: x0,
	            y: abs(x2 - x0) < ε ? y2 : y1
	          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
	            x: abs(y2 - y1) < ε ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
	            x: x1,
	            y: abs(x2 - x1) < ε ? y2 : y0
	          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
	            x: abs(y2 - y0) < ε ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -ε2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ε) * ε,
	          y: Math.round(fy(d, i) / ε) * ε,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;
	
	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;
	
	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;
	
	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * halfπ);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransformPop(s) {
	    return s.length ? s.pop() + "," : "";
	  }
	  function d3_interpolateTranslate(ta, tb, s, q) {
	    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
	      var i = s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    }
	  }
	  function d3_interpolateRotate(ra, rb, s, q) {
	    if (ra !== rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
	    }
	  }
	  function d3_interpolateSkew(wa, wb, s, q) {
	    if (wa !== wb) {
	      q.push({
	        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
	    }
	  }
	  function d3_interpolateScale(ka, kb, s, q) {
	    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
	      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
	      q.push({
	        i: i - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: i - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] !== 1 || kb[1] !== 1) {
	      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
	    }
	  }
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [];
	    a = d3.transform(a), b = d3.transform(b);
	    d3_interpolateTranslate(a.translate, b.translate, s, q);
	    d3_interpolateRotate(a.rotate, b.rotate, s, q);
	    d3_interpolateSkew(a.skew, b.skew, s, q);
	    d3_interpolateScale(a.scale, b.scale, s, q);
	    a = b = null;
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = (τ - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: groupSums[di]
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        timer = null;
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) {
	          alpha = x;
	        } else {
	          timer.c = null, timer.t = NaN, timer = null;
	          event.end({
	            type: "end",
	            alpha: alpha = 0
	          });
	        }
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        timer = d3_timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = root.y = 0;
	      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(µ, σ) {
	      var n = arguments.length;
	      if (n < 2) σ = 1;
	      if (n < 1) µ = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	    return domain;
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(1, base * n / scale.ticks().length);
	      return function(d) {
	        var i = d / pow(Math.round(log(d)));
	        if (i * base < base - .5) i *= base;
	        return i <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var rc1 = rc, rc0 = rc;
	        if (da < π) {
	          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
	          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
	        }
	        if (x1 != null) {
	          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.length > 1 ? points.join("L") : points + "Z";
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return points.join("L") + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ε) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - halfπ;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / π);
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, activeId, active;
	      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        if (--lock.count) delete lock[activeId]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id], time, timer, duration, ease, tweens;
	    function schedule(elapsed) {
	      var delay = transition.delay;
	      timer.t = delay + time;
	      if (delay <= elapsed) return start(elapsed - delay);
	      timer.c = start;
	    }
	    function start(elapsed) {
	      var activeId = lock.active, active = lock[activeId];
	      if (active) {
	        active.timer.c = null;
	        active.timer.t = NaN;
	        --lock.count;
	        delete lock[activeId];
	        active.event && active.event.interrupt.call(node, node.__data__, active.index);
	      }
	      for (var cancelId in lock) {
	        if (+cancelId < id) {
	          var cancel = lock[cancelId];
	          cancel.timer.c = null;
	          cancel.timer.t = NaN;
	          --lock.count;
	          delete lock[cancelId];
	        }
	      }
	      timer.c = tick;
	      d3_timer(function() {
	        if (timer.c && tick(elapsed || 1)) {
	          timer.c = null;
	          timer.t = NaN;
	        }
	        return 1;
	      }, 0, time);
	      lock.active = id;
	      transition.event && transition.event.start.call(node, node.__data__, i);
	      tweens = [];
	      transition.tween.forEach(function(key, value) {
	        if (value = value.call(node, node.__data__, i)) {
	          tweens.push(value);
	        }
	      });
	      ease = transition.ease;
	      duration = transition.duration;
	    }
	    function tick(elapsed) {
	      var t = elapsed / duration, e = ease(t), n = tweens.length;
	      while (n > 0) {
	        tweens[--n].call(node, e);
	      }
	      if (t >= 1) {
	        transition.event && transition.event.end.call(node, node.__data__, i);
	        if (--lock.count) delete lock[id]; else delete node[ns];
	        return 1;
	      }
	    }
	    if (!transition) {
	      time = inherit.time;
	      timer = d3_timer(schedule, 0, time);
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        timer: timer,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = d3_array(arguments);
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __jupyter_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
	}();
})
/** END DEFINE BLOCK for d3@3.5.17/d3.js **/


/** START DEFINE BLOCK for vega@2.6.3/index.js **/
jupyter.define('vega@2.6.3/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  version: '__VERSION__',
	  dataflow: __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	  parse: __jupyter_require__('vega@~2.6.3/src/parse/index.js'),
	  scene: {
	    Bounder: __jupyter_require__('vega@~2.6.3/src/scene/Bounder.js'),
	    Builder: __jupyter_require__('vega@~2.6.3/src/scene/Builder.js'),
	    Encoder: __jupyter_require__('vega@~2.6.3/src/scene/Encoder.js'),
	    GroupBuilder: __jupyter_require__('vega@~2.6.3/src/scene/GroupBuilder.js'),
	    visit: __jupyter_require__('vega@~2.6.3/src/scene/visit.js')
	  },
	  transforms: __jupyter_require__('vega@~2.6.3/src/transforms/index.js'),
	  Transform: __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	  BatchTransform: __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js'),
	  Parameter: __jupyter_require__('vega@~2.6.3/src/transforms/Parameter.js'),
	  schema: __jupyter_require__('vega@~2.6.3/src/core/schema.js'),
	  config: __jupyter_require__('vega@~2.6.3/src/core/config.js'),
	  util: __jupyter_require__('vega@~2.6.3/src/util/index.js'),
	  logging: __jupyter_require__('vega-logging@^1.0.1/index.js'),
	  debug: __jupyter_require__('vega-logging@^1.0.1/index.js').debug
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/index.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/index.js **/
jupyter.define('vega-dataflow@1.4.3/src/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  ChangeSet:    __jupyter_require__('vega-dataflow@~1.4.3/src/ChangeSet.js'),
	  Collector:    __jupyter_require__('vega-dataflow@~1.4.3/src/Collector.js'),
	  DataSource:   __jupyter_require__('vega-dataflow@~1.4.3/src/DataSource.js'),
	  Dependencies: __jupyter_require__('vega-dataflow@~1.4.3/src/Dependencies.js'),
	  Graph:        __jupyter_require__('vega-dataflow@~1.4.3/src/Graph.js'),
	  Node:         __jupyter_require__('vega-dataflow@~1.4.3/src/Node.js'),
	  Signal:       __jupyter_require__('vega-dataflow@~1.4.3/src/Signal.js'),
	  Tuple:        __jupyter_require__('vega-dataflow@~1.4.3/src/Tuple.js'),
	  debug:        __jupyter_require__('vega-logging@^1.0.1/index.js').debug
	};
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/index.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/ChangeSet.js **/
jupyter.define('vega-dataflow@1.4.3/src/ChangeSet.js', function (module, exports, __jupyter_require__) {
	var DEPS = __jupyter_require__('vega-dataflow@~1.4.3/src/Dependencies.js').ALL;
	
	function create(cs, reflow) {
	  var out = {};
	  copy(cs, out);
	
	  out.add = [];
	  out.mod = [];
	  out.rem = [];
	
	  out.reflow = reflow;
	
	  return out;
	}
	
	function copy(a, b) {
	  b.stamp = a ? a.stamp : 0;
	  b.sort  = a ? a.sort  : null;
	  b.facet = a ? a.facet : null;
	  b.trans = a ? a.trans : null;
	  b.dirty = a ? a.dirty : [];
	  b.request = a ? a.request : null;
	  for (var d, i=0, n=DEPS.length; i<n; ++i) {
	    b[d=DEPS[i]] = a ? a[d] : {};
	  }
	}
	
	module.exports = {
	  create: create,
	  copy: copy
	};
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/ChangeSet.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/Dependencies.js **/
jupyter.define('vega-dataflow@1.4.3/src/Dependencies.js', function (module, exports, __jupyter_require__) {
	var deps = module.exports = {
	  ALL: ['data', 'fields', 'scales', 'signals']
	};
	deps.ALL.forEach(function(k) { deps[k.toUpperCase()] = k; });
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/Dependencies.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/Collector.js **/
jupyter.define('vega-dataflow@1.4.3/src/Collector.js', function (module, exports, __jupyter_require__) {
	var log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@~1.4.3/src/Tuple.js'),
	    Base = __jupyter_require__('vega-dataflow@~1.4.3/src/Node.js').prototype,
	    ChangeSet = __jupyter_require__('vega-dataflow@~1.4.3/src/ChangeSet.js');
	
	function Collector(graph) {
	  Base.init.call(this, graph);
	  this._data = [];
	  this.router(true).collector(true);
	}
	
	var prototype = (Collector.prototype = Object.create(Base));
	prototype.constructor = Collector;
	
	prototype.data = function() {
	  return this._data;
	};
	
	prototype.evaluate = function(input) {
	  log.debug(input, ["collecting"]);
	
	  // Create a new output changeset to prevent pollution when the Graph
	  // merges reflow and regular changesets.
	  var output = ChangeSet.create(input);
	
	  if (input.rem.length) {
	    this._data = Tuple.idFilter(this._data, input.rem);
	    output.rem = input.rem.slice(0);
	  }
	
	  if (input.add.length) {
	    this._data = this._data.concat(input.add);
	    output.add = input.add.slice(0);
	  }
	
	  if (input.mod.length) {
	    output.mod = input.mod.slice(0);
	  }
	
	  if (input.sort) {
	    this._data.sort(input.sort);
	  }
	
	  if (input.reflow) {
	    output.mod = output.mod.concat(
	      Tuple.idFilter(this._data, output.add, output.mod, output.rem));
	    output.reflow = false;
	  }
	
	  return output;
	};
	
	module.exports = Collector;
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/Collector.js **/


/** START DEFINE BLOCK for vega-logging@1.0.2/index.js **/
jupyter.define('vega-logging@1.0.2/index.js', function (module, exports, __jupyter_require__) {
	var ts = Date.now();
	
	function write(msg) {
	  console.log('[Vega Log]', msg);
	}
	
	function error(msg) {
	  console.error('[Vega Err]', msg);
	}
	
	function debug(input, args) {
	  if (!debug.enable) return;
	  var log = Function.prototype.bind.call(console.log, console);
	  var state = {
	    prevTime:  Date.now() - ts,
	    stamp: input.stamp
	  };
	
	  if (input.add) {
	    state.add = input.add.length;
	    state.mod = input.mod.length;
	    state.rem = input.rem.length;
	    state.reflow = !!input.reflow;
	  }
	
	  log.apply(console, (args.push(JSON.stringify(state)), args));
	  ts = Date.now();
	}
	
	module.exports = {
	  log:   write,
	  error: error,
	  debug: (debug.enable = false, debug)
	};
	
})
/** END DEFINE BLOCK for vega-logging@1.0.2/index.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/Tuple.js **/
jupyter.define('vega-dataflow@1.4.3/src/Tuple.js', function (module, exports, __jupyter_require__) {
	var tupleID = 0;
	
	function ingest(datum) {
	  datum = (datum === Object(datum)) ? datum : {data: datum};
	  datum._id = ++tupleID;
	  if (datum._prev) datum._prev = null;
	  return datum;
	}
	
	function idMap(a, ids) {
	  ids = ids || {};
	  for (var i=0, n=a.length; i<n; ++i) {
	    ids[a[i]._id] = 1;
	  }
	  return ids;
	}
	
	function copy(t, c) {
	  c = c || {};
	  for (var k in t) {
	    if (k !== '_prev' && k !== '_id') c[k] = t[k];
	  }
	  return c;
	}
	
	module.exports = {
	  ingest: ingest,
	  idMap: idMap,
	
	  derive: function(d) {
	    return ingest(copy(d));
	  },
	
	  rederive: function(d, t) {
	    return copy(d, t);
	  },
	
	  set: function(t, k, v) {
	    return t[k] === v ? 0 : (t[k] = v, 1);
	  },
	
	  prev: function(t) {
	    return t._prev || t;
	  },
	
	  prev_init: function(t) {
	    if (!t._prev) { t._prev = {_id: t._id}; }
	  },
	
	  prev_update: function(t) {
	    var p = t._prev, k, v;
	    if (p) for (k in t) {
	      if (k !== '_prev' && k !== '_id') {
	        p[k] = ((v=t[k]) instanceof Object && v._prev) ? v._prev : v;
	      }
	    }
	  },
	
	  reset: function() { tupleID = 0; },
	
	  idFilter: function(data) {
	    var ids = {};
	    for (var i=arguments.length; --i>0;) {
	      idMap(arguments[i], ids);
	    }
	    return data.filter(function(x) { return !ids[x._id]; });
	  }
	};
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/Tuple.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/Node.js **/
jupyter.define('vega-dataflow@1.4.3/src/Node.js', function (module, exports, __jupyter_require__) {
	var DEPS = __jupyter_require__('vega-dataflow@~1.4.3/src/Dependencies.js').ALL,
	    nodeID = 0;
	
	function Node(graph) {
	  if (graph) this.init(graph);
	}
	
	var Flags = Node.Flags = {
	  Router:     0x01, // Responsible for propagating tuples, cannot be skipped.
	  Collector:  0x02, // Holds a materialized dataset, pulse node to reflow.
	  Produces:   0x04, // Produces new tuples. 
	  Mutates:    0x08, // Sets properties of incoming tuples.
	  Reflows:    0x10, // Forwards a reflow pulse.
	  Batch:      0x20  // Performs batch data processing, needs collector.
	};
	
	var prototype = Node.prototype;
	
	prototype.init = function(graph) {
	  this._id = ++nodeID;
	  this._graph = graph;
	  this._rank  = graph.rank(); // Topological sort by rank
	  this._qrank = null; // Rank when enqueued for propagation
	  this._stamp = 0;    // Last stamp seen
	
	  this._listeners = [];
	  this._listeners._ids = {}; // To prevent duplicate listeners
	
	  // Initialize dependencies.
	  this._deps = {};
	  for (var i=0, n=DEPS.length; i<n; ++i) {
	    this._deps[DEPS[i]] = [];
	  }
	
	  // Initialize status flags.
	  this._flags = 0;
	
	  return this;
	};
	
	prototype.rank = function() {
	  return this._rank;
	};
	
	prototype.rerank = function() {
	  var g = this._graph, 
	      q = [this],
	      cur;
	
	  while (q.length) {
	    cur = q.shift();
	    cur._rank = g.rank();
	    q.unshift.apply(q, cur.listeners());
	  }
	
	  return this;
	};
	
	prototype.qrank = function(/* set */) {
	  if (!arguments.length) return this._qrank;
	  return (this._qrank = this._rank, this);
	};
	
	prototype.last = function(stamp) { 
	  if (!arguments.length) return this._stamp;
	  return (this._stamp = stamp, this);
	};
	
	// -- status flags ---
	
	prototype._setf = function(v, b) {
	  if (b) { this._flags |= v; } else { this._flags &= ~v; }
	  return this;
	};
	
	prototype.router = function(state) {
	  if (!arguments.length) return (this._flags & Flags.Router);
	  return this._setf(Flags.Router, state);
	};
	
	prototype.collector = function(state) {
	  if (!arguments.length) return (this._flags & Flags.Collector);
	  return this._setf(Flags.Collector, state);
	};
	
	prototype.produces = function(state) {
	  if (!arguments.length) return (this._flags & Flags.Produces);
	  return this._setf(Flags.Produces, state);
	};
	
	prototype.mutates = function(state) {
	  if (!arguments.length) return (this._flags & Flags.Mutates);
	  return this._setf(Flags.Mutates, state);
	};
	
	prototype.reflows = function(state) {
	  if (!arguments.length) return (this._flags & Flags.Reflows);
	  return this._setf(Flags.Reflows, state);
	};
	
	prototype.batch = function(state) {
	  if (!arguments.length) return (this._flags & Flags.Batch);
	  return this._setf(Flags.Batch, state);
	};
	
	prototype.dependency = function(type, deps) {
	  var d = this._deps[type],
	      n = d._names || (d._names = {});  // To prevent dupe deps
	
	  // Get dependencies of the given type
	  if (arguments.length === 1) {
	    return d;
	  }
	
	  if (deps === null) {
	    // Clear dependencies of the given type
	    d.splice(0, d.length);
	    d._names = {};
	  } else if (!Array.isArray(deps)) {
	    // Separate this case to avoid cost of array creation
	    if (n[deps]) return this;
	    d.push(deps);
	    n[deps] = 1;
	  } else {
	    for (var i=0, len=deps.length, dep; i<len; ++i) {
	      dep = deps[i];
	      if (n[dep]) continue;
	      d.push(dep);
	      n[dep] = 1;
	    }
	  }
	
	  return this;
	};
	
	prototype.listeners = function() {
	  return this._listeners;
	};
	
	prototype.addListener = function(l) {
	  if (!(l instanceof Node)) {
	    throw Error('Listener is not a Node');
	  }
	  if (this._listeners._ids[l._id]) return this;
	
	  this._listeners.push(l);
	  this._listeners._ids[l._id] = 1;
	  if (this._rank > l._rank) {
	    l.rerank();
	  }
	
	  return this;
	};
	
	prototype.removeListener = function(l) {
	  if (!this._listeners._ids[l._id]) return false;
	  
	  var idx = this._listeners.indexOf(l),
	      b = idx >= 0;
	
	  if (b) {
	    this._listeners.splice(idx, 1);
	    this._listeners._ids[l._id] = null;
	  }
	  return b;
	};
	
	prototype.disconnect = function() {
	  this._listeners = [];
	  this._listeners._ids = {};
	};
	
	// Evaluate this dataflow node for the current pulse.
	// Subclasses should override to perform custom processing.
	prototype.evaluate = function(pulse) {
	  return pulse;
	};
	
	// Should this node be re-evaluated for the current pulse?
	// Searches pulse to see if any dependencies have updated.
	prototype.reevaluate = function(pulse) {
	  var prop, dep, i, n, j, m;
	
	  for (i=0, n=DEPS.length; i<n; ++i) {
	    prop = DEPS[i];
	    dep = this._deps[prop];
	    for (j=0, m=dep.length; j<m; ++j) {
	      if (pulse[prop][dep[j]]) return true;
	    }
	  }
	
	  return false;
	};
	
	Node.reset = function() { nodeID = 0; };
	
	module.exports = Node;
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/Node.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/DataSource.js **/
jupyter.define('vega-dataflow@1.4.3/src/DataSource.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    ChangeSet = __jupyter_require__('vega-dataflow@~1.4.3/src/ChangeSet.js'),
	    Collector = __jupyter_require__('vega-dataflow@~1.4.3/src/Collector.js'),
	    Tuple = __jupyter_require__('vega-dataflow@~1.4.3/src/Tuple.js'),
	    Node = __jupyter_require__('vega-dataflow@~1.4.3/src/Node.js'); // jshint ignore:line
	
	function DataSource(graph, name, facet) {
	  this._graph = graph;
	  this._name = name;
	  this._data = [];
	  this._source = null;
	  this._facet  = facet;
	  this._input  = ChangeSet.create();
	  this._output = null; // Output changeset
	  this._indexes = {};
	  this._indexFields = [];
	
	  this._inputNode  = null;
	  this._outputNode = null;
	  this._pipeline  = null; // Pipeline of transformations.
	  this._collector = null; // Collector to materialize output of pipeline.
	  this._mutates = false;  // Does any pipeline operator mutate tuples?
	}
	
	var prototype = DataSource.prototype;
	
	prototype.name = function(name) {
	  if (!arguments.length) return this._name;
	  return (this._name = name, this);
	};
	
	prototype.source = function(src) {
	  if (!arguments.length) return this._source;
	  return (this._source = this._graph.data(src));
	};
	
	prototype.insert = function(tuples) {
	  this._input.add = this._input.add.concat(tuples.map(Tuple.ingest));
	  return this;
	};
	
	prototype.remove = function(where) {
	  var remove = this._data.filter(where);
	  this._input.rem = this._input.rem.concat(remove);
	  return this;
	};
	
	prototype.update = function(where, field, func) {
	  var mod = this._input.mod,
	      ids = Tuple.idMap(mod);
	
	  this._input.fields[field] = 1;
	
	  this._data.filter(where).forEach(function(x) {
	    var prev = x[field],
	        next = func(x);
	    if (prev !== next) {
	      Tuple.set(x, field, next);
	      if (ids[x._id] !== 1) {
	        mod.push(x);
	        ids[x._id] = 1;
	      }
	    }
	  });
	
	  return this;
	};
	
	prototype.values = function(data) {
	  if (!arguments.length) return this._collector.data();
	
	  // Replace backing data
	  this._input.rem = this._data.slice();
	  if (data) { this.insert(data); }
	  return this;
	};
	
	prototype.mutates = function(m) {
	  if (!arguments.length) return this._mutates;
	  this._mutates = this._mutates || m;
	  return this;
	};
	
	prototype.last = function() {
	  return this._output;
	};
	
	prototype.fire = function(input) {
	  if (input) this._input = input;
	  this._graph.propagate(this._input, this._pipeline[0]);
	  return this;
	};
	
	prototype.pipeline = function(pipeline) {
	  if (!arguments.length) return this._pipeline;
	
	  var graph = this._graph,
	      status;
	
	  pipeline.unshift(this._inputNode = DataSourceInput(this));
	  status = graph.preprocess(pipeline);
	
	  if (status.router) {
	    pipeline.push(status.collector = new Collector(graph));
	  }
	
	  pipeline.push(this._outputNode = DataSourceOutput(this));
	  this._collector = status.collector;
	  this._mutates = !!status.mutates;
	  graph.connect(this._pipeline = pipeline);
	
	  return this;
	};
	
	prototype.synchronize = function() {
	  this._graph.synchronize(this._pipeline);
	  return this;
	};
	
	prototype.getIndex = function(field) {
	  var data = this.values(),
	      indexes = this._indexes,
	      fields  = this._indexFields,
	      f = dl.$(field),
	      index, i, len, value;
	
	  if (!indexes[field]) {
	    indexes[field] = index = {};
	    fields.push(field);
	    for (i=0, len=data.length; i<len; ++i) {
	      value = f(data[i]);
	      index[value] = (index[value] || 0) + 1;
	      Tuple.prev_init(data[i]);
	    }
	  }
	  return indexes[field];
	};
	
	prototype.listener = function() {
	  return DataSourceListener(this).addListener(this._inputNode);
	};
	
	prototype.addListener = function(l) {
	  if (l instanceof DataSource) {
	    this._collector.addListener(l.listener());
	  } else {
	    this._outputNode.addListener(l);
	  }
	  return this;
	};
	
	prototype.removeListener = function(l) {
	  this._outputNode.removeListener(l);
	};
	
	prototype.listeners = function(ds) {
	  return (ds ? this._collector : this._outputNode).listeners();
	};
	
	// Input node applies the datasource's delta, and propagates it to
	// the rest of the pipeline. It receives touches to reflow data.
	function DataSourceInput(ds) {
	  var input = new Node(ds._graph)
	    .router(true)
	    .collector(true);
	
	  input.data = function() {
	    return ds._data;
	  };
	
	  input.evaluate = function(input) {
	    log.debug(input, ['input', ds._name]);
	
	    var delta = ds._input,
	        out = ChangeSet.create(input), f;
	
	    // Delta might contain fields updated through API
	    for (f in delta.fields) {
	      out.fields[f] = 1;
	    }
	
	    // update data
	    if (delta.rem.length) {
	      ds._data = Tuple.idFilter(ds._data, delta.rem);
	    }
	
	    if (delta.add.length) {
	      ds._data = ds._data.concat(delta.add);
	    }
	
	    if (delta.sort) {
	      ds._data.sort(delta.sort);
	    }
	
	    // if reflowing, add any other tuples not currently in changeset
	    if (input.reflow) {
	      delta.mod = delta.mod.concat(
	        Tuple.idFilter(ds._data, delta.add, delta.mod, delta.rem));
	    }
	
	    // reset change list
	    ds._input = ChangeSet.create();
	
	    out.add = delta.add;
	    out.mod = delta.mod;
	    out.rem = delta.rem;
	    out.facet = ds._facet;
	    return out;
	  };
	
	  return input;
	}
	
	// Output node captures the last changeset seen by this datasource
	// (needed for joins and builds) and materializes any nested data.
	// If this datasource is faceted, materializes the values in the facet.
	function DataSourceOutput(ds) {
	  var output = new Node(ds._graph)
	    .router(true)
	    .reflows(true)
	    .collector(true);
	
	  function updateIndices(pulse) {
	    var fields = ds._indexFields,
	        i, j, f, key, index, value;
	
	    for (i=0; i<fields.length; ++i) {
	      key = fields[i];
	      index = ds._indexes[key];
	      f = dl.$(key);
	
	      for (j=0; j<pulse.add.length; ++j) {
	        value = f(pulse.add[j]);
	        Tuple.prev_init(pulse.add[j]);
	        index[value] = (index[value] || 0) + 1;
	      }
	      for (j=0; j<pulse.rem.length; ++j) {
	        value = f(pulse.rem[j]);
	        index[value] = (index[value] || 0) - 1;
	      }
	      for (j=0; j<pulse.mod.length; ++j) {
	        value = f(pulse.mod[j]._prev);
	        index[value] = (index[value] || 0) - 1;
	        value = f(pulse.mod[j]);
	        index[value] = (index[value] || 0) + 1;
	      }
	    }
	  }
	
	  output.data = function() {
	    return ds._collector ? ds._collector.data() : ds._data;
	  };
	
	  output.evaluate = function(input) {
	    log.debug(input, ['output', ds._name]);
	
	    updateIndices(input);
	    var out = ChangeSet.create(input, true);
	
	    if (ds._facet) {
	      ds._facet.values = ds.values();
	      input.facet = null;
	    }
	
	    ds._output = input;
	    out.data[ds._name] = 1;
	    return out;
	  };
	
	  return output;
	}
	
	function DataSourceListener(ds) {
	  var l = new Node(ds._graph).router(true);
	
	  l.evaluate = function(input) {
	    // Tuple derivation carries a cost. So only derive if the pipeline has
	    // operators that mutate, and thus would override the source data.
	    if (ds.mutates()) {
	      var map = ds._srcMap || (ds._srcMap = {}), // to propagate tuples correctly
	          output = ChangeSet.create(input);
	
	      output.add = input.add.map(function(t) {
	        return (map[t._id] = Tuple.derive(t));
	      });
	
	      output.mod = input.mod.map(function(t) {
	        return Tuple.rederive(t, map[t._id]);
	      });
	
	      output.rem = input.rem.map(function(t) {
	        var o = map[t._id];
	        return (map[t._id] = null, o);
	      });
	
	      return (ds._input = output);
	    } else {
	      return (ds._input = input);
	    }
	  };
	
	  return l;
	}
	
	module.exports = DataSource;
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/DataSource.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/index.js **/
jupyter.define('datalib@1.7.2/src/index.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	
	var dl = {
	  version:    '__VERSION__',
	  load:       __jupyter_require__('datalib@~1.7.2/src/import/load.js'),
	  read:       __jupyter_require__('datalib@~1.7.2/src/import/read.js'),
	  type:       __jupyter_require__('datalib@~1.7.2/src/import/type.js'),
	  Aggregator: __jupyter_require__('datalib@~1.7.2/src/aggregate/aggregator.js'),
	  groupby:    __jupyter_require__('datalib@~1.7.2/src/aggregate/groupby.js'),
	  bins:       __jupyter_require__('datalib@~1.7.2/src/bins/bins.js'),
	  $bin:       __jupyter_require__('datalib@~1.7.2/src/bins/histogram.js').$bin,
	  histogram:  __jupyter_require__('datalib@~1.7.2/src/bins/histogram.js').histogram,
	  format:     __jupyter_require__('datalib@~1.7.2/src/format.js'),
	  template:   __jupyter_require__('datalib@~1.7.2/src/template.js'),
	  time:       __jupyter_require__('datalib@~1.7.2/src/time.js')
	};
	
	util.extend(dl, util);
	util.extend(dl, __jupyter_require__('datalib@~1.7.2/src/accessor.js'));
	util.extend(dl, __jupyter_require__('datalib@~1.7.2/src/generate.js'));
	util.extend(dl, __jupyter_require__('datalib@~1.7.2/src/stats.js'));
	util.extend(dl, __jupyter_require__('datalib@~1.7.2/src/import/readers.js'));
	util.extend(dl.format, __jupyter_require__('datalib@~1.7.2/src/format-tables.js'));
	
	// backwards-compatible, deprecated API
	// will remove in the future
	dl.print = {
	  table:   dl.format.table,
	  summary: dl.format.summary
	};
	
	module.exports = dl;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/index.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/util.js **/
jupyter.define('datalib@1.7.2/src/util.js', function (module, exports, __jupyter_require__) {
	/* WEBPACK VAR INJECTION */(function(Buffer) {var u = module.exports;
	
	// utility functions
	
	var FNAME = '__name__';
	
	u.namedfunc = function(name, f) { return (f[FNAME] = name, f); };
	
	u.name = function(f) { return f==null ? null : f[FNAME]; };
	
	u.identity = function(x) { return x; };
	
	u.true = u.namedfunc('true', function() { return true; });
	
	u.false = u.namedfunc('false', function() { return false; });
	
	u.duplicate = function(obj) {
	  return JSON.parse(JSON.stringify(obj));
	};
	
	u.equal = function(a, b) {
	  return JSON.stringify(a) === JSON.stringify(b);
	};
	
	u.extend = function(obj) {
	  for (var x, name, i=1, len=arguments.length; i<len; ++i) {
	    x = arguments[i];
	    for (name in x) { obj[name] = x[name]; }
	  }
	  return obj;
	};
	
	u.length = function(x) {
	  return x != null && x.length != null ? x.length : null;
	};
	
	u.keys = function(x) {
	  var keys = [], k;
	  for (k in x) keys.push(k);
	  return keys;
	};
	
	u.vals = function(x) {
	  var vals = [], k;
	  for (k in x) vals.push(x[k]);
	  return vals;
	};
	
	u.toMap = function(list, f) {
	  return (f = u.$(f)) ?
	    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :
	    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});
	};
	
	u.keystr = function(values) {
	  // use to ensure consistent key generation across modules
	  var n = values.length;
	  if (!n) return '';
	  for (var s=String(values[0]), i=1; i<n; ++i) {
	    s += '|' + String(values[i]);
	  }
	  return s;
	};
	
	// type checking functions
	
	var toString = Object.prototype.toString;
	
	u.isObject = function(obj) {
	  return obj === Object(obj);
	};
	
	u.isFunction = function(obj) {
	  return toString.call(obj) === '[object Function]';
	};
	
	u.isString = function(obj) {
	  return typeof value === 'string' || toString.call(obj) === '[object String]';
	};
	
	u.isArray = Array.isArray || function(obj) {
	  return toString.call(obj) === '[object Array]';
	};
	
	u.isNumber = function(obj) {
	  return typeof obj === 'number' || toString.call(obj) === '[object Number]';
	};
	
	u.isBoolean = function(obj) {
	  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
	};
	
	u.isDate = function(obj) {
	  return toString.call(obj) === '[object Date]';
	};
	
	u.isValid = function(obj) {
	  return obj != null && obj === obj;
	};
	
	u.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;
	
	// type coercion functions
	
	u.number = function(s) {
	  return s == null || s === '' ? null : +s;
	};
	
	u.boolean = function(s) {
	  return s == null || s === '' ? null : s==='false' ? false : !!s;
	};
	
	// parse a date with optional d3.time-format format
	u.date = function(s, format) {
	  var d = format ? format : Date;
	  return s == null || s === '' ? null : d.parse(s);
	};
	
	u.array = function(x) {
	  return x != null ? (u.isArray(x) ? x : [x]) : [];
	};
	
	u.str = function(x) {
	  return u.isArray(x) ? '[' + x.map(u.str) + ']'
	    : u.isObject(x) || u.isString(x) ?
	      // Output valid JSON and JS source strings.
	      // See http://timelessrepo.com/json-isnt-a-javascript-subset
	      JSON.stringify(x).replace('\u2028','\\u2028').replace('\u2029', '\\u2029')
	    : x;
	};
	
	// data access functions
	
	var field_re = /\[(.*?)\]|[^.\[]+/g;
	
	u.field = function(f) {
	  return String(f).match(field_re).map(function(d) {
	    return d[0] !== '[' ? d :
	      d[1] !== "'" && d[1] !== '"' ? d.slice(1, -1) :
	      d.slice(2, -2).replace(/\\(["'])/g, '$1');
	  });
	};
	
	u.accessor = function(f) {
	  /* jshint evil: true */
	  return f==null || u.isFunction(f) ? f :
	    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));
	};
	
	// short-cut for accessor
	u.$ = u.accessor;
	
	u.mutator = function(f) {
	  var s;
	  return u.isString(f) && (s=u.field(f)).length > 1 ?
	    function(x, v) {
	      for (var i=0; i<s.length-1; ++i) x = x[s[i]];
	      x[s[i]] = v;
	    } :
	    function(x, v) { x[f] = v; };
	};
	
	
	u.$func = function(name, op) {
	  return function(f) {
	    f = u.$(f) || u.identity;
	    var n = name + (u.name(f) ? '_'+u.name(f) : '');
	    return u.namedfunc(n, function(d) { return op(f(d)); });
	  };
	};
	
	u.$valid  = u.$func('valid', u.isValid);
	u.$length = u.$func('length', u.length);
	
	u.$in = function(f, values) {
	  f = u.$(f);
	  var map = u.isArray(values) ? u.toMap(values) : values;
	  return function(d) { return !!map[f(d)]; };
	};
	
	// comparison / sorting functions
	
	u.comparator = function(sort) {
	  var sign = [];
	  if (sort === undefined) sort = [];
	  sort = u.array(sort).map(function(f) {
	    var s = 1;
	    if      (f[0] === '-') { s = -1; f = f.slice(1); }
	    else if (f[0] === '+') { s = +1; f = f.slice(1); }
	    sign.push(s);
	    return u.accessor(f);
	  });
	  return function(a, b) {
	    var i, n, f, c;
	    for (i=0, n=sort.length; i<n; ++i) {
	      f = sort[i];
	      c = u.cmp(f(a), f(b));
	      if (c) return c * sign[i];
	    }
	    return 0;
	  };
	};
	
	u.cmp = function(a, b) {
	  return (a < b || a == null) && b != null ? -1 :
	    (a > b || b == null) && a != null ? 1 :
	    ((b = b instanceof Date ? +b : b),
	     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :
	    b !== b && a === a ? 1 : 0;
	};
	
	u.numcmp = function(a, b) { return a - b; };
	
	u.stablesort = function(array, sortBy, keyFn) {
	  var indices = array.reduce(function(idx, v, i) {
	    return (idx[keyFn(v)] = i, idx);
	  }, {});
	
	  array.sort(function(a, b) {
	    var sa = sortBy(a),
	        sb = sortBy(b);
	    return sa < sb ? -1 : sa > sb ? 1
	         : (indices[keyFn(a)] - indices[keyFn(b)]);
	  });
	
	  return array;
	};
	
	// permutes an array using a Knuth shuffle
	u.permute = function(a) {
	  var m = a.length,
	      swap,
	      i;
	
	  while (m) {
	    i = Math.floor(Math.random() * m--);
	    swap = a[m];
	    a[m] = a[i];
	    a[i] = swap;
	  }
	};
	
	// string functions
	
	u.pad = function(s, length, pos, padchar) {
	  padchar = padchar || " ";
	  var d = length - s.length;
	  if (d <= 0) return s;
	  switch (pos) {
	    case 'left':
	      return strrep(d, padchar) + s;
	    case 'middle':
	    case 'center':
	      return strrep(Math.floor(d/2), padchar) +
	         s + strrep(Math.ceil(d/2), padchar);
	    default:
	      return s + strrep(d, padchar);
	  }
	};
	
	function strrep(n, str) {
	  var s = "", i;
	  for (i=0; i<n; ++i) s += str;
	  return s;
	}
	
	u.truncate = function(s, length, pos, word, ellipsis) {
	  var len = s.length;
	  if (len <= length) return s;
	  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\u2026';
	  var l = Math.max(0, length - ellipsis.length);
	
	  switch (pos) {
	    case 'left':
	      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));
	    case 'middle':
	    case 'center':
	      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);
	      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +
	        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));
	    default:
	      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;
	  }
	};
	
	function truncateOnWord(s, len, rev) {
	  var cnt = 0, tok = s.split(truncate_word_re);
	  if (rev) {
	    s = (tok = tok.reverse())
	      .filter(function(w) { cnt += w.length; return cnt <= len; })
	      .reverse();
	  } else {
	    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });
	  }
	  return s.length ? s.join('').trim() : tok[0].slice(0, len);
	}
	
	var truncate_word_re = /([\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF])/;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __jupyter_require__('buffer@4.9.1/index.js').Buffer))
})
/** END DEFINE BLOCK for datalib@1.7.2/src/util.js **/


/** START DEFINE BLOCK for buffer@4.9.1/index.js **/
jupyter.define('buffer@4.9.1/index.js', function (module, exports, __jupyter_require__) {
	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __jupyter_require__('base64-js@^1.0.2/index.js')
	var ieee754 = __jupyter_require__('ieee754@^1.1.4/index.js')
	var isArray = __jupyter_require__('isarray@^1.0.0/index.js')
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __jupyter_require__('buffer@4.9.1/index.js').Buffer, (function() { return this; }())))
})
/** END DEFINE BLOCK for buffer@4.9.1/index.js **/


/** START DEFINE BLOCK for base64-js@1.2.0/index.js **/
jupyter.define('base64-js@1.2.0/index.js', function (module, exports, __jupyter_require__) {
	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}
	
	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}
	
	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)
	
	  arr = new Arr(len * 3 / 4 - placeHolders)
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len
	
	  var L = 0
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }
	
	  parts.push(output)
	
	  return parts.join('')
	}
	
})
/** END DEFINE BLOCK for base64-js@1.2.0/index.js **/


/** START DEFINE BLOCK for ieee754@1.1.6/index.js **/
jupyter.define('ieee754@1.1.6/index.js', function (module, exports, __jupyter_require__) {
	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}
	
})
/** END DEFINE BLOCK for ieee754@1.1.6/index.js **/


/** START DEFINE BLOCK for isarray@1.0.0/index.js **/
jupyter.define('isarray@1.0.0/index.js', function (module, exports, __jupyter_require__) {
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};
	
})
/** END DEFINE BLOCK for isarray@1.0.0/index.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/load.js **/
jupyter.define('datalib@1.7.2/src/import/load.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	
	// Matches absolute URLs with optional protocol
	//   https://...    file://...    //...
	var protocol_re = /^([A-Za-z]+:)?\/\//;
	
	// Special treatment in node.js for the file: protocol
	var fileProtocol = 'file://';
	
	// Validate and cleanup URL to ensure that it is allowed to be accessed
	// Returns cleaned up URL, or false if access is not allowed
	function sanitizeUrl(opt) {
	  var url = opt.url;
	  if (!url && opt.file) { return fileProtocol + opt.file; }
	
	  // In case this is a relative url (has no host), prepend opt.baseURL
	  if (opt.baseURL && !protocol_re.test(url)) {
	    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {
	      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url
	    }
	    url = opt.baseURL + url;
	  }
	  // relative protocol, starts with '//'
	  if (!load.useXHR && startsWith(url, '//')) {
	    url = (opt.defaultProtocol || 'http') + ':' + url;
	  }
	  // If opt.domainWhiteList is set, only allows url, whose hostname
	  // * Is the same as the origin (window.location.hostname)
	  // * Equals one of the values in the whitelist
	  // * Is a proper subdomain of one of the values in the whitelist
	  if (opt.domainWhiteList) {
	    var domain, origin;
	    if (load.useXHR) {
	      var a = document.createElement('a');
	      a.href = url;
	      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript
	      // IE doesn't populate all link properties when setting .href with a relative URL,
	      // however .href will return an absolute URL which then can be used on itself
	      // to populate these additional fields.
	      if (a.host === '') {
	        a.href = a.href;
	      }
	      domain = a.hostname.toLowerCase();
	      origin = window.location.hostname;
	    } else {
	      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5
	      var parts = __jupyter_require__('__ignored__').parse(url);
	      domain = parts.hostname;
	      origin = null;
	    }
	
	    if (origin !== domain) {
	      var whiteListed = opt.domainWhiteList.some(function(d) {
	        var idx = domain.length - d.length;
	        return d === domain ||
	          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);
	      });
	      if (!whiteListed) {
	        throw 'URL is not whitelisted: ' + url;
	      }
	    }
	  }
	  return url;
	}
	
	function load(opt, callback) {
	  return load.loader(opt, callback);
	}
	
	function loader(opt, callback) {
	  var error = callback || function(e) { throw e; }, url;
	
	  try {
	    url = load.sanitizeUrl(opt); // enable override
	  } catch (err) {
	    error(err);
	    return;
	  }
	
	  if (!url) {
	    error('Invalid URL: ' + opt.url);
	  } else if (load.useXHR) {
	    // on client, use xhr
	    return load.xhr(url, opt, callback);
	  } else if (startsWith(url, fileProtocol)) {
	    // on server, if url starts with 'file://', strip it and load from file
	    return load.file(url.slice(fileProtocol.length), opt, callback);
	  } else if (url.indexOf('://') < 0) { // TODO better protocol check?
	    // on server, if no protocol assume file
	    return load.file(url, opt, callback);
	  } else {
	    // for regular URLs on server
	    return load.http(url, opt, callback);
	  }
	}
	
	function xhrHasResponse(request) {
	  var type = request.responseType;
	  return type && type !== 'text' ?
	    request.response : // null on error
	    request.responseText; // '' on error
	}
	
	function xhr(url, opt, callback) {
	  var async = !!callback;
	  var request = new XMLHttpRequest();
	  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)
	  if (typeof XDomainRequest !== 'undefined' &&
	      !('withCredentials' in request) &&
	      /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	
	  function respond() {
	    var status = request.status;
	    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	      callback(null, request.responseText);
	    } else {
	      callback(request, null);
	    }
	  }
	
	  if (async) {
	    if ('onload' in request) {
	      request.onload = request.onerror = respond;
	    } else {
	      request.onreadystatechange = function() {
	        if (request.readyState > 3) respond();
	      };
	    }
	  }
	
	  request.open('GET', url, async);
	  /* istanbul ignore else */
	  if (request.setRequestHeader) {
	    var headers = util.extend({}, load.headers, opt.headers);
	    for (var name in headers) {
	      request.setRequestHeader(name, headers[name]);
	    }
	  }
	  request.send();
	
	  if (!async && xhrHasResponse(request)) {
	    return request.responseText;
	  }
	}
	
	function file(filename, opt, callback) {
	  var fs = __jupyter_require__('__ignored__');
	  if (!callback) {
	    return fs.readFileSync(filename, 'utf8');
	  }
	  fs.readFile(filename, callback);
	}
	
	function http(url, opt, callback) {
	  var headers = util.extend({}, load.headers, opt.headers);
	
	  var options = {url: url, encoding: null, gzip: true, headers: headers};
	  if (!callback) {
	    return __jupyter_require__('__ignored__')('GET', url, options).getBody();
	  }
	  __jupyter_require__('__ignored__')(options, function(error, response, body) {
	    if (!error && response.statusCode === 200) {
	      callback(null, body);
	    } else {
	      error = error ||
	        'Load failed with response code ' + response.statusCode + '.';
	      callback(error, null);
	    }
	  });
	}
	
	function startsWith(string, searchString) {
	  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;
	}
	
	// Allow these functions to be overriden by the user of the library
	load.loader = loader;
	load.sanitizeUrl = sanitizeUrl;
	load.xhr = xhr;
	load.file = file;
	load.http = http;
	
	// Default settings
	load.useXHR = (typeof XMLHttpRequest !== 'undefined');
	load.headers = {};
	
	module.exports = load;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/load.js **/


/** START DEFINE BLOCK for __ignored__ **/
jupyter.define('__ignored__', function (module, exports, __jupyter_require__) {
	/* (ignored) */
})
/** END DEFINE BLOCK for __ignored__ **/


/** START DEFINE BLOCK for __ignored__ **/
jupyter.define('__ignored__', function (module, exports, __jupyter_require__) {
	/* (ignored) */
})
/** END DEFINE BLOCK for __ignored__ **/


/** START DEFINE BLOCK for __ignored__ **/
jupyter.define('__ignored__', function (module, exports, __jupyter_require__) {
	/* (ignored) */
})
/** END DEFINE BLOCK for __ignored__ **/


/** START DEFINE BLOCK for __ignored__ **/
jupyter.define('__ignored__', function (module, exports, __jupyter_require__) {
	/* (ignored) */
})
/** END DEFINE BLOCK for __ignored__ **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/read.js **/
jupyter.define('datalib@1.7.2/src/import/read.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	  type = __jupyter_require__('datalib@~1.7.2/src/import/type.js'),
	  formats = __jupyter_require__('datalib@~1.7.2/src/import/formats/index.js'),
	  timeF = __jupyter_require__('datalib@~1.7.2/src/format.js').time;
	
	function read(data, format) {
	  var type = (format && format.type) || 'json';
	  data = formats[type](data, format);
	  if (format && format.parse) parse(data, format.parse);
	  return data;
	}
	
	function parse(data, types) {
	  var cols, parsers, d, i, j, clen, len = data.length;
	
	  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);
	  cols = util.keys(types);
	  parsers = cols.map(function(c) {
	    var t = types[c];
	    if (t && t.indexOf('date:') === 0) {
	      var parts = t.split(/:(.+)?/, 2),  // split on first :
	          pattern = parts[1];
	      if ((pattern[0] === '\'' && pattern[pattern.length-1] === '\'') ||
	          (pattern[0] === '"'  && pattern[pattern.length-1] === '"')) {
	        pattern = pattern.slice(1, -1);
	      } else {
	        throw Error('Format pattern must be quoted: ' + pattern);
	      }
	      pattern = timeF(pattern);
	      return function(v) { return pattern.parse(v); };
	    }
	    if (!type.parsers[t]) {
	      throw Error('Illegal format pattern: ' + c + ':' + t);
	    }
	    return type.parsers[t];
	  });
	
	  for (i=0, clen=cols.length; i<len; ++i) {
	    d = data[i];
	    for (j=0; j<clen; ++j) {
	      d[cols[j]] = parsers[j](d[cols[j]]);
	    }
	  }
	  type.annotation(data, types);
	}
	
	read.formats = formats;
	module.exports = read;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/read.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/type.js **/
jupyter.define('datalib@1.7.2/src/import/type.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	
	var TYPES = '__types__';
	
	var PARSERS = {
	  boolean: util.boolean,
	  integer: util.number,
	  number:  util.number,
	  date:    util.date,
	  string:  function(x) { return x == null || x === '' ? null : x + ''; }
	};
	
	var TESTS = {
	  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },
	  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },
	  number: function(x) { return !isNaN(+x) && !util.isDate(x); },
	  date: function(x) { return !isNaN(Date.parse(x)); }
	};
	
	function annotation(data, types) {
	  if (!types) return data && data[TYPES] || null;
	  data[TYPES] = types;
	}
	
	function type(values, f) {
	  values = util.array(values);
	  f = util.$(f);
	  var v, i, n;
	
	  // if data array has type annotations, use them
	  if (values[TYPES]) {
	    v = f(values[TYPES]);
	    if (util.isString(v)) return v;
	  }
	
	  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	  }
	
	  return util.isDate(v) ? 'date' :
	    util.isNumber(v)    ? 'number' :
	    util.isBoolean(v)   ? 'boolean' :
	    util.isString(v)    ? 'string' : null;
	}
	
	function typeAll(data, fields) {
	  if (!data.length) return;
	  fields = fields || util.keys(data[0]);
	  return fields.reduce(function(types, f) {
	    return (types[f] = type(data, f), types);
	  }, {});
	}
	
	function infer(values, f) {
	  values = util.array(values);
	  f = util.$(f);
	  var i, j, v;
	
	  // types to test for, in precedence order
	  var types = ['boolean', 'integer', 'number', 'date'];
	
	  for (i=0; i<values.length; ++i) {
	    // get next value to test
	    v = f ? f(values[i]) : values[i];
	    // test value against remaining types
	    for (j=0; j<types.length; ++j) {
	      if (util.isValid(v) && !TESTS[types[j]](v)) {
	        types.splice(j, 1);
	        j -= 1;
	      }
	    }
	    // if no types left, return 'string'
	    if (types.length === 0) return 'string';
	  }
	
	  return types[0];
	}
	
	function inferAll(data, fields) {
	  fields = fields || util.keys(data[0]);
	  return fields.reduce(function(types, f) {
	    types[f] = infer(data, f);
	    return types;
	  }, {});
	}
	
	type.annotation = annotation;
	type.all = typeAll;
	type.infer = infer;
	type.inferAll = inferAll;
	type.parsers = PARSERS;
	module.exports = type;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/type.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/formats/index.js **/
jupyter.define('datalib@1.7.2/src/import/formats/index.js', function (module, exports, __jupyter_require__) {
	var dsv = __jupyter_require__('datalib@~1.7.2/src/import/formats/dsv.js');
	
	module.exports = {
	  json: __jupyter_require__('datalib@~1.7.2/src/import/formats/json.js'),
	  topojson: __jupyter_require__('datalib@~1.7.2/src/import/formats/topojson.js'),
	  treejson: __jupyter_require__('datalib@~1.7.2/src/import/formats/treejson.js'),
	  dsv: dsv,
	  csv: dsv.delimiter(','),
	  tsv: dsv.delimiter('\t')
	};
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/formats/index.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/formats/dsv.js **/
jupyter.define('datalib@1.7.2/src/import/formats/dsv.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	var d3_dsv = __jupyter_require__('d3-dsv@0.1/build/d3-dsv.js');
	
	function dsv(data, format) {
	  if (data) {
	    var h = format.header;
	    data = (h ? h.join(format.delimiter) + '\n' : '') + data;
	  }
	  return d3_dsv.dsv(format.delimiter).parse(data);
	}
	
	dsv.delimiter = function(delim) {
	  var fmt = {delimiter: delim};
	  return function(data, format) {
	    return dsv(data, format ? util.extend(format, fmt) : fmt);
	  };
	};
	
	module.exports = dsv;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/formats/dsv.js **/


/** START DEFINE BLOCK for d3-dsv@0.1.14/build/d3-dsv.js **/
jupyter.define('d3-dsv@0.1.14/build/d3-dsv.js', function (module, exports, __jupyter_require__) {
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3_dsv = {})));
	}(this, function (exports) { 'use strict';
	
	  function dsv(delimiter) {
	    return new Dsv(delimiter);
	  }
	
	  function objectConverter(columns) {
	    return new Function("d", "return {" + columns.map(function(name, i) {
	      return JSON.stringify(name) + ": d[" + i + "]";
	    }).join(",") + "}");
	  }
	
	  function customConverter(columns, f) {
	    var object = objectConverter(columns);
	    return function(row, i) {
	      return f(object(row), i, columns);
	    };
	  }
	
	  // Compute unique columns in order of discovery.
	  function inferColumns(rows) {
	    var columnSet = Object.create(null),
	        columns = [];
	
	    rows.forEach(function(row) {
	      for (var column in row) {
	        if (!(column in columnSet)) {
	          columns.push(columnSet[column] = column);
	        }
	      }
	    });
	
	    return columns;
	  }
	
	  function Dsv(delimiter) {
	    var reFormat = new RegExp("[\"" + delimiter + "\n]"),
	        delimiterCode = delimiter.charCodeAt(0);
	
	    this.parse = function(text, f) {
	      var convert, columns, rows = this.parseRows(text, function(row, i) {
	        if (convert) return convert(row, i - 1);
	        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
	      });
	      rows.columns = columns;
	      return rows;
	    };
	
	    this.parseRows = function(text, f) {
	      var EOL = {}, // sentinel value for end-of-line
	          EOF = {}, // sentinel value for end-of-file
	          rows = [], // output rows
	          N = text.length,
	          I = 0, // current character index
	          n = 0, // the current line number
	          t, // the current token
	          eol; // is the current token followed by EOL?
	
	      function token() {
	        if (I >= N) return EOF; // special case: end of file
	        if (eol) return eol = false, EOL; // special case: end of line
	
	        // special case: quotes
	        var j = I, c;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, "\"");
	        }
	
	        // common case: find next delimiter or newline
	        while (I < N) {
	          var k = 1;
	          c = text.charCodeAt(I++);
	          if (c === 10) eol = true; // \n
	          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \r|\r\n
	          else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	
	        // special case: last token before EOF
	        return text.slice(j);
	      }
	
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	
	      return rows;
	    }
	
	    this.format = function(rows, columns) {
	      if (columns == null) columns = inferColumns(rows);
	      return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
	        return columns.map(function(column) {
	          return formatValue(row[column]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	
	    this.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	
	    function formatValue(text) {
	      return reFormat.test(text) ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
	    }
	  }
	
	  dsv.prototype = Dsv.prototype;
	
	  var csv = dsv(",");
	  var tsv = dsv("\t");
	
	  var version = "0.1.14";
	
	  exports.version = version;
	  exports.dsv = dsv;
	  exports.csv = csv;
	  exports.tsv = tsv;
	
	}));
})
/** END DEFINE BLOCK for d3-dsv@0.1.14/build/d3-dsv.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/formats/json.js **/
jupyter.define('datalib@1.7.2/src/import/formats/json.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	
	module.exports = function(data, format) {
	  var d = util.isObject(data) && !util.isBuffer(data) ?
	    data : JSON.parse(data);
	  if (format && format.property) {
	    d = util.accessor(format.property)(d);
	  }
	  return d;
	};
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/formats/json.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/formats/topojson.js **/
jupyter.define('datalib@1.7.2/src/import/formats/topojson.js', function (module, exports, __jupyter_require__) {
	var json = __jupyter_require__('datalib@~1.7.2/src/import/formats/json.js');
	
	var reader = function(data, format) {
	  var topojson = reader.topojson;
	  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }
	
	  var t = json(data, format), obj;
	
	  if (format && format.feature) {
	    if ((obj = t.objects[format.feature])) {
	      return topojson.feature(t, obj).features;
	    } else {
	      throw Error('Invalid TopoJSON object: ' + format.feature);
	    }
	  } else if (format && format.mesh) {
	    if ((obj = t.objects[format.mesh])) {
	      return [topojson.mesh(t, t.objects[format.mesh])];
	    } else {
	      throw Error('Invalid TopoJSON object: ' + format.mesh);
	    }
	  } else {
	    throw Error('Missing TopoJSON feature or mesh parameter.');
	  }
	};
	
	reader.topojson = __jupyter_require__('topojson@^1.6.19/build/topojson.js');
	module.exports = reader;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/formats/topojson.js **/


/** START DEFINE BLOCK for topojson@1.6.27/build/topojson.js **/
jupyter.define('topojson@1.6.27/build/topojson.js', function (module, exports, __jupyter_require__) {
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.topojson = global.topojson || {})));
	}(this, (function (exports) { 'use strict';
	
	function noop() {}
	
	function transformAbsolute(transform) {
	  if (!transform) return noop;
	  var x0,
	      y0,
	      kx = transform.scale[0],
	      ky = transform.scale[1],
	      dx = transform.translate[0],
	      dy = transform.translate[1];
	  return function(point, i) {
	    if (!i) x0 = y0 = 0;
	    point[0] = (x0 += point[0]) * kx + dx;
	    point[1] = (y0 += point[1]) * ky + dy;
	  };
	}
	
	function transformRelative(transform) {
	  if (!transform) return noop;
	  var x0,
	      y0,
	      kx = transform.scale[0],
	      ky = transform.scale[1],
	      dx = transform.translate[0],
	      dy = transform.translate[1];
	  return function(point, i) {
	    if (!i) x0 = y0 = 0;
	    var x1 = Math.round((point[0] - dx) / kx),
	        y1 = Math.round((point[1] - dy) / ky);
	    point[0] = x1 - x0;
	    point[1] = y1 - y0;
	    x0 = x1;
	    y0 = y1;
	  };
	}
	
	function reverse(array, n) {
	  var t, j = array.length, i = j - n;
	  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
	}
	
	function bisect(a, x) {
	  var lo = 0, hi = a.length;
	  while (lo < hi) {
	    var mid = lo + hi >>> 1;
	    if (a[mid] < x) lo = mid + 1;
	    else hi = mid;
	  }
	  return lo;
	}
	
	function feature(topology, o) {
	  return o.type === "GeometryCollection" ? {
	    type: "FeatureCollection",
	    features: o.geometries.map(function(o) { return feature$1(topology, o); })
	  } : feature$1(topology, o);
	}
	
	function feature$1(topology, o) {
	  var f = {
	    type: "Feature",
	    id: o.id,
	    properties: o.properties || {},
	    geometry: object(topology, o)
	  };
	  if (o.id == null) delete f.id;
	  return f;
	}
	
	function object(topology, o) {
	  var absolute = transformAbsolute(topology.transform),
	      arcs = topology.arcs;
	
	  function arc(i, points) {
	    if (points.length) points.pop();
	    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
	      points.push(p = a[k].slice());
	      absolute(p, k);
	    }
	    if (i < 0) reverse(points, n);
	  }
	
	  function point(p) {
	    p = p.slice();
	    absolute(p, 0);
	    return p;
	  }
	
	  function line(arcs) {
	    var points = [];
	    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
	    if (points.length < 2) points.push(points[0].slice());
	    return points;
	  }
	
	  function ring(arcs) {
	    var points = line(arcs);
	    while (points.length < 4) points.push(points[0].slice());
	    return points;
	  }
	
	  function polygon(arcs) {
	    return arcs.map(ring);
	  }
	
	  function geometry(o) {
	    var t = o.type;
	    return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
	        : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
	        : null;
	  }
	
	  var geometryType = {
	    Point: function(o) { return point(o.coordinates); },
	    MultiPoint: function(o) { return o.coordinates.map(point); },
	    LineString: function(o) { return line(o.arcs); },
	    MultiLineString: function(o) { return o.arcs.map(line); },
	    Polygon: function(o) { return polygon(o.arcs); },
	    MultiPolygon: function(o) { return o.arcs.map(polygon); }
	  };
	
	  return geometry(o);
	}
	
	function stitchArcs(topology, arcs) {
	  var stitchedArcs = {},
	      fragmentByStart = {},
	      fragmentByEnd = {},
	      fragments = [],
	      emptyIndex = -1;
	
	  // Stitch empty arcs first, since they may be subsumed by other arcs.
	  arcs.forEach(function(i, j) {
	    var arc = topology.arcs[i < 0 ? ~i : i], t;
	    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
	      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
	    }
	  });
	
	  arcs.forEach(function(i) {
	    var e = ends(i),
	        start = e[0],
	        end = e[1],
	        f, g;
	
	    if (f = fragmentByEnd[start]) {
	      delete fragmentByEnd[f.end];
	      f.push(i);
	      f.end = end;
	      if (g = fragmentByStart[end]) {
	        delete fragmentByStart[g.start];
	        var fg = g === f ? f : f.concat(g);
	        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
	      } else {
	        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	      }
	    } else if (f = fragmentByStart[end]) {
	      delete fragmentByStart[f.start];
	      f.unshift(i);
	      f.start = start;
	      if (g = fragmentByEnd[start]) {
	        delete fragmentByEnd[g.end];
	        var gf = g === f ? f : g.concat(f);
	        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
	      } else {
	        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
	      }
	    } else {
	      f = [i];
	      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
	    }
	  });
	
	  function ends(i) {
	    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
	    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
	    else p1 = arc[arc.length - 1];
	    return i < 0 ? [p1, p0] : [p0, p1];
	  }
	
	  function flush(fragmentByEnd, fragmentByStart) {
	    for (var k in fragmentByEnd) {
	      var f = fragmentByEnd[k];
	      delete fragmentByStart[f.start];
	      delete f.start;
	      delete f.end;
	      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
	      fragments.push(f);
	    }
	  }
	
	  flush(fragmentByEnd, fragmentByStart);
	  flush(fragmentByStart, fragmentByEnd);
	  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });
	
	  return fragments;
	}
	
	function mesh(topology) {
	  return object(topology, meshArcs.apply(this, arguments));
	}
	
	function meshArcs(topology, o, filter) {
	  var arcs = [];
	
	  function arc(i) {
	    var j = i < 0 ? ~i : i;
	    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
	  }
	
	  function line(arcs) {
	    arcs.forEach(arc);
	  }
	
	  function polygon(arcs) {
	    arcs.forEach(line);
	  }
	
	  function geometry(o) {
	    if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
	    else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
	  }
	
	  if (arguments.length > 1) {
	    var geomsByArc = [],
	        geom;
	
	    var geometryType = {
	      LineString: line,
	      MultiLineString: polygon,
	      Polygon: polygon,
	      MultiPolygon: function(arcs) { arcs.forEach(polygon); }
	    };
	
	    geometry(o);
	
	    geomsByArc.forEach(arguments.length < 3
	        ? function(geoms) { arcs.push(geoms[0].i); }
	        : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
	  } else {
	    for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
	  }
	
	  return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
	}
	
	function cartesianTriangleArea(triangle) {
	  var a = triangle[0], b = triangle[1], c = triangle[2];
	  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
	}
	
	function ring(ring) {
	  var i = -1,
	      n = ring.length,
	      a,
	      b = ring[n - 1],
	      area = 0;
	
	  while (++i < n) {
	    a = b;
	    b = ring[i];
	    area += a[0] * b[1] - a[1] * b[0];
	  }
	
	  return area / 2;
	}
	
	function merge(topology) {
	  return object(topology, mergeArcs.apply(this, arguments));
	}
	
	function mergeArcs(topology, objects) {
	  var polygonsByArc = {},
	      polygons = [],
	      components = [];
	
	  objects.forEach(function(o) {
	    if (o.type === "Polygon") register(o.arcs);
	    else if (o.type === "MultiPolygon") o.arcs.forEach(register);
	  });
	
	  function register(polygon) {
	    polygon.forEach(function(ring$$) {
	      ring$$.forEach(function(arc) {
	        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
	      });
	    });
	    polygons.push(polygon);
	  }
	
	  function area(ring$$) {
	    return Math.abs(ring(object(topology, {type: "Polygon", arcs: [ring$$]}).coordinates[0]));
	  }
	
	  polygons.forEach(function(polygon) {
	    if (!polygon._) {
	      var component = [],
	          neighbors = [polygon];
	      polygon._ = 1;
	      components.push(component);
	      while (polygon = neighbors.pop()) {
	        component.push(polygon);
	        polygon.forEach(function(ring$$) {
	          ring$$.forEach(function(arc) {
	            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
	              if (!polygon._) {
	                polygon._ = 1;
	                neighbors.push(polygon);
	              }
	            });
	          });
	        });
	      }
	    }
	  });
	
	  polygons.forEach(function(polygon) {
	    delete polygon._;
	  });
	
	  return {
	    type: "MultiPolygon",
	    arcs: components.map(function(polygons) {
	      var arcs = [], n;
	
	      // Extract the exterior (unique) arcs.
	      polygons.forEach(function(polygon) {
	        polygon.forEach(function(ring$$) {
	          ring$$.forEach(function(arc) {
	            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
	              arcs.push(arc);
	            }
	          });
	        });
	      });
	
	      // Stitch the arcs into one or more rings.
	      arcs = stitchArcs(topology, arcs);
	
	      // If more than one ring is returned,
	      // at most one of these rings can be the exterior;
	      // choose the one with the greatest absolute area.
	      if ((n = arcs.length) > 1) {
	        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
	          if ((ki = area(arcs[i])) > k) {
	            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
	          }
	        }
	      }
	
	      return arcs;
	    })
	  };
	}
	
	function neighbors(objects) {
	  var indexesByArc = {}, // arc index -> array of object indexes
	      neighbors = objects.map(function() { return []; });
	
	  function line(arcs, i) {
	    arcs.forEach(function(a) {
	      if (a < 0) a = ~a;
	      var o = indexesByArc[a];
	      if (o) o.push(i);
	      else indexesByArc[a] = [i];
	    });
	  }
	
	  function polygon(arcs, i) {
	    arcs.forEach(function(arc) { line(arc, i); });
	  }
	
	  function geometry(o, i) {
	    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
	    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
	  }
	
	  var geometryType = {
	    LineString: line,
	    MultiLineString: polygon,
	    Polygon: polygon,
	    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
	  };
	
	  objects.forEach(geometry);
	
	  for (var i in indexesByArc) {
	    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
	      for (var k = j + 1; k < m; ++k) {
	        var ij = indexes[j], ik = indexes[k], n;
	        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
	        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
	      }
	    }
	  }
	
	  return neighbors;
	}
	
	function compareArea(a, b) {
	  return a[1][2] - b[1][2];
	}
	
	function minAreaHeap() {
	  var heap = {},
	      array = [],
	      size = 0;
	
	  heap.push = function(object) {
	    up(array[object._ = size] = object, size++);
	    return size;
	  };
	
	  heap.pop = function() {
	    if (size <= 0) return;
	    var removed = array[0], object;
	    if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
	    return removed;
	  };
	
	  heap.remove = function(removed) {
	    var i = removed._, object;
	    if (array[i] !== removed) return; // invalid request
	    if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
	    return i;
	  };
	
	  function up(object, i) {
	    while (i > 0) {
	      var j = ((i + 1) >> 1) - 1,
	          parent = array[j];
	      if (compareArea(object, parent) >= 0) break;
	      array[parent._ = i] = parent;
	      array[object._ = i = j] = object;
	    }
	  }
	
	  function down(object, i) {
	    while (true) {
	      var r = (i + 1) << 1,
	          l = r - 1,
	          j = i,
	          child = array[j];
	      if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
	      if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
	      if (j === i) break;
	      array[child._ = i] = child;
	      array[object._ = i = j] = object;
	    }
	  }
	
	  return heap;
	}
	
	function presimplify(topology, triangleArea) {
	  var absolute = transformAbsolute(topology.transform),
	      relative = transformRelative(topology.transform),
	      heap = minAreaHeap();
	
	  if (!triangleArea) triangleArea = cartesianTriangleArea;
	
	  topology.arcs.forEach(function(arc) {
	    var triangles = [],
	        maxArea = 0,
	        triangle,
	        i,
	        n,
	        p;
	
	    // To store each point’s effective area, we create a new array rather than
	    // extending the passed-in point to workaround a Chrome/V8 bug (getting
	    // stuck in smi mode). For midpoints, the initial effective area of
	    // Infinity will be computed in the next step.
	    for (i = 0, n = arc.length; i < n; ++i) {
	      p = arc[i];
	      absolute(arc[i] = [p[0], p[1], Infinity], i);
	    }
	
	    for (i = 1, n = arc.length - 1; i < n; ++i) {
	      triangle = arc.slice(i - 1, i + 2);
	      triangle[1][2] = triangleArea(triangle);
	      triangles.push(triangle);
	      heap.push(triangle);
	    }
	
	    for (i = 0, n = triangles.length; i < n; ++i) {
	      triangle = triangles[i];
	      triangle.previous = triangles[i - 1];
	      triangle.next = triangles[i + 1];
	    }
	
	    while (triangle = heap.pop()) {
	      var previous = triangle.previous,
	          next = triangle.next;
	
	      // If the area of the current point is less than that of the previous point
	      // to be eliminated, use the latter's area instead. This ensures that the
	      // current point cannot be eliminated without eliminating previously-
	      // eliminated points.
	      if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
	      else maxArea = triangle[1][2];
	
	      if (previous) {
	        previous.next = next;
	        previous[2] = triangle[2];
	        update(previous);
	      }
	
	      if (next) {
	        next.previous = previous;
	        next[0] = triangle[0];
	        update(next);
	      }
	    }
	
	    arc.forEach(relative);
	  });
	
	  function update(triangle) {
	    heap.remove(triangle);
	    triangle[1][2] = triangleArea(triangle);
	    heap.push(triangle);
	  }
	
	  return topology;
	}
	
	var version = "1.6.27";
	
	exports.version = version;
	exports.mesh = mesh;
	exports.meshArcs = meshArcs;
	exports.merge = merge;
	exports.mergeArcs = mergeArcs;
	exports.feature = feature;
	exports.neighbors = neighbors;
	exports.presimplify = presimplify;
	
	Object.defineProperty(exports, '__esModule', { value: true });
	
	})));
})
/** END DEFINE BLOCK for topojson@1.6.27/build/topojson.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/formats/treejson.js **/
jupyter.define('datalib@1.7.2/src/import/formats/treejson.js', function (module, exports, __jupyter_require__) {
	var json = __jupyter_require__('datalib@~1.7.2/src/import/formats/json.js');
	
	module.exports = function(tree, format) {
	  return toTable(json(tree, format), format);
	};
	
	function toTable(root, fields) {
	  var childrenField = fields && fields.children || 'children',
	      parentField = fields && fields.parent || 'parent',
	      table = [];
	
	  function visit(node, parent) {
	    node[parentField] = parent;
	    table.push(node);
	    var children = node[childrenField];
	    if (children) {
	      for (var i=0; i<children.length; ++i) {
	        visit(children[i], node);
	      }
	    }
	  }
	
	  visit(root, null);
	  return (table.root = root, table);
	}
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/formats/treejson.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/format.js **/
jupyter.define('datalib@1.7.2/src/format.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    d3_time = __jupyter_require__('d3-time@0.1/build/d3-time.js'),
	    d3_timeF = __jupyter_require__('d3-time-format@0.2/build/d3-time-format.js'),
	    d3_numberF = __jupyter_require__('d3-format@0.4/build/d3-format.js'),
	    numberF = d3_numberF, // defaults to EN-US
	    timeF = d3_timeF,     // defaults to EN-US
	    tmpDate = new Date(2000, 0, 1),
	    monthFull, monthAbbr, dayFull, dayAbbr;
	
	
	module.exports = {
	  // Update number formatter to use provided locale configuration.
	  // For more see https://github.com/d3/d3-format
	  numberLocale: numberLocale,
	  number:       function(f) { return numberF.format(f); },
	  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },
	
	  // Update time formatter to use provided locale configuration.
	  // For more see https://github.com/d3/d3-time-format
	  timeLocale:   timeLocale,
	  time:         function(f) { return timeF.format(f); },
	  utc:          function(f) { return timeF.utcFormat(f); },
	
	  // Set number and time locale simultaneously.
	  locale:       function(l) { numberLocale(l); timeLocale(l); },
	
	  // automatic formatting functions
	  auto: {
	    number:   autoNumberFormat,
	    linear:   linearNumberFormat,
	    time:     function() { return timeAutoFormat(); },
	    utc:      function() { return utcAutoFormat(); }
	  },
	
	  month:      monthFormat,      // format month name from integer code
	  day:        dayFormat,        // format week day name from integer code
	  quarter:    quarterFormat,    // format quarter name from timestamp
	  utcQuarter: utcQuarterFormat  // format quarter name from utc timestamp
	};
	
	// -- Locales ----
	
	// transform 'en-US' style locale string to match d3-format v0.4+ convention
	function localeRef(l) {
	  return l.length > 4 && 'locale' + (
	    l[0].toUpperCase() + l[1].toLowerCase() +
	    l[3].toUpperCase() + l[4].toLowerCase()
	  );
	}
	
	function numberLocale(l) {
	  var f = util.isString(l) ? d3_numberF[localeRef(l)] : d3_numberF.locale(l);
	  if (f == null) throw Error('Unrecognized locale: ' + l);
	  numberF = f;
	}
	
	function timeLocale(l) {
	  var f = util.isString(l) ? d3_timeF[localeRef(l)] : d3_timeF.locale(l);
	  if (f == null) throw Error('Unrecognized locale: ' + l);
	  timeF = f;
	  monthFull = monthAbbr = dayFull = dayAbbr = null;
	}
	
	// -- Number Formatting ----
	
	var e10 = Math.sqrt(50),
	    e5 = Math.sqrt(10),
	    e2 = Math.sqrt(2);
	
	function linearRange(domain, count) {
	  if (!domain.length) domain = [0];
	  if (count == null) count = 10;
	
	  var start = domain[0],
	      stop = domain[domain.length - 1];
	
	  if (stop < start) { error = stop; stop = start; start = error; }
	
	  var span = (stop - start) || (count = 1, start || stop || 1),
	      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),
	      error = span / count / step;
	
	  // Filter ticks to get closer to the desired count.
	  if (error >= e10) step *= 10;
	  else if (error >= e5) step *= 5;
	  else if (error >= e2) step *= 2;
	
	  // Round start and stop values to step interval.
	  return [
	    Math.ceil(start / step) * step,
	    Math.floor(stop / step) * step + step / 2, // inclusive
	    step
	  ];
	}
	
	function trimZero(f, decimal) {
	  return function(x) {
	    var s = f(x),
	        n = s.indexOf(decimal);
	    if (n < 0) return s;
	
	    var idx = rightmostDigit(s, n),
	        end = idx < s.length ? s.slice(idx) : '';
	
	    while (--idx > n) {
	      if (s[idx] !== '0') { ++idx; break; }
	    }
	    return s.slice(0, idx) + end;
	  };
	}
	
	function rightmostDigit(s, n) {
	  var i = s.lastIndexOf('e'), c;
	  if (i > 0) return i;
	  for (i=s.length; --i > n;) {
	    c = s.charCodeAt(i);
	    if (c >= 48 && c <= 57) return i+1; // is digit
	  }
	}
	
	function autoNumberFormat(f) {
	  var decimal = numberF.format('.1f')(1)[1]; // get decimal char
	  if (f == null) f = ',';
	  f = d3_numberF.formatSpecifier(f);
	  if (f.precision == null) f.precision = 12;
	  switch (f.type) {
	    case '%': f.precision -= 2; break;
	    case 'e': f.precision -= 1; break;
	  }
	  return trimZero(numberF.format(f), decimal);
	}
	
	function linearNumberFormat(domain, count, f) {
	  var range = linearRange(domain, count);
	
	  if (f == null) f = ',f';
	
	  switch (f = d3_numberF.formatSpecifier(f), f.type) {
	    case 's': {
	      var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));
	      if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);
	      return numberF.formatPrefix(f, value);
	    }
	    case '':
	    case 'e':
	    case 'g':
	    case 'p':
	    case 'r': {
	      if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');
	      break;
	    }
	    case 'f':
	    case '%': {
	      if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - 2 * (f.type === '%');
	      break;
	    }
	  }
	  return numberF.format(f);
	}
	
	// -- Datetime Formatting ----
	
	function timeAutoFormat() {
	  var f = timeF.format,
	      formatMillisecond = f('.%L'),
	      formatSecond = f(':%S'),
	      formatMinute = f('%I:%M'),
	      formatHour = f('%I %p'),
	      formatDay = f('%a %d'),
	      formatWeek = f('%b %d'),
	      formatMonth = f('%B'),
	      formatYear = f('%Y');
	
	  return function(date) {
	    var d = +date;
	    return (d3_time.second(date) < d ? formatMillisecond
	        : d3_time.minute(date) < d ? formatSecond
	        : d3_time.hour(date) < d ? formatMinute
	        : d3_time.day(date) < d ? formatHour
	        : d3_time.month(date) < d ?
	          (d3_time.week(date) < d ? formatDay : formatWeek)
	        : d3_time.year(date) < d ? formatMonth
	        : formatYear)(date);
	  };
	}
	
	function utcAutoFormat() {
	  var f = timeF.utcFormat,
	      formatMillisecond = f('.%L'),
	      formatSecond = f(':%S'),
	      formatMinute = f('%I:%M'),
	      formatHour = f('%I %p'),
	      formatDay = f('%a %d'),
	      formatWeek = f('%b %d'),
	      formatMonth = f('%B'),
	      formatYear = f('%Y');
	
	  return function(date) {
	    var d = +date;
	    return (d3_time.utcSecond(date) < d ? formatMillisecond
	        : d3_time.utcMinute(date) < d ? formatSecond
	        : d3_time.utcHour(date) < d ? formatMinute
	        : d3_time.utcDay(date) < d ? formatHour
	        : d3_time.utcMonth(date) < d ?
	          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)
	        : d3_time.utcYear(date) < d ? formatMonth
	        : formatYear)(date);
	  };
	}
	
	function monthFormat(month, abbreviate) {
	  var f = abbreviate ?
	    (monthAbbr || (monthAbbr = timeF.format('%b'))) :
	    (monthFull || (monthFull = timeF.format('%B')));
	  return (tmpDate.setMonth(month), f(tmpDate));
	}
	
	function dayFormat(day, abbreviate) {
	  var f = abbreviate ?
	    (dayAbbr || (dayAbbr = timeF.format('%a'))) :
	    (dayFull || (dayFull = timeF.format('%A')));
	  return (tmpDate.setMonth(0), tmpDate.setDate(2 + day), f(tmpDate));
	}
	
	function quarterFormat(date) {
	  return Math.floor(date.getMonth() / 3) + 1;
	}
	
	function utcQuarterFormat(date) {
	  return Math.floor(date.getUTCMonth() / 3) + 1;
	}
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/format.js **/


/** START DEFINE BLOCK for d3-time@0.1.1/build/d3-time.js **/
jupyter.define('d3-time@0.1.1/build/d3-time.js', function (module, exports, __jupyter_require__) {
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :
	  factory((global.d3_time = {}));
	}(this, function (exports) { 'use strict';
	
	  var t0 = new Date;
	  var t1 = new Date;
	  function newInterval(floori, offseti, count, field) {
	
	    function interval(date) {
	      return floori(date = new Date(+date)), date;
	    }
	
	    interval.floor = interval;
	
	    interval.round = function(date) {
	      var d0 = new Date(+date),
	          d1 = new Date(date - 1);
	      floori(d0), floori(d1), offseti(d1, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    };
	
	    interval.ceil = function(date) {
	      return floori(date = new Date(date - 1)), offseti(date, 1), date;
	    };
	
	    interval.offset = function(date, step) {
	      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	    };
	
	    interval.range = function(start, stop, step) {
	      var range = [];
	      start = new Date(start - 1);
	      stop = new Date(+stop);
	      step = step == null ? 1 : Math.floor(step);
	      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	      offseti(start, 1), floori(start);
	      if (start < stop) range.push(new Date(+start));
	      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));
	      return range;
	    };
	
	    interval.filter = function(test) {
	      return newInterval(function(date) {
	        while (floori(date), !test(date)) date.setTime(date - 1);
	      }, function(date, step) {
	        while (--step >= 0) while (offseti(date, 1), !test(date));
	      });
	    };
	
	    if (count) {
	      interval.count = function(start, end) {
	        t0.setTime(+start), t1.setTime(+end);
	        floori(t0), floori(t1);
	        return Math.floor(count(t0, t1));
	      };
	
	      interval.every = function(step) {
	        step = Math.floor(step);
	        return !isFinite(step) || !(step > 0) ? null
	            : !(step > 1) ? interval
	            : interval.filter(field
	                ? function(d) { return field(d) % step === 0; }
	                : function(d) { return interval.count(0, d) % step === 0; });
	      };
	    }
	
	    return interval;
	  };
	
	  var millisecond = newInterval(function() {
	    // noop
	  }, function(date, step) {
	    date.setTime(+date + step);
	  }, function(start, end) {
	    return end - start;
	  });
	
	  // An optimized implementation for this simple case.
	  millisecond.every = function(k) {
	    k = Math.floor(k);
	    if (!isFinite(k) || !(k > 0)) return null;
	    if (!(k > 1)) return millisecond;
	    return newInterval(function(date) {
	      date.setTime(Math.floor(date / k) * k);
	    }, function(date, step) {
	      date.setTime(+date + step * k);
	    }, function(start, end) {
	      return (end - start) / k;
	    });
	  };
	
	  var second = newInterval(function(date) {
	    date.setMilliseconds(0);
	  }, function(date, step) {
	    date.setTime(+date + step * 1e3);
	  }, function(start, end) {
	    return (end - start) / 1e3;
	  }, function(date) {
	    return date.getSeconds();
	  });
	
	  var minute = newInterval(function(date) {
	    date.setSeconds(0, 0);
	  }, function(date, step) {
	    date.setTime(+date + step * 6e4);
	  }, function(start, end) {
	    return (end - start) / 6e4;
	  }, function(date) {
	    return date.getMinutes();
	  });
	
	  var hour = newInterval(function(date) {
	    date.setMinutes(0, 0, 0);
	  }, function(date, step) {
	    date.setTime(+date + step * 36e5);
	  }, function(start, end) {
	    return (end - start) / 36e5;
	  }, function(date) {
	    return date.getHours();
	  });
	
	  var day = newInterval(function(date) {
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	
	  function weekday(i) {
	    return newInterval(function(date) {
	      date.setHours(0, 0, 0, 0);
	      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	    }, function(date, step) {
	      date.setDate(date.getDate() + step * 7);
	    }, function(start, end) {
	      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;
	    });
	  }
	
	  var sunday = weekday(0);
	  var monday = weekday(1);
	  var tuesday = weekday(2);
	  var wednesday = weekday(3);
	  var thursday = weekday(4);
	  var friday = weekday(5);
	  var saturday = weekday(6);
	
	  var month = newInterval(function(date) {
	    date.setHours(0, 0, 0, 0);
	    date.setDate(1);
	  }, function(date, step) {
	    date.setMonth(date.getMonth() + step);
	  }, function(start, end) {
	    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	  }, function(date) {
	    return date.getMonth();
	  });
	
	  var year = newInterval(function(date) {
	    date.setHours(0, 0, 0, 0);
	    date.setMonth(0, 1);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step);
	  }, function(start, end) {
	    return end.getFullYear() - start.getFullYear();
	  }, function(date) {
	    return date.getFullYear();
	  });
	
	  var utcSecond = newInterval(function(date) {
	    date.setUTCMilliseconds(0);
	  }, function(date, step) {
	    date.setTime(+date + step * 1e3);
	  }, function(start, end) {
	    return (end - start) / 1e3;
	  }, function(date) {
	    return date.getUTCSeconds();
	  });
	
	  var utcMinute = newInterval(function(date) {
	    date.setUTCSeconds(0, 0);
	  }, function(date, step) {
	    date.setTime(+date + step * 6e4);
	  }, function(start, end) {
	    return (end - start) / 6e4;
	  }, function(date) {
	    return date.getUTCMinutes();
	  });
	
	  var utcHour = newInterval(function(date) {
	    date.setUTCMinutes(0, 0, 0);
	  }, function(date, step) {
	    date.setTime(+date + step * 36e5);
	  }, function(start, end) {
	    return (end - start) / 36e5;
	  }, function(date) {
	    return date.getUTCHours();
	  });
	
	  var utcDay = newInterval(function(date) {
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step);
	  }, function(start, end) {
	    return (end - start) / 864e5;
	  }, function(date) {
	    return date.getUTCDate() - 1;
	  });
	
	  function utcWeekday(i) {
	    return newInterval(function(date) {
	      date.setUTCHours(0, 0, 0, 0);
	      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	    }, function(date, step) {
	      date.setUTCDate(date.getUTCDate() + step * 7);
	    }, function(start, end) {
	      return (end - start) / 6048e5;
	    });
	  }
	
	  var utcSunday = utcWeekday(0);
	  var utcMonday = utcWeekday(1);
	  var utcTuesday = utcWeekday(2);
	  var utcWednesday = utcWeekday(3);
	  var utcThursday = utcWeekday(4);
	  var utcFriday = utcWeekday(5);
	  var utcSaturday = utcWeekday(6);
	
	  var utcMonth = newInterval(function(date) {
	    date.setUTCHours(0, 0, 0, 0);
	    date.setUTCDate(1);
	  }, function(date, step) {
	    date.setUTCMonth(date.getUTCMonth() + step);
	  }, function(start, end) {
	    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
	  }, function(date) {
	    return date.getUTCMonth();
	  });
	
	  var utcYear = newInterval(function(date) {
	    date.setUTCHours(0, 0, 0, 0);
	    date.setUTCMonth(0, 1);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step);
	  }, function(start, end) {
	    return end.getUTCFullYear() - start.getUTCFullYear();
	  }, function(date) {
	    return date.getUTCFullYear();
	  });
	
	  var milliseconds = millisecond.range;
	  var seconds = second.range;
	  var minutes = minute.range;
	  var hours = hour.range;
	  var days = day.range;
	  var sundays = sunday.range;
	  var mondays = monday.range;
	  var tuesdays = tuesday.range;
	  var wednesdays = wednesday.range;
	  var thursdays = thursday.range;
	  var fridays = friday.range;
	  var saturdays = saturday.range;
	  var weeks = sunday.range;
	  var months = month.range;
	  var years = year.range;
	
	  var utcMillisecond = millisecond;
	  var utcMilliseconds = milliseconds;
	  var utcSeconds = utcSecond.range;
	  var utcMinutes = utcMinute.range;
	  var utcHours = utcHour.range;
	  var utcDays = utcDay.range;
	  var utcSundays = utcSunday.range;
	  var utcMondays = utcMonday.range;
	  var utcTuesdays = utcTuesday.range;
	  var utcWednesdays = utcWednesday.range;
	  var utcThursdays = utcThursday.range;
	  var utcFridays = utcFriday.range;
	  var utcSaturdays = utcSaturday.range;
	  var utcWeeks = utcSunday.range;
	  var utcMonths = utcMonth.range;
	  var utcYears = utcYear.range;
	
	  var version = "0.1.1";
	
	  exports.version = version;
	  exports.milliseconds = milliseconds;
	  exports.seconds = seconds;
	  exports.minutes = minutes;
	  exports.hours = hours;
	  exports.days = days;
	  exports.sundays = sundays;
	  exports.mondays = mondays;
	  exports.tuesdays = tuesdays;
	  exports.wednesdays = wednesdays;
	  exports.thursdays = thursdays;
	  exports.fridays = fridays;
	  exports.saturdays = saturdays;
	  exports.weeks = weeks;
	  exports.months = months;
	  exports.years = years;
	  exports.utcMillisecond = utcMillisecond;
	  exports.utcMilliseconds = utcMilliseconds;
	  exports.utcSeconds = utcSeconds;
	  exports.utcMinutes = utcMinutes;
	  exports.utcHours = utcHours;
	  exports.utcDays = utcDays;
	  exports.utcSundays = utcSundays;
	  exports.utcMondays = utcMondays;
	  exports.utcTuesdays = utcTuesdays;
	  exports.utcWednesdays = utcWednesdays;
	  exports.utcThursdays = utcThursdays;
	  exports.utcFridays = utcFridays;
	  exports.utcSaturdays = utcSaturdays;
	  exports.utcWeeks = utcWeeks;
	  exports.utcMonths = utcMonths;
	  exports.utcYears = utcYears;
	  exports.millisecond = millisecond;
	  exports.second = second;
	  exports.minute = minute;
	  exports.hour = hour;
	  exports.day = day;
	  exports.sunday = sunday;
	  exports.monday = monday;
	  exports.tuesday = tuesday;
	  exports.wednesday = wednesday;
	  exports.thursday = thursday;
	  exports.friday = friday;
	  exports.saturday = saturday;
	  exports.week = sunday;
	  exports.month = month;
	  exports.year = year;
	  exports.utcSecond = utcSecond;
	  exports.utcMinute = utcMinute;
	  exports.utcHour = utcHour;
	  exports.utcDay = utcDay;
	  exports.utcSunday = utcSunday;
	  exports.utcMonday = utcMonday;
	  exports.utcTuesday = utcTuesday;
	  exports.utcWednesday = utcWednesday;
	  exports.utcThursday = utcThursday;
	  exports.utcFriday = utcFriday;
	  exports.utcSaturday = utcSaturday;
	  exports.utcWeek = utcSunday;
	  exports.utcMonth = utcMonth;
	  exports.utcYear = utcYear;
	  exports.interval = newInterval;
	
	}));
})
/** END DEFINE BLOCK for d3-time@0.1.1/build/d3-time.js **/


/** START DEFINE BLOCK for d3-time-format@0.2.1/build/d3-time-format.js **/
jupyter.define('d3-time-format@0.2.1/build/d3-time-format.js', function (module, exports, __jupyter_require__) {
	(function (global, factory) {
	   true ? factory(exports, __jupyter_require__('d3-time@0.1/build/d3-time.js')) :
	  typeof define === 'function' && define.amd ? define('d3-time-format', ['exports', 'd3-time'], factory) :
	  factory((global.d3_time_format = {}),global.d3_time);
	}(this, function (exports,d3Time) { 'use strict';
	
	  function localDate(d) {
	    if (0 <= d.y && d.y < 100) {
	      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	      date.setFullYear(d.y);
	      return date;
	    }
	    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	  }
	
	  function utcDate(d) {
	    if (0 <= d.y && d.y < 100) {
	      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	      date.setUTCFullYear(d.y);
	      return date;
	    }
	    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	  }
	
	  function newYear(y) {
	    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
	  }
	
	  function locale$1(locale) {
	    var locale_dateTime = locale.dateTime,
	        locale_date = locale.date,
	        locale_time = locale.time,
	        locale_periods = locale.periods,
	        locale_weekdays = locale.days,
	        locale_shortWeekdays = locale.shortDays,
	        locale_months = locale.months,
	        locale_shortMonths = locale.shortMonths;
	
	    var periodRe = formatRe(locale_periods),
	        periodLookup = formatLookup(locale_periods),
	        weekdayRe = formatRe(locale_weekdays),
	        weekdayLookup = formatLookup(locale_weekdays),
	        shortWeekdayRe = formatRe(locale_shortWeekdays),
	        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	        monthRe = formatRe(locale_months),
	        monthLookup = formatLookup(locale_months),
	        shortMonthRe = formatRe(locale_shortMonths),
	        shortMonthLookup = formatLookup(locale_shortMonths);
	
	    var formats = {
	      "a": formatShortWeekday,
	      "A": formatWeekday,
	      "b": formatShortMonth,
	      "B": formatMonth,
	      "c": null,
	      "d": formatDayOfMonth,
	      "e": formatDayOfMonth,
	      "H": formatHour24,
	      "I": formatHour12,
	      "j": formatDayOfYear,
	      "L": formatMilliseconds,
	      "m": formatMonthNumber,
	      "M": formatMinutes,
	      "p": formatPeriod,
	      "S": formatSeconds,
	      "U": formatWeekNumberSunday,
	      "w": formatWeekdayNumber,
	      "W": formatWeekNumberMonday,
	      "x": null,
	      "X": null,
	      "y": formatYear,
	      "Y": formatFullYear,
	      "Z": formatZone,
	      "%": formatLiteralPercent
	    };
	
	    var utcFormats = {
	      "a": formatUTCShortWeekday,
	      "A": formatUTCWeekday,
	      "b": formatUTCShortMonth,
	      "B": formatUTCMonth,
	      "c": null,
	      "d": formatUTCDayOfMonth,
	      "e": formatUTCDayOfMonth,
	      "H": formatUTCHour24,
	      "I": formatUTCHour12,
	      "j": formatUTCDayOfYear,
	      "L": formatUTCMilliseconds,
	      "m": formatUTCMonthNumber,
	      "M": formatUTCMinutes,
	      "p": formatUTCPeriod,
	      "S": formatUTCSeconds,
	      "U": formatUTCWeekNumberSunday,
	      "w": formatUTCWeekdayNumber,
	      "W": formatUTCWeekNumberMonday,
	      "x": null,
	      "X": null,
	      "y": formatUTCYear,
	      "Y": formatUTCFullYear,
	      "Z": formatUTCZone,
	      "%": formatLiteralPercent
	    };
	
	    var parses = {
	      "a": parseShortWeekday,
	      "A": parseWeekday,
	      "b": parseShortMonth,
	      "B": parseMonth,
	      "c": parseLocaleDateTime,
	      "d": parseDayOfMonth,
	      "e": parseDayOfMonth,
	      "H": parseHour24,
	      "I": parseHour24,
	      "j": parseDayOfYear,
	      "L": parseMilliseconds,
	      "m": parseMonthNumber,
	      "M": parseMinutes,
	      "p": parsePeriod,
	      "S": parseSeconds,
	      "U": parseWeekNumberSunday,
	      "w": parseWeekdayNumber,
	      "W": parseWeekNumberMonday,
	      "x": parseLocaleDate,
	      "X": parseLocaleTime,
	      "y": parseYear,
	      "Y": parseFullYear,
	      "Z": parseZone,
	      "%": parseLiteralPercent
	    };
	
	    // These recursive directive definitions must be deferred.
	    formats.x = newFormat(locale_date, formats);
	    formats.X = newFormat(locale_time, formats);
	    formats.c = newFormat(locale_dateTime, formats);
	    utcFormats.x = newFormat(locale_date, utcFormats);
	    utcFormats.X = newFormat(locale_time, utcFormats);
	    utcFormats.c = newFormat(locale_dateTime, utcFormats);
	
	    function newFormat(specifier, formats) {
	      return function(date) {
	        var string = [],
	            i = -1,
	            j = 0,
	            n = specifier.length,
	            c,
	            pad,
	            format;
	
	        if (!(date instanceof Date)) date = new Date(+date);
	
	        while (++i < n) {
	          if (specifier.charCodeAt(i) === 37) {
	            string.push(specifier.slice(j, i));
	            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	            else pad = c === "e" ? " " : "0";
	            if (format = formats[c]) c = format(date, pad);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	
	        string.push(specifier.slice(j, i));
	        return string.join("");
	      };
	    }
	
	    function newParse(specifier, newDate) {
	      return function(string) {
	        var d = newYear(1900),
	            i = parseSpecifier(d, specifier, string += "", 0);
	        if (i != string.length) return null;
	
	        // The am-pm flag is 0 for AM, and 1 for PM.
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	
	        // Convert day-of-week and week-of-year to day-of-year.
	        if ("W" in d || "U" in d) {
	          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
	          var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
	          d.m = 0;
	          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
	        }
	
	        // If a time zone is specified, all fields are interpreted as UTC and then
	        // offset according to the specified time zone.
	        if ("Z" in d) {
	          d.H += d.Z / 100 | 0;
	          d.M += d.Z % 100;
	          return utcDate(d);
	        }
	
	        // Otherwise, all fields are in local time.
	        return newDate(d);
	      };
	    }
	
	    function parseSpecifier(d, specifier, string, j) {
	      var i = 0,
	          n = specifier.length,
	          m = string.length,
	          c,
	          parse;
	
	      while (i < n) {
	        if (j >= m) return -1;
	        c = specifier.charCodeAt(i++);
	        if (c === 37) {
	          c = specifier.charAt(i++);
	          parse = parses[c in pads ? specifier.charAt(i++) : c];
	          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	
	      return j;
	    }
	
	    function parsePeriod(d, string, i) {
	      var n = periodRe.exec(string.slice(i));
	      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }
	
	    function parseShortWeekday(d, string, i) {
	      var n = shortWeekdayRe.exec(string.slice(i));
	      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }
	
	    function parseWeekday(d, string, i) {
	      var n = weekdayRe.exec(string.slice(i));
	      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }
	
	    function parseShortMonth(d, string, i) {
	      var n = shortMonthRe.exec(string.slice(i));
	      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }
	
	    function parseMonth(d, string, i) {
	      var n = monthRe.exec(string.slice(i));
	      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	    }
	
	    function parseLocaleDateTime(d, string, i) {
	      return parseSpecifier(d, locale_dateTime, string, i);
	    }
	
	    function parseLocaleDate(d, string, i) {
	      return parseSpecifier(d, locale_date, string, i);
	    }
	
	    function parseLocaleTime(d, string, i) {
	      return parseSpecifier(d, locale_time, string, i);
	    }
	
	    function formatShortWeekday(d) {
	      return locale_shortWeekdays[d.getDay()];
	    }
	
	    function formatWeekday(d) {
	      return locale_weekdays[d.getDay()];
	    }
	
	    function formatShortMonth(d) {
	      return locale_shortMonths[d.getMonth()];
	    }
	
	    function formatMonth(d) {
	      return locale_months[d.getMonth()];
	    }
	
	    function formatPeriod(d) {
	      return locale_periods[+(d.getHours() >= 12)];
	    }
	
	    function formatUTCShortWeekday(d) {
	      return locale_shortWeekdays[d.getUTCDay()];
	    }
	
	    function formatUTCWeekday(d) {
	      return locale_weekdays[d.getUTCDay()];
	    }
	
	    function formatUTCShortMonth(d) {
	      return locale_shortMonths[d.getUTCMonth()];
	    }
	
	    function formatUTCMonth(d) {
	      return locale_months[d.getUTCMonth()];
	    }
	
	    function formatUTCPeriod(d) {
	      return locale_periods[+(d.getUTCHours() >= 12)];
	    }
	
	    return {
	      format: function(specifier) {
	        var f = newFormat(specifier += "", formats);
	        f.parse = newParse(specifier, localDate);
	        f.toString = function() { return specifier; };
	        return f;
	      },
	      utcFormat: function(specifier) {
	        var f = newFormat(specifier += "", utcFormats);
	        f.parse = newParse(specifier, utcDate);
	        f.toString = function() { return specifier; };
	        return f;
	      }
	    };
	  };
	
	  var pads = {"-": "", "_": " ", "0": "0"};
	  var numberRe = /^\s*\d+/;
	  var percentRe = /^%/;
	  var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  function pad(value, fill, width) {
	    var sign = value < 0 ? "-" : "",
	        string = (sign ? -value : value) + "",
	        length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	
	  function requote(s) {
	    return s.replace(requoteRe, "\\$&");
	  }
	
	  function formatRe(names) {
	    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	  }
	
	  function formatLookup(names) {
	    var map = {}, i = -1, n = names.length;
	    while (++i < n) map[names[i].toLowerCase()] = i;
	    return map;
	  }
	
	  function parseWeekdayNumber(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 1));
	    return n ? (d.w = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseWeekNumberSunday(d, string, i) {
	    var n = numberRe.exec(string.slice(i));
	    return n ? (d.U = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseWeekNumberMonday(d, string, i) {
	    var n = numberRe.exec(string.slice(i));
	    return n ? (d.W = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseFullYear(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 4));
	    return n ? (d.y = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseYear(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	  }
	
	  function parseZone(d, string, i) {
	    var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
	    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	  }
	
	  function parseMonthNumber(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	  }
	
	  function parseDayOfMonth(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.d = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseDayOfYear(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 3));
	    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseHour24(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.H = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseMinutes(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.M = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseSeconds(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 2));
	    return n ? (d.S = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseMilliseconds(d, string, i) {
	    var n = numberRe.exec(string.slice(i, i + 3));
	    return n ? (d.L = +n[0], i + n[0].length) : -1;
	  }
	
	  function parseLiteralPercent(d, string, i) {
	    var n = percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	
	  function formatDayOfMonth(d, p) {
	    return pad(d.getDate(), p, 2);
	  }
	
	  function formatHour24(d, p) {
	    return pad(d.getHours(), p, 2);
	  }
	
	  function formatHour12(d, p) {
	    return pad(d.getHours() % 12 || 12, p, 2);
	  }
	
	  function formatDayOfYear(d, p) {
	    return pad(1 + d3Time.day.count(d3Time.year(d), d), p, 3);
	  }
	
	  function formatMilliseconds(d, p) {
	    return pad(d.getMilliseconds(), p, 3);
	  }
	
	  function formatMonthNumber(d, p) {
	    return pad(d.getMonth() + 1, p, 2);
	  }
	
	  function formatMinutes(d, p) {
	    return pad(d.getMinutes(), p, 2);
	  }
	
	  function formatSeconds(d, p) {
	    return pad(d.getSeconds(), p, 2);
	  }
	
	  function formatWeekNumberSunday(d, p) {
	    return pad(d3Time.sunday.count(d3Time.year(d), d), p, 2);
	  }
	
	  function formatWeekdayNumber(d) {
	    return d.getDay();
	  }
	
	  function formatWeekNumberMonday(d, p) {
	    return pad(d3Time.monday.count(d3Time.year(d), d), p, 2);
	  }
	
	  function formatYear(d, p) {
	    return pad(d.getFullYear() % 100, p, 2);
	  }
	
	  function formatFullYear(d, p) {
	    return pad(d.getFullYear() % 10000, p, 4);
	  }
	
	  function formatZone(d) {
	    var z = d.getTimezoneOffset();
	    return (z > 0 ? "-" : (z *= -1, "+"))
	        + pad(z / 60 | 0, "0", 2)
	        + pad(z % 60, "0", 2);
	  }
	
	  function formatUTCDayOfMonth(d, p) {
	    return pad(d.getUTCDate(), p, 2);
	  }
	
	  function formatUTCHour24(d, p) {
	    return pad(d.getUTCHours(), p, 2);
	  }
	
	  function formatUTCHour12(d, p) {
	    return pad(d.getUTCHours() % 12 || 12, p, 2);
	  }
	
	  function formatUTCDayOfYear(d, p) {
	    return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
	  }
	
	  function formatUTCMilliseconds(d, p) {
	    return pad(d.getUTCMilliseconds(), p, 3);
	  }
	
	  function formatUTCMonthNumber(d, p) {
	    return pad(d.getUTCMonth() + 1, p, 2);
	  }
	
	  function formatUTCMinutes(d, p) {
	    return pad(d.getUTCMinutes(), p, 2);
	  }
	
	  function formatUTCSeconds(d, p) {
	    return pad(d.getUTCSeconds(), p, 2);
	  }
	
	  function formatUTCWeekNumberSunday(d, p) {
	    return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
	  }
	
	  function formatUTCWeekdayNumber(d) {
	    return d.getUTCDay();
	  }
	
	  function formatUTCWeekNumberMonday(d, p) {
	    return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
	  }
	
	  function formatUTCYear(d, p) {
	    return pad(d.getUTCFullYear() % 100, p, 2);
	  }
	
	  function formatUTCFullYear(d, p) {
	    return pad(d.getUTCFullYear() % 10000, p, 4);
	  }
	
	  function formatUTCZone() {
	    return "+0000";
	  }
	
	  function formatLiteralPercent() {
	    return "%";
	  }
	
	  var locale = locale$1({
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	  });
	
	  var caES = locale$1({
	    dateTime: "%A, %e de %B de %Y, %X",
	    date: "%d/%m/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte"],
	    shortDays: ["dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds."],
	    months: ["gener", "febrer", "març", "abril", "maig", "juny", "juliol", "agost", "setembre", "octubre", "novembre", "desembre"],
	    shortMonths: ["gen.", "febr.", "març", "abr.", "maig", "juny", "jul.", "ag.", "set.", "oct.", "nov.", "des."]
	  });
	
	  var deCH = locale$1({
	    dateTime: "%A, der %e. %B %Y, %X",
	    date: "%d.%m.%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"], // unused
	    days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
	    shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
	    months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
	    shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
	  });
	
	  var deDE = locale$1({
	    dateTime: "%A, der %e. %B %Y, %X",
	    date: "%d.%m.%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"], // unused
	    days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
	    shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
	    months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
	    shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
	  });
	
	  var enCA = locale$1({
	    dateTime: "%a %b %e %X %Y",
	    date: "%Y-%m-%d",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	  });
	
	  var enGB = locale$1({
	    dateTime: "%a %e %b %X %Y",
	    date: "%d/%m/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	  });
	
	  var esES = locale$1({
	    dateTime: "%A, %e de %B de %Y, %X",
	    date: "%d/%m/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado"],
	    shortDays: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
	    months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
	    shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"]
	  });
	
	  var fiFI = locale$1({
	    dateTime: "%A, %-d. %Bta %Y klo %X",
	    date: "%-d.%-m.%Y",
	    time: "%H:%M:%S",
	    periods: ["a.m.", "p.m."],
	    days: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"],
	    shortDays: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
	    months: ["tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu"],
	    shortMonths: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kesä", "Heinä", "Elo", "Syys", "Loka", "Marras", "Joulu"]
	  });
	
	  var frCA = locale$1({
	    dateTime: "%a %e %b %Y %X",
	    date: "%Y-%m-%d",
	    time: "%H:%M:%S",
	    periods: ["", ""],
	    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
	    shortDays: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
	    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
	    shortMonths: ["jan", "fév", "mar", "avr", "mai", "jui", "jul", "aoû", "sep", "oct", "nov", "déc"]
	  });
	
	  var frFR = locale$1({
	    dateTime: "%A, le %e %B %Y, %X",
	    date: "%d/%m/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"], // unused
	    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
	    shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
	    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
	    shortMonths: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."]
	  });
	
	  var heIL = locale$1({
	    dateTime: "%A, %e ב%B %Y %X",
	    date: "%d.%m.%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
	    shortDays: ["א׳", "ב׳", "ג׳", "ד׳", "ה׳", "ו׳", "ש׳"],
	    months: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"],
	    shortMonths: ["ינו׳", "פבר׳", "מרץ", "אפר׳", "מאי", "יוני", "יולי", "אוג׳", "ספט׳", "אוק׳", "נוב׳", "דצמ׳"]
	  });
	
	  var huHU = locale$1({
	    dateTime: "%Y. %B %-e., %A %X",
	    date: "%Y. %m. %d.",
	    time: "%H:%M:%S",
	    periods: ["de.", "du."], // unused
	    days: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"],
	    shortDays: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
	    months: ["január", "február", "március", "április", "május", "június", "július", "augusztus", "szeptember", "október", "november", "december"],
	    shortMonths: ["jan.", "feb.", "már.", "ápr.", "máj.", "jún.", "júl.", "aug.", "szept.", "okt.", "nov.", "dec."]
	  });
	
	  var itIT = locale$1({
	    dateTime: "%A %e %B %Y, %X",
	    date: "%d/%m/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"], // unused
	    days: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"],
	    shortDays: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
	    months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
	    shortMonths: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
	  });
	
	  var jaJP = locale$1({
	    dateTime: "%Y %b %e %a %X",
	    date: "%Y/%m/%d",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"],
	    shortDays: ["日", "月", "火", "水", "木", "金", "土"],
	    months: ["睦月", "如月", "弥生", "卯月", "皐月", "水無月", "文月", "葉月", "長月", "神無月", "霜月", "師走"],
	    shortMonths: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"]
	  });
	
	  var koKR = locale$1({
	    dateTime: "%Y/%m/%d %a %X",
	    date: "%Y/%m/%d",
	    time: "%H:%M:%S",
	    periods: ["오전", "오후"],
	    days: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"],
	    shortDays: ["일", "월", "화", "수", "목", "금", "토"],
	    months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
	    shortMonths: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"]
	  });
	
	  var mkMK = locale$1({
	    dateTime: "%A, %e %B %Y г. %X",
	    date: "%d.%m.%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота"],
	    shortDays: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
	    months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
	    shortMonths: ["јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек"]
	  });
	
	  var nlNL = locale$1({
	    dateTime: "%a %e %B %Y %T",
	    date: "%d-%m-%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"], // unused
	    days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
	    shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
	    months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
	    shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
	  });
	
	  var plPL = locale$1({
	    dateTime: "%A, %e %B %Y, %X",
	    date: "%d/%m/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"], // unused
	    days: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
	    shortDays: ["Niedz.", "Pon.", "Wt.", "Śr.", "Czw.", "Pt.", "Sob."],
	    months: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
	    shortMonths: ["Stycz.", "Luty", "Marz.", "Kwie.", "Maj", "Czerw.", "Lipc.", "Sierp.", "Wrz.", "Paźdz.", "Listop.", "Grudz."]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */
	  });
	
	  var ptBR = locale$1({
	    dateTime: "%A, %e de %B de %Y. %X",
	    date: "%d/%m/%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
	    shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
	    months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
	    shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
	  });
	
	  var ruRU = locale$1({
	    dateTime: "%A, %e %B %Y г. %X",
	    date: "%d.%m.%Y",
	    time: "%H:%M:%S",
	    periods: ["AM", "PM"],
	    days: ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
	    shortDays: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
	    months: ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
	    shortMonths: ["янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек"]
	  });
	
	  var svSE = locale$1({
	    dateTime: "%A den %d %B %Y %X",
	    date: "%Y-%m-%d",
	    time: "%H:%M:%S",
	    periods: ["fm", "em"],
	    days: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"],
	    shortDays: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
	    months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
	    shortMonths: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"]
	  });
	
	  var zhCN = locale$1({
	    dateTime: "%a %b %e %X %Y",
	    date: "%Y/%-m/%-d",
	    time: "%H:%M:%S",
	    periods: ["上午", "下午"],
	    days: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
	    shortDays: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
	    months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
	    shortMonths: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
	  });
	
	  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
	
	  function formatIsoNative(date) {
	    return date.toISOString();
	  }
	
	  formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	
	  formatIsoNative.toString = function() {
	    return isoSpecifier;
	  };
	
	  var formatIso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z")
	      ? formatIsoNative
	      : locale.utcFormat(isoSpecifier);
	
	  var format = locale.format;
	  var utcFormat = locale.utcFormat;
	
	  var version = "0.2.1";
	
	  exports.version = version;
	  exports.format = format;
	  exports.utcFormat = utcFormat;
	  exports.locale = locale$1;
	  exports.localeCaEs = caES;
	  exports.localeDeCh = deCH;
	  exports.localeDeDe = deDE;
	  exports.localeEnCa = enCA;
	  exports.localeEnGb = enGB;
	  exports.localeEnUs = locale;
	  exports.localeEsEs = esES;
	  exports.localeFiFi = fiFI;
	  exports.localeFrCa = frCA;
	  exports.localeFrFr = frFR;
	  exports.localeHeIl = heIL;
	  exports.localeHuHu = huHU;
	  exports.localeItIt = itIT;
	  exports.localeJaJp = jaJP;
	  exports.localeKoKr = koKR;
	  exports.localeMkMk = mkMK;
	  exports.localeNlNl = nlNL;
	  exports.localePlPl = plPL;
	  exports.localePtBr = ptBR;
	  exports.localeRuRu = ruRU;
	  exports.localeSvSe = svSE;
	  exports.localeZhCn = zhCN;
	  exports.isoFormat = formatIso;
	
	}));
})
/** END DEFINE BLOCK for d3-time-format@0.2.1/build/d3-time-format.js **/


/** START DEFINE BLOCK for d3-format@0.4.2/build/d3-format.js **/
jupyter.define('d3-format@0.4.2/build/d3-format.js', function (module, exports, __jupyter_require__) {
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define('d3-format', ['exports'], factory) :
	  factory((global.d3_format = {}));
	}(this, function (exports) { 'use strict';
	
	  // Computes the decimal coefficient and exponent of the specified number x with
	  // significant digits p, where x is positive and p is in [1, 21] or undefined.
	  // For example, formatDecimal(1.23) returns ["123", 0].
	  function formatDecimal(x, p) {
	    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
	    var i, coefficient = x.slice(0, i);
	
	    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	    return [
	      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	      +x.slice(i + 1)
	    ];
	  };
	
	  function exponent(x) {
	    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
	  };
	
	  function formatGroup(grouping, thousands) {
	    return function(value, width) {
	      var i = value.length,
	          t = [],
	          j = 0,
	          g = grouping[0],
	          length = 0;
	
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = grouping[j = (j + 1) % grouping.length];
	      }
	
	      return t.reverse().join(thousands);
	    };
	  };
	
	  var prefixExponent;
	
	  function formatPrefixAuto(x, p) {
	    var d = formatDecimal(x, p);
	    if (!d) return x + "";
	    var coefficient = d[0],
	        exponent = d[1],
	        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	        n = coefficient.length;
	    return i === n ? coefficient
	        : i > n ? coefficient + new Array(i - n + 1).join("0")
	        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	  };
	
	  function formatRounded(x, p) {
	    var d = formatDecimal(x, p);
	    if (!d) return x + "";
	    var coefficient = d[0],
	        exponent = d[1];
	    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	  };
	
	  function formatDefault(x, p) {
	    x = x.toPrecision(p);
	
	    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
	      switch (x[i]) {
	        case ".": i0 = i1 = i; break;
	        case "0": if (i0 === 0) i0 = i; i1 = i; break;
	        case "e": break out;
	        default: if (i0 > 0) i0 = 0; break;
	      }
	    }
	
	    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
	  };
	
	  var formatTypes = {
	    "": formatDefault,
	    "%": function(x, p) { return (x * 100).toFixed(p); },
	    "b": function(x) { return Math.round(x).toString(2); },
	    "c": function(x) { return x + ""; },
	    "d": function(x) { return Math.round(x).toString(10); },
	    "e": function(x, p) { return x.toExponential(p); },
	    "f": function(x, p) { return x.toFixed(p); },
	    "g": function(x, p) { return x.toPrecision(p); },
	    "o": function(x) { return Math.round(x).toString(8); },
	    "p": function(x, p) { return formatRounded(x * 100, p); },
	    "r": formatRounded,
	    "s": formatPrefixAuto,
	    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
	    "x": function(x) { return Math.round(x).toString(16); }
	  };
	
	  // [[fill]align][sign][symbol][0][width][,][.precision][type]
	  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;
	
	  function formatSpecifier(specifier) {
	    return new FormatSpecifier(specifier);
	  };
	
	  function FormatSpecifier(specifier) {
	    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	
	    var match,
	        fill = match[1] || " ",
	        align = match[2] || ">",
	        sign = match[3] || "-",
	        symbol = match[4] || "",
	        zero = !!match[5],
	        width = match[6] && +match[6],
	        comma = !!match[7],
	        precision = match[8] && +match[8].slice(1),
	        type = match[9] || "";
	
	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";
	
	    // Map invalid types to the default format.
	    else if (!formatTypes[type]) type = "";
	
	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";
	
	    this.fill = fill;
	    this.align = align;
	    this.sign = sign;
	    this.symbol = symbol;
	    this.zero = zero;
	    this.width = width;
	    this.comma = comma;
	    this.precision = precision;
	    this.type = type;
	  }
	
	  FormatSpecifier.prototype.toString = function() {
	    return this.fill
	        + this.align
	        + this.sign
	        + this.symbol
	        + (this.zero ? "0" : "")
	        + (this.width == null ? "" : Math.max(1, this.width | 0))
	        + (this.comma ? "," : "")
	        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
	        + this.type;
	  };
	
	  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];
	
	  function identity(x) {
	    return x;
	  }
	
	  function locale(locale) {
	    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
	        currency = locale.currency,
	        decimal = locale.decimal;
	
	    function format(specifier) {
	      specifier = formatSpecifier(specifier);
	
	      var fill = specifier.fill,
	          align = specifier.align,
	          sign = specifier.sign,
	          symbol = specifier.symbol,
	          zero = specifier.zero,
	          width = specifier.width,
	          comma = specifier.comma,
	          precision = specifier.precision,
	          type = specifier.type;
	
	      // Compute the prefix and suffix.
	      // For SI-prefix, the suffix is lazily computed.
	      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";
	
	      // What format function should we use?
	      // Is this an integer type?
	      // Can this type generate exponential notation?
	      var formatType = formatTypes[type],
	          maybeSuffix = !type || /[defgprs%]/.test(type);
	
	      // Set the default precision if not specified,
	      // or clamp the specified precision to the supported range.
	      // For significant precision, it must be in [1, 21].
	      // For fixed precision, it must be in [0, 20].
	      precision = precision == null ? (type ? 6 : 12)
	          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	          : Math.max(0, Math.min(20, precision));
	
	      return function(value) {
	        var valuePrefix = prefix,
	            valueSuffix = suffix;
	
	        if (type === "c") {
	          valueSuffix = formatType(value) + valueSuffix;
	          value = "";
	        } else {
	          value = +value;
	
	          // Convert negative to positive, and compute the prefix.
	          // Note that -0 is not less than 0, but 1 / -0 is!
	          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);
	
	          // Perform the initial formatting.
	          value = formatType(value, precision);
	
	          // If the original value was negative, it may be rounded to zero during
	          // formatting; treat this as (positive) zero.
	          if (valueNegative) {
	            var i = -1, n = value.length, c;
	            valueNegative = false;
	            while (++i < n) {
	              if (c = value.charCodeAt(i), (48 < c && c < 58)
	                  || (type === "x" && 96 < c && c < 103)
	                  || (type === "X" && 64 < c && c < 71)) {
	                valueNegative = true;
	                break;
	              }
	            }
	          }
	
	          // Compute the prefix and suffix.
	          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");
	
	          // Break the formatted value into the integer “value” part that can be
	          // grouped, and fractional or exponential “suffix” part that is not.
	          if (maybeSuffix) {
	            var i = -1, n = value.length, c;
	            while (++i < n) {
	              if (c = value.charCodeAt(i), 48 > c || c > 57) {
	                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	                value = value.slice(0, i);
	                break;
	              }
	            }
	          }
	        }
	
	        // If the fill character is not "0", grouping is applied before padding.
	        if (comma && !zero) value = group(value, Infinity);
	
	        // Compute the padding.
	        var length = valuePrefix.length + value.length + valueSuffix.length,
	            padding = length < width ? new Array(width - length + 1).join(fill) : "";
	
	        // If the fill character is "0", grouping is applied after padding.
	        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
	
	        // Reconstruct the final output based on the desired alignment.
	        switch (align) {
	          case "<": return valuePrefix + value + valueSuffix + padding;
	          case "=": return valuePrefix + padding + value + valueSuffix;
	          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
	        }
	        return padding + valuePrefix + value + valueSuffix;
	      };
	    }
	
	    function formatPrefix(specifier, value) {
	      var f = format((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
	          k = Math.pow(10, -e),
	          prefix = prefixes[8 + e / 3];
	      return function(value) {
	        return f(k * value) + prefix;
	      };
	    }
	
	    return {
	      format: format,
	      formatPrefix: formatPrefix
	    };
	  };
	
	  var defaultLocale = locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["$", ""]
	  });
	
	  var caES = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["", "\xa0€"]
	  });
	
	  var csCZ = locale({
	    decimal: ",",
	    thousands: "\xa0",
	    grouping: [3],
	    currency: ["", "\xa0Kč"],
	  });
	
	  var deCH = locale({
	    decimal: ",",
	    thousands: "'",
	    grouping: [3],
	    currency: ["", "\xa0CHF"]
	  });
	
	  var deDE = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["", "\xa0€"]
	  });
	
	  var enCA = locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["$", ""]
	  });
	
	  var enGB = locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["£", ""]
	  });
	
	  var esES = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["", "\xa0€"]
	  });
	
	  var fiFI = locale({
	    decimal: ",",
	    thousands: "\xa0",
	    grouping: [3],
	    currency: ["", "\xa0€"]
	  });
	
	  var frCA = locale({
	    decimal: ",",
	    thousands: "\xa0",
	    grouping: [3],
	    currency: ["", "$"]
	  });
	
	  var frFR = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["", "\xa0€"]
	  });
	
	  var heIL = locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["₪", ""]
	  });
	
	  var huHU = locale({
	    decimal: ",",
	    thousands: "\xa0",
	    grouping: [3],
	    currency: ["", "\xa0Ft"]
	  });
	
	  var itIT = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["€", ""]
	  });
	
	  var jaJP = locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["", "円"]
	  });
	
	  var koKR = locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["₩", ""]
	  });
	
	  var mkMK = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["", "\xa0ден."]
	  });
	
	  var nlNL = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["€\xa0", ""]
	  });
	
	  var plPL = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["", "zł"]
	  });
	
	  var ptBR = locale({
	    decimal: ",",
	    thousands: ".",
	    grouping: [3],
	    currency: ["R$", ""]
	  });
	
	  var ruRU = locale({
	    decimal: ",",
	    thousands: "\xa0",
	    grouping: [3],
	    currency: ["", "\xa0руб."]
	  });
	
	  var svSE = locale({
	    decimal: ",",
	    thousands: "\xa0",
	    grouping: [3],
	    currency: ["", "SEK"]
	  });
	
	  var zhCN = locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [3],
	    currency: ["¥", ""]
	  });
	
	  function precisionFixed(step) {
	    return Math.max(0, -exponent(Math.abs(step)));
	  };
	
	  function precisionPrefix(step, value) {
	    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
	  };
	
	  function precisionRound(step, max) {
	    step = Math.abs(step), max = Math.abs(max) - step;
	    return Math.max(0, exponent(max) - exponent(step)) + 1;
	  };
	
	  var format = defaultLocale.format;
	  var formatPrefix = defaultLocale.formatPrefix;
	
	  var version = "0.4.2";
	
	  exports.version = version;
	  exports.format = format;
	  exports.formatPrefix = formatPrefix;
	  exports.locale = locale;
	  exports.localeCaEs = caES;
	  exports.localeCsCz = csCZ;
	  exports.localeDeCh = deCH;
	  exports.localeDeDe = deDE;
	  exports.localeEnCa = enCA;
	  exports.localeEnGb = enGB;
	  exports.localeEnUs = defaultLocale;
	  exports.localeEsEs = esES;
	  exports.localeFiFi = fiFI;
	  exports.localeFrCa = frCA;
	  exports.localeFrFr = frFR;
	  exports.localeHeIl = heIL;
	  exports.localeHuHu = huHU;
	  exports.localeItIt = itIT;
	  exports.localeJaJp = jaJP;
	  exports.localeKoKr = koKR;
	  exports.localeMkMk = mkMK;
	  exports.localeNlNl = nlNL;
	  exports.localePlPl = plPL;
	  exports.localePtBr = ptBR;
	  exports.localeRuRu = ruRU;
	  exports.localeSvSe = svSE;
	  exports.localeZhCn = zhCN;
	  exports.formatSpecifier = formatSpecifier;
	  exports.precisionFixed = precisionFixed;
	  exports.precisionPrefix = precisionPrefix;
	  exports.precisionRound = precisionRound;
	
	}));
})
/** END DEFINE BLOCK for d3-format@0.4.2/build/d3-format.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/aggregate/aggregator.js **/
jupyter.define('datalib@1.7.2/src/aggregate/aggregator.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    Measures = __jupyter_require__('datalib@~1.7.2/src/aggregate/measures.js'),
	    Collector = __jupyter_require__('datalib@~1.7.2/src/aggregate/collector.js');
	
	function Aggregator() {
	  this._cells = {};
	  this._aggr = [];
	  this._stream = false;
	}
	
	var Flags = Aggregator.Flags = {
	  ADD_CELL: 1,
	  MOD_CELL: 2
	};
	
	var proto = Aggregator.prototype;
	
	// Parameters
	
	proto.stream = function(v) {
	  if (v == null) return this._stream;
	  this._stream = !!v;
	  this._aggr = [];
	  return this;
	};
	
	// key accessor to use for streaming removes
	proto.key = function(key) {
	  if (key == null) return this._key;
	  this._key = util.$(key);
	  return this;
	};
	
	// Input: array of objects of the form
	// {name: string, get: function}
	proto.groupby = function(dims) {
	  this._dims = util.array(dims).map(function(d, i) {
	    d = util.isString(d) ? {name: d, get: util.$(d)}
	      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}
	      : (d.name && util.isFunction(d.get)) ? d : null;
	    if (d == null) throw 'Invalid groupby argument: ' + d;
	    return d;
	  });
	  return this.clear();
	};
	
	// Input: array of objects of the form
	// {name: string, ops: [string, ...]}
	proto.summarize = function(fields) {
	  fields = summarize_args(fields);
	  this._count = true;
	  var aggr = (this._aggr = []),
	      m, f, i, j, op, as, get;
	
	  for (i=0; i<fields.length; ++i) {
	    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {
	      op = f.ops[j];
	      if (op !== 'count') this._count = false;
	      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));
	      m.push(Measures[op](as));
	    }
	    get = f.get && util.$(f.get) ||
	      (f.name === '*' ? util.identity : util.$(f.name));
	    aggr.push({
	      name: f.name,
	      measures: Measures.create(
	        m,
	        this._stream, // streaming remove flag
	        get,          // input tuple getter
	        this._assign) // output tuple setter
	    });
	  }
	  return this.clear();
	};
	
	// Convenience method to summarize by count
	proto.count = function() {
	  return this.summarize({'*':'count'});
	};
	
	// Override to perform custom tuple value assignment
	proto._assign = function(object, name, value) {
	  object[name] = value;
	};
	
	function summarize_args(fields) {
	  if (util.isArray(fields)) { return fields; }
	  if (fields == null) { return []; }
	  var a = [], name, ops;
	  for (name in fields) {
	    ops = util.array(fields[name]);
	    a.push({name: name, ops: ops});
	  }
	  return a;
	}
	
	// Cell Management
	
	proto.clear = function() {
	  return (this._cells = {}, this);
	};
	
	proto._cellkey = function(x) {
	  var d = this._dims,
	      n = d.length, i,
	      k = String(d[0].get(x));
	  for (i=1; i<n; ++i) {
	    k += '|' + d[i].get(x);
	  }
	  return k;
	};
	
	proto._cell = function(x) {
	  var key = this._dims.length ? this._cellkey(x) : '';
	  return this._cells[key] || (this._cells[key] = this._newcell(x, key));
	};
	
	proto._newcell = function(x, key) {
	  var cell = {
	    num:   0,
	    tuple: this._newtuple(x, key),
	    flag:  Flags.ADD_CELL,
	    aggs:  {}
	  };
	
	  var aggr = this._aggr, i;
	  for (i=0; i<aggr.length; ++i) {
	    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);
	  }
	  if (cell.collect) {
	    cell.data = new Collector(this._key);
	  }
	  return cell;
	};
	
	proto._newtuple = function(x) {
	  var dims = this._dims,
	      t = {}, i, n;
	  for (i=0, n=dims.length; i<n; ++i) {
	    t[dims[i].name] = dims[i].get(x);
	  }
	  return this._ingest(t);
	};
	
	// Override to perform custom tuple ingestion
	proto._ingest = util.identity;
	
	// Process Tuples
	
	proto._add = function(x) {
	  var cell = this._cell(x),
	      aggr = this._aggr, i;
	
	  cell.num += 1;
	  if (!this._count) { // skip if count-only
	    if (cell.collect) cell.data.add(x);
	    for (i=0; i<aggr.length; ++i) {
	      cell.aggs[aggr[i].name].add(x);
	    }
	  }
	  cell.flag |= Flags.MOD_CELL;
	  if (this._on_add) this._on_add(x, cell);
	};
	
	proto._rem = function(x) {
	  var cell = this._cell(x),
	      aggr = this._aggr, i;
	
	  cell.num -= 1;
	  if (!this._count) { // skip if count-only
	    if (cell.collect) cell.data.rem(x);
	    for (i=0; i<aggr.length; ++i) {
	      cell.aggs[aggr[i].name].rem(x);
	    }
	  }
	  cell.flag |= Flags.MOD_CELL;
	  if (this._on_rem) this._on_rem(x, cell);
	};
	
	proto._mod = function(curr, prev) {
	  var cell0 = this._cell(prev),
	      cell1 = this._cell(curr),
	      aggr = this._aggr, i;
	
	  if (cell0 !== cell1) {
	    cell0.num -= 1;
	    cell1.num += 1;
	    if (cell0.collect) cell0.data.rem(prev);
	    if (cell1.collect) cell1.data.add(curr);
	  } else if (cell0.collect && !util.isObject(curr)) {
	    cell0.data.rem(prev);
	    cell0.data.add(curr);
	  }
	
	  for (i=0; i<aggr.length; ++i) {
	    cell0.aggs[aggr[i].name].rem(prev);
	    cell1.aggs[aggr[i].name].add(curr);
	  }
	  cell0.flag |= Flags.MOD_CELL;
	  cell1.flag |= Flags.MOD_CELL;
	  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);
	};
	
	proto._markMod = function(x) {
	  var cell0 = this._cell(x);
	  cell0.flag |= Flags.MOD_CELL;
	};
	
	proto.result = function() {
	  var result = [],
	      aggr = this._aggr,
	      cell, i, k;
	
	  for (k in this._cells) {
	    cell = this._cells[k];
	    if (cell.num > 0) {
	      // consolidate collector values
	      if (cell.collect) {
	        cell.data.values();
	      }
	      // update tuple properties
	      for (i=0; i<aggr.length; ++i) {
	        cell.aggs[aggr[i].name].set();
	      }
	      // add output tuple
	      result.push(cell.tuple);
	    } else {
	      delete this._cells[k];
	    }
	    cell.flag = 0;
	  }
	
	  this._rems = false;
	  return result;
	};
	
	proto.changes = function(output) {
	  var changes = output || {add:[], rem:[], mod:[]},
	      aggr = this._aggr,
	      cell, flag, i, k;
	
	  for (k in this._cells) {
	    cell = this._cells[k];
	    flag = cell.flag;
	
	    // consolidate collector values
	    if (cell.collect) {
	      cell.data.values();
	    }
	
	    // update tuple properties
	    for (i=0; i<aggr.length; ++i) {
	      cell.aggs[aggr[i].name].set();
	    }
	
	    // organize output tuples
	    if (cell.num <= 0) {
	      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??
	      delete this._cells[k];
	      if (this._on_drop) this._on_drop(cell);
	    } else {
	      if (this._on_keep) this._on_keep(cell);
	      if (flag & Flags.ADD_CELL) {
	        changes.add.push(cell.tuple);
	      } else if (flag & Flags.MOD_CELL) {
	        changes.mod.push(cell.tuple);
	      }
	    }
	
	    cell.flag = 0;
	  }
	
	  this._rems = false;
	  return changes;
	};
	
	proto.execute = function(input) {
	  return this.clear().insert(input).result();
	};
	
	proto.insert = function(input) {
	  this._consolidate();
	  for (var i=0; i<input.length; ++i) {
	    this._add(input[i]);
	  }
	  return this;
	};
	
	proto.remove = function(input) {
	  if (!this._stream) {
	    throw 'Aggregator not configured for streaming removes.' +
	      ' Call stream(true) prior to calling summarize.';
	  }
	  for (var i=0; i<input.length; ++i) {
	    this._rem(input[i]);
	  }
	  this._rems = true;
	  return this;
	};
	
	// consolidate removals
	proto._consolidate = function() {
	  if (!this._rems) return;
	  for (var k in this._cells) {
	    if (this._cells[k].collect) {
	      this._cells[k].data.values();
	    }
	  }
	  this._rems = false;
	};
	
	module.exports = Aggregator;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/aggregate/aggregator.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/aggregate/measures.js **/
jupyter.define('datalib@1.7.2/src/aggregate/measures.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	
	var types = {
	  'values': measure({
	    name: 'values',
	    init: 'cell.collect = true;',
	    set:  'cell.data.values()', idx: -1
	  }),
	  'count': measure({
	    name: 'count',
	    set:  'cell.num'
	  }),
	  'missing': measure({
	    name: 'missing',
	    set:  'this.missing'
	  }),
	  'valid': measure({
	    name: 'valid',
	    set:  'this.valid'
	  }),
	  'sum': measure({
	    name: 'sum',
	    init: 'this.sum = 0;',
	    add:  'this.sum += v;',
	    rem:  'this.sum -= v;',
	    set:  'this.sum'
	  }),
	  'mean': measure({
	    name: 'mean',
	    init: 'this.mean = 0;',
	    add:  'var d = v - this.mean; this.mean += d / this.valid;',
	    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',
	    set:  'this.mean'
	  }),
	  'average': measure({
	    name: 'average',
	    set:  'this.mean',
	    req:  ['mean'], idx: 1
	  }),
	  'variance': measure({
	    name: 'variance',
	    init: 'this.dev = 0;',
	    add:  'this.dev += d * (v - this.mean);',
	    rem:  'this.dev -= d * (v - this.mean);',
	    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',
	    req:  ['mean'], idx: 1
	  }),
	  'variancep': measure({
	    name: 'variancep',
	    set:  'this.valid > 1 ? this.dev / this.valid : 0',
	    req:  ['variance'], idx: 2
	  }),
	  'stdev': measure({
	    name: 'stdev',
	    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',
	    req:  ['variance'], idx: 2
	  }),
	  'stdevp': measure({
	    name: 'stdevp',
	    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',
	    req:  ['variance'], idx: 2
	  }),
	  'stderr': measure({
	    name: 'stderr',
	    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid * (this.valid-1))) : 0',
	    req:  ['variance'], idx: 2
	  }),
	  'median': measure({
	    name: 'median',
	    set:  'cell.data.q2(this.get)',
	    req:  ['values'], idx: 3
	  }),
	  'q1': measure({
	    name: 'q1',
	    set:  'cell.data.q1(this.get)',
	    req:  ['values'], idx: 3
	  }),
	  'q3': measure({
	    name: 'q3',
	    set:  'cell.data.q3(this.get)',
	    req:  ['values'], idx: 3
	  }),
	  'distinct': measure({
	    name: 'distinct',
	    set:  'this.distinct(cell.data.values(), this.get)',
	    req:  ['values'], idx: 3
	  }),
	  'argmin': measure({
	    name: 'argmin',
	    add:  'if (v < this.min) this.argmin = t;',
	    rem:  'if (v <= this.min) this.argmin = null;',
	    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',
	    req:  ['min'], str: ['values'], idx: 3
	  }),
	  'argmax': measure({
	    name: 'argmax',
	    add:  'if (v > this.max) this.argmax = t;',
	    rem:  'if (v >= this.max) this.argmax = null;',
	    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',
	    req:  ['max'], str: ['values'], idx: 3
	  }),
	  'min': measure({
	    name: 'min',
	    init: 'this.min = +Infinity;',
	    add:  'if (v < this.min) this.min = v;',
	    rem:  'if (v <= this.min) this.min = NaN;',
	    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',
	    str:  ['values'], idx: 4
	  }),
	  'max': measure({
	    name: 'max',
	    init: 'this.max = -Infinity;',
	    add:  'if (v > this.max) this.max = v;',
	    rem:  'if (v >= this.max) this.max = NaN;',
	    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',
	    str:  ['values'], idx: 4
	  }),
	  'modeskew': measure({
	    name: 'modeskew',
	    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',
	    req:  ['mean', 'variance', 'median'], idx: 5
	  })
	};
	
	function measure(base) {
	  return function(out) {
	    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);
	    m.out = out || base.name;
	    return m;
	  };
	}
	
	function resolve(agg, stream) {
	  function collect(m, a) {
	    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }
	    if (a.req) a.req.forEach(helper);
	    if (stream && a.str) a.str.forEach(helper);
	    return m;
	  }
	  var map = agg.reduce(
	    collect,
	    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})
	  );
	  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });
	}
	
	function create(agg, stream, accessor, mutator) {
	  var all = resolve(agg, stream),
	      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',
	      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',
	      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',
	      set = 'var t = this.tuple; var cell = this.cell;';
	
	  all.forEach(function(a) {
	    if (a.idx < 0) {
	      ctr = a.init + ctr;
	      add = a.add + add;
	      rem = a.rem + rem;
	    } else {
	      ctr += a.init;
	      add += a.add;
	      rem += a.rem;
	    }
	  });
	  agg.slice()
	    .sort(function(a, b) { return a.idx - b.idx; })
	    .forEach(function(a) {
	      set += 'this.assign(t,\''+a.out+'\','+a.set+');';
	    });
	  set += 'return t;';
	
	  /* jshint evil: true */
	  ctr = Function('cell', 't', ctr);
	  ctr.prototype.assign = mutator;
	  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);
	  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);
	  ctr.prototype.set = Function(set);
	  ctr.prototype.get = accessor;
	  ctr.prototype.distinct = __jupyter_require__('datalib@~1.7.2/src/stats.js').count.distinct;
	  ctr.prototype.isValid = util.isValid;
	  ctr.fields = agg.map(util.$('out'));
	  return ctr;
	}
	
	types.create = create;
	module.exports = types;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/aggregate/measures.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/stats.js **/
jupyter.define('datalib@1.7.2/src/stats.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	var type = __jupyter_require__('datalib@~1.7.2/src/import/type.js');
	var gen = __jupyter_require__('datalib@~1.7.2/src/generate.js');
	
	var stats = module.exports;
	
	// Collect unique values.
	// Output: an array of unique values, in first-observed order
	stats.unique = function(values, f, results) {
	  f = util.$(f);
	  results = results || [];
	  var u = {}, v, i, n;
	  for (i=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (v in u) continue;
	    u[v] = 1;
	    results.push(v);
	  }
	  return results;
	};
	
	// Return the length of the input array.
	stats.count = function(values) {
	  return values && values.length || 0;
	};
	
	// Count the number of non-null, non-undefined, non-NaN values.
	stats.count.valid = function(values, f) {
	  f = util.$(f);
	  var v, i, n, valid = 0;
	  for (i=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) valid += 1;
	  }
	  return valid;
	};
	
	// Count the number of null or undefined values.
	stats.count.missing = function(values, f) {
	  f = util.$(f);
	  var v, i, n, count = 0;
	  for (i=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (v == null) count += 1;
	  }
	  return count;
	};
	
	// Count the number of distinct values.
	// Null, undefined and NaN are each considered distinct values.
	stats.count.distinct = function(values, f) {
	  f = util.$(f);
	  var u = {}, v, i, n, count = 0;
	  for (i=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (v in u) continue;
	    u[v] = 1;
	    count += 1;
	  }
	  return count;
	};
	
	// Construct a map from distinct values to occurrence counts.
	stats.count.map = function(values, f) {
	  f = util.$(f);
	  var map = {}, v, i, n;
	  for (i=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    map[v] = (v in map) ? map[v] + 1 : 1;
	  }
	  return map;
	};
	
	// Compute the median of an array of numbers.
	stats.median = function(values, f) {
	  if (f) values = values.map(util.$(f));
	  values = values.filter(util.isValid).sort(util.cmp);
	  return stats.quantile(values, 0.5);
	};
	
	// Computes the quartile boundaries of an array of numbers.
	stats.quartile = function(values, f) {
	  if (f) values = values.map(util.$(f));
	  values = values.filter(util.isValid).sort(util.cmp);
	  var q = stats.quantile;
	  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];
	};
	
	// Compute the quantile of a sorted array of numbers.
	// Adapted from the D3.js implementation.
	stats.quantile = function(values, f, p) {
	  if (p === undefined) { p = f; f = util.identity; }
	  f = util.$(f);
	  var H = (values.length - 1) * p + 1,
	      h = Math.floor(H),
	      v = +f(values[h - 1]),
	      e = H - h;
	  return e ? v + e * (f(values[h]) - v) : v;
	};
	
	// Compute the sum of an array of numbers.
	stats.sum = function(values, f) {
	  f = util.$(f);
	  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) sum += v;
	  }
	  return sum;
	};
	
	// Compute the mean (average) of an array of numbers.
	stats.mean = function(values, f) {
	  f = util.$(f);
	  var mean = 0, delta, i, n, c, v;
	  for (i=0, c=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) {
	      delta = v - mean;
	      mean = mean + delta / (++c);
	    }
	  }
	  return mean;
	};
	
	// Compute the geometric mean of an array of numbers.
	stats.mean.geometric = function(values, f) {
	  f = util.$(f);
	  var mean = 1, c, n, v, i;
	  for (i=0, c=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) {
	      if (v <= 0) {
	        throw Error("Geometric mean only defined for positive values.");
	      }
	      mean *= v;
	      ++c;
	    }
	  }
	  mean = c > 0 ? Math.pow(mean, 1/c) : 0;
	  return mean;
	};
	
	// Compute the harmonic mean of an array of numbers.
	stats.mean.harmonic = function(values, f) {
	  f = util.$(f);
	  var mean = 0, c, n, v, i;
	  for (i=0, c=0, n=values.length; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) {
	      mean += 1/v;
	      ++c;
	    }
	  }
	  return c / mean;
	};
	
	// Compute the sample variance of an array of numbers.
	stats.variance = function(values, f) {
	  f = util.$(f);
	  if (!util.isArray(values) || values.length < 2) return 0;
	  var mean = 0, M2 = 0, delta, i, c, v;
	  for (i=0, c=0; i<values.length; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) {
	      delta = v - mean;
	      mean = mean + delta / (++c);
	      M2 = M2 + delta * (v - mean);
	    }
	  }
	  M2 = M2 / (c - 1);
	  return M2;
	};
	
	// Compute the sample standard deviation of an array of numbers.
	stats.stdev = function(values, f) {
	  return Math.sqrt(stats.variance(values, f));
	};
	
	// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.
	stats.modeskew = function(values, f) {
	  var avg = stats.mean(values, f),
	      med = stats.median(values, f),
	      std = stats.stdev(values, f);
	  return std === 0 ? 0 : (avg - med) / std;
	};
	
	// Find the minimum value in an array.
	stats.min = function(values, f) {
	  return stats.extent(values, f)[0];
	};
	
	// Find the maximum value in an array.
	stats.max = function(values, f) {
	  return stats.extent(values, f)[1];
	};
	
	// Find the minimum and maximum of an array of values.
	stats.extent = function(values, f) {
	  f = util.$(f);
	  var a, b, v, i, n = values.length;
	  for (i=0; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) { a = b = v; break; }
	  }
	  for (; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) {
	      if (v < a) a = v;
	      if (v > b) b = v;
	    }
	  }
	  return [a, b];
	};
	
	// Find the integer indices of the minimum and maximum values.
	stats.extent.index = function(values, f) {
	  f = util.$(f);
	  var x = -1, y = -1, a, b, v, i, n = values.length;
	  for (i=0; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) { a = b = v; x = y = i; break; }
	  }
	  for (; i<n; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) {
	      if (v < a) { a = v; x = i; }
	      if (v > b) { b = v; y = i; }
	    }
	  }
	  return [x, y];
	};
	
	// Compute the dot product of two arrays of numbers.
	stats.dot = function(values, a, b) {
	  var sum = 0, i, v;
	  if (!b) {
	    if (values.length !== a.length) {
	      throw Error('Array lengths must match.');
	    }
	    for (i=0; i<values.length; ++i) {
	      v = values[i] * a[i];
	      if (v === v) sum += v;
	    }
	  } else {
	    a = util.$(a);
	    b = util.$(b);
	    for (i=0; i<values.length; ++i) {
	      v = a(values[i]) * b(values[i]);
	      if (v === v) sum += v;
	    }
	  }
	  return sum;
	};
	
	// Compute the vector distance between two arrays of numbers.
	// Default is Euclidean (exp=2) distance, configurable via exp argument.
	stats.dist = function(values, a, b, exp) {
	  var f = util.isFunction(b) || util.isString(b),
	      X = values,
	      Y = f ? values : a,
	      e = f ? exp : b,
	      L2 = e === 2 || e == null,
	      n = values.length, s = 0, d, i;
	  if (f) {
	    a = util.$(a);
	    b = util.$(b);
	  }
	  for (i=0; i<n; ++i) {
	    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);
	    s += L2 ? d*d : Math.pow(Math.abs(d), e);
	  }
	  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);
	};
	
	// Compute the Cohen's d effect size between two arrays of numbers.
	stats.cohensd = function(values, a, b) {
	  var X = b ? values.map(util.$(a)) : values,
	      Y = b ? values.map(util.$(b)) : a,
	      x1 = stats.mean(X),
	      x2 = stats.mean(Y),
	      n1 = stats.count.valid(X),
	      n2 = stats.count.valid(Y);
	
	  if ((n1+n2-2) <= 0) {
	    // if both arrays are size 1, or one is empty, there's no effect size
	    return 0;
	  }
	  // pool standard deviation
	  var s1 = stats.variance(X),
	      s2 = stats.variance(Y),
	      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));
	  // if there is no variance, there's no effect size
	  return s===0 ? 0 : (x1 - x2) / s;
	};
	
	// Computes the covariance between two arrays of numbers
	stats.covariance = function(values, a, b) {
	  var X = b ? values.map(util.$(a)) : values,
	      Y = b ? values.map(util.$(b)) : a,
	      n = X.length,
	      xm = stats.mean(X),
	      ym = stats.mean(Y),
	      sum = 0, c = 0, i, x, y, vx, vy;
	
	  if (n !== Y.length) {
	    throw Error('Input lengths must match.');
	  }
	
	  for (i=0; i<n; ++i) {
	    x = X[i]; vx = util.isValid(x);
	    y = Y[i]; vy = util.isValid(y);
	    if (vx && vy) {
	      sum += (x-xm) * (y-ym);
	      ++c;
	    } else if (vx || vy) {
	      throw Error('Valid values must align.');
	    }
	  }
	  return sum / (c-1);
	};
	
	// Compute ascending rank scores for an array of values.
	// Ties are assigned their collective mean rank.
	stats.rank = function(values, f) {
	  f = util.$(f) || util.identity;
	  var a = values.map(function(v, i) {
	      return {idx: i, val: f(v)};
	    })
	    .sort(util.comparator('val'));
	
	  var n = values.length,
	      r = Array(n),
	      tie = -1, p = {}, i, v, mu;
	
	  for (i=0; i<n; ++i) {
	    v = a[i].val;
	    if (tie < 0 && p === v) {
	      tie = i - 1;
	    } else if (tie > -1 && p !== v) {
	      mu = 1 + (i-1 + tie) / 2;
	      for (; tie<i; ++tie) r[a[tie].idx] = mu;
	      tie = -1;
	    }
	    r[a[i].idx] = i + 1;
	    p = v;
	  }
	
	  if (tie > -1) {
	    mu = 1 + (n-1 + tie) / 2;
	    for (; tie<n; ++tie) r[a[tie].idx] = mu;
	  }
	
	  return r;
	};
	
	// Compute the sample Pearson product-moment correlation of two arrays of numbers.
	stats.cor = function(values, a, b) {
	  var fn = b;
	  b = fn ? values.map(util.$(b)) : a;
	  a = fn ? values.map(util.$(a)) : values;
	
	  var dot = stats.dot(a, b),
	      mua = stats.mean(a),
	      mub = stats.mean(b),
	      sda = stats.stdev(a),
	      sdb = stats.stdev(b),
	      n = values.length;
	
	  return (dot - n*mua*mub) / ((n-1) * sda * sdb);
	};
	
	// Compute the Spearman rank correlation of two arrays of values.
	stats.cor.rank = function(values, a, b) {
	  var ra = b ? stats.rank(values, a) : stats.rank(values),
	      rb = b ? stats.rank(values, b) : stats.rank(a),
	      n = values.length, i, s, d;
	
	  for (i=0, s=0; i<n; ++i) {
	    d = ra[i] - rb[i];
	    s += d * d;
	  }
	
	  return 1 - 6*s / (n * (n*n-1));
	};
	
	// Compute the distance correlation of two arrays of numbers.
	// http://en.wikipedia.org/wiki/Distance_correlation
	stats.cor.dist = function(values, a, b) {
	  var X = b ? values.map(util.$(a)) : values,
	      Y = b ? values.map(util.$(b)) : a;
	
	  var A = stats.dist.mat(X),
	      B = stats.dist.mat(Y),
	      n = A.length,
	      i, aa, bb, ab;
	
	  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {
	    aa += A[i]*A[i];
	    bb += B[i]*B[i];
	    ab += A[i]*B[i];
	  }
	
	  return Math.sqrt(ab / Math.sqrt(aa*bb));
	};
	
	// Simple linear regression.
	// Returns a "fit" object with slope (m), intercept (b),
	// r value (R), and sum-squared residual error (rss).
	stats.linearRegression = function(values, a, b) {
	  var X = b ? values.map(util.$(a)) : values,
	      Y = b ? values.map(util.$(b)) : a,
	      n = X.length,
	      xy = stats.covariance(X, Y), // will throw err if valid vals don't align
	      sx = stats.stdev(X),
	      sy = stats.stdev(Y),
	      slope = xy / (sx*sx),
	      icept = stats.mean(Y) - slope * stats.mean(X),
	      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},
	      res, i;
	
	  for (i=0; i<n; ++i) {
	    if (util.isValid(X[i]) && util.isValid(Y[i])) {
	      res = (slope*X[i] + icept) - Y[i];
	      fit.rss += res * res;
	    }
	  }
	
	  return fit;
	};
	
	// Namespace for bootstrap
	stats.bootstrap = {};
	
	// Construct a bootstrapped confidence interval at a given percentile level
	// Arguments are an array, an optional n (defaults to 1000),
	//  an optional alpha (defaults to 0.05), and an optional smoothing parameter
	stats.bootstrap.ci = function(values, a, b, c, d) {
	  var X, N, alpha, smooth, bs, means, i;
	  if (util.isFunction(a) || util.isString(a)) {
	    X = values.map(util.$(a));
	    N = b;
	    alpha = c;
	    smooth = d;
	  } else {
	    X = values;
	    N = a;
	    alpha = b;
	    smooth = c;
	  }
	  N = N ? +N : 1000;
	  alpha = alpha || 0.05;
	
	  bs = gen.random.bootstrap(X, smooth);
	  for (i=0, means = Array(N); i<N; ++i) {
	    means[i] = stats.mean(bs.samples(X.length));
	  }
	  means.sort(util.numcmp);
	  return [
	    stats.quantile(means, alpha/2),
	    stats.quantile(means, 1-(alpha/2))
	  ];
	};
	
	// Namespace for z-tests
	stats.z = {};
	
	// Construct a z-confidence interval at a given significance level
	// Arguments are an array and an optional alpha (defaults to 0.05).
	stats.z.ci = function(values, a, b) {
	  var X = values, alpha = a;
	  if (util.isFunction(a) || util.isString(a)) {
	    X = values.map(util.$(a));
	    alpha = b;
	  }
	  alpha = alpha || 0.05;
	
	  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),
	      mu = stats.mean(X),
	      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));
	  return [mu - (z*SE), mu + (z*SE)];
	};
	
	// Perform a z-test of means. Returns the p-value.
	// If a single array is provided, performs a one-sample location test.
	// If two arrays or a table and two accessors are provided, performs
	// a two-sample location test. A paired test is performed if specified
	// by the options hash.
	// The options hash format is: {paired: boolean, nullh: number}.
	// http://en.wikipedia.org/wiki/Z-test
	// http://en.wikipedia.org/wiki/Paired_difference_test
	stats.z.test = function(values, a, b, opt) {
	  if (util.isFunction(b) || util.isString(b)) { // table and accessors
	    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);
	  } else if (util.isArray(a)) { // two arrays
	    return (b && b.paired ? ztestP : ztest2)(b, values, a);
	  } else if (util.isFunction(a) || util.isString(a)) {
	    return ztest1(b, values, a); // table and accessor
	  } else {
	    return ztest1(a, values); // one array
	  }
	};
	
	// Perform a z-test of means. Returns the p-value.
	// Assuming we have a list of values, and a null hypothesis. If no null
	// hypothesis, assume our null hypothesis is mu=0.
	function ztest1(opt, X, f) {
	  var nullH = opt && opt.nullh || 0,
	      gaussian = gen.random.normal(0, 1),
	      mu = stats.mean(X,f),
	      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));
	
	  if (SE===0) {
	    // Test not well defined when standard error is 0.
	    return (mu - nullH) === 0 ? 1 : 0;
	  }
	  // Two-sided, so twice the one-sided cdf.
	  var z = (mu - nullH) / SE;
	  return 2 * gaussian.cdf(-Math.abs(z));
	}
	
	// Perform a two sample paired z-test of means. Returns the p-value.
	function ztestP(opt, values, a, b) {
	  var X = b ? values.map(util.$(a)) : values,
	      Y = b ? values.map(util.$(b)) : a,
	      n1 = stats.count(X),
	      n2 = stats.count(Y),
	      diffs = Array(), i;
	
	  if (n1 !== n2) {
	    throw Error('Array lengths must match.');
	  }
	  for (i=0; i<n1; ++i) {
	    // Only valid differences should contribute to the test statistic
	    if (util.isValid(X[i]) && util.isValid(Y[i])) {
	      diffs.push(X[i] - Y[i]);
	    }
	  }
	  return stats.z.test(diffs, opt && opt.nullh || 0);
	}
	
	// Perform a two sample z-test of means. Returns the p-value.
	function ztest2(opt, values, a, b) {
	  var X = b ? values.map(util.$(a)) : values,
	      Y = b ? values.map(util.$(b)) : a,
	      n1 = stats.count.valid(X),
	      n2 = stats.count.valid(Y),
	      gaussian = gen.random.normal(0, 1),
	      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),
	      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);
	
	  if (SE===0) {
	    // Not well defined when pooled standard error is 0.
	    return meanDiff===0 ? 1 : 0;
	  }
	  // Two-tailed, so twice the one-sided cdf.
	  var z = meanDiff / SE;
	  return 2 * gaussian.cdf(-Math.abs(z));
	}
	
	// Construct a mean-centered distance matrix for an array of numbers.
	stats.dist.mat = function(X) {
	  var n = X.length,
	      m = n*n,
	      A = Array(m),
	      R = gen.zeros(n),
	      M = 0, v, i, j;
	
	  for (i=0; i<n; ++i) {
	    A[i*n+i] = 0;
	    for (j=i+1; j<n; ++j) {
	      A[i*n+j] = (v = Math.abs(X[i] - X[j]));
	      A[j*n+i] = v;
	      R[i] += v;
	      R[j] += v;
	    }
	  }
	
	  for (i=0; i<n; ++i) {
	    M += R[i];
	    R[i] /= n;
	  }
	  M /= m;
	
	  for (i=0; i<n; ++i) {
	    for (j=i; j<n; ++j) {
	      A[i*n+j] += M - R[i] - R[j];
	      A[j*n+i] = A[i*n+j];
	    }
	  }
	
	  return A;
	};
	
	// Compute the Shannon entropy (log base 2) of an array of counts.
	stats.entropy = function(counts, f) {
	  f = util.$(f);
	  var i, p, s = 0, H = 0, n = counts.length;
	  for (i=0; i<n; ++i) {
	    s += (f ? f(counts[i]) : counts[i]);
	  }
	  if (s === 0) return 0;
	  for (i=0; i<n; ++i) {
	    p = (f ? f(counts[i]) : counts[i]) / s;
	    if (p) H += p * Math.log(p);
	  }
	  return -H / Math.LN2;
	};
	
	// Compute the mutual information between two discrete variables.
	// Returns an array of the form [MI, MI_distance]
	// MI_distance is defined as 1 - I(a,b) / H(a,b).
	// http://en.wikipedia.org/wiki/Mutual_information
	stats.mutual = function(values, a, b, counts) {
	  var x = counts ? values.map(util.$(a)) : values,
	      y = counts ? values.map(util.$(b)) : a,
	      z = counts ? values.map(util.$(counts)) : b;
	
	  var px = {},
	      py = {},
	      n = z.length,
	      s = 0, I = 0, H = 0, p, t, i;
	
	  for (i=0; i<n; ++i) {
	    px[x[i]] = 0;
	    py[y[i]] = 0;
	  }
	
	  for (i=0; i<n; ++i) {
	    px[x[i]] += z[i];
	    py[y[i]] += z[i];
	    s += z[i];
	  }
	
	  t = 1 / (s * Math.LN2);
	  for (i=0; i<n; ++i) {
	    if (z[i] === 0) continue;
	    p = (s * z[i]) / (px[x[i]] * py[y[i]]);
	    I += z[i] * t * Math.log(p);
	    H += z[i] * t * Math.log(z[i]/s);
	  }
	
	  return [I, 1 + I/H];
	};
	
	// Compute the mutual information between two discrete variables.
	stats.mutual.info = function(values, a, b, counts) {
	  return stats.mutual(values, a, b, counts)[0];
	};
	
	// Compute the mutual information distance between two discrete variables.
	// MI_distance is defined as 1 - I(a,b) / H(a,b).
	stats.mutual.dist = function(values, a, b, counts) {
	  return stats.mutual(values, a, b, counts)[1];
	};
	
	// Compute a profile of summary statistics for a variable.
	stats.profile = function(values, f) {
	  var mean = 0,
	      valid = 0,
	      missing = 0,
	      distinct = 0,
	      min = null,
	      max = null,
	      M2 = 0,
	      vals = [],
	      u = {}, delta, sd, i, v, x;
	
	  // compute summary stats
	  for (i=0; i<values.length; ++i) {
	    v = f ? f(values[i]) : values[i];
	
	    // update unique values
	    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);
	
	    if (v == null) {
	      ++missing;
	    } else if (util.isValid(v)) {
	      // update stats
	      x = (typeof v === 'string') ? v.length : v;
	      if (min===null || x < min) min = x;
	      if (max===null || x > max) max = x;
	      delta = x - mean;
	      mean = mean + delta / (++valid);
	      M2 = M2 + delta * (x - mean);
	      vals.push(x);
	    }
	  }
	  M2 = M2 / (valid - 1);
	  sd = Math.sqrt(M2);
	
	  // sort values for median and iqr
	  vals.sort(util.cmp);
	
	  return {
	    type:     type(values, f),
	    unique:   u,
	    count:    values.length,
	    valid:    valid,
	    missing:  missing,
	    distinct: distinct,
	    min:      min,
	    max:      max,
	    mean:     mean,
	    stdev:    sd,
	    median:   (v = stats.quantile(vals, 0.5)),
	    q1:       stats.quantile(vals, 0.25),
	    q3:       stats.quantile(vals, 0.75),
	    modeskew: sd === 0 ? 0 : (mean - v) / sd
	  };
	};
	
	// Compute profiles for all variables in a data set.
	stats.summary = function(data, fields) {
	  fields = fields || util.keys(data[0]);
	  var s = fields.map(function(f) {
	    var p = stats.profile(data, util.$(f));
	    return (p.field = f, p);
	  });
	  return (s.__summary__ = true, s);
	};
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/stats.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/generate.js **/
jupyter.define('datalib@1.7.2/src/generate.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    gen = module.exports;
	
	gen.repeat = function(val, n) {
	  var a = Array(n), i;
	  for (i=0; i<n; ++i) a[i] = val;
	  return a;
	};
	
	gen.zeros = function(n) {
	  return gen.repeat(0, n);
	};
	
	gen.range = function(start, stop, step) {
	  if (arguments.length < 3) {
	    step = 1;
	    if (arguments.length < 2) {
	      stop = start;
	      start = 0;
	    }
	  }
	  if ((stop - start) / step == Infinity) throw new Error('Infinite range');
	  var range = [], i = -1, j;
	  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);
	  else while ((j = start + step * ++i) < stop) range.push(j);
	  return range;
	};
	
	gen.random = {};
	
	gen.random.uniform = function(min, max) {
	  if (max === undefined) {
	    max = min === undefined ? 1 : min;
	    min = 0;
	  }
	  var d = max - min;
	  var f = function() {
	    return min + d * Math.random();
	  };
	  f.samples = function(n) {
	    return gen.zeros(n).map(f);
	  };
	  f.pdf = function(x) {
	    return (x >= min && x <= max) ? 1/d : 0;
	  };
	  f.cdf = function(x) {
	    return x < min ? 0 : x > max ? 1 : (x - min) / d;
	  };
	  f.icdf = function(p) {
	    return (p >= 0 && p <= 1) ? min + p*d : NaN;
	  };
	  return f;
	};
	
	gen.random.integer = function(a, b) {
	  if (b === undefined) {
	    b = a;
	    a = 0;
	  }
	  var d = b - a;
	  var f = function() {
	    return a + Math.floor(d * Math.random());
	  };
	  f.samples = function(n) {
	    return gen.zeros(n).map(f);
	  };
	  f.pdf = function(x) {
	    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;
	  };
	  f.cdf = function(x) {
	    var v = Math.floor(x);
	    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;
	  };
	  f.icdf = function(p) {
	    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;
	  };
	  return f;
	};
	
	gen.random.normal = function(mean, stdev) {
	  mean = mean || 0;
	  stdev = stdev || 1;
	  var next;
	  var f = function() {
	    var x = 0, y = 0, rds, c;
	    if (next !== undefined) {
	      x = next;
	      next = undefined;
	      return x;
	    }
	    do {
	      x = Math.random()*2-1;
	      y = Math.random()*2-1;
	      rds = x*x + y*y;
	    } while (rds === 0 || rds > 1);
	    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform
	    next = mean + y*c*stdev;
	    return mean + x*c*stdev;
	  };
	  f.samples = function(n) {
	    return gen.zeros(n).map(f);
	  };
	  f.pdf = function(x) {
	    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));
	    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;
	  };
	  f.cdf = function(x) {
	    // Approximation from West (2009)
	    // Better Approximations to Cumulative Normal Functions
	    var cd,
	        z = (x - mean) / stdev,
	        Z = Math.abs(z);
	    if (Z > 37) {
	      cd = 0;
	    } else {
	      var sum, exp = Math.exp(-Z*Z/2);
	      if (Z < 7.07106781186547) {
	        sum = 3.52624965998911e-02 * Z + 0.700383064443688;
	        sum = sum * Z + 6.37396220353165;
	        sum = sum * Z + 33.912866078383;
	        sum = sum * Z + 112.079291497871;
	        sum = sum * Z + 221.213596169931;
	        sum = sum * Z + 220.206867912376;
	        cd = exp * sum;
	        sum = 8.83883476483184e-02 * Z + 1.75566716318264;
	        sum = sum * Z + 16.064177579207;
	        sum = sum * Z + 86.7807322029461;
	        sum = sum * Z + 296.564248779674;
	        sum = sum * Z + 637.333633378831;
	        sum = sum * Z + 793.826512519948;
	        sum = sum * Z + 440.413735824752;
	        cd = cd / sum;
	      } else {
	        sum = Z + 0.65;
	        sum = Z + 4 / sum;
	        sum = Z + 3 / sum;
	        sum = Z + 2 / sum;
	        sum = Z + 1 / sum;
	        cd = exp / sum / 2.506628274631;
	      }
	    }
	    return z > 0 ? 1 - cd : cd;
	  };
	  f.icdf = function(p) {
	    // Approximation of Probit function using inverse error function.
	    if (p <= 0 || p >= 1) return NaN;
	    var x = 2*p - 1,
	        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),
	        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),
	        b = Math.log(1 - (x*x)) / v,
	        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);
	    return mean + stdev * Math.SQRT2 * s;
	  };
	  return f;
	};
	
	gen.random.bootstrap = function(domain, smooth) {
	  // Generates a bootstrap sample from a set of observations.
	  // Smooth bootstrapping adds random zero-centered noise to the samples.
	  var val = domain.filter(util.isValid),
	      len = val.length,
	      err = smooth ? gen.random.normal(0, smooth) : null;
	  var f = function() {
	    return val[~~(Math.random()*len)] + (err ? err() : 0);
	  };
	  f.samples = function(n) {
	    return gen.zeros(n).map(f);
	  };
	  return f;
	};
})
/** END DEFINE BLOCK for datalib@1.7.2/src/generate.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/aggregate/collector.js **/
jupyter.define('datalib@1.7.2/src/aggregate/collector.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	var stats = __jupyter_require__('datalib@~1.7.2/src/stats.js');
	
	var REM = '__dl_rem__';
	
	function Collector(key) {
	  this._add = [];
	  this._rem = [];
	  this._key = key || null;
	  this._last = null;
	}
	
	var proto = Collector.prototype;
	
	proto.add = function(v) {
	  this._add.push(v);
	};
	
	proto.rem = function(v) {
	  this._rem.push(v);
	};
	
	proto.values = function() {
	  this._get = null;
	  if (this._rem.length === 0) return this._add;
	
	  var a = this._add,
	      r = this._rem,
	      k = this._key,
	      x = Array(a.length - r.length),
	      i, j, n, m;
	
	  if (!util.isObject(r[0])) {
	    // processing raw values
	    m = stats.count.map(r);
	    for (i=0, j=0, n=a.length; i<n; ++i) {
	      if (m[a[i]] > 0) {
	        m[a[i]] -= 1;
	      } else {
	        x[j++] = a[i];
	      }
	    }
	  } else if (k) {
	    // has unique key field, so use that
	    m = util.toMap(r, k);
	    for (i=0, j=0, n=a.length; i<n; ++i) {
	      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }
	    }
	  } else {
	    // no unique key, mark tuples directly
	    for (i=0, n=r.length; i<n; ++i) {
	      r[i][REM] = 1;
	    }
	    for (i=0, j=0, n=a.length; i<n; ++i) {
	      if (!a[i][REM]) { x[j++] = a[i]; }
	    }
	    for (i=0, n=r.length; i<n; ++i) {
	      delete r[i][REM];
	    }
	  }
	
	  this._rem = [];
	  return (this._add = x);
	};
	
	// memoizing statistics methods
	
	proto.extent = function(get) {
	  if (this._get !== get || !this._ext) {
	    var v = this.values(),
	        i = stats.extent.index(v, get);
	    this._ext = [v[i[0]], v[i[1]]];
	    this._get = get;
	  }
	  return this._ext;
	};
	
	proto.argmin = function(get) {
	  return this.extent(get)[0];
	};
	
	proto.argmax = function(get) {
	  return this.extent(get)[1];
	};
	
	proto.min = function(get) {
	  var m = this.extent(get)[0];
	  return m != null ? get(m) : +Infinity;
	};
	
	proto.max = function(get) {
	  var m = this.extent(get)[1];
	  return m != null ? get(m) : -Infinity;
	};
	
	proto.quartile = function(get) {
	  if (this._get !== get || !this._q) {
	    this._q = stats.quartile(this.values(), get);
	    this._get = get;
	  }
	  return this._q;
	};
	
	proto.q1 = function(get) {
	  return this.quartile(get)[0];
	};
	
	proto.q2 = function(get) {
	  return this.quartile(get)[1];
	};
	
	proto.q3 = function(get) {
	  return this.quartile(get)[2];
	};
	
	module.exports = Collector;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/aggregate/collector.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/aggregate/groupby.js **/
jupyter.define('datalib@1.7.2/src/aggregate/groupby.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	var Aggregator = __jupyter_require__('datalib@~1.7.2/src/aggregate/aggregator.js');
	
	module.exports = function() {
	  // flatten arguments into a single array
	  var args = [].reduce.call(arguments, function(a, x) {
	    return a.concat(util.array(x));
	  }, []);
	  // create and return an aggregator
	  return new Aggregator()
	    .groupby(args)
	    .summarize({'*':'values'});
	};
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/aggregate/groupby.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/bins/bins.js **/
jupyter.define('datalib@1.7.2/src/bins/bins.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    time = __jupyter_require__('datalib@~1.7.2/src/time.js'),
	    EPSILON = 1e-15;
	
	function bins(opt) {
	  if (!opt) { throw Error("Missing binning options."); }
	
	  // determine range
	  var maxb = opt.maxbins || 15,
	      base = opt.base || 10,
	      logb = Math.log(base),
	      div = opt.div || [5, 2],
	      min = opt.min,
	      max = opt.max,
	      span = max - min,
	      step, level, minstep, precision, v, i, eps;
	
	  if (opt.step) {
	    // if step size is explicitly given, use that
	    step = opt.step;
	  } else if (opt.steps) {
	    // if provided, limit choice to acceptable step sizes
	    step = opt.steps[Math.min(
	      opt.steps.length - 1,
	      bisect(opt.steps, span/maxb, 0, opt.steps.length)
	    )];
	  } else {
	    // else use span to determine step size
	    level = Math.ceil(Math.log(maxb) / logb);
	    minstep = opt.minstep || 0;
	    step = Math.max(
	      minstep,
	      Math.pow(base, Math.round(Math.log(span) / logb) - level)
	    );
	
	    // increase step size if too many bins
	    while (Math.ceil(span/step) > maxb) { step *= base; }
	
	    // decrease step size if allowed
	    for (i=0; i<div.length; ++i) {
	      v = step / div[i];
	      if (v >= minstep && span / v <= maxb) step = v;
	    }
	  }
	
	  // update precision, min and max
	  v = Math.log(step);
	  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;
	  eps = Math.pow(base, -precision - 1);
	  min = Math.min(min, Math.floor(min / step + eps) * step);
	  max = Math.ceil(max / step) * step;
	
	  return {
	    start: min,
	    stop:  max,
	    step:  step,
	    unit:  {precision: precision},
	    value: value,
	    index: index
	  };
	}
	
	function bisect(a, x, lo, hi) {
	  while (lo < hi) {
	    var mid = lo + hi >>> 1;
	    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }
	    else { hi = mid; }
	  }
	  return lo;
	}
	
	function value(v) {
	  return this.step * Math.floor(v / this.step + EPSILON);
	}
	
	function index(v) {
	  return Math.floor((v - this.start) / this.step + EPSILON);
	}
	
	function date_value(v) {
	  return this.unit.date(value.call(this, v));
	}
	
	function date_index(v) {
	  return index.call(this, this.unit.unit(v));
	}
	
	bins.date = function(opt) {
	  if (!opt) { throw Error("Missing date binning options."); }
	
	  // find time step, then bin
	  var units = opt.utc ? time.utc : time,
	      dmin = opt.min,
	      dmax = opt.max,
	      maxb = opt.maxbins || 20,
	      minb = opt.minbins || 4,
	      span = (+dmax) - (+dmin),
	      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),
	      spec = bins({
	        min:     unit.min != null ? unit.min : unit.unit(dmin),
	        max:     unit.max != null ? unit.max : unit.unit(dmax),
	        maxbins: maxb,
	        minstep: unit.minstep,
	        steps:   unit.step
	      });
	
	  spec.unit = unit;
	  spec.index = date_index;
	  if (!opt.raw) spec.value = date_value;
	  return spec;
	};
	
	module.exports = bins;
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/bins/bins.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/time.js **/
jupyter.define('datalib@1.7.2/src/time.js', function (module, exports, __jupyter_require__) {
	var d3_time = __jupyter_require__('d3-time@0.1/build/d3-time.js');
	
	var tempDate = new Date(),
	    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD
	    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);
	
	function date(d) {
	  return (tempDate.setTime(+d), tempDate);
	}
	
	// create a time unit entry
	function entry(type, date, unit, step, min, max) {
	  var e = {
	    type: type,
	    date: date,
	    unit: unit
	  };
	  if (step) {
	    e.step = step;
	  } else {
	    e.minstep = 1;
	  }
	  if (min != null) e.min = min;
	  if (max != null) e.max = max;
	  return e;
	}
	
	function create(type, unit, base, step, min, max) {
	  return entry(type,
	    function(d) { return unit.offset(base, d); },
	    function(d) { return unit.count(base, d); },
	    step, min, max);
	}
	
	var locale = [
	  create('second', d3_time.second, baseDate),
	  create('minute', d3_time.minute, baseDate),
	  create('hour',   d3_time.hour,   baseDate),
	  create('day',    d3_time.day,    baseDate, [1, 7]),
	  create('month',  d3_time.month,  baseDate, [1, 3, 6]),
	  create('year',   d3_time.year,   baseDate),
	
	  // periodic units
	  entry('seconds',
	    function(d) { return new Date(1970, 0, 1, 0, 0, d); },
	    function(d) { return date(d).getSeconds(); },
	    null, 0, 59
	  ),
	  entry('minutes',
	    function(d) { return new Date(1970, 0, 1, 0, d); },
	    function(d) { return date(d).getMinutes(); },
	    null, 0, 59
	  ),
	  entry('hours',
	    function(d) { return new Date(1970, 0, 1, d); },
	    function(d) { return date(d).getHours(); },
	    null, 0, 23
	  ),
	  entry('weekdays',
	    function(d) { return new Date(1970, 0, 4+d); },
	    function(d) { return date(d).getDay(); },
	    [1], 0, 6
	  ),
	  entry('dates',
	    function(d) { return new Date(1970, 0, d); },
	    function(d) { return date(d).getDate(); },
	    [1], 1, 31
	  ),
	  entry('months',
	    function(d) { return new Date(1970, d % 12, 1); },
	    function(d) { return date(d).getMonth(); },
	    [1], 0, 11
	  )
	];
	
	var utc = [
	  create('second', d3_time.utcSecond, utcBaseDate),
	  create('minute', d3_time.utcMinute, utcBaseDate),
	  create('hour',   d3_time.utcHour,   utcBaseDate),
	  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),
	  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),
	  create('year',   d3_time.utcYear,   utcBaseDate),
	
	  // periodic units
	  entry('seconds',
	    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },
	    function(d) { return date(d).getUTCSeconds(); },
	    null, 0, 59
	  ),
	  entry('minutes',
	    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },
	    function(d) { return date(d).getUTCMinutes(); },
	    null, 0, 59
	  ),
	  entry('hours',
	    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },
	    function(d) { return date(d).getUTCHours(); },
	    null, 0, 23
	  ),
	  entry('weekdays',
	    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },
	    function(d) { return date(d).getUTCDay(); },
	    [1], 0, 6
	  ),
	  entry('dates',
	    function(d) { return new Date(Date.UTC(1970, 0, d)); },
	    function(d) { return date(d).getUTCDate(); },
	    [1], 1, 31
	  ),
	  entry('months',
	    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },
	    function(d) { return date(d).getUTCMonth(); },
	    [1], 0, 11
	  )
	];
	
	var STEPS = [
	  [31536e6, 5],  // 1-year
	  [7776e6, 4],   // 3-month
	  [2592e6, 4],   // 1-month
	  [12096e5, 3],  // 2-week
	  [6048e5, 3],   // 1-week
	  [1728e5, 3],   // 2-day
	  [864e5, 3],    // 1-day
	  [432e5, 2],    // 12-hour
	  [216e5, 2],    // 6-hour
	  [108e5, 2],    // 3-hour
	  [36e5, 2],     // 1-hour
	  [18e5, 1],     // 30-minute
	  [9e5, 1],      // 15-minute
	  [3e5, 1],      // 5-minute
	  [6e4, 1],      // 1-minute
	  [3e4, 0],      // 30-second
	  [15e3, 0],     // 15-second
	  [5e3, 0],      // 5-second
	  [1e3, 0]       // 1-second
	];
	
	function find(units, span, minb, maxb) {
	  var step = STEPS[0], i, n, bins;
	
	  for (i=1, n=STEPS.length; i<n; ++i) {
	    step = STEPS[i];
	    if (span > step[0]) {
	      bins = span / step[0];
	      if (bins > maxb) {
	        return units[STEPS[i-1][1]];
	      }
	      if (bins >= minb) {
	        return units[step[1]];
	      }
	    }
	  }
	  return units[STEPS[n-1][1]];
	}
	
	function toUnitMap(units) {
	  var map = {}, i, n;
	  for (i=0, n=units.length; i<n; ++i) {
	    map[units[i].type] = units[i];
	  }
	  map.find = function(span, minb, maxb) {
	    return find(units, span, minb, maxb);
	  };
	  return map;
	}
	
	module.exports = toUnitMap(locale);
	module.exports.utc = toUnitMap(utc);
})
/** END DEFINE BLOCK for datalib@1.7.2/src/time.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/bins/histogram.js **/
jupyter.define('datalib@1.7.2/src/bins/histogram.js', function (module, exports, __jupyter_require__) {
	var bins = __jupyter_require__('datalib@~1.7.2/src/bins/bins.js'),
	    gen  = __jupyter_require__('datalib@~1.7.2/src/generate.js'),
	    type = __jupyter_require__('datalib@~1.7.2/src/import/type.js'),
	    util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    stats = __jupyter_require__('datalib@~1.7.2/src/stats.js');
	
	var qtype = {
	  'integer': 1,
	  'number': 1,
	  'date': 1
	};
	
	function $bin(values, f, opt) {
	  opt = options(values, f, opt);
	  var b = spec(opt);
	  return !b ? (opt.accessor || util.identity) :
	    util.$func('bin', b.unit.unit ?
	      function(x) { return b.value(b.unit.unit(x)); } :
	      function(x) { return b.value(x); }
	    )(opt.accessor);
	}
	
	function histogram(values, f, opt) {
	  opt = options(values, f, opt);
	  var b = spec(opt);
	  return b ?
	    numerical(values, opt.accessor, b) :
	    categorical(values, opt.accessor, opt && opt.sort);
	}
	
	function spec(opt) {
	  var t = opt.type, b = null;
	  if (t == null || qtype[t]) {
	    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;
	    b = (t === 'date') ? bins.date(opt) : bins(opt);
	  }
	  return b;
	}
	
	function options() {
	  var a = arguments,
	      i = 0,
	      values = util.isArray(a[i]) ? a[i++] : null,
	      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,
	      opt = util.extend({}, a[i]);
	
	  if (values) {
	    opt.type = opt.type || type(values, f);
	    if (qtype[opt.type]) {
	      var ext = stats.extent(values, f);
	      opt = util.extend({min: ext[0], max: ext[1]}, opt);
	    }
	  }
	  if (f) { opt.accessor = f; }
	  return opt;
	}
	
	function numerical(values, f, b) {
	  var h = gen.range(b.start, b.stop + b.step/2, b.step)
	    .map(function(v) { return {value: b.value(v), count: 0}; });
	
	  for (var i=0, v, j; i<values.length; ++i) {
	    v = f ? f(values[i]) : values[i];
	    if (util.isValid(v)) {
	      j = b.index(v);
	      if (j < 0 || j >= h.length || !isFinite(j)) continue;
	      h[j].count += 1;
	    }
	  }
	  h.bins = b;
	  return h;
	}
	
	function categorical(values, f, sort) {
	  var u = stats.unique(values, f),
	      c = stats.count.map(values, f);
	  return u.map(function(k) { return {value: k, count: c[k]}; })
	    .sort(util.comparator(sort ? '-count' : '+value'));
	}
	
	module.exports = {
	  $bin: $bin,
	  histogram: histogram
	};
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/bins/histogram.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/template.js **/
jupyter.define('datalib@1.7.2/src/template.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    format = __jupyter_require__('datalib@~1.7.2/src/format.js');
	
	var context = {
	  formats:    [],
	  format_map: {},
	  truncate:   util.truncate,
	  pad:        util.pad,
	  day:        format.day,
	  month:      format.month,
	  quarter:    format.quarter,
	  utcQuarter: format.utcQuarter
	};
	
	function template(text) {
	  var src = source(text, 'd');
	  src = 'var __t; return ' + src + ';';
	
	  /* jshint evil: true */
	  return (new Function('d', src)).bind(context);
	}
	
	template.source = source;
	template.context = context;
	template.format = get_format;
	module.exports = template;
	
	// Clear cache of format objects.
	// This can *break* prior template functions, so invoke with care!
	template.clearFormatCache = function() {
	  context.formats = [];
	  context.format_map = {};
	};
	
	// Generate property access code for use within template source.
	// object: the name of the object (variable) containing template data
	// property: the property access string, verbatim from template tag
	template.property = function(object, property) {
	  var src = util.field(property).map(util.str).join('][');
	  return object + '[' + src + ']';
	};
	
	// Generate source code for a template function.
	// text: the template text
	// variable: the name of the data object variable ('obj' by default)
	// properties: optional hash for collecting all accessed properties
	function source(text, variable, properties) {
	  variable = variable || 'obj';
	  var index = 0;
	  var src = '\'';
	  var regex = template_re;
	
	  // Compile the template source, escaping string literals appropriately.
	  text.replace(regex, function(match, interpolate, offset) {
	    src += text
	      .slice(index, offset)
	      .replace(template_escaper, template_escapeChar);
	    index = offset + match.length;
	
	    if (interpolate) {
	      src += '\'\n+((__t=(' +
	        template_var(interpolate, variable, properties) +
	        '))==null?\'\':__t)+\n\'';
	    }
	
	    // Adobe VMs need the match returned to produce the correct offest.
	    return match;
	  });
	  return src + '\'';
	}
	
	function template_var(text, variable, properties) {
	  var filters = text.match(filter_re);
	  var prop = filters.shift().trim();
	  var stringCast = true;
	
	  function strcall(fn) {
	    fn = fn || '';
	    if (stringCast) {
	      stringCast = false;
	      src = 'String(' + src + ')' + fn;
	    } else {
	      src += fn;
	    }
	    return src;
	  }
	
	  function date() {
	    return '(typeof ' + src + '==="number"?new Date('+src+'):'+src+')';
	  }
	
	  function formatter(type) {
	    var pattern = args[0];
	    if ((pattern[0] === '\'' && pattern[pattern.length-1] === '\'') ||
	        (pattern[0] === '"'  && pattern[pattern.length-1] === '"')) {
	      pattern = pattern.slice(1, -1);
	    } else {
	      throw Error('Format pattern must be quoted: ' + pattern);
	    }
	    a = template_format(pattern, type);
	    stringCast = false;
	    var arg = type === 'number' ? src : date();
	    src = 'this.formats['+a+']('+arg+')';
	  }
	
	  if (properties) properties[prop] = 1;
	  var src = template.property(variable, prop);
	
	  for (var i=0; i<filters.length; ++i) {
	    var f = filters[i], args = null, pidx, a, b;
	
	    if ((pidx=f.indexOf(':')) > 0) {
	      f = f.slice(0, pidx);
	      args = filters[i].slice(pidx+1)
	        .match(args_re)
	        .map(function(s) { return s.trim(); });
	    }
	    f = f.trim();
	
	    switch (f) {
	      case 'length':
	        strcall('.length');
	        break;
	      case 'lower':
	        strcall('.toLowerCase()');
	        break;
	      case 'upper':
	        strcall('.toUpperCase()');
	        break;
	      case 'lower-locale':
	        strcall('.toLocaleLowerCase()');
	        break;
	      case 'upper-locale':
	        strcall('.toLocaleUpperCase()');
	        break;
	      case 'trim':
	        strcall('.trim()');
	        break;
	      case 'left':
	        a = util.number(args[0]);
	        strcall('.slice(0,' + a + ')');
	        break;
	      case 'right':
	        a = util.number(args[0]);
	        strcall('.slice(-' + a +')');
	        break;
	      case 'mid':
	        a = util.number(args[0]);
	        b = a + util.number(args[1]);
	        strcall('.slice(+'+a+','+b+')');
	        break;
	      case 'slice':
	        a = util.number(args[0]);
	        strcall('.slice('+ a +
	          (args.length > 1 ? ',' + util.number(args[1]) : '') +
	          ')');
	        break;
	      case 'truncate':
	        a = util.number(args[0]);
	        b = args[1];
	        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
	        src = 'this.truncate(' + strcall() + ',' + a + ',\'' + b + '\')';
	        break;
	      case 'pad':
	        a = util.number(args[0]);
	        b = args[1];
	        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
	        src = 'this.pad(' + strcall() + ',' + a + ',\'' + b + '\')';
	        break;
	      case 'number':
	        formatter('number');
	        break;
	      case 'time':
	        formatter('time');
	        break;
	      case 'time-utc':
	        formatter('utc');
	        break;
	      case 'month':
	        src = 'this.month(' + src + ')';
	        break;
	      case 'month-abbrev':
	        src = 'this.month(' + src + ',true)';
	        break;
	      case 'day':
	        src = 'this.day(' + src + ')';
	        break;
	      case 'day-abbrev':
	        src = 'this.day(' + src + ',true)';
	        break;
	      case 'quarter':
	        src = 'this.quarter(' + src + ')';
	        break;
	      case 'quarter-utc':
	        src = 'this.utcQuarter(' + src + ')';
	        break;
	      default:
	        throw Error('Unrecognized template filter: ' + f);
	    }
	  }
	
	  return src;
	}
	
	var template_re = /\{\{(.+?)\}\}|$/g,
	    filter_re = /(?:"[^"]*"|\'[^\']*\'|[^\|"]+|[^\|\']+)+/g,
	    args_re = /(?:"[^"]*"|\'[^\']*\'|[^,"]+|[^,\']+)+/g;
	
	// Certain characters need to be escaped so that they can be put into a
	// string literal.
	var template_escapes = {
	  '\'':     '\'',
	  '\\':     '\\',
	  '\r':     'r',
	  '\n':     'n',
	  '\u2028': 'u2028',
	  '\u2029': 'u2029'
	};
	
	var template_escaper = /\\|'|\r|\n|\u2028|\u2029/g;
	
	function template_escapeChar(match) {
	  return '\\' + template_escapes[match];
	}
	
	function template_format(pattern, type) {
	  var key = type + ':' + pattern;
	  if (context.format_map[key] == null) {
	    var f = format[type](pattern);
	    var i = context.formats.length;
	    context.formats.push(f);
	    context.format_map[key] = i;
	    return i;
	  }
	  return context.format_map[key];
	}
	
	function get_format(pattern, type) {
	  return context.formats[template_format(pattern, type)];
	}
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/template.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/accessor.js **/
jupyter.define('datalib@1.7.2/src/accessor.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    time = __jupyter_require__('datalib@~1.7.2/src/time.js'),
	    utc = time.utc;
	
	var u = module.exports;
	
	u.$year   = util.$func('year', time.year.unit);
	u.$month  = util.$func('month', time.months.unit);
	u.$date   = util.$func('date', time.dates.unit);
	u.$day    = util.$func('day', time.weekdays.unit);
	u.$hour   = util.$func('hour', time.hours.unit);
	u.$minute = util.$func('minute', time.minutes.unit);
	u.$second = util.$func('second', time.seconds.unit);
	
	u.$utcYear   = util.$func('utcYear', utc.year.unit);
	u.$utcMonth  = util.$func('utcMonth', utc.months.unit);
	u.$utcDate   = util.$func('utcDate', utc.dates.unit);
	u.$utcDay    = util.$func('utcDay', utc.weekdays.unit);
	u.$utcHour   = util.$func('utcHour', utc.hours.unit);
	u.$utcMinute = util.$func('utcMinute', utc.minutes.unit);
	u.$utcSecond = util.$func('utcSecond', utc.seconds.unit);
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/accessor.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/import/readers.js **/
jupyter.define('datalib@1.7.2/src/import/readers.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js');
	var load = __jupyter_require__('datalib@~1.7.2/src/import/load.js');
	var read = __jupyter_require__('datalib@~1.7.2/src/import/read.js');
	
	module.exports = util
	  .keys(read.formats)
	  .reduce(function(out, type) {
	    out[type] = function(opt, format, callback) {
	      // process arguments
	      if (util.isString(opt)) { opt = {url: opt}; }
	      if (arguments.length === 2 && util.isFunction(format)) {
	        callback = format;
	        format = undefined;
	      }
	
	      // set up read format
	      format = util.extend({parse: 'auto'}, format);
	      format.type = type;
	
	      // load data
	      var data = load(opt, callback ? function(error, data) {
	        if (error) { callback(error, null); return; }
	        try {
	          // data loaded, now parse it (async)
	          data = read(data, format);
	          callback(null, data);
	        } catch (e) {
	          callback(e, null);
	        }
	      } : undefined);
	
	      // data loaded, now parse it (sync)
	      if (!callback) return read(data, format);
	    };
	    return out;
	  }, {});
	
})
/** END DEFINE BLOCK for datalib@1.7.2/src/import/readers.js **/


/** START DEFINE BLOCK for datalib@1.7.2/src/format-tables.js **/
jupyter.define('datalib@1.7.2/src/format-tables.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('datalib@~1.7.0/src/util.js'),
	    type = __jupyter_require__('datalib@~1.7.2/src/import/type.js'),
	    stats = __jupyter_require__('datalib@~1.7.2/src/stats.js'),
	    template = __jupyter_require__('datalib@~1.7.2/src/template.js');
	
	module.exports = {
	  table:   formatTable,  // format a data table
	  summary: formatSummary // format a data table summary
	};
	
	var FMT = {
	  'date':    '|time:"%m/%d/%Y %H:%M:%S"',
	  'number':  '|number:".4f"',
	  'integer': '|number:"d"'
	};
	
	var POS = {
	  'number':  'left',
	  'integer': 'left'
	};
	
	function formatTable(data, opt) {
	  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);
	  var fields = opt.fields || util.keys(data[0]),
	      types = type.all(data);
	
	  if (opt.start || opt.limit) {
	    var a = opt.start || 0,
	        b = opt.limit ? a + opt.limit : data.length;
	    data = data.slice(a, b);
	  }
	
	  // determine char width of fields
	  var lens = fields.map(function(name) {
	    var format = FMT[types[name]] || '',
	        t = template('{{' + name + format + '}}'),
	        l = stats.max(data, function(x) { return t(x).length; });
	    l = Math.max(Math.min(name.length, opt.minwidth), l);
	    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;
	  });
	
	  // print header row
	  var head = fields.map(function(name, i) {
	    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);
	  }).join(opt.separator);
	
	  // build template function for each row
	  var tmpl = template(fields.map(function(name, i) {
	    return '{{' +
	      name +
	      (FMT[types[name]] || '') +
	      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +
	      ('|truncate:' + lens[i]) +
	    '}}';
	  }).join(opt.separator));
	
	  // print table
	  return head + "\n" + data.map(tmpl).join('\n');
	}
	
	function formatSummary(s) {
	  s = s ? s.__summary__ ? s : stats.summary(s) : this;
	  var str = [], i, n;
	  for (i=0, n=s.length; i<n; ++i) {
	    str.push('-- ' + s[i].field + ' --');
	    if (s[i].type === 'string' || s[i].distinct < 10) {
	      str.push(printCategoricalProfile(s[i]));
	    } else {
	      str.push(printQuantitativeProfile(s[i]));
	    }
	    str.push('');
	  }
	  return str.join('\n');
	}
	
	function printQuantitativeProfile(p) {
	  return [
	    'valid:    ' + p.valid,
	    'missing:  ' + p.missing,
	    'distinct: ' + p.distinct,
	    'min:      ' + p.min,
	    'max:      ' + p.max,
	    'median:   ' + p.median,
	    'mean:     ' + p.mean,
	    'stdev:    ' + p.stdev,
	    'modeskew: ' + p.modeskew
	  ].join('\n');
	}
	
	function printCategoricalProfile(p) {
	  var list = [
	    'valid:    ' + p.valid,
	    'missing:  ' + p.missing,
	    'distinct: ' + p.distinct,
	    'top values: '
	  ];
	  var u = p.unique;
	  var top = util.keys(u)
	    .sort(function(a,b) { return u[b] - u[a]; })
	    .slice(0, 6)
	    .map(function(v) { return ' \'' + v + '\' (' + u[v] + ')'; });
	  return list.concat(top).join('\n');
	}
})
/** END DEFINE BLOCK for datalib@1.7.2/src/format-tables.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/Graph.js **/
jupyter.define('vega-dataflow@1.4.3/src/Graph.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Heap = __jupyter_require__('vega-dataflow@~1.4.3/src/Heap.js'),
	    ChangeSet = __jupyter_require__('vega-dataflow@~1.4.3/src/ChangeSet.js'),
	    DataSource = __jupyter_require__('vega-dataflow@~1.4.3/src/DataSource.js'),
	    Collector = __jupyter_require__('vega-dataflow@~1.4.3/src/Collector.js'),
	    Tuple = __jupyter_require__('vega-dataflow@~1.4.3/src/Tuple.js'),
	    Signal = __jupyter_require__('vega-dataflow@~1.4.3/src/Signal.js'),
	    Deps = __jupyter_require__('vega-dataflow@~1.4.3/src/Dependencies.js');
	
	function Graph() {
	}
	
	var prototype = Graph.prototype;
	
	prototype.init = function() {
	  this._stamp = 0;
	  this._rank  = 0;
	
	  this._data = {};
	  this._signals = {};
	  this._requestedIndexes = {};
	
	  this.doNotPropagate = {};
	};
	
	prototype.rank = function() {
	  return ++this._rank;
	};
	
	prototype.values = function(type, names, hash) {
	  var data = (type === Deps.SIGNALS ? this._signals : this._data),
	      n = (names !== undefined ? names : dl.keys(data)),
	      vals, i;
	
	  if (Array.isArray(n)) {
	    vals = hash || {};
	    for (i=0; i<n.length; ++i) {
	      vals[n[i]] = data[n[i]].values();
	    }
	    return vals;
	  } else {
	    return data[n].values();
	  }
	};
	
	// Retain for backwards-compatibility
	prototype.dataValues = function(names) {
	  return this.values(Deps.DATA, names);
	};
	
	// Retain for backwards-compatibility
	prototype.signalValues = function(names) {
	  return this.values(Deps.SIGNALS, names);
	};
	
	prototype.data = function(name, pipeline, facet) {
	  var db = this._data;
	  if (!arguments.length) {
	    var all = [], key;
	    for (key in db) { all.push(db[key]); }
	    return all;
	  } else if (arguments.length === 1) {
	    return db[name];
	  } else {
	    return (db[name] = new DataSource(this, name, facet).pipeline(pipeline));
	  }
	};
	
	prototype.signal = function(name, init) {
	  if (arguments.length === 1) {
	    var m = this;
	    return Array.isArray(name) ?
	      name.map(function(n) { return m._signals[n]; }) :
	      this._signals[name];
	  } else {
	    return (this._signals[name] = new Signal(this, name, init));
	  }
	};
	
	prototype.signalRef = function(ref) {
	  if (!Array.isArray(ref)) {
	    ref = dl.field(ref);
	  }
	
	  var value = this.signal(ref[0]).value();
	  if (ref.length > 1) {
	    for (var i=1, n=ref.length; i<n; ++i) {
	      value = value[ref[i]];
	    }
	  }
	  return value;
	};
	
	prototype.requestIndex = function(data, field) {
	  var ri  = this._requestedIndexes,
	      reg = ri[data] || (ri[data] = {}); 
	  return (reg[field] = true, this);
	};
	
	prototype.buildIndexes = function() {
	  var ri = this._requestedIndexes,
	      data = dl.keys(ri),
	      i, len, j, jlen, d, src, fields, f;
	
	  for (i=0, len=data.length; i<len; ++i) {
	    src = this.data(d=data[i]);
	    if (!src) throw Error('Data source '+dl.str(d)+' does not exist.');
	
	    fields = dl.keys(ri[d]);
	    for (j=0, jlen=fields.length; j<jlen; ++j) {
	      if ((f=fields[j]) === null) continue;
	      src.getIndex(f);
	      ri[d][f] = null;
	    }
	  }
	
	  return this;
	};
	
	// Stamp should be specified with caution. It is necessary for inline datasources,
	// which need to be populated during the same cycle even though propagation has
	// passed that part of the dataflow graph. 
	// If skipSignals is true, Signal nodes do not get reevaluated but their listeners
	// are queued for propagation. This is useful when setting signal values in batch
	// (e.g., time travel to the initial state).
	prototype.propagate = function(pulse, node, stamp, skipSignals) {
	  var pulses = {},
	      listeners, next, nplse, tpls, ntpls, i, len, isSg;
	
	  // new PQ with each propagation cycle so that we can pulse branches
	  // of the dataflow graph during a propagation (e.g., when creating
	  // a new inline datasource).
	  var pq = new Heap(function(a, b) {
	    // Sort on qrank (queue-rank).
	    // Rank can change during propagation due to rewiring.
	    return a._qrank - b._qrank;
	  });
	
	  if (pulse.stamp) throw Error('Pulse already has a non-zero stamp.');
	
	  pulse.stamp = stamp || ++this._stamp;
	  pulses[node._id] = pulse;
	  pq.push(node.qrank(true));
	
	  while (pq.size() > 0) {
	    node  = pq.peek();
	    isSg  = node instanceof Signal;
	    pulse = pulses[node._id];
	
	    if (node.rank() !== node.qrank()) {
	      // A node's rank might change during a propagation. Re-queue if so.
	      pq.replace(node.qrank(true));
	    } else {
	      // Evaluate node and propagate pulse.
	      pq.pop();
	      pulses[node._id] = null;
	      listeners = node._listeners;
	
	      if (!isSg || (isSg && !skipSignals)) {
	        pulse = this.evaluate(pulse, node);
	      }
	
	      // Propagate the pulse.
	      if (pulse !== this.doNotPropagate) {
	        // Ensure reflow pulses always send reflow pulses even if skipped.
	        if (!pulse.reflow && node.reflows()) {
	          pulse = ChangeSet.create(pulse, true);
	        }
	
	        for (i=0, len=listeners.length; i<len; ++i) {
	          next = listeners[i];
	
	          if ((nplse = pulses[next._id]) !== undefined) {
	            if (nplse === null) throw Error('Already propagated to node.');
	            if (nplse === pulse) continue;  // Re-queueing the same pulse.
	
	            // We've already queued this node. Ensure there should be at most one
	            // pulse with tuples (add/mod/rem), and the remainder will be reflows.
	            tpls  = pulse.add.length || pulse.mod.length || pulse.rem.length;
	            ntpls = nplse.add.length || nplse.mod.length || nplse.rem.length;
	
	            if (tpls && ntpls) throw Error('Multiple changeset pulses to same node');
	
	            // Combine reflow and tuples into a single pulse.
	            pulses[next._id] = tpls ? pulse : nplse;
	            pulses[next._id].reflow = pulse.reflow || nplse.reflow;
	          } else {
	            // First time we're seeing this node, queue it for propagation.
	            pq.push(next.qrank(true));
	            pulses[next._id] = pulse;
	          }
	        }
	      }
	    }
	  }
	
	  return this.done(pulse);
	};
	
	// Perform final bookkeeping on the graph, after propagation is complete.
	//  - For all updated datasources, synchronize their previous values.
	prototype.done = function(pulse) {
	  log.debug(pulse, ['bookkeeping']);
	  for (var d in pulse.data) { this.data(d).synchronize(); }
	  return this;
	};
	
	// Process a new branch of the dataflow graph prior to connection:
	// (1) Insert new Collector nodes as needed.
	// (2) Track + return mutation/routing status of the branch.
	prototype.preprocess = function(branch) {
	  var graph = this,
	      mutates = 0,
	      node, router, collector, collects;
	
	  for (var i=0; i<branch.length; ++i) {
	    node = branch[i];
	
	    // Batch nodes need access to a materialized dataset.
	    if (node.batch() && !node._collector) {
	      if (router || !collector) {
	        node = new Collector(graph);
	        branch.splice(i, 0, node);
	        router = false;
	      } else {
	        node._collector = collector;
	      }
	    }
	
	    if ((collects = node.collector())) collector = node;
	    router  = router  || node.router() && !collects;
	    mutates = mutates || node.mutates();
	
	    // A collector needs to be inserted after tuple-producing
	    // nodes for correct previous value tracking.
	    if (node.produces()) {
	      branch.splice(i+1, 0, new Collector(graph));
	      router = false;
	    }
	  }
	
	  return {router: router, collector: collector, mutates: mutates};
	};
	
	prototype.connect = function(branch) {
	  var collector, node, data, signals, i, n, j, m, x, y;
	
	  // connect the pipeline
	  for (i=0, n=branch.length; i<n; ++i) {
	    node = branch[i];
	    if (node.collector()) collector = node;
	
	    data = node.dependency(Deps.DATA);
	    for (j=0, m=data.length; j<m; ++j) {
	      if (!(x=this.data(y=data[j]))) {
	        throw new Error('Unknown data source ' + dl.str(y));
	      }
	
	      x.addListener(collector);
	    }
	
	    signals = node.dependency(Deps.SIGNALS);
	    for (j=0, m=signals.length; j<m; ++j) {
	      if (!(x=this.signal(y=signals[j]))) {
	        throw new Error('Unknown signal ' + dl.str(y));
	      }
	
	      x.addListener(collector);
	    }
	
	    if (i > 0) branch[i-1].addListener(node);
	  }
	
	  return branch;
	};
	
	prototype.disconnect = function(branch) {
	  var collector, node, data, signals, i, n, j, m;
	
	  for (i=0, n=branch.length; i<n; ++i) {
	    node = branch[i];
	    if (node.collector()) collector = node;
	
	    data = node.dependency(Deps.DATA);
	    for (j=0, m=data.length; j<m; ++j) {
	      this.data(data[j]).removeListener(collector);
	    }
	
	    signals = node.dependency(Deps.SIGNALS);
	    for (j=0, m=signals.length; j<m; ++j) {
	      this.signal(signals[j]).removeListener(collector);
	    }
	
	    node.disconnect();
	  }
	
	  return branch;
	};
	
	prototype.synchronize = function(branch) {
	  var ids = {},
	      node, data, i, n, j, m, d, id;
	
	  for (i=0, n=branch.length; i<n; ++i) {
	    node = branch[i];
	    if (!node.collector()) continue;
	
	    for (j=0, data=node.data(), m=data.length; j<m; ++j) {
	      id = (d = data[j])._id;
	      if (ids[id]) continue;
	      Tuple.prev_update(d);
	      ids[id] = 1;
	    }
	  }
	
	  return this;
	};
	
	prototype.reevaluate = function(pulse, node) {
	  var reflowed = pulse.reflow && node.last() >= pulse.stamp,
	      run = node.router() || pulse.add.length || pulse.rem.length;
	
	  return run || !reflowed || node.reevaluate(pulse);
	};
	
	prototype.evaluate = function(pulse, node) {
	  if (!this.reevaluate(pulse, node)) return pulse;
	  pulse = node.evaluate(pulse);
	  node.last(pulse.stamp);
	  return pulse;
	};
	
	module.exports = Graph;
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/Graph.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/Heap.js **/
jupyter.define('vega-dataflow@1.4.3/src/Heap.js', function (module, exports, __jupyter_require__) {
	function Heap(comparator) {
	  this.cmp = comparator;
	  this.nodes = [];
	}
	
	var prototype = Heap.prototype;
	
	prototype.size = function() {
	  return this.nodes.length;
	};
	
	prototype.clear = function() {
	  return (this.nodes = [], this);
	};
	
	prototype.peek = function() {
	  return this.nodes[0];
	};
	
	prototype.push = function(x) {
	  var array = this.nodes;
	  array.push(x);
	  return _siftdown(array, 0, array.length-1, this.cmp);
	};
	
	prototype.pop = function() {
	  var array = this.nodes,
	      last = array.pop(),
	      item;
	
	  if (array.length) {
	    item = array[0];
	    array[0] = last;
	    _siftup(array, 0, this.cmp);
	  } else {
	    item = last;
	  }
	  return item;
	};
	
	prototype.replace = function(item) {
	  var array = this.nodes,
	      retval = array[0];
	  array[0] = item;
	  _siftup(array, 0, this.cmp);
	  return retval;
	};
	
	prototype.pushpop = function(item) {
	  var array = this.nodes, ref = array[0];
	  if (array.length && this.cmp(ref, item) < 0) {
	    array[0] = item;
	    item = ref;
	    _siftup(array, 0, this.cmp);
	  }
	  return item;
	};
	
	function _siftdown(array, start, idx, cmp) {
	  var item, parent, pidx;
	
	  item = array[idx];
	  while (idx > start) {
	    pidx = (idx - 1) >> 1;
	    parent = array[pidx];
	    if (cmp(item, parent) < 0) {
	      array[idx] = parent;
	      idx = pidx;
	      continue;
	    }
	    break;
	  }
	  return (array[idx] = item);
	}
	
	function _siftup(array, idx, cmp) {
	  var start = idx,
	      end = array.length,
	      item = array[idx],
	      cidx = 2 * idx + 1, ridx;
	
	  while (cidx < end) {
	    ridx = cidx + 1;
	    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {
	      cidx = ridx;
	    }
	    array[idx] = array[cidx];
	    idx = cidx;
	    cidx = 2 * idx + 1;
	  }
	  array[idx] = item;
	  return _siftdown(array, start, idx, cmp);
	}
	
	module.exports = Heap;
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/Heap.js **/


/** START DEFINE BLOCK for vega-dataflow@1.4.3/src/Signal.js **/
jupyter.define('vega-dataflow@1.4.3/src/Signal.js', function (module, exports, __jupyter_require__) {
	var ChangeSet = __jupyter_require__('vega-dataflow@~1.4.3/src/ChangeSet.js'),
	    Node = __jupyter_require__('vega-dataflow@~1.4.3/src/Node.js'), // jshint ignore:line
	    Base = Node.prototype;
	
	function Signal(graph, name, initialValue) {
	  Base.init.call(this, graph);
	  this._name  = name;
	  this._value = initialValue;
	  this._verbose = false; // Verbose signals re-pulse the graph even if prev === val.
	  this._handlers = [];
	  return this;
	}
	
	var prototype = (Signal.prototype = Object.create(Base));
	prototype.constructor = Signal;
	
	prototype.name = function() {
	  return this._name;
	};
	
	prototype.value = function(val) {
	  if (!arguments.length) return this._value;
	  return (this._value = val, this);
	};
	
	// Alias to value, for shared API with DataSource
	prototype.values = prototype.value;
	
	prototype.verbose = function(v) {
	  if (!arguments.length) return this._verbose;
	  return (this._verbose = !!v, this);
	};
	
	prototype.evaluate = function(input) {
	  return input.signals[this._name] ? input : this._graph.doNotPropagate;
	};
	
	prototype.fire = function(cs) {
	  if (!cs) cs = ChangeSet.create(null, true);
	  cs.signals[this._name] = 1;
	  this._graph.propagate(cs, this);
	};
	
	prototype.on = function(handler) {
	  var signal = this,
	      node = new Node(this._graph);
	
	  node.evaluate = function(input) {
	    handler(signal.name(), signal.value());
	    return input;
	  };
	
	  this._handlers.push({
	    handler: handler,
	    node: node
	  });
	
	  return this.addListener(node);
	};
	
	prototype.off = function(handler) {
	  var h = this._handlers, i, x;
	
	  for (i=h.length; --i>=0;) {
	    if (!handler || h[i].handler === handler) {
	      x = h.splice(i, 1)[0];
	      this.removeListener(x.node);
	    }
	  }
	
	  return this;
	};
	
	module.exports = Signal;
	
})
/** END DEFINE BLOCK for vega-dataflow@1.4.3/src/Signal.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/index.js **/
jupyter.define('vega@2.6.3/src/parse/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  axes:       __jupyter_require__('vega@~2.6.3/src/parse/axes.js'),
	  background: __jupyter_require__('vega@~2.6.3/src/parse/background.js'),
	  data:       __jupyter_require__('vega@~2.6.3/src/parse/data.js'),
	  events:     __jupyter_require__('vega-event-selector@^1.0.0/index.js'),
	  expr:       __jupyter_require__('vega@~2.6.3/src/parse/expr.js'),
	  legends:    __jupyter_require__('vega@~2.6.3/src/parse/legends.js'),
	  mark:       __jupyter_require__('vega@~2.6.3/src/parse/mark.js'),
	  marks:      __jupyter_require__('vega@~2.6.3/src/parse/marks.js'),
	  modify:     __jupyter_require__('vega@~2.6.3/src/parse/modify.js'),
	  padding:    __jupyter_require__('vega@~2.6.3/src/parse/padding.js'),
	  predicates: __jupyter_require__('vega@~2.6.3/src/parse/predicates.js'),
	  properties: __jupyter_require__('vega@~2.6.3/src/parse/properties.js'),
	  signals:    __jupyter_require__('vega@~2.6.3/src/parse/signals.js'),
	  spec:       __jupyter_require__('vega@~2.6.3/src/parse/spec.js'),
	  streams:    __jupyter_require__('vega@~2.6.3/src/parse/streams.js'),
	  transforms: __jupyter_require__('vega@~2.6.3/src/parse/transforms.js')
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/index.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/axes.js **/
jupyter.define('vega@2.6.3/src/parse/axes.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    axs = __jupyter_require__('vega@~2.6.3/src/scene/axis.js'),
	    themeVal = __jupyter_require__('vega@~2.6.3/src/util/theme-val.js');
	
	var ORIENT = {
	  "x":      "bottom",
	  "y":      "left",
	  "top":    "top",
	  "bottom": "bottom",
	  "left":   "left",
	  "right":  "right"
	};
	
	function parseAxes(model, spec, axes, group) {
	  var cfg = config(model);
	  (spec || []).forEach(function(def, index) {
	    axes[index] = axes[index] || axs(model, cfg[def.type]);
	    parseAxis(cfg[def.type], def, index, axes[index], group);
	  });
	}
	
	function parseAxis(config, def, index, axis, group) {
	  // axis scale
	  var scale;
	  if (def.scale !== undefined) {
	    axis.scale(scale = group.scale(def.scale));
	  }
	
	  // grid by scaletype
	  var grid = config.grid;
	  if (dl.isObject(grid)) {
	    config.grid = grid[scale.type] !== undefined ? grid[scale.type] : grid.default;
	  }
	
	  // axis orientation
	  axis.orient(themeVal(def, config, 'orient', ORIENT[def.type]));
	  // axis offset
	  axis.offset(themeVal(def, config, 'offset', 0));
	  // axis layer
	  axis.layer(themeVal(def, config, 'layer', 'front'));
	  // axis grid lines
	  axis.grid(themeVal(def, config, 'grid', false));
	  // axis title
	  axis.title(def.title || null);
	  // axis title offset
	  axis.titleOffset(themeVal(def, config, 'titleOffset'));
	  // axis values
	  axis.tickValues(def.values || null);
	  // axis label formatting
	  axis.tickFormat(def.format || null);
	  axis.tickFormatType(def.formatType || null);
	  // axis tick subdivision
	  axis.tickSubdivide(def.subdivide || 0);
	  // axis tick padding (config.padding for backwards compatibility).
	  axis.tickPadding(themeVal(def, config, 'tickPadding', config.padding));
	
	  // axis tick size(s)
	  var ts = themeVal(def, config, 'tickSize'),
	      size = [ts, ts, ts];
	
	  size[0] = themeVal(def, config, 'tickSizeMajor', size[0]);
	  size[1] = themeVal(def, config, 'tickSizeMinor', size[1]);
	  size[2] = themeVal(def, config, 'tickSizeEnd', size[2]);
	
	  if (size.length) {
	    axis.tickSize.apply(axis, size);
	  }
	
	  // axis tick count
	  axis.tickCount(themeVal(def, config, 'ticks'));
	
	  // style properties
	  var p = def.properties;
	  if (p && p.ticks) {
	    axis.majorTickProperties(p.majorTicks ?
	      dl.extend({}, p.ticks, p.majorTicks) : p.ticks);
	    axis.minorTickProperties(p.minorTicks ?
	      dl.extend({}, p.ticks, p.minorTicks) : p.ticks);
	  } else {
	    axis.majorTickProperties(p && p.majorTicks || {});
	    axis.minorTickProperties(p && p.minorTicks || {});
	  }
	  axis.tickLabelProperties(p && p.labels || {});
	  axis.titleProperties(p && p.title || {});
	  axis.gridLineProperties(p && p.grid || {});
	  axis.domainProperties(p && p.axis || {});
	}
	
	function config(model) {
	  var cfg  = model.config(),
	      axis = cfg.axis;
	
	  return {
	    x: dl.extend(dl.duplicate(axis), cfg.axis_x),
	    y: dl.extend(dl.duplicate(axis), cfg.axis_y)
	  };
	}
	
	module.exports = parseAxes;
	
	parseAxes.schema = {
	  "defs": {
	    "axis": {
	      "type": "object",
	      "properties": {
	        "type": {"enum": ["x", "y"]},
	        "scale": {"type": "string"},
	        "orient": {"enum": ["top", "bottom", "left", "right"]},
	        "title": {"type": "string"},
	        "titleOffset": {"type": "number"},
	        "format": {"type": "string"},
	        "formatType": {"enum": ["time", "utc", "string", "number"]},
	        "ticks": {"type": "number"},
	        "values": {
	          "type": "array",
	          "items": {"type": ["string", "number"]}
	        },
	        "subdivide": {"type": "number"},
	        "tickPadding": {"type": "number"},
	        "tickSize": {"type": "number"},
	        "tickSizeMajor": {"type": "number"},
	        "tickSizeMinor": {"type": "number"},
	        "tickSizeEnd": {"type": "number"},
	        "offset": {
	          "oneOf": [{"type": "number"}, {
	            "type": "object",
	            "properties": {
	              "scale": {"type": "string"},
	              "value": {"type": ["string", "number"]}
	            },
	            "required": ["scale", "value"],
	            "additionalProperties": false
	          }]
	        },
	        "layer": {"enum": ["front", "back"], "default": "front"},
	        "grid": {"type": "boolean"},
	        "properties": {
	          "type": "object",
	          "properties": {
	            "ticks": {"$ref": "#/defs/propset"},
	            "majorTicks": {"$ref": "#/defs/propset"},
	            "minorTicks": {"$ref": "#/defs/propset"},
	            "labels": {"$ref": "#/defs/propset"},
	            "title": {"$ref": "#/defs/propset"},
	            "grid": {"$ref": "#/defs/propset"},
	            "axis": {"$ref": "#/defs/propset"}
	          },
	          "additionalProperties": false
	        }
	      },
	      "additionalProperties": false,
	      "required": ["type", "scale"]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/axes.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/axis.js **/
jupyter.define('vega@2.6.3/src/scene/axis.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    parseMark = __jupyter_require__('vega@~2.6.3/src/parse/mark.js'),
	    util = __jupyter_require__('vega@~2.6.3/src/util/index.js');
	
	var axisBounds = new (__jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').Bounds)();
	var ORDINAL = 'ordinal';
	
	function axs(model, config) {
	  var scale,
	      orient = config.orient,
	      offset = 0,
	      titleOffset = config.titleOffset,
	      axisDef = {},
	      layer = 'front',
	      grid = false,
	      title = null,
	      tickMajorSize = config.tickSize,
	      tickMinorSize = config.tickSize,
	      tickEndSize = config.tickSize,
	      tickPadding = config.tickPadding || config.padding,
	      tickValues = null,
	      tickFormatString = null,
	      tickFormatType = null,
	      tickSubdivide = 0,
	      tickCount = config.ticks,
	      gridLineStyle = {},
	      tickLabelStyle = {},
	      majorTickStyle = {},
	      minorTickStyle = {},
	      titleStyle = {},
	      domainStyle = {},
	      m = { // Axis marks as references for updates
	        gridLines:  {},
	        majorTicks: {},
	        minorTicks: {},
	        tickLabels: {},
	        domain: {},
	        title:  {}
	      };
	
	  var axis = {};
	
	  function reset() {
	    axisDef.type = null;
	  }
	
	  function ingest(d) {
	    return {data: d};
	  }
	
	  function getTicks(format) {
	    var major = tickValues || (scale.ticks ? scale.ticks(tickCount) : scale.domain()),
	        minor = axisSubdivide(scale, major, tickSubdivide).map(ingest);
	    major = major.map(function(d) { return (d = ingest(d), d.label = format(d.data), d); });
	    return [major, minor];
	  }
	
	  axis.def = function() {
	    if (!axisDef.type) axis_def(scale);
	
	    var format = util.getTickFormat(scale, tickCount, tickFormatType, tickFormatString),
	        ticks  = getTicks(format),
	        tdata  = title ? [title].map(ingest) : [];
	
	    axisDef.marks[0].from = function() { return grid ? ticks[0] : []; };
	    axisDef.marks[1].from = function() { return ticks[0]; };
	    axisDef.marks[2].from = function() { return ticks[1]; };
	    axisDef.marks[3].from = axisDef.marks[1].from;
	    axisDef.marks[4].from = function() { return [1]; };
	    axisDef.marks[5].from = function() { return tdata; };
	    axisDef.offset = offset;
	    axisDef.orient = orient;
	    axisDef.layer = layer;
	    if (titleOffset === 'auto') titleAutoOffset(axisDef);
	
	    return axisDef;
	  };
	
	  function titleAutoOffset(axisDef) {
	    var orient = axisDef.orient,
	        update = axisDef.marks[5].properties.update,
	        fn = update.encode,
	        min = config.titleOffsetAutoMin,
	        max = config.titleOffsetAutoMax,
	        pad = config.titleOffsetAutoMargin;
	
	    // Offset axis title using bounding box of axis domain and labels
	    // Assumes other components are **encoded and bounded** beforehand
	    update.encode = function(item, group, trans, db, signals, preds) {
	      var dirty = fn.call(fn, item, group, trans, db, signals, preds),
	          field = (orient==='bottom' || orient==='top') ? 'y' : 'x';
	      if (titleStyle[field] != null) return dirty;
	
	      axisBounds.clear()
	        .union(group.items[3].bounds)
	        .union(group.items[4].bounds);
	
	      var o = trans ? {} : item,
	          method = (orient==='left' || orient==='right') ? 'width' : 'height',
	          sign = (orient==='top' || orient==='left') ? -1 : 1,
	          off = ~~(axisBounds[method]() + item.fontSize/2 + pad);
	
	      Tuple.set(o, field, sign * Math.min(Math.max(min, off), max));
	      if (trans) trans.interpolate(item, o);
	      return true;
	    };
	  }
	
	  function axis_def(scale) {
	    // setup scale mapping
	    var newScale, oldScale, range;
	    if (scale.type === ORDINAL) {
	      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};
	      oldScale = newScale;
	    } else {
	      newScale = {scale: scale.scaleName, offset: 0.5};
	      oldScale = {scale: scale.scaleName+':prev', offset: 0.5};
	    }
	    range = axisScaleRange(scale);
	
	    // setup axis marks
	    dl.extend(m.gridLines, axisTicks(config));
	    dl.extend(m.majorTicks, axisTicks(config));
	    dl.extend(m.minorTicks, axisTicks(config));
	    dl.extend(m.tickLabels, axisTickLabels(config));
	    dl.extend(m.domain, axisDomain(config));
	    dl.extend(m.title, axisTitle(config));
	    m.gridLines.properties.enter.stroke = {value: config.gridColor};
	    m.gridLines.properties.enter.strokeOpacity = {value: config.gridOpacity};
	    m.gridLines.properties.enter.strokeWidth = {value: config.gridWidth};
	    m.gridLines.properties.enter.strokeDash = {value: config.gridDash};
	
	    // extend axis marks based on axis orientation
	    axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity, scale, config, offset);
	    axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize, scale, config);
	    axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize, scale, config);
	
	    axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);
	
	    axisDomainExtend(orient, m.domain, range, tickEndSize);
	    axisTitleExtend(orient, m.title, range, +titleOffset || -1);
	
	    // add / override custom style properties
	    dl.extend(m.gridLines.properties.update, gridLineStyle);
	    dl.extend(m.majorTicks.properties.update, majorTickStyle);
	    dl.extend(m.minorTicks.properties.update, minorTickStyle);
	    dl.extend(m.tickLabels.properties.update, tickLabelStyle);
	    dl.extend(m.domain.properties.update, domainStyle);
	    dl.extend(m.title.properties.update, titleStyle);
	
	    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];
	    dl.extend(axisDef, {
	      type: 'group',
	      interactive: false,
	      properties: {
	        enter: {
	          encode: axisUpdate,
	          scales: [scale.scaleName],
	          signals: [], data: []
	        },
	        update: {
	          encode: axisUpdate,
	          scales: [scale.scaleName],
	          signals: [], data: []
	        }
	      }
	    });
	
	    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });
	  }
	
	  axis.scale = function(x) {
	    if (!arguments.length) return scale;
	    if (scale !== x) { scale = x; reset(); }
	    return axis;
	  };
	
	  axis.orient = function(x) {
	    if (!arguments.length) return orient;
	    if (orient !== x) {
	      orient = x in axisOrients ? x + '' : config.orient;
	      reset();
	    }
	    return axis;
	  };
	
	  axis.title = function(x) {
	    if (!arguments.length) return title;
	    if (title !== x) { title = x; reset(); }
	    return axis;
	  };
	
	  axis.tickCount = function(x) {
	    if (!arguments.length) return tickCount;
	    tickCount = x;
	    return axis;
	  };
	
	  axis.tickValues = function(x) {
	    if (!arguments.length) return tickValues;
	    tickValues = x;
	    return axis;
	  };
	
	  axis.tickFormat = function(x) {
	    if (!arguments.length) return tickFormatString;
	    if (tickFormatString !== x) {
	      tickFormatString = x;
	      reset();
	    }
	    return axis;
	  };
	
	  axis.tickFormatType = function(x) {
	    if (!arguments.length) return tickFormatType;
	    if (tickFormatType !== x) {
	      tickFormatType = x;
	      reset();
	    }
	    return axis;
	  };
	
	  axis.tickSize = function(x, y) {
	    if (!arguments.length) return tickMajorSize;
	    var n = arguments.length - 1,
	        major = +x,
	        minor = n > 1 ? +y : tickMajorSize,
	        end   = n > 0 ? +arguments[n] : tickMajorSize;
	
	    if (tickMajorSize !== major ||
	        tickMinorSize !== minor ||
	        tickEndSize !== end) {
	      reset();
	    }
	
	    tickMajorSize = major;
	    tickMinorSize = minor;
	    tickEndSize = end;
	    return axis;
	  };
	
	  axis.tickSubdivide = function(x) {
	    if (!arguments.length) return tickSubdivide;
	    tickSubdivide = +x;
	    return axis;
	  };
	
	  axis.offset = function(x) {
	    if (!arguments.length) return offset;
	    offset = dl.isObject(x) ? x : +x;
	    return axis;
	  };
	
	  axis.tickPadding = function(x) {
	    if (!arguments.length) return tickPadding;
	    if (tickPadding !== +x) { tickPadding = +x; reset(); }
	    return axis;
	  };
	
	  axis.titleOffset = function(x) {
	    if (!arguments.length) return titleOffset;
	    if (titleOffset !== x) { titleOffset = x; reset(); }
	    return axis;
	  };
	
	  axis.layer = function(x) {
	    if (!arguments.length) return layer;
	    if (layer !== x) { layer = x; reset(); }
	    return axis;
	  };
	
	  axis.grid = function(x) {
	    if (!arguments.length) return grid;
	    if (grid !== x) { grid = x; reset(); }
	    return axis;
	  };
	
	  axis.gridLineProperties = function(x) {
	    if (!arguments.length) return gridLineStyle;
	    if (gridLineStyle !== x) { gridLineStyle = x; }
	    return axis;
	  };
	
	  axis.majorTickProperties = function(x) {
	    if (!arguments.length) return majorTickStyle;
	    if (majorTickStyle !== x) { majorTickStyle = x; }
	    return axis;
	  };
	
	  axis.minorTickProperties = function(x) {
	    if (!arguments.length) return minorTickStyle;
	    if (minorTickStyle !== x) { minorTickStyle = x; }
	    return axis;
	  };
	
	  axis.tickLabelProperties = function(x) {
	    if (!arguments.length) return tickLabelStyle;
	    if (tickLabelStyle !== x) { tickLabelStyle = x; }
	    return axis;
	  };
	
	  axis.titleProperties = function(x) {
	    if (!arguments.length) return titleStyle;
	    if (titleStyle !== x) { titleStyle = x; }
	    return axis;
	  };
	
	  axis.domainProperties = function(x) {
	    if (!arguments.length) return domainStyle;
	    if (domainStyle !== x) { domainStyle = x; }
	    return axis;
	  };
	
	  axis.reset = function() {
	    reset();
	    return axis;
	  };
	
	  return axis;
	}
	
	var axisOrients = {top: 1, right: 1, bottom: 1, left: 1};
	
	function axisSubdivide(scale, ticks, m) {
	  var subticks = [];
	  if (m && ticks.length > 1) {
	    var extent = axisScaleExtent(scale.domain()),
	        i = -1,
	        n = ticks.length,
	        d = (ticks[1] - ticks[0]) / ++m,
	        j,
	        v;
	    while (++i < n) {
	      for (j = m; --j > 0;) {
	        if ((v = +ticks[i] - j * d) >= extent[0]) {
	          subticks.push(v);
	        }
	      }
	    }
	    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {
	      subticks.push(v);
	    }
	  }
	  return subticks;
	}
	
	function axisScaleExtent(domain) {
	  var start = domain[0], stop = domain[domain.length - 1];
	  return start < stop ? [start, stop] : [stop, start];
	}
	
	function axisScaleRange(scale) {
	  return scale.rangeExtent ?
	    scale.rangeExtent() :
	    axisScaleExtent(scale.range());
	}
	
	var axisAlign = {
	  bottom: 'center',
	  top: 'center',
	  left: 'right',
	  right: 'left'
	};
	
	var axisBaseline = {
	  bottom: 'top',
	  top: 'bottom',
	  left: 'middle',
	  right: 'middle'
	};
	
	function axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {
	  size = Math.max(size, 0) + pad;
	  if (orient === 'left' || orient === 'top') {
	    size *= -1;
	  }
	  if (orient === 'top' || orient === 'bottom') {
	    dl.extend(labels.properties.enter, {
	      x: oldScale,
	      y: {value: size},
	    });
	    dl.extend(labels.properties.update, {
	      x: newScale,
	      y: {value: size},
	      align: {value: 'center'},
	      baseline: {value: axisBaseline[orient]}
	    });
	  } else {
	    dl.extend(labels.properties.enter, {
	      x: {value: size},
	      y: oldScale,
	    });
	    dl.extend(labels.properties.update, {
	      x: {value: size},
	      y: newScale,
	      align: {value: axisAlign[orient]},
	      baseline: {value: 'middle'}
	    });
	  }
	}
	
	function axisTicksExtend(orient, ticks, oldRef, newRef, size, scale, config, offset) {
	  var sign = (orient === 'left' || orient === 'top') ? -1 : 1;
	  if (size === Infinity) {
	    size = (orient === 'top' || orient === 'bottom') ?
	      {field: {group: 'height', level: 2}, mult: -sign, offset: offset*-sign} :
	      {field: {group: 'width',  level: 2}, mult: -sign, offset: offset*-sign};
	  } else {
	    size = {value: sign * size, offset: offset};
	  }
	
	  // Update offset of tick placement to be in between ordinal marks
	  // instead of directly aligned with.
	  if (config.tickPlacement === 'between' && scale.type === ORDINAL) {
	    var rng = scale.range(),
	        tickOffset = 0.5 + (scale.rangeBand() || (rng[1] - rng[0]) / 2);
	    newRef = oldRef = dl.duplicate(newRef);
	    newRef.offset = oldRef.offset = tickOffset;
	  }
	
	  if (orient === 'top' || orient === 'bottom') {
	    dl.extend(ticks.properties.enter, {
	      x:  oldRef,
	      y:  {value: 0},
	      y2: size
	    });
	    dl.extend(ticks.properties.update, {
	      x:  newRef,
	      y:  {value: 0},
	      y2: size
	    });
	    dl.extend(ticks.properties.exit, {
	      x:  newRef,
	    });
	  } else {
	    dl.extend(ticks.properties.enter, {
	      x:  {value: 0},
	      x2: size,
	      y:  oldRef
	    });
	    dl.extend(ticks.properties.update, {
	      x:  {value: 0},
	      x2: size,
	      y:  newRef
	    });
	    dl.extend(ticks.properties.exit, {
	      y:  newRef,
	    });
	  }
	}
	
	function axisTitleExtend(orient, title, range, offset) {
	  var update = title.properties.update,
	      mid = ~~((range[0] + range[1]) / 2),
	      sign = (orient === 'top' || orient === 'left') ? -1 : 1;
	
	  if (orient === 'bottom' || orient === 'top') {
	    update.x = {value: mid};
	    update.angle = {value: 0};
	    if (offset >= 0) update.y = {value: sign * offset};
	  } else {
	    update.y = {value: mid};
	    update.angle = {value: orient === 'left' ? -90 : 90};
	    if (offset >= 0) update.x = {value: sign * offset};
	  }
	}
	
	function axisDomainExtend(orient, domain, range, size) {
	  var path;
	  if (orient === 'top' || orient === 'left') {
	    size = -1 * size;
	  }
	  if (orient === 'bottom' || orient === 'top') {
	    path = 'M' + range[0] + ',' + size + 'V0H' + range[1] + 'V' + size;
	  } else {
	    path = 'M' + size + ',' + range[0] + 'H0V' + range[1] + 'H' + size;
	  }
	  domain.properties.update.path = {value: path};
	}
	
	function axisUpdate(item, group, trans) {
	  var o = trans ? {} : item,
	      offset = item.mark.def.offset,
	      orient = item.mark.def.orient,
	      width  = group.width,
	      height = group.height; // TODO fallback to global w,h?
	
	  if (dl.isArray(offset)) {
	    var ofx = offset[0],
	        ofy = offset[1];
	
	    switch (orient) {
	      case 'left':   { Tuple.set(o, 'x', -ofx); Tuple.set(o, 'y', ofy); break; }
	      case 'right':  { Tuple.set(o, 'x', width + ofx); Tuple.set(o, 'y', ofy); break; }
	      case 'bottom': { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', height + ofy); break; }
	      case 'top':    { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', -ofy); break; }
	      default:       { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', ofy); }
	    }
	  } else {
	    if (dl.isObject(offset)) {
	      offset = -group.scale(offset.scale)(offset.value);
	    }
	
	    switch (orient) {
	      case 'left':   { Tuple.set(o, 'x', -offset); Tuple.set(o, 'y', 0); break; }
	      case 'right':  { Tuple.set(o, 'x', width + offset); Tuple.set(o, 'y', 0); break; }
	      case 'bottom': { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', height + offset); break; }
	      case 'top':    { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', -offset); break; }
	      default:       { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', 0); }
	    }
	  }
	
	  if (trans) trans.interpolate(item, o);
	  return true;
	}
	
	function axisTicks(config) {
	  return {
	    type: 'rule',
	    interactive: false,
	    key: 'data',
	    properties: {
	      enter: {
	        stroke: {value: config.tickColor},
	        strokeWidth: {value: config.tickWidth},
	        opacity: {value: 1e-6}
	      },
	      exit: { opacity: {value: 1e-6} },
	      update: { opacity: {value: 1} }
	    }
	  };
	}
	
	function axisTickLabels(config) {
	  return {
	    type: 'text',
	    interactive: true,
	    key: 'data',
	    properties: {
	      enter: {
	        fill: {value: config.tickLabelColor},
	        font: {value: config.tickLabelFont},
	        fontSize: {value: config.tickLabelFontSize},
	        opacity: {value: 1e-6},
	        text: {field: 'label'}
	      },
	      exit: { opacity: {value: 1e-6} },
	      update: { opacity: {value: 1} }
	    }
	  };
	}
	
	function axisTitle(config) {
	  return {
	    type: 'text',
	    interactive: true,
	    properties: {
	      enter: {
	        font: {value: config.titleFont},
	        fontSize: {value: config.titleFontSize},
	        fontWeight: {value: config.titleFontWeight},
	        fill: {value: config.titleColor},
	        align: {value: 'center'},
	        baseline: {value: 'middle'},
	        text: {field: 'data'}
	      },
	      update: {}
	    }
	  };
	}
	
	function axisDomain(config) {
	  return {
	    type: 'path',
	    interactive: false,
	    properties: {
	      enter: {
	        x: {value: 0.5},
	        y: {value: 0.5},
	        stroke: {value: config.axisColor},
	        strokeWidth: {value: config.axisWidth}
	      },
	      update: {}
	    }
	  };
	}
	
	module.exports = axs;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/axis.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/mark.js **/
jupyter.define('vega@2.6.3/src/parse/mark.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    parseProperties = __jupyter_require__('vega@~2.6.3/src/parse/properties.js');
	
	function parseMark(model, mark, applyDefaults) {
	  var props = mark.properties || (applyDefaults && (mark.properties = {})),
	      enter = props.enter || (applyDefaults && (props.enter = {})),
	      group = mark.marks,
	      config = model.config().marks || {};
	
	  if (applyDefaults) {
	    // for scatter plots, set symbol size specified in config if not in spec
	    if (mark.type === 'symbol' && !enter.size && config.symbolSize) {
	        enter.size = {value: config.symbolSize};
	    }
	
	    // Themes define a default "color" that maps to fill/stroke based on mark type.
	    var colorMap = {
	      arc: 'fill', area: 'fill', rect: 'fill', symbol: 'fill', text: 'fill',
	      line: 'stroke', path: 'stroke', rule: 'stroke'
	    };
	
	    // Set default mark color if no color is given in spec, and only do so for
	    // user-defined marks (not axis/legend marks).
	    var colorProp = colorMap[mark.type];
	    if (!enter[colorProp] && config.color) {
	      enter[colorProp] = {value: config.color};
	    }
	  }
	
	  // parse mark property definitions
	  dl.keys(props).forEach(function(k) {
	    props[k] = parseProperties(model, mark.type, props[k]);
	  });
	
	  // parse delay function
	  if (mark.delay) {
	    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});
	  }
	
	  // recurse if group type
	  if (group) {
	    mark.marks = group.map(function(g) { return parseMark(model, g, true); });
	  }
	
	  return mark;
	}
	
	module.exports = parseMark;
	
	parseMark.schema = {
	  "defs": {
	    "mark": {
	      "type": "object",
	
	      "properties": {
	        "name": {"type": "string"},
	        "key": {"type": "string"},
	        "type": {"enum": ["rect", "symbol", "path", "arc",
	          "area", "line", "rule", "image", "text", "group"]},
	
	        "from": {
	          "type": "object",
	          "properties": {
	            "data": {"type": "string"},
	            "mark": {"type": "string"},
	            "transform": {"$ref": "#/defs/transform"}
	          },
	          "additionalProperties": false
	        },
	
	        "delay": {"$ref": "#/refs/numberValue"},
	        "ease": {
	          "enum": ["linear", "quad", "cubic", "sin",
	            "exp", "circle", "bounce"].reduce(function(acc, e) {
	              ["in", "out", "in-out", "out-in"].forEach(function(m) {
	                acc.push(e+"-"+m);
	              });
	              return acc;
	          }, [])
	        },
	
	        "interactive": {"type": "boolean"},
	
	        "properties": {
	          "type": "object",
	          "properties": {
	            "enter":  {"$ref": "#/defs/propset"},
	            "update": {"$ref": "#/defs/propset"},
	            "exit":   {"$ref": "#/defs/propset"},
	            "hover":  {"$ref": "#/defs/propset"}
	          },
	          "additionalProperties": false,
	          "anyOf": [{"required": ["enter"]}, {"required": ["update"]}]
	        }
	      },
	
	      // "additionalProperties": false,
	      "required": ["type"]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/mark.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/properties.js **/
jupyter.define('vega@2.6.3/src/parse/properties.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple;
	
	var DEPS = ["signals", "scales", "data", "fields"];
	
	function properties(model, mark, spec) {
	  var config = model.config(),
	      code = "",
	      names = dl.keys(spec),
	      exprs = [], // parsed expressions injected in the generated code
	      i, len, name, ref, vars = {},
	      deps = {
	        signals: {},
	        scales:  {},
	        data:    {},
	        fields:  {},
	        nested:  [],
	        _nRefs:  {},  // Temp stash to de-dupe nested refs.
	        reflow:  false
	      };
	
	  code += "var o = trans ? {} : item, d=0, exprs=this.exprs, set=this.tpl.set, tmpl=signals||{}, t;\n" +
	          // Stash for dl.template
	          "tmpl.datum  = item.datum;\n" +
	          "tmpl.group  = group;\n" +
	          "tmpl.parent = group.datum;\n";
	
	  function handleDep(p) {
	    if (ref[p] == null) return;
	    var k = dl.array(ref[p]), i, n;
	    for (i=0, n=k.length; i<n; ++i) {
	      deps[p][k[i]] = 1;
	    }
	  }
	
	  function handleNestedRefs(r) {
	    var k = (r.parent ? "parent_" : "group_")+r.level;
	    deps._nRefs[k] = r;
	  }
	
	  parseShape(model, config, spec);
	
	  for (i=0, len=names.length; i<len; ++i) {
	    ref = spec[name = names[i]];
	    code += (i > 0) ? "\n  " : "  ";
	    if (ref.rule) {
	      // a production rule valueref
	      ref = rule(model, name, ref.rule, exprs);
	      code += "\n  " + ref.code;
	    } else if (dl.isArray(ref)) {
	      // a production rule valueref as an array
	      ref = rule(model, name, ref, exprs);
	      code += "\n  " + ref.code;
	    } else {
	      // a simple valueref
	      ref = valueRef(config, name, ref);
	      code += "d += set(o, "+dl.str(name)+", "+ref.val+");";
	    }
	
	    vars[name] = true;
	    DEPS.forEach(handleDep);
	    deps.reflow = deps.reflow || ref.reflow;
	    if (ref.nested.length) ref.nested.forEach(handleNestedRefs);
	  }
	
	  // If nested references are present, sort them based on their level
	  // to speed up determination of whether encoders should be reeval'd.
	  dl.keys(deps._nRefs).forEach(function(k) { deps.nested.push(deps._nRefs[k]); });
	  deps.nested.sort(function(a, b) {
	    a = a.level;
	    b = b.level;
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  });
	
	  if (vars.x2) {
	    if (vars.x) {
	      code += "\n  if (o.x > o.x2) { " +
	              "\n    t = o.x;" +
	              "\n    d += set(o, 'x', o.x2);" +
	              "\n    d += set(o, 'x2', t); " +
	              "\n  };";
	      code += "\n  d += set(o, 'width', (o.x2 - o.x));";
	    } else if (vars.width) {
	      code += "\n  d += set(o, 'x', (o.x2 - o.width));";
	    } else {
	      code += "\n  d += set(o, 'x', o.x2);";
	    }
	  }
	
	  if (vars.xc) {
	    if (vars.width) {
	      code += "\n  d += set(o, 'x', (o.xc - o.width/2));" ;
	    } else {
	      code += "\n  d += set(o, 'x', o.xc);" ;
	    }
	  }
	
	  if (vars.y2) {
	    if (vars.y) {
	      code += "\n  if (o.y > o.y2) { " +
	              "\n    t = o.y;" +
	              "\n    d += set(o, 'y', o.y2);" +
	              "\n    d += set(o, 'y2', t);" +
	              "\n  };";
	      code += "\n  d += set(o, 'height', (o.y2 - o.y));";
	    } else if (vars.height) {
	      code += "\n  d += set(o, 'y', (o.y2 - o.height));";
	    } else {
	      code += "\n  d += set(o, 'y', o.y2);";
	    }
	  }
	
	  if (vars.yc) {
	    if (vars.height) {
	      code += "\n  d += set(o, 'y', (o.yc - o.height/2));" ;
	    } else {
	      code += "\n  d += set(o, 'y', o.yc);" ;
	    }
	  }
	
	  if (hasPath(mark, vars)) code += "\n  d += (item.touch(), 1);";
	  code += "\n  if (trans) trans.interpolate(item, o);";
	  code += "\n  return d > 0;";
	
	  try {
	    /* jshint evil:true */
	    var encoder = Function('item', 'group', 'trans', 'db',
	      'signals', 'predicates', code);
	
	    encoder.tpl  = Tuple;
	    encoder.exprs = exprs;
	    encoder.util = dl;
	    encoder.d3   = d3; // For color spaces
	    dl.extend(encoder, dl.template.context);
	    return {
	      encode:  encoder,
	      signals: dl.keys(deps.signals),
	      scales:  dl.keys(deps.scales),
	      data:    dl.keys(deps.data),
	      fields:  dl.keys(deps.fields),
	      nested:  deps.nested,
	      reflow:  deps.reflow
	    };
	  } catch (e) {
	    log.error(e);
	    log.log(code);
	  }
	}
	
	function dependencies(a, b) {
	  if (!dl.isObject(a)) {
	    a = {reflow: false, nested: []};
	    DEPS.forEach(function(d) { a[d] = []; });
	  }
	
	  if (dl.isObject(b)) {
	    a.reflow = a.reflow || b.reflow;
	    a.nested.push.apply(a.nested, b.nested);
	    DEPS.forEach(function(d) { a[d].push.apply(a[d], b[d]); });
	  }
	
	  return a;
	}
	
	function hasPath(mark, vars) {
	  return vars.path ||
	    ((mark==='area' || mark==='line') &&
	      (vars.x || vars.x2 || vars.width ||
	       vars.y || vars.y2 || vars.height ||
	       vars.tension || vars.interpolate));
	}
	
	var hb = /{{(.*?)}}/g;
	function parseShape(model, config, spec) {
	  var shape = spec.shape,
	      last = 0,
	      value, match;
	
	  if (shape && (value = shape.value)) {
	    if (config.shape && config.shape[value]) {
	      value = config.shape[value];
	    }
	
	    // Parse handlebars
	    shape = '';
	    while ((match = hb.exec(value)) !== null) {
	      shape += value.substring(last, match.index);
	      shape += model.expr(match[1]).fn();
	      last = hb.lastIndex;
	    }
	    spec.shape.value = shape + value.substring(last);
	  }
	}
	
	function rule(model, name, rules, exprs) {
	  var config  = model.config(),
	      deps = dependencies(),
	      inputs  = [],
	      code = '';
	
	  (rules||[]).forEach(function(r, i) {
	    var ref = valueRef(config, name, r);
	    dependencies(deps, ref);
	
	    if (r.test) {
	      // rule uses an expression instead of a predicate.
	      var exprFn = model.expr(r.test);
	      deps.signals.push.apply(deps.signals, exprFn.globals);
	      deps.data.push.apply(deps.data, exprFn.dataSources);
	
	      code += "if (exprs[" + exprs.length + "](item.datum, item.mark.group.datum, null)) {" +
	          "\n    d += set(o, "+dl.str(name)+", " +ref.val+");";
	      code += rules[i+1] ? "\n  } else " : "  }";
	
	      exprs.push(exprFn.fn);
	    } else {
	      var def = r.predicate,
	          predName = def && (def.name || def),
	          pred = model.predicate(predName),
	          p = 'predicates['+dl.str(predName)+']',
	          input = [], args = name+'_arg'+i;
	
	      if (dl.isObject(def)) {
	        dl.keys(def).forEach(function(k) {
	          if (k === 'name') return;
	          var ref = valueRef(config, i, def[k], true);
	          input.push(dl.str(k)+': '+ref.val);
	          dependencies(deps, ref);
	        });
	      }
	
	      if (predName) {
	        // append the predicates dependencies to our dependencies
	        deps.signals.push.apply(deps.signals, pred.signals);
	        deps.data.push.apply(deps.data, pred.data);
	        inputs.push(args+" = {\n    "+input.join(",\n    ")+"\n  }");
	        code += "if ("+p+".call("+p+","+args+", db, signals, predicates)) {" +
	          "\n    d += set(o, "+dl.str(name)+", "+ref.val+");";
	        code += rules[i+1] ? "\n  } else " : "  }";
	      } else {
	        code += "{" +
	          "\n    d += set(o, "+dl.str(name)+", "+ref.val+");"+
	          "\n  }\n";
	      }
	    }
	  });
	
	  if (inputs.length) code = "var " + inputs.join(",\n      ") + ";\n  " + code;
	  return (deps.code = code, deps);
	}
	
	function valueRef(config, name, ref, predicateArg) {
	  if (ref == null) return null;
	
	  if (name==='fill' || name==='stroke') {
	    if (ref.c) {
	      return colorRef(config, 'hcl', ref.h, ref.c, ref.l);
	    } else if (ref.h || ref.s) {
	      return colorRef(config, 'hsl', ref.h, ref.s, ref.l);
	    } else if (ref.l || ref.a) {
	      return colorRef(config, 'lab', ref.l, ref.a, ref.b);
	    } else if (ref.r || ref.g || ref.b) {
	      return colorRef(config, 'rgb', ref.r, ref.g, ref.b);
	    }
	  }
	
	  // initialize value
	  var val = null, scale = null,
	      deps = dependencies(),
	      sgRef = null, fRef = null, sRef = null, tmpl = {};
	
	  if (ref.template !== undefined) {
	    val = dl.template.source(ref.template, 'tmpl', tmpl);
	    dl.keys(tmpl).forEach(function(k) {
	      var f = dl.field(k),
	          a = f.shift();
	      if (a === 'parent' || a === 'group') {
	        deps.nested.push({
	          parent: a === 'parent',
	          group:  a === 'group',
	          level:  1
	        });
	      } else if (a === 'datum') {
	        deps.fields.push(f[0]);
	      } else {
	        deps.signals.push(a);
	      }
	    });
	  }
	
	  if (ref.value !== undefined) {
	    val = dl.str(ref.value);
	  }
	
	  if (ref.signal !== undefined) {
	    sgRef = dl.field(ref.signal);
	    val = 'signals['+sgRef.map(dl.str).join('][')+']';
	    deps.signals.push(sgRef.shift());
	  }
	
	  if (ref.field !== undefined) {
	    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;
	    fRef = fieldRef(ref.field);
	    val  = fRef.val;
	    dependencies(deps, fRef);
	  }
	
	  if (ref.scale !== undefined) {
	    sRef  = scaleRef(ref.scale);
	    scale = sRef.val;
	    dependencies(deps, sRef);
	    deps.scales.push(ref.scale.name || ref.scale);
	
	    // run through scale function if val specified.
	    // if no val, scale function is predicate arg.
	    if (val !== null || ref.band || ref.mult || ref.offset || !predicateArg) {
	      val = scale + (ref.band ? '.rangeBand()' :
	        '('+(val !== null ? val : 'item.datum.data')+')');
	    } else if (predicateArg) {
	      val = scale;
	    }
	  }
	
	  // multiply, offset, return value
	  val = '(' + (ref.mult?(dl.number(ref.mult)+' * '):'') + val + ')' +
	        (ref.offset ? ' + ' + dl.number(ref.offset) : '');
	
	  // Collate dependencies
	  return (deps.val = val, deps);
	}
	
	function colorRef(config, type, x, y, z) {
	  var xx = x ? valueRef(config, '', x) : config.color[type][0],
	      yy = y ? valueRef(config, '', y) : config.color[type][1],
	      zz = z ? valueRef(config, '', z) : config.color[type][2],
	      deps = dependencies();
	
	  [xx, yy, zz].forEach(function(v) {
	    if (dl.isArray) return;
	    dependencies(deps, v);
	  });
	
	  var val = '(this.d3.' + type + '(' + [xx.val, yy.val, zz.val].join(',') + ') + "")';
	  return (deps.val = val, deps);
	}
	
	// {field: {datum: "foo"} }  -> item.datum.foo
	// {field: {group: "foo"} }  -> group.foo
	// {field: {parent: "foo"} } -> group.datum.foo
	function fieldRef(ref) {
	  if (dl.isString(ref)) {
	    return {val: dl.field(ref).map(dl.str).join('][')};
	  }
	
	  // Resolve nesting/parent lookups
	  var l = ref.level || 1,
	      nested = (ref.group || ref.parent) && l,
	      scope = nested ? Array(l).join('group.mark.') : '',
	      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),
	      val = r.val,
	      deps = dependencies(null, r);
	
	  if (ref.datum) {
	    val = 'item.datum['+val+']';
	    deps.fields.push(ref.datum);
	  } else if (ref.group) {
	    val = scope+'group['+val+']';
	    deps.nested.push({ level: l, group: true });
	  } else if (ref.parent) {
	    val = scope+'group.datum['+val+']';
	    deps.nested.push({ level: l, parent: true });
	  } else if (ref.signal) {
	    val = 'signals['+val+']';
	    deps.signals.push(dl.field(ref.signal)[0]);
	    deps.reflow = true;
	  }
	
	  return (deps.val = val, deps);
	}
	
	// {scale: "x"}
	// {scale: {name: "x"}},
	// {scale: fieldRef}
	function scaleRef(ref) {
	  var scale = null,
	      fr = null,
	      deps = dependencies();
	
	  if (dl.isString(ref)) {
	    scale = dl.str(ref);
	  } else if (ref.name) {
	    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;
	  } else {
	    scale = (fr = fieldRef(ref)).val;
	  }
	
	  scale = '(item.mark._scaleRefs['+scale+'] = 1, group.scale('+scale+'))';
	  if (ref.invert) scale += '.invert';
	
	  // Mark scale refs as they're dealt with separately in mark._scaleRefs.
	  if (fr) fr.nested.forEach(function(g) { g.scale = true; });
	  return fr ? (fr.val = scale, fr) : (deps.val = scale, deps);
	}
	
	module.exports = properties;
	
	function valueSchema(type) {
	  type = dl.isArray(type) ? {"enum": type} : {"type": type};
	  var modType = type.type === "number" && type.type || "string";
	  var valRef  = {
	    "type": "object",
	    "allOf": [{"$ref": "#/refs/" + modType + "Modifiers"}, {
	      "oneOf": [{
	        "$ref": "#/refs/signal",
	        "required": ["signal"]
	      }, {
	        "properties": {"value": type},
	        "required": ["value"]
	      }, {
	        "properties": {"field": {"$ref": "#/refs/field"}},
	        "required": ["field"]
	      }, {
	        "properties": {"band": {"type": "boolean"}},
	        "required": ["band"]
	      }]
	    }]
	  };
	
	  if (type.type === "string") {
	    valRef.allOf[1].oneOf.push({
	      "properties": {"template": {"type": "string"}},
	      "required": ["template"]
	    });
	  }
	
	  return {
	    "oneOf": [{
	      "type": "object",
	      "properties": {
	        "rule": {
	          "type": "array",
	          "items": {
	            "allOf": [{"$ref": "#/defs/rule"}, valRef]
	          }
	        }
	      },
	      "additionalProperties": false,
	      "required": ["rule"]
	    },
	    {
	      "type": "array",
	      "items": {
	        "allOf": [{"$ref": "#/defs/rule"}, valRef]
	      }
	    },
	    valRef]
	  };
	}
	
	properties.schema = {
	  "refs": {
	    "field": {
	      "title": "FieldRef",
	      "oneOf": [
	        {"type": "string"},
	        {
	          "oneOf": [
	            {"$ref": "#/refs/signal"},
	            {
	              "type": "object",
	              "properties": {"datum": {"$ref": "#/refs/field"}},
	              "required": ["datum"],
	              "additionalProperties": false
	            },
	            {
	              "type": "object",
	              "properties": {
	                "group": {"$ref": "#/refs/field"},
	                "level": {"type": "number"}
	              },
	              "required": ["group"],
	              "additionalProperties": false
	            },
	            {
	              "type": "object",
	              "properties": {
	                "parent": {"$ref": "#/refs/field"},
	                "level": {"type": "number"}
	              },
	              "required": ["parent"],
	              "additionalProperties": false
	            }
	          ]
	        }
	      ]
	    },
	
	    "scale": {
	      "title": "ScaleRef",
	      "oneOf": [
	        {"$ref": "#/refs/field"},
	        {
	          "type": "object",
	          "properties": {
	            "name": {"$ref": "#/refs/field"},
	            "invert": {"type": "boolean", "default": false}
	          },
	          "required": ["name"]
	        }
	      ]
	    },
	
	    "stringModifiers": {
	      "properties": {
	        "scale": {"$ref": "#/refs/scale"}
	      }
	    },
	
	    "numberModifiers": {
	      "properties": {
	        "mult": {"type": "number"},
	        "offset": {"type": "number"},
	        "scale": {"$ref": "#/refs/scale"}
	      }
	    },
	
	    "value": valueSchema({}, "value"),
	    "numberValue": valueSchema("number", "numberValue"),
	    "stringValue": valueSchema("string", "stringValue"),
	    "booleanValue": valueSchema("boolean", "booleanValue"),
	    "arrayValue": valueSchema("array", "arrayValue"),
	
	    "colorValue": {
	      "title": "ColorRef",
	      "oneOf": [{"$ref": "#/refs/stringValue"}, {
	        "type": "object",
	        "properties": {
	          "r": {"$ref": "#/refs/numberValue"},
	          "g": {"$ref": "#/refs/numberValue"},
	          "b": {"$ref": "#/refs/numberValue"}
	        },
	        "required": ["r", "g", "b"]
	      }, {
	        "type": "object",
	        "properties": {
	          "h": {"$ref": "#/refs/numberValue"},
	          "s": {"$ref": "#/refs/numberValue"},
	          "l": {"$ref": "#/refs/numberValue"}
	        },
	        "required": ["h", "s", "l"]
	      }, {
	        "type": "object",
	        "properties": {
	          "l": {"$ref": "#/refs/numberValue"},
	          "a": {"$ref": "#/refs/numberValue"},
	          "b": {"$ref": "#/refs/numberValue"}
	        },
	        "required": ["l", "a", "b"]
	      }, {
	        "type": "object",
	        "properties": {
	          "h": {"$ref": "#/refs/numberValue"},
	          "c": {"$ref": "#/refs/numberValue"},
	          "l": {"$ref": "#/refs/numberValue"}
	        },
	        "required": ["h", "c", "l"]
	      }]
	    }
	  },
	
	  "defs": {
	    "rule": {
	      "anyOf": [
	        {
	          "type": "object",
	          "properties": {
	            "predicate": {
	              "oneOf": [
	                {"type": "string"},
	                {
	                  "type": "object",
	                  "properties": {"name": { "type": "string" }},
	                  "required": ["name"]
	                }
	              ]
	            }
	          }
	        },
	        {
	          "type": "object",
	          "properties": {"test": {"type": "string"}}
	        }
	      ]
	    },
	    "propset": {
	      "title": "Mark property set",
	      "type": "object",
	      "properties": {
	        // Common Properties
	        "x": {"$ref": "#/refs/numberValue"},
	        "x2": {"$ref": "#/refs/numberValue"},
	        "xc": {"$ref": "#/refs/numberValue"},
	        "width": {"$ref": "#/refs/numberValue"},
	        "y": {"$ref": "#/refs/numberValue"},
	        "y2": {"$ref": "#/refs/numberValue"},
	        "yc": {"$ref": "#/refs/numberValue"},
	        "height": {"$ref": "#/refs/numberValue"},
	        "opacity": {"$ref": "#/refs/numberValue"},
	        "fill": {"$ref": "#/refs/colorValue"},
	        "fillOpacity": {"$ref": "#/refs/numberValue"},
	        "stroke": {"$ref": "#/refs/colorValue"},
	        "strokeWidth": {"$ref": "#/refs/numberValue"},
	        "strokeOpacity": {"$ref": "#/refs/numberValue"},
	        "strokeDash": {"$ref": "#/refs/arrayValue"},
	        "strokeDashOffset": {"$ref": "#/refs/numberValue"},
	        "cursor": {"$ref": "#/refs/stringValue"},
	
	        // Group-mark properties
	        "clip": {"$ref": "#/refs/booleanValue"},
	
	        // Symbol-mark properties
	        "size": {"$ref": "#/refs/numberValue"},
	        "shape": {
	          "anyOf": [
	            valueSchema(["circle", "square", "cross", "diamond",
	              "triangle-up", "triangle-down"]),
	            {"$ref": "#/refs/stringValue"}
	          ]
	        },
	
	        // Path-mark properties
	        "path": {"$ref": "#/refs/stringValue"},
	
	        // Arc-mark properties
	        "innerRadius": {"$ref": "#/refs/numberValue"},
	        "outerRadius": {"$ref": "#/refs/numberValue"},
	        "startAngle": {"$ref": "#/refs/numberValue"},
	        "endAngle": {"$ref": "#/refs/numberValue"},
	
	        // Area- and line-mark properties
	        "interpolate": valueSchema(["linear", "linear-closed",
	          "step", "step-before", "step-after",
	          "basis", "basis-open", "basis-closed", 
	          "cardinal", "cardinal-open", "cardinal-closed",
	          "bundle", "monotone"]),
	        "tension": {"$ref": "#/refs/numberValue"},
	        "orient": valueSchema(["horizontal", "vertical"]),
	
	        // Image-mark properties
	        "url": {"$ref": "#/refs/stringValue"},
	        "align": valueSchema(["left", "right", "center"]),
	        "baseline": valueSchema(["top", "middle", "bottom", "alphabetic"]),
	
	        // Text-mark properties
	        "text": {"$ref": "#/refs/stringValue"},
	        "dx": {"$ref": "#/refs/numberValue"},
	        "dy": {"$ref": "#/refs/numberValue"},
	        "radius":{"$ref": "#/refs/numberValue"},
	        "theta": {"$ref": "#/refs/numberValue"},
	        "angle": {"$ref": "#/refs/numberValue"},
	        "font": {"$ref": "#/refs/stringValue"},
	        "fontSize": {"$ref": "#/refs/numberValue"},
	        "fontWeight": {"$ref": "#/refs/stringValue"},
	        "fontStyle": {"$ref": "#/refs/stringValue"}
	      },
	
	      "additionalProperties": false
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/properties.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/util/index.js **/
jupyter.define('vega@2.6.3/src/util/index.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    u  = {};
	
	dl.extend(u, __jupyter_require__('vega@~2.6.3/src/util/format.js'));
	module.exports = dl.extend(u, dl);
})
/** END DEFINE BLOCK for vega@2.6.3/src/util/index.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/util/format.js **/
jupyter.define('vega@2.6.3/src/util/format.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js');
	
	var TIME    = 'time',
	    UTC     = 'utc',
	    STRING  = 'string',
	    ORDINAL = 'ordinal',
	    NUMBER  = 'number';
	
	function getTickFormat(scale, tickCount, tickFormatType, tickFormatString) {
	  var formatType = tickFormatType || inferFormatType(scale);
	  return getFormatter(scale, tickCount, formatType, tickFormatString);
	}
	
	function inferFormatType(scale) {
	  switch (scale.type) {
	    case TIME:    return TIME;
	    case UTC:     return UTC;
	    case ORDINAL: return STRING;
	    default:      return NUMBER;
	  }
	}
	
	// Adapted from d3 log scale
	// TODO customize? replace with range-size-aware filtering?
	function logFilter(scale, domain, count, f) {
	  if (count == null) return f;
	  var base = scale.base(),
	      k = Math.min(base, scale.ticks().length / count),
	      v = domain[0] > 0 ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),
	      e;
	  function log(x) {
	    return (domain[0] < 0 ?
	      -Math.log(x > 0 ? 0 : -x) :
	      Math.log(x < 0 ? 0 : x)) / Math.log(base);
	  }
	  function pow(x) {
	    return domain[0] < 0 ? -Math.pow(base, -x) : Math.pow(base, x);
	  }
	  return function(d) {
	    return pow(v(log(d) + e)) / d >= k ? f(d) : '';
	  };
	}
	
	function getFormatter(scale, tickCount, formatType, str) {
	  var fmt = dl.format,
	      log = scale.type === 'log',
	      domain;
	
	  switch (formatType) {
	    case NUMBER:
	      domain = scale.domain();
	      return log ?
	        logFilter(scale, domain, tickCount, fmt.auto.number(str || null)) :
	        fmt.auto.linear(domain, tickCount, str || null);
	    case TIME: return (str ? fmt : fmt.auto).time(str);
	    case UTC:  return (str ? fmt : fmt.auto).utc(str);
	    default:   return String;
	  }
	}
	
	module.exports = {
	  getTickFormat: getTickFormat
	};
})
/** END DEFINE BLOCK for vega@2.6.3/src/util/format.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/index.js **/
jupyter.define('vega-scenegraph@1.1.0/src/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  path:       __jupyter_require__('vega-scenegraph@~1.1.0/src/path/index.js'),
	  render:     __jupyter_require__('vega-scenegraph@~1.1.0/src/render/index.js'),
	  Item:       __jupyter_require__('vega-scenegraph@~1.1.0/src/util/Item.js'),
	  bound:      __jupyter_require__('vega-scenegraph@~1.1.0/src/util/bound.js'),
	  Bounds:     __jupyter_require__('vega-scenegraph@~1.1.0/src/util/Bounds.js'),
	  canvas:     __jupyter_require__('vega-scenegraph@~1.1.0/src/util/canvas.js'),
	  Gradient:   __jupyter_require__('vega-scenegraph@~1.1.0/src/util/Gradient.js'),
	  toJSON:     __jupyter_require__('vega-scenegraph@~1.1.0/src/util/scene.js').toJSON,
	  fromJSON:   __jupyter_require__('vega-scenegraph@~1.1.0/src/util/scene.js').fromJSON
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/index.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/index.js **/
jupyter.define('vega-scenegraph@1.1.0/src/path/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  parse:  __jupyter_require__('vega-scenegraph@~1.1.0/src/path/parse.js'),
	  render: __jupyter_require__('vega-scenegraph@~1.1.0/src/path/render.js')
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/index.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/parse.js **/
jupyter.define('vega-scenegraph@1.1.0/src/path/parse.js', function (module, exports, __jupyter_require__) {
	// Path parsing and rendering code adapted from fabric.js -- Thanks!
	var cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },
	    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\d)([-+])/g, /\s|,|###/];
	
	module.exports = function(pathstr) {
	  var result = [],
	      path,
	      curr,
	      chunks,
	      parsed, param,
	      cmd, len, i, j, n, m;
	
	  // First, break path into command sequence
	  path = pathstr
	    .slice()
	    .replace(regexp[0], '###$1')
	    .split(regexp[1])
	    .slice(1);
	
	  // Next, parse each command in turn
	  for (i=0, n=path.length; i<n; ++i) {
	    curr = path[i];
	    chunks = curr
	      .slice(1)
	      .trim()
	      .replace(regexp[2],'$1###$2')
	      .split(regexp[3]);
	    cmd = curr.charAt(0);
	
	    parsed = [cmd];
	    for (j=0, m=chunks.length; j<m; ++j) {
	      if ((param = +chunks[j]) === param) { // not NaN
	        parsed.push(param);
	      }
	    }
	
	    len = cmdlen[cmd.toLowerCase()];
	    if (parsed.length-1 > len) {
	      for (j=1, m=parsed.length; j<m; j+=len) {
	        result.push([cmd].concat(parsed.slice(j, j+len)));
	      }
	    }
	    else {
	      result.push(parsed);
	    }
	  }
	
	  return result;
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/parse.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/render.js **/
jupyter.define('vega-scenegraph@1.1.0/src/path/render.js', function (module, exports, __jupyter_require__) {
	var arc = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/arc.js');
	
	module.exports = function(g, path, l, t) {
	  var current, // current instruction
	      previous = null,
	      x = 0, // current x
	      y = 0, // current y
	      controlX = 0, // current control point x
	      controlY = 0, // current control point y
	      tempX,
	      tempY,
	      tempControlX,
	      tempControlY;
	
	  if (l == null) l = 0;
	  if (t == null) t = 0;
	
	  g.beginPath();
	
	  for (var i=0, len=path.length; i<len; ++i) {
	    current = path[i];
	
	    switch (current[0]) { // first letter
	
	      case 'l': // lineto, relative
	        x += current[1];
	        y += current[2];
	        g.lineTo(x + l, y + t);
	        break;
	
	      case 'L': // lineto, absolute
	        x = current[1];
	        y = current[2];
	        g.lineTo(x + l, y + t);
	        break;
	
	      case 'h': // horizontal lineto, relative
	        x += current[1];
	        g.lineTo(x + l, y + t);
	        break;
	
	      case 'H': // horizontal lineto, absolute
	        x = current[1];
	        g.lineTo(x + l, y + t);
	        break;
	
	      case 'v': // vertical lineto, relative
	        y += current[1];
	        g.lineTo(x + l, y + t);
	        break;
	
	      case 'V': // verical lineto, absolute
	        y = current[1];
	        g.lineTo(x + l, y + t);
	        break;
	
	      case 'm': // moveTo, relative
	        x += current[1];
	        y += current[2];
	        g.moveTo(x + l, y + t);
	        break;
	
	      case 'M': // moveTo, absolute
	        x = current[1];
	        y = current[2];
	        g.moveTo(x + l, y + t);
	        break;
	
	      case 'c': // bezierCurveTo, relative
	        tempX = x + current[5];
	        tempY = y + current[6];
	        controlX = x + current[3];
	        controlY = y + current[4];
	        g.bezierCurveTo(
	          x + current[1] + l, // x1
	          y + current[2] + t, // y1
	          controlX + l, // x2
	          controlY + t, // y2
	          tempX + l,
	          tempY + t
	        );
	        x = tempX;
	        y = tempY;
	        break;
	
	      case 'C': // bezierCurveTo, absolute
	        x = current[5];
	        y = current[6];
	        controlX = current[3];
	        controlY = current[4];
	        g.bezierCurveTo(
	          current[1] + l,
	          current[2] + t,
	          controlX + l,
	          controlY + t,
	          x + l,
	          y + t
	        );
	        break;
	
	      case 's': // shorthand cubic bezierCurveTo, relative
	        // transform to absolute x,y
	        tempX = x + current[3];
	        tempY = y + current[4];
	        // calculate reflection of previous control points
	        controlX = 2 * x - controlX;
	        controlY = 2 * y - controlY;
	        g.bezierCurveTo(
	          controlX + l,
	          controlY + t,
	          x + current[1] + l,
	          y + current[2] + t,
	          tempX + l,
	          tempY + t
	        );
	
	        // set control point to 2nd one of this command
	        // the first control point is assumed to be the reflection of
	        // the second control point on the previous command relative
	        // to the current point.
	        controlX = x + current[1];
	        controlY = y + current[2];
	
	        x = tempX;
	        y = tempY;
	        break;
	
	      case 'S': // shorthand cubic bezierCurveTo, absolute
	        tempX = current[3];
	        tempY = current[4];
	        // calculate reflection of previous control points
	        controlX = 2*x - controlX;
	        controlY = 2*y - controlY;
	        g.bezierCurveTo(
	          controlX + l,
	          controlY + t,
	          current[1] + l,
	          current[2] + t,
	          tempX + l,
	          tempY + t
	        );
	        x = tempX;
	        y = tempY;
	        // set control point to 2nd one of this command
	        // the first control point is assumed to be the reflection of
	        // the second control point on the previous command relative
	        // to the current point.
	        controlX = current[1];
	        controlY = current[2];
	
	        break;
	
	      case 'q': // quadraticCurveTo, relative
	        // transform to absolute x,y
	        tempX = x + current[3];
	        tempY = y + current[4];
	
	        controlX = x + current[1];
	        controlY = y + current[2];
	
	        g.quadraticCurveTo(
	          controlX + l,
	          controlY + t,
	          tempX + l,
	          tempY + t
	        );
	        x = tempX;
	        y = tempY;
	        break;
	
	      case 'Q': // quadraticCurveTo, absolute
	        tempX = current[3];
	        tempY = current[4];
	
	        g.quadraticCurveTo(
	          current[1] + l,
	          current[2] + t,
	          tempX + l,
	          tempY + t
	        );
	        x = tempX;
	        y = tempY;
	        controlX = current[1];
	        controlY = current[2];
	        break;
	
	      case 't': // shorthand quadraticCurveTo, relative
	
	        // transform to absolute x,y
	        tempX = x + current[1];
	        tempY = y + current[2];
	
	        if (previous[0].match(/[QqTt]/) === null) {
	          // If there is no previous command or if the previous command was not a Q, q, T or t,
	          // assume the control point is coincident with the current point
	          controlX = x;
	          controlY = y;
	        }
	        else if (previous[0] === 't') {
	          // calculate reflection of previous control points for t
	          controlX = 2 * x - tempControlX;
	          controlY = 2 * y - tempControlY;
	        }
	        else if (previous[0] === 'q') {
	          // calculate reflection of previous control points for q
	          controlX = 2 * x - controlX;
	          controlY = 2 * y - controlY;
	        }
	
	        tempControlX = controlX;
	        tempControlY = controlY;
	
	        g.quadraticCurveTo(
	          controlX + l,
	          controlY + t,
	          tempX + l,
	          tempY + t
	        );
	        x = tempX;
	        y = tempY;
	        controlX = x + current[1];
	        controlY = y + current[2];
	        break;
	
	      case 'T':
	        tempX = current[1];
	        tempY = current[2];
	
	        // calculate reflection of previous control points
	        controlX = 2 * x - controlX;
	        controlY = 2 * y - controlY;
	        g.quadraticCurveTo(
	          controlX + l,
	          controlY + t,
	          tempX + l,
	          tempY + t
	        );
	        x = tempX;
	        y = tempY;
	        break;
	
	      case 'a':
	        drawArc(g, x + l, y + t, [
	          current[1],
	          current[2],
	          current[3],
	          current[4],
	          current[5],
	          current[6] + x + l,
	          current[7] + y + t
	        ]);
	        x += current[6];
	        y += current[7];
	        break;
	
	      case 'A':
	        drawArc(g, x + l, y + t, [
	          current[1],
	          current[2],
	          current[3],
	          current[4],
	          current[5],
	          current[6] + l,
	          current[7] + t
	        ]);
	        x = current[6];
	        y = current[7];
	        break;
	
	      case 'z':
	      case 'Z':
	        g.closePath();
	        break;
	    }
	    previous = current;
	  }
	};
	
	function drawArc(g, x, y, coords) {
	  var seg = arc.segments(
	    coords[5], // end x
	    coords[6], // end y
	    coords[0], // radius x
	    coords[1], // radius y
	    coords[3], // large flag
	    coords[4], // sweep flag
	    coords[2], // rotation
	    x, y
	  );
	  for (var i=0; i<seg.length; ++i) {
	    var bez = arc.bezier(seg[i]);
	    g.bezierCurveTo.apply(g, bez);
	  }
	}
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/render.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/arc.js **/
jupyter.define('vega-scenegraph@1.1.0/src/path/arc.js', function (module, exports, __jupyter_require__) {
	var segmentCache = {},
	    bezierCache = {},
	    join = [].join;
	
	// Copied from Inkscape svgtopdf, thanks!
	function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
	  var key = join.call(arguments);
	  if (segmentCache[key]) {
	    return segmentCache[key];
	  }
	
	  var th = rotateX * (Math.PI/180);
	  var sin_th = Math.sin(th);
	  var cos_th = Math.cos(th);
	  rx = Math.abs(rx);
	  ry = Math.abs(ry);
	  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
	  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
	  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);
	  if (pl > 1) {
	    pl = Math.sqrt(pl);
	    rx *= pl;
	    ry *= pl;
	  }
	
	  var a00 = cos_th / rx;
	  var a01 = sin_th / rx;
	  var a10 = (-sin_th) / ry;
	  var a11 = (cos_th) / ry;
	  var x0 = a00 * ox + a01 * oy;
	  var y0 = a10 * ox + a11 * oy;
	  var x1 = a00 * x + a01 * y;
	  var y1 = a10 * x + a11 * y;
	
	  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);
	  var sfactor_sq = 1 / d - 0.25;
	  if (sfactor_sq < 0) sfactor_sq = 0;
	  var sfactor = Math.sqrt(sfactor_sq);
	  if (sweep == large) sfactor = -sfactor;
	  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);
	  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);
	
	  var th0 = Math.atan2(y0-yc, x0-xc);
	  var th1 = Math.atan2(y1-yc, x1-xc);
	
	  var th_arc = th1-th0;
	  if (th_arc < 0 && sweep === 1){
	    th_arc += 2 * Math.PI;
	  } else if (th_arc > 0 && sweep === 0) {
	    th_arc -= 2 * Math.PI;
	  }
	
	  var segs = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
	  var result = [];
	  for (var i=0; i<segs; ++i) {
	    var th2 = th0 + i * th_arc / segs;
	    var th3 = th0 + (i+1) * th_arc / segs;
	    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
	  }
	
	  return (segmentCache[key] = result);
	}
	
	function bezier(params) {
	  var key = join.call(params);
	  if (bezierCache[key]) {
	    return bezierCache[key];
	  }
	  
	  var cx = params[0],
	      cy = params[1],
	      th0 = params[2],
	      th1 = params[3],
	      rx = params[4],
	      ry = params[5],
	      sin_th = params[6],
	      cos_th = params[7];
	
	  var a00 = cos_th * rx;
	  var a01 = -sin_th * ry;
	  var a10 = sin_th * rx;
	  var a11 = cos_th * ry;
	
	  var cos_th0 = Math.cos(th0);
	  var sin_th0 = Math.sin(th0);
	  var cos_th1 = Math.cos(th1);
	  var sin_th1 = Math.sin(th1);
	
	  var th_half = 0.5 * (th1 - th0);
	  var sin_th_h2 = Math.sin(th_half * 0.5);
	  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
	  var x1 = cx + cos_th0 - t * sin_th0;
	  var y1 = cy + sin_th0 + t * cos_th0;
	  var x3 = cx + cos_th1;
	  var y3 = cy + sin_th1;
	  var x2 = x3 + t * sin_th1;
	  var y2 = y3 - t * cos_th1;
	
	  return (bezierCache[key] = [
	    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,
	    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,
	    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3
	  ]);
	}
	
	module.exports = {
	  segments: segments,
	  bezier: bezier,
	  cache: {
	    segments: segmentCache,
	    bezier: bezierCache
	  }
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/path/arc.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/index.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  'canvas': __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/index.js'),
	  'svg':    __jupyter_require__('vega-scenegraph@~1.1.0/src/render/svg/index.js')
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/index.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/index.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  Handler:  __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/CanvasHandler.js'),
	  Renderer: __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/CanvasRenderer.js')
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/index.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/CanvasHandler.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/CanvasHandler.js', function (module, exports, __jupyter_require__) {
	var DOM = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/dom.js'),
	    Handler = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/Handler.js'),
	    marks = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/index.js');
	
	function CanvasHandler() {
	  Handler.call(this);
	  this._down = null;
	  this._touch = null;
	  this._first = true;
	}
	
	var base = Handler.prototype;
	var prototype = (CanvasHandler.prototype = Object.create(base));
	prototype.constructor = CanvasHandler;
	
	prototype.initialize = function(el, pad, obj) {
	  // add event listeners
	  var canvas = this._canvas = DOM.find(el, 'canvas');
	  if (canvas) {
	    var that = this;
	    this.events.forEach(function(type) {
	      canvas.addEventListener(type, function(evt) {
	        if (prototype[type]) {
	          prototype[type].call(that, evt);
	        } else {
	          that.fire(type, evt);
	        }
	      });
	    });
	  }
	
	  return base.initialize.call(this, el, pad, obj);
	};
	
	prototype.canvas = function() {
	  return this._canvas;
	};
	
	// retrieve the current canvas context
	prototype.context = function() {
	  return this._canvas.getContext('2d');
	};
	
	// supported events
	prototype.events = [
	  'keydown',
	  'keypress',
	  'keyup',
	  'dragenter',
	  'dragleave',
	  'dragover',
	  'mousedown',
	  'mouseup',
	  'mousemove',
	  'mouseout',
	  'mouseover',
	  'click',
	  'dblclick',
	  'wheel',
	  'mousewheel',
	  'touchstart',
	  'touchmove',
	  'touchend'
	];
	
	// to keep firefox happy
	prototype.DOMMouseScroll = function(evt) {
	  this.fire('mousewheel', evt);
	};
	
	function move(moveEvent, overEvent, outEvent) {
	  return function(evt) {
	    var a = this._active,
	        p = this.pickEvent(evt);
	
	    if (p === a) {
	      // active item and picked item are the same
	      this.fire(moveEvent, evt); // fire move
	    } else {
	      // active item and picked item are different
	      this.fire(outEvent, evt);  // fire out for prior active item
	      this._active = p;            // set new active item
	      this.fire(overEvent, evt); // fire over for new active item
	      this.fire(moveEvent, evt); // fire move for new active item
	    }
	  };
	}
	
	function inactive(type) {
	  return function(evt) {
	    this.fire(type, evt);
	    this._active = null;
	  };
	}
	
	prototype.mousemove = move('mousemove', 'mouseover', 'mouseout');
	prototype.dragover  = move('dragover', 'dragenter', 'dragleave');
	
	prototype.mouseout  = inactive('mouseout');
	prototype.dragleave = inactive('dragleave');
	
	prototype.mousedown = function(evt) {
	  this._down = this._active;
	  this.fire('mousedown', evt);
	};
	
	prototype.click = function(evt) {
	  if (this._down === this._active) {
	    this.fire('click', evt);
	    this._down = null;
	  }
	};
	
	prototype.touchstart = function(evt) {
	  this._touch = this.pickEvent(evt.changedTouches[0]);
	
	  if (this._first) {
	    this._active = this._touch;
	    this._first = false;
	  }
	
	  this.fire('touchstart', evt, true);
	};
	
	prototype.touchmove = function(evt) {
	  this.fire('touchmove', evt, true);
	};
	
	prototype.touchend = function(evt) {
	  this.fire('touchend', evt, true);
	  this._touch = null;
	};
	
	// fire an event
	prototype.fire = function(type, evt, touch) {
	  var a = touch ? this._touch : this._active,
	      h = this._handlers[type], i, len;
	  if (h) {
	    evt.vegaType = type;
	    for (i=0, len=h.length; i<len; ++i) {
	      h[i].handler.call(this._obj, evt, a);
	    }
	  }
	};
	
	// add an event handler
	prototype.on = function(type, handler) {
	  var name = this.eventName(type),
	      h = this._handlers;
	  (h[name] || (h[name] = [])).push({
	    type: type,
	    handler: handler
	  });
	  return this;
	};
	
	// remove an event handler
	prototype.off = function(type, handler) {
	  var name = this.eventName(type),
	      h = this._handlers[name], i;
	  if (!h) return;
	  for (i=h.length; --i>=0;) {
	    if (h[i].type !== type) continue;
	    if (!handler || h[i].handler === handler) h.splice(i, 1);
	  }
	  return this;
	};
	
	prototype.pickEvent = function(evt) {
	  var rect = this._canvas.getBoundingClientRect(),
	      pad = this._padding, x, y;
	  return this.pick(this._scene,
	    x = (evt.clientX - rect.left),
	    y = (evt.clientY - rect.top),
	    x - pad.left, y - pad.top);
	};
	
	// find the scenegraph item at the current mouse position
	// x, y -- the absolute x, y mouse coordinates on the canvas element
	// gx, gy -- the relative coordinates within the current group
	prototype.pick = function(scene, x, y, gx, gy) {
	  var g = this.context(),
	      mark = marks[scene.marktype];
	  return mark.pick.call(this, g, scene, x, y, gx, gy);
	};
	
	module.exports = CanvasHandler;
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/CanvasHandler.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/dom.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/dom.js', function (module, exports, __jupyter_require__) {
	// create a new DOM element
	function create(doc, tag, ns) {
	  return ns ? doc.createElementNS(ns, tag) : doc.createElement(tag);
	}
	
	// remove element from DOM
	// recursively remove parent elements if empty
	function remove(el) {
	  if (!el) return;
	  var p = el.parentNode;
	  if (p) {
	    p.removeChild(el);
	    if (!p.childNodes || !p.childNodes.length) remove(p);
	  }
	}
	
	module.exports = {
	  // find first child element with matching tag
	  find: function(el, tag) {
	    tag = tag.toLowerCase();
	    for (var i=0, n=el.childNodes.length; i<n; ++i) {
	      if (el.childNodes[i].tagName.toLowerCase() === tag) {
	        return el.childNodes[i];
	      }
	    }
	  },
	  // retrieve child element at given index
	  // create & insert if doesn't exist or if tag/className do not match
	  child: function(el, index, tag, ns, className, insert) {
	    var a, b;
	    a = b = el.childNodes[index];
	    if (!a || insert ||
	        a.tagName.toLowerCase() !== tag.toLowerCase() ||
	        className && a.getAttribute('class') != className) {
	      a = create(el.ownerDocument, tag, ns);
	      el.insertBefore(a, b || null);
	      if (className) a.setAttribute('class', className);
	    }
	    return a;
	  },
	  // remove all child elements at or above the given index
	  clear: function(el, index) {
	    var curr = el.childNodes.length;
	    while (curr > index) {
	      el.removeChild(el.childNodes[--curr]);
	    }
	    return el;
	  },
	  remove: remove,
	  // generate css class name for mark
	  cssClass: function(mark) {
	    return 'mark-' + mark.marktype + (mark.name ? ' '+mark.name : '');
	  },
	  // generate string for an opening xml tag
	  // tag: the name of the xml tag
	  // attr: hash of attribute name-value pairs to include
	  // raw: additional raw string to include in tag markup
	  openTag: function(tag, attr, raw) {
	    var s = '<' + tag, key, val;
	    if (attr) {
	      for (key in attr) {
	        val = attr[key];
	        if (val != null) {
	          s += ' ' + key + '="' + val + '"';
	        }
	      }
	    }
	    if (raw) s += ' ' + raw;
	    return s + '>';
	  },
	  // generate string for closing xml tag
	  // tag: the name of the xml tag
	  closeTag: function(tag) {
	    return '</' + tag + '>';
	  }
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/dom.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/Handler.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/Handler.js', function (module, exports, __jupyter_require__) {
	function Handler() {
	  this._active = null;
	  this._handlers = {};
	}
	
	var prototype = Handler.prototype;
	
	prototype.initialize = function(el, pad, obj) {
	  this._el = el;
	  this._obj = obj || null;
	  return this.padding(pad);
	};
	
	prototype.element = function() {
	  return this._el;
	};
	
	prototype.padding = function(pad) {
	  this._padding = pad || {top:0, left:0, bottom:0, right:0};
	  return this;
	};
	
	prototype.scene = function(scene) {
	  if (!arguments.length) return this._scene;
	  this._scene = scene;
	  return this;
	};
	
	// add an event handler
	// subclasses should override
	prototype.on = function(/*type, handler*/) {};
	
	// remove an event handler
	// subclasses should override
	prototype.off = function(/*type, handler*/) {};
	
	// return an array with all registered event handlers
	prototype.handlers = function() {
	  var h = this._handlers, a = [], k;
	  for (k in h) { a.push.apply(a, h[k]); }
	  return a;
	};
	
	prototype.eventName = function(name) {
	  var i = name.indexOf('.');
	  return i < 0 ? name : name.slice(0,i);
	};
	
	module.exports = Handler;
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/Handler.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/index.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  arc:    __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/arc.js'),
	  area:   __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/area.js'),
	  group:  __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/group.js'),
	  image:  __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/image.js'),
	  line:   __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/line.js'),
	  path:   __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/path.js'),
	  rect:   __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/rect.js'),
	  rule:   __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/rule.js'),
	  symbol: __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/symbol.js'),
	  text:   __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/text.js')
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/index.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/arc.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/arc.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js');
	var halfpi = Math.PI / 2;
	
	function path(g, o) {
	  var x = o.x || 0,
	      y = o.y || 0,
	      ir = o.innerRadius || 0,
	      or = o.outerRadius || 0,
	      sa = (o.startAngle || 0) - halfpi,
	      ea = (o.endAngle || 0) - halfpi;
	  g.beginPath();
	  if (ir === 0) g.moveTo(x, y);
	  else g.arc(x, y, ir, sa, ea, 0);
	  g.arc(x, y, or, ea, sa, 1);
	  g.closePath();
	}
	
	module.exports = {
	  draw: util.drawAll(path),
	  pick: util.pickPath(path)
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/arc.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/util.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/util.js', function (module, exports, __jupyter_require__) {
	function drawPathOne(path, g, o, items) {
	  if (path(g, items)) return;
	
	  var opac = o.opacity == null ? 1 : o.opacity;
	  if (opac===0) return;
	
	  if (o.fill && fill(g, o, opac)) { g.fill(); }
	  if (o.stroke && stroke(g, o, opac)) { g.stroke(); }
	}
	
	function drawPathAll(path, g, scene, bounds) {
	  var i, len, item;
	  for (i=0, len=scene.items.length; i<len; ++i) {
	    item = scene.items[i];
	    if (!bounds || bounds.intersects(item.bounds)) {
	      drawPathOne(path, g, item, item);
	    }
	  }
	}
	
	function drawAll(pathFunc) {
	  return function(g, scene, bounds) {
	    drawPathAll(pathFunc, g, scene, bounds);
	  };
	}
	
	function drawOne(pathFunc) {
	  return function(g, scene, bounds) {
	    if (!scene.items.length) return;
	    if (!bounds || bounds.intersects(scene.bounds)) {
	      drawPathOne(pathFunc, g, scene.items[0], scene.items);
	    }
	  };
	}
	
	var trueFunc = function() { return true; };
	
	function pick(test) {
	  if (!test) test = trueFunc;
	
	  return function(g, scene, x, y, gx, gy) {
	    if (!scene.items.length) return null;
	
	    var o, b, i;
	
	    if (g.pixelratio != null && g.pixelratio !== 1) {
	      x *= g.pixelratio;
	      y *= g.pixelratio;
	    }
	
	    for (i=scene.items.length; --i >= 0;) {
	      o = scene.items[i]; b = o.bounds;
	      // first hit test against bounding box
	      if ((b && !b.contains(gx, gy)) || !b) continue;
	      // if in bounding box, perform more careful test
	      if (test(g, o, x, y, gx, gy)) return o;
	    }
	    return null;
	  };
	}
	
	function testPath(path, filled) {
	  return function(g, o, x, y) {
	    var item = Array.isArray(o) ? o[0] : o,
	        fill = (filled == null) ? item.fill : filled,
	        stroke = item.stroke && g.isPointInStroke, lw, lc;
	
	    if (stroke) {
	      lw = item.strokeWidth;
	      lc = item.strokeCap;
	      g.lineWidth = lw != null ? lw : 1;
	      g.lineCap   = lc != null ? lc : 'butt';
	    }
	
	    return path(g, o) ? false :
	      (fill && g.isPointInPath(x, y)) ||
	      (stroke && g.isPointInStroke(x, y));
	  };
	}
	
	function pickPath(path) {
	  return pick(testPath(path));
	}
	
	function fill(g, o, opacity) {
	  opacity *= (o.fillOpacity==null ? 1 : o.fillOpacity);
	  if (opacity > 0) {
	    g.globalAlpha = opacity;
	    g.fillStyle = color(g, o, o.fill);
	    return true;
	  } else {
	    return false;
	  }
	}
	
	function stroke(g, o, opacity) {
	  var lw = (lw = o.strokeWidth) != null ? lw : 1, lc;
	  if (lw <= 0) return false;
	
	  opacity *= (o.strokeOpacity==null ? 1 : o.strokeOpacity);
	  if (opacity > 0) {
	    g.globalAlpha = opacity;
	    g.strokeStyle = color(g, o, o.stroke);
	    g.lineWidth = lw;
	    g.lineCap = (lc = o.strokeCap) != null ? lc : 'butt';
	    g.vgLineDash(o.strokeDash || null);
	    g.vgLineDashOffset(o.strokeDashOffset || 0);
	    return true;
	  } else {
	    return false;
	  }
	}
	
	function color(g, o, value) {
	  return (value.id) ?
	    gradient(g, value, o.bounds) :
	    value;
	}
	
	function gradient(g, p, b) {
	  var w = b.width(),
	      h = b.height(),
	      x1 = b.x1 + p.x1 * w,
	      y1 = b.y1 + p.y1 * h,
	      x2 = b.x1 + p.x2 * w,
	      y2 = b.y1 + p.y2 * h,
	      grad = g.createLinearGradient(x1, y1, x2, y2),
	      stop = p.stops,
	      i, n;
	
	  for (i=0, n=stop.length; i<n; ++i) {
	    grad.addColorStop(stop[i].offset, stop[i].color);
	  }
	  return grad;
	}
	
	module.exports = {
	  drawOne:  drawOne,
	  drawAll:  drawAll,
	  pick:     pick,
	  pickPath: pickPath,
	  testPath: testPath,
	  stroke:   stroke,
	  fill:     fill,
	  color:    color,
	  gradient: gradient
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/util.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/area.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/area.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js'),
	    parse = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/parse.js'),
	    render = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/render.js'),
	    areaPath = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/svg.js').path.area;
	
	function path(g, items) {
	  var o = items[0],
	      p = o.pathCache || (o.pathCache = parse(areaPath(items)));
	  render(g, p);
	}
	
	function pick(g, scene, x, y, gx, gy) {
	  var items = scene.items,
	      b = scene.bounds;
	
	  if (!items || !items.length || b && !b.contains(gx, gy)) {
	    return null;
	  }
	
	  if (g.pixelratio != null && g.pixelratio !== 1) {
	    x *= g.pixelratio;
	    y *= g.pixelratio;
	  }
	  return hit(g, items, x, y) ? items[0] : null;
	}
	
	var hit = util.testPath(path);
	
	module.exports = {
	  draw: util.drawOne(path),
	  pick: pick,
	  nested: true
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/area.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/svg.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/svg.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    d3_svg = __jupyter_require__('d3@3.5.17/d3.js').svg,
	    parse = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/parse.js');
	
	function x(o)     { return o.x || 0; }
	function y(o)     { return o.y || 0; }
	function xw(o)    { return (o.x || 0) + (o.width || 0); }
	function yh(o)    { return (o.y || 0) + (o.height || 0); }
	function size(o)  { return o.size == null ? 100 : o.size; }
	function shape(o) { return o.shape || 'circle'; }
	
	var areav = d3_svg.area().x(x).y1(y).y0(yh),
	    areah = d3_svg.area().y(y).x1(x).x0(xw),
	    line  = d3_svg.line().x(x).y(y);
	
	module.exports = {
	  metadata: {
	    'version': '1.1',
	    'xmlns': 'http://www.w3.org/2000/svg',
	    'xmlns:xlink': 'http://www.w3.org/1999/xlink'
	  },
	  path: {
	    arc: d3_svg.arc(),
	    symbol: d3_svg.symbol().type(shape).size(size),
	    area: function(items) {
	      var o = items[0];
	      return (o.orient === 'horizontal' ? areah : areav)
	        .interpolate(o.interpolate || 'linear')
	        .tension(o.tension || 0.7)
	        (items);
	    },
	    line: function(items) {
	      var o = items[0];
	      return line
	        .interpolate(o.interpolate || 'linear')
	        .tension(o.tension || 0.7)
	        (items);
	    },
	    resize: function(pathStr, size) {
	      var path = parse(pathStr),
	          newPath = '',
	          command, current, index, i, n, j, m;
	
	      size = Math.sqrt(size);
	      for (i=0, n=path.length; i<n; ++i) {
	        for (command=path[i], j=0, m=command.length; j<m; ++j) {
	          if (command[j] === 'Z') break;
	          if ((current = +command[j]) === current) {
	            // if number, need to resize
	            index = pathStr.indexOf(current);
	            newPath += pathStr.substring(0, index) + (current * size);
	            pathStr  = pathStr.substring(index + (current+'').length);
	          }
	        }
	      }
	
	      return newPath + 'Z';
	    }
	  },
	  symbolTypes: dl.toMap(d3_svg.symbolTypes),
	  textAlign: {
	    'left':   'start',
	    'center': 'middle',
	    'right':  'end'
	  },
	  textBaseline: {
	    'top':    'before-edge',
	    'bottom': 'after-edge',
	    'middle': 'central'
	  },
	  styles: {
	    'fill':             'fill',
	    'fillOpacity':      'fill-opacity',
	    'stroke':           'stroke',
	    'strokeWidth':      'stroke-width',
	    'strokeOpacity':    'stroke-opacity',
	    'strokeCap':        'stroke-linecap',
	    'strokeDash':       'stroke-dasharray',
	    'strokeDashOffset': 'stroke-dashoffset',
	    'opacity':          'opacity'
	  },
	  styleProperties: [
	    'fill',
	    'fillOpacity',
	    'stroke',
	    'strokeWidth',
	    'strokeOpacity',
	    'strokeCap',
	    'strokeDash',
	    'strokeDashOffset',
	    'opacity'
	  ]
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/svg.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/group.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/group.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js'),
	    EMPTY = [];
	
	function draw(g, scene, bounds) {
	  if (!scene.items || !scene.items.length) return;
	
	  var groups = scene.items,
	      renderer = this,
	      group, items, axes, legends, gx, gy, w, h, opac, i, n, j, m;
	
	  for (i=0, n=groups.length; i<n; ++i) {
	    group = groups[i];
	    axes = group.axisItems || EMPTY;
	    items = group.items || EMPTY;
	    legends = group.legendItems || EMPTY;
	    gx = group.x || 0;
	    gy = group.y || 0;
	    w = group.width || 0;
	    h = group.height || 0;
	
	    // draw group background
	    if (group.stroke || group.fill) {
	      opac = group.opacity == null ? 1 : group.opacity;
	      if (opac > 0) {
	        if (group.fill && util.fill(g, group, opac)) {
	          g.fillRect(gx, gy, w, h);
	        }
	        if (group.stroke && util.stroke(g, group, opac)) {
	          g.strokeRect(gx, gy, w, h);
	        }
	      }
	    }
	
	    // setup graphics context
	    g.save();
	    g.translate(gx, gy);
	    if (group.clip) {
	      g.beginPath();
	      g.rect(0, 0, w, h);
	      g.clip();
	    }
	    if (bounds) bounds.translate(-gx, -gy);
	
	    // draw group contents
	    for (j=0, m=axes.length; j<m; ++j) {
	      if (axes[j].layer === 'back') {
	        renderer.draw(g, axes[j], bounds);
	      }
	    }
	    for (j=0, m=items.length; j<m; ++j) {
	      renderer.draw(g, items[j], bounds);
	    }
	    for (j=0, m=axes.length; j<m; ++j) {
	      if (axes[j].layer !== 'back') {
	        renderer.draw(g, axes[j], bounds);
	      }
	    }
	    for (j=0, m=legends.length; j<m; ++j) {
	      renderer.draw(g, legends[j], bounds);
	    }
	
	    // restore graphics context
	    if (bounds) bounds.translate(gx, gy);
	    g.restore();
	  }    
	}
	
	function pick(g, scene, x, y, gx, gy) {
	  if (scene.bounds && !scene.bounds.contains(gx, gy)) {
	    return null;
	  }
	
	  var groups = scene.items || EMPTY, subscene,
	      group, axes, items, legends, hits, dx, dy, i, j, b;
	
	  for (i=groups.length; --i>=0;) {
	    group = groups[i];
	
	    // first hit test against bounding box
	    // if a group is clipped, that should be handled by the bounds check.
	    b = group.bounds;
	    if (b && !b.contains(gx, gy)) continue;
	
	    // passed bounds check, so test sub-groups
	    axes = group.axisItems || EMPTY;
	    items = group.items || EMPTY;
	    legends = group.legendItems || EMPTY;
	    dx = (group.x || 0);
	    dy = (group.y || 0);
	
	    g.save();
	    g.translate(dx, dy);
	    dx = gx - dx;
	    dy = gy - dy;
	    for (j=legends.length; --j>=0;) {
	      subscene = legends[j];
	      if (subscene.interactive !== false) {
	        hits = this.pick(subscene, x, y, dx, dy);
	        if (hits) { g.restore(); return hits; }
	      }
	    }
	    for (j=axes.length; --j>=0;) {
	      subscene = axes[j];
	      if (subscene.interactive !== false && subscene.layer !== 'back') {
	        hits = this.pick(subscene, x, y, dx, dy);
	        if (hits) { g.restore(); return hits; }
	      }
	    }
	    for (j=items.length; --j>=0;) {
	      subscene = items[j];
	      if (subscene.interactive !== false) {
	        hits = this.pick(subscene, x, y, dx, dy);
	        if (hits) { g.restore(); return hits; }
	      }
	    }
	    for (j=axes.length; --j>=0;) {
	      subscene = axes[j];
	      if (subscene.interative !== false && subscene.layer === 'back') {
	        hits = this.pick(subscene, x, y, dx, dy);
	        if (hits) { g.restore(); return hits; }
	      }
	    }
	    g.restore();
	
	    if (scene.interactive !== false && (group.fill || group.stroke) &&
	        dx >= 0 && dx <= group.width && dy >= 0 && dy <= group.height) {
	      return group;
	    }
	  }
	
	  return null;
	}
	
	module.exports = {
	  draw: draw,
	  pick: pick
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/group.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/image.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/image.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js');
	
	function draw(g, scene, bounds) {
	  if (!scene.items || !scene.items.length) return;
	
	  var renderer = this,
	      items = scene.items, o;
	
	  for (var i=0, len=items.length; i<len; ++i) {
	    o = items[i];
	    if (bounds && !bounds.intersects(o.bounds))
	      continue; // bounds check
	
	    if (!(o.image && o.image.url === o.url)) {
	      o.image = renderer.loadImage(o.url);
	      o.image.url = o.url;
	    }
	
	    var x = o.x || 0,
	        y = o.y || 0,
	        w = o.width || (o.image && o.image.width) || 0,
	        h = o.height || (o.image && o.image.height) || 0,
	        opac;
	    x = x - (o.align==='center' ? w/2 : o.align==='right' ? w : 0);
	    y = y - (o.baseline==='middle' ? h/2 : o.baseline==='bottom' ? h : 0);
	
	    if (o.image.loaded) {
	      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;
	      g.drawImage(o.image, x, y, w, h);
	    }
	  }
	}
	
	module.exports = {
	  draw: draw,
	  pick: util.pick()
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/image.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/line.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/line.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js'),
	    parse = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/parse.js'),
	    render = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/render.js'),
	    linePath = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/svg.js').path.line;
	    
	function path(g, items) {
	  var o = items[0],
	      p = o.pathCache || (o.pathCache = parse(linePath(items)));
	  render(g, p);
	}
	
	function pick(g, scene, x, y, gx, gy) {
	  var items = scene.items,
	      b = scene.bounds;
	
	  if (!items || !items.length || b && !b.contains(gx, gy)) {
	    return null;
	  }
	
	  if (g.pixelratio != null && g.pixelratio !== 1) {
	    x *= g.pixelratio;
	    y *= g.pixelratio;
	  }
	  return hit(g, items, x, y) ? items[0] : null;
	}
	
	var hit = util.testPath(path, false);
	
	module.exports = {
	  draw: util.drawOne(path),
	  pick: pick,
	  nested: true
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/line.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/path.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/path.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js'),
	    parse = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/parse.js'),
	    render = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/render.js');
	
	function path(g, o) {
	  if (o.path == null) return true;
	  var p = o.pathCache || (o.pathCache = parse(o.path));
	  render(g, p, o.x, o.y);
	}
	
	module.exports = {
	  draw: util.drawAll(path),
	  pick: util.pickPath(path)
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/path.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/rect.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/rect.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js');
	
	function draw(g, scene, bounds) {
	  if (!scene.items || !scene.items.length) return;
	
	  var items = scene.items,
	      o, opac, x, y, w, h;
	
	  for (var i=0, len=items.length; i<len; ++i) {
	    o = items[i];
	    if (bounds && !bounds.intersects(o.bounds))
	      continue; // bounds check
	
	    opac = o.opacity == null ? 1 : o.opacity;
	    if (opac === 0) continue;
	
	    x = o.x || 0;
	    y = o.y || 0;
	    w = o.width || 0;
	    h = o.height || 0;
	
	    if (o.fill && util.fill(g, o, opac)) {
	      g.fillRect(x, y, w, h);
	    }
	    if (o.stroke && util.stroke(g, o, opac)) {
	      g.strokeRect(x, y, w, h);
	    }
	  }
	}
	
	module.exports = {
	  draw: draw,
	  pick: util.pick()
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/rect.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/rule.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/rule.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js');
	
	function draw(g, scene, bounds) {
	  if (!scene.items || !scene.items.length) return;
	
	  var items = scene.items,
	      o, opac, x1, y1, x2, y2;
	
	  for (var i=0, len=items.length; i<len; ++i) {
	    o = items[i];
	    if (bounds && !bounds.intersects(o.bounds))
	      continue; // bounds check
	
	    opac = o.opacity == null ? 1 : o.opacity;
	    if (opac === 0) continue;
	      
	    x1 = o.x || 0;
	    y1 = o.y || 0;
	    x2 = o.x2 != null ? o.x2 : x1;
	    y2 = o.y2 != null ? o.y2 : y1;
	
	    if (o.stroke && util.stroke(g, o, opac)) {
	      g.beginPath();
	      g.moveTo(x1, y1);
	      g.lineTo(x2, y2);
	      g.stroke();
	    }
	  }
	}
	
	function stroke(g, o) {
	  var x1 = o.x || 0,
	      y1 = o.y || 0,
	      x2 = o.x2 != null ? o.x2 : x1,
	      y2 = o.y2 != null ? o.y2 : y1,
	      lw = o.strokeWidth,
	      lc = o.strokeCap;
	
	  g.lineWidth = lw != null ? lw : 1;
	  g.lineCap   = lc != null ? lc : 'butt';
	  g.beginPath();
	  g.moveTo(x1, y1);
	  g.lineTo(x2, y2);
	}
	
	function hit(g, o, x, y) {
	  if (!g.isPointInStroke) return false;
	  stroke(g, o);
	  return g.isPointInStroke(x, y);
	}
	
	module.exports = {
	  draw: draw,
	  pick: util.pick(hit)
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/rule.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/symbol.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/symbol.js', function (module, exports, __jupyter_require__) {
	var util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js'),
	    parse = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/parse.js'),
	    render = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/render.js');
	
	var sqrt3 = Math.sqrt(3),
	    tan30 = Math.tan(30 * Math.PI / 180);
	
	function path(g, o) {
	  var size = o.size != null ? o.size : 100,
	      x = o.x, y = o.y, r, t, rx, ry;
	
	  g.beginPath();
	
	  if (o.shape == null || o.shape === 'circle') {
	    r = Math.sqrt(size / Math.PI);
	    g.arc(x, y, r, 0, 2*Math.PI, 0);
	    g.closePath();
	    return;
	  }
	
	  switch (o.shape) {
	    case 'cross':
	      r = Math.sqrt(size / 5) / 2;
	      t = 3*r;
	      g.moveTo(x-t, y-r);
	      g.lineTo(x-r, y-r);
	      g.lineTo(x-r, y-t);
	      g.lineTo(x+r, y-t);
	      g.lineTo(x+r, y-r);
	      g.lineTo(x+t, y-r);
	      g.lineTo(x+t, y+r);
	      g.lineTo(x+r, y+r);
	      g.lineTo(x+r, y+t);
	      g.lineTo(x-r, y+t);
	      g.lineTo(x-r, y+r);
	      g.lineTo(x-t, y+r);
	      break;
	
	    case 'diamond':
	      ry = Math.sqrt(size / (2 * tan30));
	      rx = ry * tan30;
	      g.moveTo(x, y-ry);
	      g.lineTo(x+rx, y);
	      g.lineTo(x, y+ry);
	      g.lineTo(x-rx, y);
	      break;
	
	    case 'square':
	      t = Math.sqrt(size);
	      r = t / 2;
	      g.rect(x-r, y-r, t, t);
	      break;
	
	    case 'triangle-down':
	      rx = Math.sqrt(size / sqrt3);
	      ry = rx * sqrt3 / 2;
	      g.moveTo(x, y+ry);
	      g.lineTo(x+rx, y-ry);
	      g.lineTo(x-rx, y-ry);
	      break;
	
	    case 'triangle-up':
	      rx = Math.sqrt(size / sqrt3);
	      ry = rx * sqrt3 / 2;
	      g.moveTo(x, y-ry);
	      g.lineTo(x+rx, y+ry);
	      g.lineTo(x-rx, y+ry);
	      break;
	
	    // custom shape
	    default:
	      var pathArray = resize(parse(o.shape), size);
	      render(g, pathArray, x, y);
	  }
	  g.closePath();
	}
	
	// Scale custom shapes (defined within a unit square) by given size.
	function resize(path, size) {
	  var sz = Math.sqrt(size),
	      i, n, j, m, curr;
	
	  for (i=0, n=path.length; i<n; ++i) {
	    for (curr=path[i], j=1, m=curr.length; j<m; ++j) {
	      curr[j] *= sz;
	    }
	  }
	  return path;
	}
	
	module.exports = {
	  draw: util.drawAll(path),
	  pick: util.pickPath(path)
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/symbol.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/text.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/marks/text.js', function (module, exports, __jupyter_require__) {
	var Bounds = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/Bounds.js'),
	    textBounds = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/bound.js').text,
	    text = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/text.js'),
	    util = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/util.js'),
	    tempBounds = new Bounds();
	
	function draw(g, scene, bounds) {
	  if (!scene.items || !scene.items.length) return;
	
	  var items = scene.items,
	      o, opac, x, y, r, t, str;
	
	  for (var i=0, len=items.length; i<len; ++i) {
	    o = items[i];
	    if (bounds && !bounds.intersects(o.bounds))
	      continue; // bounds check
	
	    str = text.value(o.text);
	    if (!str) continue;
	    opac = o.opacity == null ? 1 : o.opacity;
	    if (opac === 0) continue;
	
	    g.font = text.font(o);
	    g.textAlign = o.align || 'left';
	
	    x = (o.x || 0);
	    y = (o.y || 0);
	    if ((r = o.radius)) {
	      t = (o.theta || 0) - Math.PI/2;
	      x += r * Math.cos(t);
	      y += r * Math.sin(t);
	    }
	
	    if (o.angle) {
	      g.save();
	      g.translate(x, y);
	      g.rotate(o.angle * Math.PI/180);
	      x = y = 0; // reset x, y
	    }
	    x += (o.dx || 0);
	    y += (o.dy || 0) + text.offset(o);
	
	    if (o.fill && util.fill(g, o, opac)) {
	      g.fillText(str, x, y);
	    }
	    if (o.stroke && util.stroke(g, o, opac)) {
	      g.strokeText(str, x, y);
	    }
	    if (o.angle) g.restore();
	  }
	}
	
	function hit(g, o, x, y, gx, gy) {
	  if (o.fontSize <= 0) return false;
	  if (!o.angle) return true; // bounds sufficient if no rotation
	
	  // project point into space of unrotated bounds
	  var b = textBounds(o, tempBounds, true),
	      a = -o.angle * Math.PI / 180,
	      cos = Math.cos(a),
	      sin = Math.sin(a),
	      ox = o.x,
	      oy = o.y,
	      px = cos*gx - sin*gy + (ox - ox*cos + oy*sin),
	      py = sin*gx + cos*gy + (oy - ox*sin - oy*cos);
	
	  return b.contains(px, py);
	}
	
	module.exports = {
	  draw: draw,
	  pick: util.pick(hit)
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/marks/text.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/Bounds.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/Bounds.js', function (module, exports, __jupyter_require__) {
	function Bounds(b) {
	  this.clear();
	  if (b) this.union(b);
	}
	
	var prototype = Bounds.prototype;
	
	prototype.clone = function() {
	  return new Bounds(this);
	};
	
	prototype.clear = function() {
	  this.x1 = +Number.MAX_VALUE;
	  this.y1 = +Number.MAX_VALUE;
	  this.x2 = -Number.MAX_VALUE;
	  this.y2 = -Number.MAX_VALUE;
	  return this;
	};
	
	prototype.set = function(x1, y1, x2, y2) {
	  this.x1 = x1;
	  this.y1 = y1;
	  this.x2 = x2;
	  this.y2 = y2;
	  return this;
	};
	
	prototype.add = function(x, y) {
	  if (x < this.x1) this.x1 = x;
	  if (y < this.y1) this.y1 = y;
	  if (x > this.x2) this.x2 = x;
	  if (y > this.y2) this.y2 = y;
	  return this;
	};
	
	prototype.expand = function(d) {
	  this.x1 -= d;
	  this.y1 -= d;
	  this.x2 += d;
	  this.y2 += d;
	  return this;
	};
	
	prototype.round = function() {
	  this.x1 = Math.floor(this.x1);
	  this.y1 = Math.floor(this.y1);
	  this.x2 = Math.ceil(this.x2);
	  this.y2 = Math.ceil(this.y2);
	  return this;
	};
	
	prototype.translate = function(dx, dy) {
	  this.x1 += dx;
	  this.x2 += dx;
	  this.y1 += dy;
	  this.y2 += dy;
	  return this;
	};
	
	prototype.rotate = function(angle, x, y) {
	  var cos = Math.cos(angle),
	      sin = Math.sin(angle),
	      cx = x - x*cos + y*sin,
	      cy = y - x*sin - y*cos,
	      x1 = this.x1, x2 = this.x2,
	      y1 = this.y1, y2 = this.y2;
	
	  return this.clear()
	    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)
	    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)
	    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)
	    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);
	};
	
	prototype.union = function(b) {
	  if (b.x1 < this.x1) this.x1 = b.x1;
	  if (b.y1 < this.y1) this.y1 = b.y1;
	  if (b.x2 > this.x2) this.x2 = b.x2;
	  if (b.y2 > this.y2) this.y2 = b.y2;
	  return this;
	};
	
	prototype.encloses = function(b) {
	  return b && (
	    this.x1 <= b.x1 &&
	    this.x2 >= b.x2 &&
	    this.y1 <= b.y1 &&
	    this.y2 >= b.y2
	  );
	};
	
	prototype.alignsWith = function(b) {
	  return b && (
	    this.x1 == b.x1 ||
	    this.x2 == b.x2 ||
	    this.y1 == b.y1 ||
	    this.y2 == b.y2
	  );
	};
	
	prototype.intersects = function(b) {
	  return b && !(
	    this.x2 < b.x1 ||
	    this.x1 > b.x2 ||
	    this.y2 < b.y1 ||
	    this.y1 > b.y2
	  );
	};
	
	prototype.contains = function(x, y) {
	  return !(
	    x < this.x1 ||
	    x > this.x2 ||
	    y < this.y1 ||
	    y > this.y2
	  );
	};
	
	prototype.width = function() {
	  return this.x2 - this.x1;
	};
	
	prototype.height = function() {
	  return this.y2 - this.y1;
	};
	
	module.exports = Bounds;
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/Bounds.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/bound.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/bound.js', function (module, exports, __jupyter_require__) {
	var BoundsContext = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/BoundsContext.js'),
	    Bounds = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/Bounds.js'),
	    canvas = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/canvas.js'),
	    svg = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/svg.js'),
	    text = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/text.js'),
	    paths = __jupyter_require__('vega-scenegraph@~1.1.0/src/path/index.js'),
	    parse = paths.parse,
	    drawPath = paths.render,
	    areaPath = svg.path.area,
	    linePath = svg.path.line,
	    halfpi = Math.PI / 2,
	    sqrt3 = Math.sqrt(3),
	    tan30 = Math.tan(30 * Math.PI / 180),
	    g2D = null,
	    bc = BoundsContext();
	
	function context() {
	  return g2D || (g2D = canvas.instance(1,1).getContext('2d'));
	}
	
	function strokeBounds(o, bounds) {
	  if (o.stroke && o.opacity !== 0 && o.stokeOpacity !== 0) {
	    bounds.expand(o.strokeWidth != null ? o.strokeWidth : 1);
	  }
	  return bounds;
	}
	
	function pathBounds(o, path, bounds, x, y) {
	  if (path == null) {
	    bounds.set(0, 0, 0, 0);
	  } else {
	    drawPath(bc.bounds(bounds), path, x, y);
	    strokeBounds(o, bounds);
	  }
	  return bounds;
	}
	
	function path(o, bounds) {
	  var p = o.path ? o.pathCache || (o.pathCache = parse(o.path)) : null;
	  return pathBounds(o, p, bounds, o.x, o.y);
	}
	
	function area(mark, bounds) {
	  if (mark.items.length === 0) return bounds;
	  var items = mark.items,
	      item = items[0],
	      p = item.pathCache || (item.pathCache = parse(areaPath(items)));
	  return pathBounds(item, p, bounds);
	}
	
	function line(mark, bounds) {
	  if (mark.items.length === 0) return bounds;
	  var items = mark.items,
	      item = items[0],
	      p = item.pathCache || (item.pathCache = parse(linePath(items)));
	  return pathBounds(item, p, bounds);
	}
	
	function rect(o, bounds) {
	  var x, y;
	  return strokeBounds(o, bounds.set(
	    x = o.x || 0,
	    y = o.y || 0,
	    (x + o.width) || 0,
	    (y + o.height) || 0
	  ));
	}
	
	function image(o, bounds) {
	  var x = o.x || 0,
	      y = o.y || 0,
	      w = o.width || 0,
	      h = o.height || 0;
	  x = x - (o.align === 'center' ? w/2 : (o.align === 'right' ? w : 0));
	  y = y - (o.baseline === 'middle' ? h/2 : (o.baseline === 'bottom' ? h : 0));
	  return bounds.set(x, y, x+w, y+h);
	}
	
	function rule(o, bounds) {
	  var x1, y1;
	  return strokeBounds(o, bounds.set(
	    x1 = o.x || 0,
	    y1 = o.y || 0,
	    o.x2 != null ? o.x2 : x1,
	    o.y2 != null ? o.y2 : y1
	  ));
	}
	
	function arc(o, bounds) {
	  var cx = o.x || 0,
	      cy = o.y || 0,
	      ir = o.innerRadius || 0,
	      or = o.outerRadius || 0,
	      sa = (o.startAngle || 0) - halfpi,
	      ea = (o.endAngle || 0) - halfpi,
	      xmin = Infinity, xmax = -Infinity,
	      ymin = Infinity, ymax = -Infinity,
	      a, i, n, x, y, ix, iy, ox, oy;
	
	  var angles = [sa, ea],
	      s = sa - (sa % halfpi);
	  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {
	    angles.push(s);
	  }
	
	  for (i=0, n=angles.length; i<n; ++i) {
	    a = angles[i];
	    x = Math.cos(a); ix = ir*x; ox = or*x;
	    y = Math.sin(a); iy = ir*y; oy = or*y;
	    xmin = Math.min(xmin, ix, ox);
	    xmax = Math.max(xmax, ix, ox);
	    ymin = Math.min(ymin, iy, oy);
	    ymax = Math.max(ymax, iy, oy);
	  }
	
	  return strokeBounds(o, bounds.set(
	    cx + xmin,
	    cy + ymin,
	    cx + xmax,
	    cy + ymax
	  ));
	}
	
	function symbol(o, bounds) {
	  var size = o.size != null ? o.size : 100,
	      x = o.x || 0,
	      y = o.y || 0,
	      r, t, rx, ry;
	
	  switch (o.shape) {
	    case 'cross':
	      t = 3 * Math.sqrt(size / 5) / 2;
	      bounds.set(x-t, y-t, x+t, y+t);
	      break;
	
	    case 'diamond':
	      ry = Math.sqrt(size / (2 * tan30));
	      rx = ry * tan30;
	      bounds.set(x-rx, y-ry, x+rx, y+ry);
	      break;
	
	    case 'square':
	      t = Math.sqrt(size);
	      r = t / 2;
	      bounds.set(x-r, y-r, x+r, y+r);
	      break;
	
	    case 'triangle-down':
	      rx = Math.sqrt(size / sqrt3);
	      ry = rx * sqrt3 / 2;
	      bounds.set(x-rx, y-ry, x+rx, y+ry);
	      break;
	
	    case 'triangle-up':
	      rx = Math.sqrt(size / sqrt3);
	      ry = rx * sqrt3 / 2;
	      bounds.set(x-rx, y-ry, x+rx, y+ry);
	      break;
	
	    default:
	      r = Math.sqrt(size/Math.PI);
	      bounds.set(x-r, y-r, x+r, y+r);
	  }
	
	  return strokeBounds(o, bounds);
	}
	
	function textMark(o, bounds, noRotate) {
	  var g = context(),
	      h = text.size(o),
	      a = o.align,
	      r = o.radius || 0,
	      x = (o.x || 0),
	      y = (o.y || 0),
	      dx = (o.dx || 0),
	      dy = (o.dy || 0) + text.offset(o) - Math.round(0.8*h), // use 4/5 offset
	      w, t;
	
	  if (r) {
	    t = (o.theta || 0) - Math.PI/2;
	    x += r * Math.cos(t);
	    y += r * Math.sin(t);
	  }
	
	  // horizontal alignment
	  g.font = text.font(o);
	  w = g.measureText(text.value(o.text)).width;
	  if (a === 'center') {
	    dx -= (w / 2);
	  } else if (a === 'right') {
	    dx -= w;
	  } else {
	    // left by default, do nothing
	  }
	
	  bounds.set(dx+=x, dy+=y, dx+w, dy+h);
	  if (o.angle && !noRotate) {
	    bounds.rotate(o.angle*Math.PI/180, x, y);
	  }
	  return bounds.expand(noRotate ? 0 : 1);
	}
	
	function group(g, bounds, includeLegends) {
	  var axes = g.axisItems || [],
	      items = g.items || [],
	      legends = g.legendItems || [],
	      j, m;
	
	  if (!g.clip) {
	    for (j=0, m=axes.length; j<m; ++j) {
	      bounds.union(axes[j].bounds);
	    }
	    for (j=0, m=items.length; j<m; ++j) {
	      if (items[j].bounds) bounds.union(items[j].bounds);
	    }
	    if (includeLegends) {
	      for (j=0, m=legends.length; j<m; ++j) {
	        bounds.union(legends[j].bounds);
	      }
	    }
	  }
	  if (g.clip || g.width || g.height) {
	    strokeBounds(g, bounds
	      .add(0, 0)
	      .add(g.width || 0, g.height || 0));
	  }
	  return bounds.translate(g.x || 0, g.y || 0);
	}
	
	var methods = {
	  group:  group,
	  symbol: symbol,
	  image:  image,
	  rect:   rect,
	  rule:   rule,
	  arc:    arc,
	  text:   textMark,
	  path:   path,
	  area:   area,
	  line:   line
	};
	methods.area.nest = true;
	methods.line.nest = true;
	
	function itemBounds(item, func, opt) {
	  var type = item.mark.marktype;
	  func = func || methods[type];
	  if (func.nest) item = item.mark;
	
	  var curr = item.bounds,
	      prev = item['bounds:prev'] || (item['bounds:prev'] = new Bounds());
	
	  if (curr) {
	    prev.clear().union(curr);
	    curr.clear();
	  } else {
	    item.bounds = new Bounds();
	  }
	  func(item, item.bounds, opt);
	  if (!curr) prev.clear().union(item.bounds);
	  return item.bounds;
	}
	
	var DUMMY_ITEM = {mark: null};
	
	function markBounds(mark, bounds, opt) {
	  var type  = mark.marktype,
	      func  = methods[type],
	      items = mark.items,
	      hasi  = items && items.length,
	      i, n, o, b;
	
	  if (func.nest) {
	    o = hasi ? items[0]
	      : (DUMMY_ITEM.mark = mark, DUMMY_ITEM); // no items, so fake it
	    b = itemBounds(o, func, opt);
	    bounds = bounds && bounds.union(b) || b;
	    return bounds;
	  }
	
	  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();
	  if (hasi) {  
	    for (i=0, n=items.length; i<n; ++i) {
	      bounds.union(itemBounds(items[i], func, opt));
	    }
	  }
	  return (mark.bounds = bounds);
	}
	
	module.exports = {
	  mark:  markBounds,
	  item:  itemBounds,
	  text:  textMark,
	  group: group
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/bound.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/BoundsContext.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/BoundsContext.js', function (module, exports, __jupyter_require__) {
	module.exports = function(b) {
	  function noop() { }
	  function add(x,y) { b.add(x, y); }
	
	  return {
	    bounds: function(_) {
	      if (!arguments.length) return b;
	      return (b = _, this);
	    },
	    beginPath: noop,
	    closePath: noop,
	    moveTo: add,
	    lineTo: add,
	    quadraticCurveTo: function(x1, y1, x2, y2) {
	      b.add(x1, y1);
	      b.add(x2, y2);
	    },
	    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
	      b.add(x1, y1);
	      b.add(x2, y2);
	      b.add(x3, y3);
	    }
	  };
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/BoundsContext.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/canvas.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/canvas.js', function (module, exports, __jupyter_require__) {
	function instance(w, h) {
	  w = w || 1;
	  h = h || 1;
	  var canvas;
	
	  if (typeof document !== 'undefined' && document.createElement) {
	    canvas = document.createElement('canvas');
	    canvas.width = w;
	    canvas.height = h;
	  } else {
	    var Canvas = __jupyter_require__('__ignored__');
	    if (!Canvas.prototype) return null;
	    canvas = new Canvas(w, h);
	  }
	  return lineDash(canvas);
	}
	
	function resize(canvas, w, h, p, retina) {
	  var g = this._ctx = canvas.getContext('2d'), 
	      s = 1;
	
	  canvas.width = w + p.left + p.right;
	  canvas.height = h + p.top + p.bottom;
	
	  // if browser canvas, attempt to modify for retina display
	  if (retina && typeof HTMLElement !== 'undefined' &&
	      canvas instanceof HTMLElement)
	  {
	    g.pixelratio = (s = pixelRatio(canvas) || 1);
	  }
	
	  g.setTransform(s, 0, 0, s, s*p.left, s*p.top);
	  return canvas;
	}
	
	function pixelRatio(canvas) {
	  var g = canvas.getContext('2d');
	
	  // get canvas pixel data
	  var devicePixelRatio = window && window.devicePixelRatio || 1,
	      backingStoreRatio = (
	        g.webkitBackingStorePixelRatio ||
	        g.mozBackingStorePixelRatio ||
	        g.msBackingStorePixelRatio ||
	        g.oBackingStorePixelRatio ||
	        g.backingStorePixelRatio) || 1,
	      ratio = devicePixelRatio / backingStoreRatio;
	
	  if (devicePixelRatio !== backingStoreRatio) {
	    // set actual and visible canvas size
	    var w = canvas.width,
	        h = canvas.height;
	    canvas.width = w * ratio;
	    canvas.height = h * ratio;
	    canvas.style.width = w + 'px';
	    canvas.style.height = h + 'px';
	  }
	
	  return ratio;
	}
	
	function lineDash(canvas) {
	  var g = canvas.getContext('2d');
	  if (g.vgLineDash) return; // already initialized!
	
	  var NOOP = function() {},
	      NODASH = [];
	  
	  if (g.setLineDash) {
	    g.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };
	    g.vgLineDashOffset = function(off) { this.lineDashOffset = off; };
	  } else if (g.webkitLineDash !== undefined) {
	  	g.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };
	    g.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };
	  } else if (g.mozDash !== undefined) {
	    g.vgLineDash = function(dash) { this.mozDash = dash; };
	    g.vgLineDashOffset = NOOP;
	  } else {
	    g.vgLineDash = NOOP;
	    g.vgLineDashOffset = NOOP;
	  }
	  return canvas;
	}
	
	module.exports = {
	  instance:   instance,
	  resize:     resize,
	  lineDash:   lineDash
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/canvas.js **/


/** START DEFINE BLOCK for __ignored__ **/
jupyter.define('__ignored__', function (module, exports, __jupyter_require__) {
	/* (ignored) */
})
/** END DEFINE BLOCK for __ignored__ **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/text.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/text.js', function (module, exports, __jupyter_require__) {
	function size(item) {
	  return item.fontSize != null ? item.fontSize : 11;
	}
	
	module.exports = {
	  size: size,
	  value: function(s) {
	    return s != null ? String(s) : '';
	  },
	  font: function(item, quote) {
	    var font = item.font;
	    if (quote && font) {
	      font = String(font).replace(/\"/g, '\'');
	    }
	    return '' +
	      (item.fontStyle ? item.fontStyle + ' ' : '') +
	      (item.fontVariant ? item.fontVariant + ' ' : '') +
	      (item.fontWeight ? item.fontWeight + ' ' : '') +
	      size(item) + 'px ' +
	      (font || 'sans-serif');
	  },
	  offset: function(item) {
	    // perform our own font baseline calculation
	    // why? not all browsers support SVG 1.1 'alignment-baseline' :(
	    var baseline = item.baseline,
	        h = size(item);
	    return Math.round(
	      baseline === 'top'    ?  0.93*h :
	      baseline === 'middle' ?  0.30*h :
	      baseline === 'bottom' ? -0.21*h : 0
	    );
	  }
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/text.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/CanvasRenderer.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/canvas/CanvasRenderer.js', function (module, exports, __jupyter_require__) {
	var DOM = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/dom.js'),
	    Bounds = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/Bounds.js'),
	    ImageLoader = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/ImageLoader.js'),
	    Canvas = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/canvas.js'),
	    Renderer = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/Renderer.js'),
	    marks = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/canvas/marks/index.js');
	
	function CanvasRenderer(loadConfig) {
	  Renderer.call(this);
	  this._loader = new ImageLoader(loadConfig);
	}
	
	CanvasRenderer.RETINA = true;
	
	var base = Renderer.prototype;
	var prototype = (CanvasRenderer.prototype = Object.create(base));
	prototype.constructor = CanvasRenderer;
	
	prototype.initialize = function(el, width, height, padding) {
	  this._canvas = Canvas.instance(width, height);
	  if (el) {
	    DOM.clear(el, 0).appendChild(this._canvas);
	    this._canvas.setAttribute('class', 'marks');
	  }
	  return base.initialize.call(this, el, width, height, padding);
	};
	
	prototype.resize = function(width, height, padding) {
	  base.resize.call(this, width, height, padding);
	  Canvas.resize(this._canvas, this._width, this._height,
	    this._padding, CanvasRenderer.RETINA);
	  return this;
	};
	
	prototype.canvas = function() {
	  return this._canvas;
	};
	
	prototype.context = function() {
	  return this._canvas ? this._canvas.getContext('2d') : null;
	};
	
	prototype.pendingImages = function() {
	  return this._loader.pending();
	};
	
	function clipToBounds(g, items) {
	  if (!items) return null;
	
	  var b = new Bounds(), i, n, item, mark, group;
	  for (i=0, n=items.length; i<n; ++i) {
	    item = items[i];
	    mark = item.mark;
	    group = mark.group;
	    item = marks[mark.marktype].nested ? mark : item;
	    b.union(translate(item.bounds, group));
	    if (item['bounds:prev']) {
	      b.union(translate(item['bounds:prev'], group));
	    }
	  }
	  b.round();
	
	  g.beginPath();
	  g.rect(b.x1, b.y1, b.width(), b.height());
	  g.clip();
	
	  return b;
	}
	
	function translate(bounds, group) {
	  if (group == null) return bounds;
	  var b = bounds.clone();
	  for (; group != null; group = group.mark.group) {
	    b.translate(group.x || 0, group.y || 0);
	  }
	  return b;
	}
	
	prototype.render = function(scene, items) {
	  var g = this.context(),
	      p = this._padding,
	      w = this._width + p.left + p.right,
	      h = this._height + p.top + p.bottom,
	      b;
	
	  // setup
	  this._scene = scene; // cache scene for async redraw
	  g.save();
	  b = clipToBounds(g, items);
	  this.clear(-p.left, -p.top, w, h);
	
	  // render
	  this.draw(g, scene, b);
	  
	  // takedown
	  g.restore();
	  this._scene = null; // clear scene cache
	
	  return this;
	};
	
	prototype.draw = function(ctx, scene, bounds) {
	  var mark = marks[scene.marktype];
	  mark.draw.call(this, ctx, scene, bounds);
	};
	
	prototype.clear = function(x, y, w, h) {
	  var g = this.context();
	  g.clearRect(x, y, w, h);
	  if (this._bgcolor != null) {
	    g.fillStyle = this._bgcolor;
	    g.fillRect(x, y, w, h); 
	  }
	};
	
	prototype.loadImage = function(uri) {
	  var renderer = this,
	      scene = this._scene;
	  return this._loader.loadImage(uri, function() {
	    renderer.renderAsync(scene);
	  });
	};
	
	prototype.renderAsync = function(scene) {
	  // TODO make safe for multiple scene rendering?
	  var renderer = this;
	  if (renderer._async_id) {
	    clearTimeout(renderer._async_id);
	  }
	  renderer._async_id = setTimeout(function() {
	    renderer.render(scene);
	    delete renderer._async_id;
	  }, 10);
	};
	
	module.exports = CanvasRenderer;
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/canvas/CanvasRenderer.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/ImageLoader.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/ImageLoader.js', function (module, exports, __jupyter_require__) {
	var load = __jupyter_require__('datalib@~1.7.2/src/import/load.js');
	
	function ImageLoader(loadConfig) {
	  this._pending = 0;
	  this._config = loadConfig || ImageLoader.Config; 
	}
	
	// Overridable global default load configuration
	ImageLoader.Config = null;
	
	var prototype = ImageLoader.prototype;
	
	prototype.pending = function() {
	  return this._pending;
	};
	
	prototype.params = function(uri) {
	  var p = {url: uri}, k;
	  for (k in this._config) { p[k] = this._config[k]; }
	  return p;
	};
	
	prototype.imageURL = function(uri) {
	  return load.sanitizeUrl(this.params(uri));
	};
	
	function browser(uri, callback) {
	  var url = load.sanitizeUrl(this.params(uri));
	  if (!url) { // error
	    if (callback) callback(uri, null);
	    return null;
	  }
	
	  var loader = this,
	      image = new Image();
	
	  loader._pending += 1;
	
	  image.onload = function() {
	    loader._pending -= 1;
	    image.loaded = true;
	    if (callback) callback(null, image);
	  };
	  image.src = url;
	
	  return image;
	}
	
	function server(uri, callback) {
	  var loader = this,
	      image = new (__jupyter_require__('__ignored__').Image)();
	
	  loader._pending += 1;
	
	  load(this.params(uri), function(err, data) {
	    loader._pending -= 1;
	    if (err) {
	      if (callback) callback(err, null);
	      return null;
	    }
	    image.src = data;
	    image.loaded = true;
	    if (callback) callback(null, image);
	  });
	
	  return image;
	}
	
	prototype.loadImage = function(uri, callback) {
	  return load.useXHR ?
	    browser.call(this, uri, callback) :
	    server.call(this, uri, callback);
	};
	
	module.exports = ImageLoader;
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/ImageLoader.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/Renderer.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/Renderer.js', function (module, exports, __jupyter_require__) {
	function Renderer() {
	  this._el = null;
	  this._bgcolor = null;
	}
	
	var prototype = Renderer.prototype;
	
	prototype.initialize = function(el, width, height, padding) {
	  this._el = el;
	  return this.resize(width, height, padding);
	};
	
	// Returns the parent container element for a visualization
	prototype.element = function() {
	  return this._el;
	};
	
	// Returns the scene element (e.g., canvas or SVG) of the visualization
	// Subclasses must override if the first child is not the scene element
	prototype.scene = function() {
	  return this._el && this._el.firstChild;
	};
	
	prototype.background = function(bgcolor) {
	  if (arguments.length === 0) return this._bgcolor;
	  this._bgcolor = bgcolor;
	  return this;
	};
	
	prototype.resize = function(width, height, padding) {
	  this._width = width;
	  this._height = height;
	  this._padding = padding || {top:0, left:0, bottom:0, right:0};
	  return this;
	};
	
	prototype.render = function(/*scene, items*/) {
	  return this;
	};
	
	module.exports = Renderer;
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/Renderer.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/index.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/svg/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  Handler:  __jupyter_require__('vega-scenegraph@~1.1.0/src/render/svg/SVGHandler.js'),
	  Renderer: __jupyter_require__('vega-scenegraph@~1.1.0/src/render/svg/SVGRenderer.js'),
	  string: {
	    Renderer : __jupyter_require__('vega-scenegraph@~1.1.0/src/render/svg/SVGStringRenderer.js')
	  }
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/index.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/SVGHandler.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/svg/SVGHandler.js', function (module, exports, __jupyter_require__) {
	var DOM = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/dom.js'),
	    Handler = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/Handler.js');
	
	function SVGHandler() {
	  Handler.call(this);
	}
	
	var base = Handler.prototype;
	var prototype = (SVGHandler.prototype = Object.create(base));
	prototype.constructor = SVGHandler;
	
	prototype.initialize = function(el, pad, obj) {
	  this._svg = DOM.find(el, 'svg');
	  return base.initialize.call(this, el, pad, obj);
	};
	
	prototype.svg = function() {
	  return this._svg;
	};
	
	// wrap an event listener for the SVG DOM
	prototype.listener = function(handler) {
	  var that = this;
	  return function(evt) {
	    var target = evt.target,
	        item = target.__data__;
	    evt.vegaType = evt.type;
	    item = Array.isArray(item) ? item[0] : item;
	    handler.call(that._obj, evt, item);
	  };
	};
	
	// add an event handler
	prototype.on = function(type, handler) {
	  var name = this.eventName(type),
	      svg = this._svg,
	      h = this._handlers,
	      x = {
	        type:     type,
	        handler:  handler,
	        listener: this.listener(handler)
	      };
	
	  (h[name] || (h[name] = [])).push(x);
	  svg.addEventListener(name, x.listener);
	  return this;
	};
	
	// remove an event handler
	prototype.off = function(type, handler) {
	  var name = this.eventName(type),
	      svg = this._svg,
	      h = this._handlers[name], i;
	  if (!h) return;
	  for (i=h.length; --i>=0;) {
	    if (h[i].type === type && !handler || h[i].handler === handler) {
	      svg.removeEventListener(name, h[i].listener);
	      h.splice(i, 1);
	    }
	  }
	  return this;
	};
	
	module.exports = SVGHandler;
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/SVGHandler.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/SVGRenderer.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/svg/SVGRenderer.js', function (module, exports, __jupyter_require__) {
	var ImageLoader = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/ImageLoader.js'),
	    Renderer = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/Renderer.js'),
	    text = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/text.js'),
	    DOM = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/dom.js'),
	    SVG = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/svg.js'),
	    ns = SVG.metadata.xmlns,
	    marks = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/svg/marks.js');
	
	function SVGRenderer(loadConfig) {
	  Renderer.call(this);
	  this._loader = new ImageLoader(loadConfig);
	  this._dirtyID = 0;
	}
	
	var base = Renderer.prototype;
	var prototype = (SVGRenderer.prototype = Object.create(base));
	prototype.constructor = SVGRenderer;
	
	prototype.initialize = function(el, width, height, padding) {
	  if (el) {
	    this._svg = DOM.child(el, 0, 'svg', ns, 'marks');
	    DOM.clear(el, 1);
	    // set the svg root group
	    this._root = DOM.child(this._svg, 0, 'g', ns);
	    DOM.clear(this._svg, 1);
	  }
	
	  // create the svg definitions cache
	  this._defs = {
	    clip_id:  1,
	    gradient: {},
	    clipping: {}
	  };
	
	  // set background color if defined
	  this.background(this._bgcolor);
	
	  return base.initialize.call(this, el, width, height, padding);
	};
	
	prototype.background = function(bgcolor) {
	  if (arguments.length && this._svg) {
	    this._svg.style.setProperty('background-color', bgcolor);
	  }
	  return base.background.apply(this, arguments);
	};
	
	prototype.resize = function(width, height, padding) {
	  base.resize.call(this, width, height, padding);
	  
	  if (this._svg) {
	    var w = this._width,
	        h = this._height,
	        p = this._padding;
	  
	    this._svg.setAttribute('width', w + p.left + p.right);
	    this._svg.setAttribute('height', h + p.top + p.bottom);
	    
	    this._root.setAttribute('transform', 'translate('+p.left+','+p.top+')');
	  }
	
	  return this;
	};
	
	prototype.svg = function() {
	  if (!this._svg) return null;
	
	  var attr = {
	    'class':  'marks',
	    'width':  this._width + this._padding.left + this._padding.right,
	    'height': this._height + this._padding.top + this._padding.bottom,
	  };
	  for (var key in SVG.metadata) {
	    attr[key] = SVG.metadata[key];
	  }
	
	  return DOM.openTag('svg', attr) + this._svg.innerHTML + DOM.closeTag('svg');
	};
	
	prototype.imageURL = function(url) {
	  return this._loader.imageURL(url);
	};
	
	
	// -- Render entry point --
	
	prototype.render = function(scene, items) {
	  if (this._dirtyCheck(items)) {
	    if (this._dirtyAll) this._resetDefs();
	    this.draw(this._root, scene, -1);
	    DOM.clear(this._root, 1);
	  }
	  this.updateDefs();
	  return this;
	};
	
	prototype.draw = function(el, scene, index) {
	  this.drawMark(el, scene, index, marks[scene.marktype]);
	};
	
	
	// -- Manage SVG definitions ('defs') block --
	
	prototype.updateDefs = function() {
	  var svg = this._svg,
	      defs = this._defs,
	      el = defs.el,
	      index = 0, id;
	
	  for (id in defs.gradient) {
	    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
	    updateGradient(el, defs.gradient[id], index++);
	  }
	
	  for (id in defs.clipping) {
	    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
	    updateClipping(el, defs.clipping[id], index++);
	  }
	
	  // clean-up
	  if (el) {
	    if (index === 0) {
	      svg.removeChild(el);
	      defs.el = null;
	    } else {
	      DOM.clear(el, index);      
	    }
	  }
	};
	
	function updateGradient(el, grad, index) {
	  var i, n, stop;
	
	  el = DOM.child(el, index, 'linearGradient', ns);
	  el.setAttribute('id', grad.id);
	  el.setAttribute('x1', grad.x1);
	  el.setAttribute('x2', grad.x2);
	  el.setAttribute('y1', grad.y1);
	  el.setAttribute('y2', grad.y2);
	  
	  for (i=0, n=grad.stops.length; i<n; ++i) {
	    stop = DOM.child(el, i, 'stop', ns);
	    stop.setAttribute('offset', grad.stops[i].offset);
	    stop.setAttribute('stop-color', grad.stops[i].color);
	  }
	  DOM.clear(el, i);
	}
	
	function updateClipping(el, clip, index) {
	  var rect;
	
	  el = DOM.child(el, index, 'clipPath', ns);
	  el.setAttribute('id', clip.id);
	  rect = DOM.child(el, 0, 'rect', ns);
	  rect.setAttribute('x', 0);
	  rect.setAttribute('y', 0);
	  rect.setAttribute('width', clip.width);
	  rect.setAttribute('height', clip.height);
	}
	
	prototype._resetDefs = function() {
	  var def = this._defs;
	  def.clip_id = 1;
	  def.gradient = {};
	  def.clipping = {};
	};
	
	
	// -- Manage rendering of items marked as dirty --
	
	prototype.isDirty = function(item) {
	  return this._dirtyAll || item.dirty === this._dirtyID;
	};
	
	prototype._dirtyCheck = function(items) {
	  this._dirtyAll = true;
	  if (!items) return true;
	
	  var id = ++this._dirtyID,
	      item, mark, type, mdef, i, n, o;
	
	  for (i=0, n=items.length; i<n; ++i) {
	    item = items[i];
	    mark = item.mark;
	    if (mark.marktype !== type) {
	      // memoize mark instance lookup
	      type = mark.marktype;
	      mdef = marks[type];
	    }
	
	    if (item.status === 'exit') { // EXIT
	      if (item._svg) {
	        if (mdef.nest && item.mark.items.length) {
	          // if nested mark with remaining points, update instead
	          this._update(mdef, item._svg, item.mark.items[0]);
	          o = item.mark.items[0];
	          o._svg = item._svg;
	          o._update = id;
	        } else {
	          // otherwise remove from DOM
	          DOM.remove(item._svg);
	        }
	        item._svg = null;
	      }
	      continue;
	    }
	
	    item = (mdef.nest ? mark.items[0] : item);
	    if (item._update === id) { // Already processed
	      continue;
	    } else if (item._svg) { // UPDATE
	      this._update(mdef, item._svg, item);
	    } else { // ENTER
	      this._dirtyAll = false;
	      dirtyParents(item, id);
	    }
	    item._update = id;
	  }
	  return !this._dirtyAll;
	};
	
	function dirtyParents(item, id) {
	  for (; item && item.dirty !== id; item=item.mark.group) {
	    item.dirty = id;
	    if (item.mark && item.mark.dirty !== id) {
	      item.mark.dirty = id;
	    } else return;
	  }
	}
	
	
	// -- Construct & maintain scenegraph to SVG mapping ---
	
	// Draw a mark container.
	prototype.drawMark = function(el, scene, index, mdef) {
	  if (!this.isDirty(scene)) return;
	
	  var items = mdef.nest ?
	        (scene.items && scene.items.length ? [scene.items[0]] : []) :
	        scene.items || [],
	      events = scene.interactive === false ? 'none' : null,
	      isGroup = (mdef.tag === 'g'),
	      className = DOM.cssClass(scene),
	      p, i, n, c, d, insert;
	
	  p = DOM.child(el, index+1, 'g', ns, className);
	  p.setAttribute('class', className);
	  scene._svg = p;
	  if (!isGroup && events) {
	    p.style.setProperty('pointer-events', events);
	  }
	
	  for (i=0, n=items.length; i<n; ++i) {
	    if (this.isDirty(d = items[i])) {
	      insert = !(this._dirtyAll || d._svg);
	      c = bind(p, mdef, d, i, insert);
	      this._update(mdef, c, d);
	      if (isGroup) {
	        if (insert) this._dirtyAll = true;
	        this._recurse(c, d);
	        if (insert) this._dirtyAll = false;
	      }
	    }
	  }
	  DOM.clear(p, i);
	  return p;
	};
	
	// Recursively process group contents.
	prototype._recurse = function(el, group) {
	  var items = group.items || [],
	      legends = group.legendItems || [],
	      axes = group.axisItems || [],
	      idx = 0, j, m;
	
	  for (j=0, m=axes.length; j<m; ++j) {
	    if (axes[j].layer === 'back') {
	      this.drawMark(el, axes[j], idx++, marks.group);
	    }
	  }
	  for (j=0, m=items.length; j<m; ++j) {
	    this.draw(el, items[j], idx++);
	  }
	  for (j=0, m=axes.length; j<m; ++j) {
	    if (axes[j].layer !== 'back') {
	      this.drawMark(el, axes[j], idx++, marks.group);
	    }
	  }
	  for (j=0, m=legends.length; j<m; ++j) {
	    this.drawMark(el, legends[j], idx++, marks.group);
	  }
	
	  // remove any extraneous DOM elements
	  DOM.clear(el, 1 + idx);
	};
	
	// Bind a scenegraph item to an SVG DOM element.
	// Create new SVG elements as needed.
	function bind(el, mdef, item, index, insert) {
	  // create svg element, bind item data for D3 compatibility
	  var node = DOM.child(el, index, mdef.tag, ns, null, insert);
	  node.__data__ = item;
	  node.__values__ = {fill: 'default'};
	
	  // create background rect
	  if (mdef.tag === 'g') {
	    var bg = DOM.child(node, 0, 'rect', ns, 'background');
	    bg.__data__ = item;
	  }
	
	  // add pointer from scenegraph item to svg element
	  return (item._svg = node);
	}
	
	
	// -- Set attributes & styles on SVG elements ---
	
	var element = null, // temp var for current SVG element
	    values = null;  // temp var for current values hash
	
	// Extra configuration for certain mark types
	var mark_extras = {
	  group: function(mdef, el, item) {
	    element = el.childNodes[0];
	    values = el.__values__; // use parent's values hash
	    mdef.background(emit, item, this);
	
	    var value = item.mark.interactive === false ? 'none' : null;
	    if (value !== values.events) {
	      element.style.setProperty('pointer-events', value);
	      values.events = value;
	    }
	  },
	  text: function(mdef, el, item) {
	    var str = text.value(item.text);
	    if (str !== values.text) {
	      el.textContent = str;
	      values.text = str;
	    }
	    str = text.font(item);
	    if (str !== values.font) {
	      el.style.setProperty('font', str);
	      values.font = str;
	    }
	  }
	};
	
	prototype._update = function(mdef, el, item) {
	  // set dom element and values cache
	  // provides access to emit method
	  element = el;
	  values = el.__values__;
	
	  // apply svg attributes
	  mdef.attr(emit, item, this);
	
	  // some marks need special treatment
	  var extra = mark_extras[mdef.type];
	  if (extra) extra(mdef, el, item);
	
	  // apply svg css styles
	  // note: element may be modified by 'extra' method
	  this.style(element, item);
	};
	
	function emit(name, value, ns) {
	  // early exit if value is unchanged
	  if (value === values[name]) return;
	
	  if (value != null) {
	    // if value is provided, update DOM attribute
	    if (ns) {
	      element.setAttributeNS(ns, name, value);
	    } else {
	      element.setAttribute(name, value);
	    }
	  } else {
	    // else remove DOM attribute
	    if (ns) {
	      element.removeAttributeNS(ns, name);
	    } else {
	      element.removeAttribute(name);
	    }
	  }
	
	  // note current value for future comparison
	  values[name] = value;
	}
	
	prototype.style = function(el, o) {
	  if (o == null) return;
	  var i, n, prop, name, value;
	
	  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
	    prop = SVG.styleProperties[i];
	    value = o[prop];
	    if (value === values[prop]) continue;
	
	    name = SVG.styles[prop];
	    if (value == null) {
	      if (name === 'fill') {
	        el.style.setProperty(name, 'none');
	      } else {
	        el.style.removeProperty(name);
	      }
	    } else {
	      if (value.id) {
	        // ensure definition is included
	        this._defs.gradient[value.id] = value;
	        value = 'url(' + href() + '#' + value.id + ')';
	      }
	      el.style.setProperty(name, value+'');
	    }
	
	    values[prop] = value;
	  }
	};
	
	function href() {
	  return typeof window !== 'undefined' ? window.location.href : '';
	}
	
	module.exports = SVGRenderer;
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/SVGRenderer.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/marks.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/svg/marks.js', function (module, exports, __jupyter_require__) {
	var text = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/text.js'),
	    SVG = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/svg.js'),
	    symbolTypes = SVG.symbolTypes,
	    textAlign = SVG.textAlign,
	    path = SVG.path;
	
	function translateItem(o) {
	  return translate(o.x || 0, o.y || 0);
	}
	
	function translate(x, y) {
	  return 'translate(' + x + ',' + y + ')';
	}
	
	module.exports = {
	  arc: {
	    tag:  'path',
	    type: 'arc',
	    attr: function(emit, o) {
	      emit('transform', translateItem(o));
	      emit('d', path.arc(o));
	    }
	  },
	  area: {
	    tag:  'path',
	    type: 'area',
	    nest: true,
	    attr: function(emit, o) {
	      var items = o.mark.items;
	      if (items.length) emit('d', path.area(items));
	    }
	  },
	  group: {
	    tag:  'g',
	    type: 'group',
	    attr: function(emit, o, renderer) {
	      var id = null, defs, c;
	      emit('transform', translateItem(o));
	      if (o.clip) {
	        defs = renderer._defs;
	        id = o.clip_id || (o.clip_id = 'clip' + defs.clip_id++);
	        c = defs.clipping[id] || (defs.clipping[id] = {id: id});
	        c.width = o.width || 0;
	        c.height = o.height || 0;
	      }
	      emit('clip-path', id ? ('url(#' + id + ')') : null);
	    },
	    background: function(emit, o) {
	      emit('class', 'background');
	      emit('width', o.width || 0);
	      emit('height', o.height || 0);
	    }
	  },
	  image: {
	    tag:  'image',
	    type: 'image',
	    attr: function(emit, o, renderer) {
	      var x = o.x || 0,
	          y = o.y || 0,
	          w = o.width || 0,
	          h = o.height || 0,
	          url = renderer.imageURL(o.url);
	
	      x = x - (o.align === 'center' ? w/2 : o.align === 'right' ? w : 0);
	      y = y - (o.baseline === 'middle' ? h/2 : o.baseline === 'bottom' ? h : 0);
	
	      emit('href', url, 'http://www.w3.org/1999/xlink', 'xlink:href');
	      emit('transform', translate(x, y));
	      emit('width', w);
	      emit('height', h);
	    }
	  },
	  line: {
	    tag:  'path',
	    type: 'line',
	    nest: true,
	    attr: function(emit, o) {
	      var items = o.mark.items;
	      if (items.length) emit('d', path.line(items));
	    }
	  },
	  path: {
	    tag:  'path',
	    type: 'path',
	    attr: function(emit, o) {
	      emit('transform', translateItem(o));
	      emit('d', o.path);
	    }
	  },
	  rect: {
	    tag:  'rect',
	    type: 'rect',
	    nest: false,
	    attr: function(emit, o) {
	      emit('transform', translateItem(o));
	      emit('width', o.width || 0);
	      emit('height', o.height || 0);
	    }
	  },
	  rule: {
	    tag:  'line',
	    type: 'rule',
	    attr: function(emit, o) {
	      emit('transform', translateItem(o));
	      emit('x2', o.x2 != null ? o.x2 - (o.x||0) : 0);
	      emit('y2', o.y2 != null ? o.y2 - (o.y||0) : 0);
	    }
	  },
	  symbol: {
	    tag:  'path',
	    type: 'symbol',
	    attr: function(emit, o) {
	      var pathStr = !o.shape || symbolTypes[o.shape] ?
	        path.symbol(o) : path.resize(o.shape, o.size);
	
	      emit('transform', translateItem(o));
	      emit('d', pathStr);
	    }
	  },
	  text: {
	    tag:  'text',
	    type: 'text',
	    nest: false,
	    attr: function(emit, o) {
	      var dx = (o.dx || 0),
	          dy = (o.dy || 0) + text.offset(o),
	          x = (o.x || 0),
	          y = (o.y || 0),
	          a = o.angle || 0,
	          r = o.radius || 0, t;
	
	      if (r) {
	        t = (o.theta || 0) - Math.PI/2;
	        x += r * Math.cos(t);
	        y += r * Math.sin(t);
	      }
	
	      emit('text-anchor', textAlign[o.align] || 'start');
	
	      if (a) {
	        t = translate(x, y) + ' rotate('+a+')';
	        if (dx || dy) t += ' ' + translate(dx, dy);
	      } else {
	        t = translate(x+dx, y+dy);
	      }
	      emit('transform', t);
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/marks.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/SVGStringRenderer.js **/
jupyter.define('vega-scenegraph@1.1.0/src/render/svg/SVGStringRenderer.js', function (module, exports, __jupyter_require__) {
	var Renderer = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/Renderer.js'),
	    ImageLoader = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/ImageLoader.js'),
	    SVG = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/svg.js'),
	    text = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/text.js'),
	    DOM = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/dom.js'),
	    openTag = DOM.openTag,
	    closeTag = DOM.closeTag,
	    MARKS = __jupyter_require__('vega-scenegraph@~1.1.0/src/render/svg/marks.js');
	
	function SVGStringRenderer(loadConfig) {
	  Renderer.call(this);
	
	  this._loader = new ImageLoader(loadConfig);
	
	  this._text = {
	    head: '',
	    root: '',
	    foot: '',
	    defs: '',
	    body: ''
	  };
	
	  this._defs = {
	    clip_id:  1,
	    gradient: {},
	    clipping: {}
	  };
	}
	
	var base = Renderer.prototype;
	var prototype = (SVGStringRenderer.prototype = Object.create(base));
	prototype.constructor = SVGStringRenderer;
	
	prototype.resize = function(width, height, padding) {
	  base.resize.call(this, width, height, padding);
	  var p = this._padding,
	      t = this._text;
	
	  var attr = {
	    'class':  'marks',
	    'width':  this._width + p.left + p.right,
	    'height': this._height + p.top + p.bottom,
	  };
	  for (var key in SVG.metadata) {
	    attr[key] = SVG.metadata[key];
	  }
	
	  t.head = openTag('svg', attr);
	  t.root = openTag('g', {
	    transform: 'translate(' + p.left + ',' + p.top + ')'
	  });
	  t.foot = closeTag('g') + closeTag('svg');
	
	  return this;
	};
	
	prototype.svg = function() {
	  var t = this._text;
	  return t.head + t.defs + t.root + t.body + t.foot;
	};
	
	prototype.render = function(scene) {
	  this._text.body = this.mark(scene);
	  this._text.defs = this.buildDefs();
	  return this;
	};
	
	prototype.reset = function() {
	  this._defs.clip_id = 0;
	  return this;
	};
	
	prototype.buildDefs = function() {
	  var all = this._defs,
	      defs = '',
	      i, id, def, stops;
	
	  for (id in all.gradient) {
	    def = all.gradient[id];
	    stops = def.stops;
	
	    defs += openTag('linearGradient', {
	      id: id,
	      x1: def.x1,
	      x2: def.x2,
	      y1: def.y1,
	      y2: def.y2
	    });
	    
	    for (i=0; i<stops.length; ++i) {
	      defs += openTag('stop', {
	        offset: stops[i].offset,
	        'stop-color': stops[i].color
	      }) + closeTag('stop');
	    }
	    
	    defs += closeTag('linearGradient');
	  }
	  
	  for (id in all.clipping) {
	    def = all.clipping[id];
	
	    defs += openTag('clipPath', {id: id});
	
	    defs += openTag('rect', {
	      x: 0,
	      y: 0,
	      width: def.width,
	      height: def.height
	    }) + closeTag('rect');
	
	    defs += closeTag('clipPath');
	  }
	  
	  return (defs.length > 0) ? openTag('defs') + defs + closeTag('defs') : '';
	};
	
	prototype.imageURL = function(url) {
	  return this._loader.imageURL(url);
	};
	
	var object;
	
	function emit(name, value, ns, prefixed) {
	  object[prefixed || name] = value;
	}
	
	prototype.attributes = function(attr, item) {
	  object = {};
	  attr(emit, item, this);
	  return object;
	};
	
	prototype.mark = function(scene) {
	  var mdef = MARKS[scene.marktype],
	      tag  = mdef.tag,
	      attr = mdef.attr,
	      nest = mdef.nest || false,
	      data = nest ?
	          (scene.items && scene.items.length ? [scene.items[0]] : []) :
	          (scene.items || []),
	      defs = this._defs,
	      str = '',
	      style, i, item;
	
	  if (tag !== 'g' && scene.interactive === false) {
	    style = 'style="pointer-events: none;"';
	  }
	
	  // render opening group tag
	  str += openTag('g', {
	    'class': DOM.cssClass(scene)
	  }, style);
	
	  // render contained elements
	  for (i=0; i<data.length; ++i) {
	    item = data[i];
	    style = (tag !== 'g') ? styles(item, scene, tag, defs) : null;
	    str += openTag(tag, this.attributes(attr, item), style);
	    if (tag === 'text') {
	      str += escape_text(text.value(item.text));
	    } else if (tag === 'g') {
	      str += openTag('rect',
	        this.attributes(mdef.background, item),
	        styles(item, scene, 'bgrect', defs)) + closeTag('rect');
	      str += this.markGroup(item);
	    }
	    str += closeTag(tag);
	  }
	
	  // render closing group tag
	  return str + closeTag('g');
	};
	
	prototype.markGroup = function(scene) {
	  var str = '',
	      axes = scene.axisItems || [],
	      items = scene.items || [],
	      legends = scene.legendItems || [],
	      j, m;
	
	  for (j=0, m=axes.length; j<m; ++j) {
	    if (axes[j].layer === 'back') {
	      str += this.mark(axes[j]);
	    }
	  }
	  for (j=0, m=items.length; j<m; ++j) {
	    str += this.mark(items[j]);
	  }
	  for (j=0, m=axes.length; j<m; ++j) {
	    if (axes[j].layer !== 'back') {
	      str += this.mark(axes[j]);
	    }
	  }
	  for (j=0, m=legends.length; j<m; ++j) {
	    str += this.mark(legends[j]);
	  }
	
	  return str;
	};
	
	function styles(o, mark, tag, defs) {
	  if (o == null) return '';
	  var i, n, prop, name, value, s = '';
	
	  if (tag === 'bgrect' && mark.interactive === false) {
	    s += 'pointer-events: none;';
	  }
	
	  if (tag === 'text') {
	    s += 'font: ' + text.font(o) + ';';
	  }
	
	  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
	    prop = SVG.styleProperties[i];
	    name = SVG.styles[prop];
	    value = o[prop];
	
	    if (value == null) {
	      if (name === 'fill') {
	        s += (s.length ? ' ' : '') + 'fill: none;';
	      }
	    } else {
	      if (value.id) {
	        // ensure definition is included
	        defs.gradient[value.id] = value;
	        value = 'url(#' + value.id + ')';
	      }
	      s += (s.length ? ' ' : '') + name + ': ' + value + ';';
	    }
	  }
	
	  return s ? 'style="' + s + '"' : null;
	}
	
	function escape_text(s) {
	  return s.replace(/&/g, '&amp;')
	          .replace(/</g, '&lt;')
	          .replace(/>/g, '&gt;');
	}
	
	module.exports = SVGStringRenderer;
	
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/render/svg/SVGStringRenderer.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/Item.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/Item.js', function (module, exports, __jupyter_require__) {
	function Item(mark) {
	  this.mark = mark;
	}
	
	var prototype = Item.prototype;
	
	prototype.hasPropertySet = function(name) {
	  var props = this.mark.def.properties;
	  return props && props[name] != null;
	};
	
	prototype.cousin = function(offset, index) {
	  if (offset === 0) return this;
	  offset = offset || -1;
	  var mark = this.mark,
	      group = mark.group,
	      iidx = index==null ? mark.items.indexOf(this) : index,
	      midx = group.items.indexOf(mark) + offset;
	  return group.items[midx].items[iidx];
	};
	
	prototype.sibling = function(offset) {
	  if (offset === 0) return this;
	  offset = offset || -1;
	  var mark = this.mark,
	      iidx = mark.items.indexOf(this) + offset;
	  return mark.items[iidx];
	};
	
	prototype.remove = function() {
	  var item = this,
	      list = item.mark.items,
	      i = list.indexOf(item);
	  if (i >= 0) {
	    if (i===list.length-1) {
	      list.pop();
	    } else {
	      list.splice(i, 1);
	    }
	  }
	  return item;
	};
	
	prototype.touch = function() {
	  if (this.pathCache) this.pathCache = null;
	};
	
	module.exports = Item;
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/Item.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/Gradient.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/Gradient.js', function (module, exports, __jupyter_require__) {
	var gradient_id = 0;
	
	function Gradient(type) {
	  this.id = 'gradient_' + (gradient_id++);
	  this.type = type || 'linear';
	  this.stops = [];
	  this.x1 = 0;
	  this.x2 = 1;
	  this.y1 = 0;
	  this.y2 = 0;
	}
	
	var prototype = Gradient.prototype;
	
	prototype.stop = function(offset, color) {
	  this.stops.push({
	    offset: offset,
	    color: color
	  });
	  return this;
	};
	
	module.exports = Gradient;
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/Gradient.js **/


/** START DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/scene.js **/
jupyter.define('vega-scenegraph@1.1.0/src/util/scene.js', function (module, exports, __jupyter_require__) {
	var bound = __jupyter_require__('vega-scenegraph@~1.1.0/src/util/bound.js');
	
	var sets = [
	  'items',
	  'axisItems',
	  'legendItems'
	];
	
	var keys = [
	  'marktype', 'name', 'interactive', 'clip',
	  'items', 'axisItems', 'legendItems', 'layer',
	  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout
	  'fill', 'fillOpacity', 'opacity',                             // fill
	  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke
	  'strokeDash', 'strokeDashOffset',                             // stroke dash
	  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc
	  'interpolate', 'tension', 'orient',                           // area, line
	  'url',                                                        // image
	  'path',                                                       // path
	  'x2', 'y2',                                                   // rule
	  'size', 'shape',                                              // symbol
	  'text', 'angle', 'theta', 'radius', 'dx', 'dy',               // text
	  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant'  // font
	];
	
	function toJSON(scene, indent) {
	  return JSON.stringify(scene, keys, indent);
	}
	
	function fromJSON(json) {
	  var scene = (typeof json === 'string' ? JSON.parse(json) : json);
	  return initialize(scene);
	}
	
	function initialize(scene) {
	  var type = scene.marktype,
	      i, n, s, m, items;
	
	  for (s=0, m=sets.length; s<m; ++s) {
	    if ((items = scene[sets[s]])) {
	      for (i=0, n=items.length; i<n; ++i) {
	        items[i][type ? 'mark' : 'group'] = scene;
	        if (!type || type === 'group') {
	          initialize(items[i]);
	        }
	      }
	    }
	  }
	
	  if (type) bound.mark(scene);
	  return scene;
	}
	
	module.exports = {
	  toJSON:   toJSON,
	  fromJSON: fromJSON
	};
})
/** END DEFINE BLOCK for vega-scenegraph@1.1.0/src/util/scene.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/util/theme-val.js **/
jupyter.define('vega@2.6.3/src/util/theme-val.js', function (module, exports, __jupyter_require__) {
	module.exports = function(def, config, property, defaultVal) {
	  if (def[property] !== undefined) {
	    return def[property];
	  } else if (config !== undefined && config[property] !== undefined) {
	    return config[property];
	  } else if (defaultVal !== undefined) {
	    return defaultVal;
	  }
	  return undefined;
	};
})
/** END DEFINE BLOCK for vega@2.6.3/src/util/theme-val.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/background.js **/
jupyter.define('vega@2.6.3/src/parse/background.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js');
	
	function parseBg(bg) {
	  // return null if input is null or undefined
	  if (bg == null) return null;
	  // run through d3 rgb to sanity check
	  return d3.rgb(bg) + '';
	}
	
	module.exports = parseBg;
	
	parseBg.schema = {"defs": {"background": {"type": "string"}}};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/background.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/data.js **/
jupyter.define('vega@2.6.3/src/parse/data.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    parseTransforms = __jupyter_require__('vega@~2.6.3/src/parse/transforms.js'),
	    parseModify = __jupyter_require__('vega@~2.6.3/src/parse/modify.js');
	
	function parseData(model, spec, callback) {
	  var config = model.config(),
	      count = 0;
	
	  function onError(error, d) {
	    log.error('PARSE DATA FAILED: ' + d.name + ' ' + error);
	    count = -1;
	    callback(error);
	  }
	
	  function onLoad(d) {
	    return function(error, data) {
	      if (error) {
	        onError(error, d);
	      } else if (count > 0) {
	        try {
	          model.data(d.name).values(dl.read(data, d.format));
	          if (--count === 0) callback();
	        } catch (err) {
	          onError(err, d);
	        }
	      }
	    };
	  }
	
	  // process each data set definition
	  (spec || []).forEach(function(d) {
	    if (d.url) {
	      count += 1;
	      dl.load(dl.extend({url: d.url}, config.load), onLoad(d));
	    }
	    try {
	      parseData.datasource(model, d);
	    } catch (err) {
	      onError(err, d);
	    }
	  });
	
	  if (count === 0) setTimeout(callback, 1);
	  return spec;
	}
	
	parseData.datasource = function(model, d) {
	  var transform = (d.transform || []).map(function(t) {
	        return parseTransforms(model, t);
	      }),
	      mod = (d.modify || []).map(function(m) {
	        return parseModify(model, m, d);
	      }),
	      ds = model.data(d.name, mod.concat(transform));
	
	  if (d.values) {
	    ds.values(dl.read(d.values, d.format));
	  } else if (d.source) {
	    // Derived ds will be pulsed by its src rather than the model.
	    ds.source(d.source).addListener(ds);
	    model.removeListener(ds.pipeline()[0]);
	  }
	
	  return ds;
	};
	
	module.exports = parseData;
	
	var parseDef = {
	  "oneOf": [
	    {"enum": ["auto"]},
	    {
	      "type": "object",
	      "additionalProperties": {
	        "enum": ["number", "boolean", "date", "string"]
	      }
	    }
	  ]
	};
	
	parseData.schema = {
	  "defs": {
	    "data": {
	      "title": "Input data set definition",
	      "type": "object",
	
	      "allOf": [{
	        "properties": {
	          "name": {"type": "string"},
	          "transform": {"$ref": "#/defs/transform"},
	          "modify": {"$ref": "#/defs/modify"},
	          "format": {
	            "type": "object",
	            "oneOf": [{
	              "properties": {
	                "type": {"enum": ["json"]},
	                "parse": parseDef,
	                "property": {"type": "string"}
	              },
	              "additionalProperties": false
	            }, {
	              "properties": {
	                "type": {"enum": ["csv", "tsv"]},
	                "parse": parseDef
	              },
	              "additionalProperties": false
	            }, {
	              "oneOf": [{
	                "properties": {
	                  "type": {"enum": ["topojson"]},
	                  "feature": {"type": "string"}
	                },
	                "additionalProperties": false
	              }, {
	                "properties": {
	                  "type": {"enum": ["topojson"]},
	                  "mesh": {"type": "string"}
	                },
	                "additionalProperties": false
	              }]
	            }, {
	              "properties": {
	                "type": {"enum": ["treejson"]},
	                "children": {"type": "string"},
	                "parse": parseDef
	              },
	              "additionalProperties": false
	            }]
	          }
	        },
	        "required": ["name"]
	      }, {
	        "anyOf": [{
	          "required": ["name", "modify"]
	        }, {
	          "oneOf": [{
	            "properties": {"source": {"type": "string"}},
	            "required": ["source"]
	          }, {
	            "properties": {"values": {"type": "array"}},
	            "required": ["values"]
	          }, {
	            "properties": {"url": {"type": "string"}},
	            "required": ["url"]
	          }]
	        }]
	      }]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/data.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/transforms.js **/
jupyter.define('vega@2.6.3/src/parse/transforms.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    transforms = __jupyter_require__('vega@~2.6.3/src/transforms/index.js');
	
	function parseTransforms(model, def) {
	  var transform = transforms[def.type],
	      tx;
	
	  if (!transform) throw new Error('"' + def.type + '" is not a valid transformation');
	
	  tx = new transform(model);
	  // We want to rename output fields before setting any other properties,
	  // as subsequent properties may require output to be set (e.g. group by).
	  if(def.output) tx.output(def.output);
	
	  dl.keys(def).forEach(function(k) {
	    if(k === 'type' || k === 'output') return;
	    tx.param(k, def[k]);
	  });
	
	  return tx;
	}
	
	module.exports = parseTransforms;
	
	var keys = dl.keys(transforms)
	  .filter(function(k) { return transforms[k].schema; });
	
	var defs = keys.reduce(function(acc, k) {
	  return (acc[k+'Transform'] = transforms[k].schema, acc);
	}, {});
	
	parseTransforms.schema = {
	  "defs": dl.extend(defs, {
	    "transform": {
	      "type": "array",
	      "items": {
	        "oneOf": keys.map(function(k) {
	          return {"$ref": "#/defs/"+k+"Transform"};
	        })
	      }
	    }
	  })
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/transforms.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/index.js **/
jupyter.define('vega@2.6.3/src/transforms/index.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  aggregate:    __jupyter_require__('vega@~2.6.3/src/transforms/Aggregate.js'),
	  bin:          __jupyter_require__('vega@~2.6.3/src/transforms/Bin.js'),
	  cross:        __jupyter_require__('vega@~2.6.3/src/transforms/Cross.js'),
	  countpattern: __jupyter_require__('vega@~2.6.3/src/transforms/CountPattern.js'),
	  linkpath:     __jupyter_require__('vega@~2.6.3/src/transforms/LinkPath.js'),
	  facet:        __jupyter_require__('vega@~2.6.3/src/transforms/Facet.js'),
	  filter:       __jupyter_require__('vega@~2.6.3/src/transforms/Filter.js'),
	  fold:         __jupyter_require__('vega@~2.6.3/src/transforms/Fold.js'),
	  force:        __jupyter_require__('vega@~2.6.3/src/transforms/Force.js'),
	  formula:      __jupyter_require__('vega@~2.6.3/src/transforms/Formula.js'),
	  geo:          __jupyter_require__('vega@~2.6.3/src/transforms/Geo.js'),
	  geopath:      __jupyter_require__('vega@~2.6.3/src/transforms/GeoPath.js'),
	  hierarchy:    __jupyter_require__('vega@~2.6.3/src/transforms/Hierarchy.js'),
	  impute:       __jupyter_require__('vega@~2.6.3/src/transforms/Impute.js'),
	  lookup:       __jupyter_require__('vega@~2.6.3/src/transforms/Lookup.js'),
	  pie:          __jupyter_require__('vega@~2.6.3/src/transforms/Pie.js'),
	  rank:         __jupyter_require__('vega@~2.6.3/src/transforms/Rank.js'),
	  sort:         __jupyter_require__('vega@~2.6.3/src/transforms/Sort.js'),
	  stack:        __jupyter_require__('vega@~2.6.3/src/transforms/Stack.js'),
	  treeify:      __jupyter_require__('vega@~2.6.3/src/transforms/Treeify.js'),
	  treemap:      __jupyter_require__('vega@~2.6.3/src/transforms/Treemap.js'),
	  voronoi:      __jupyter_require__('vega@~2.6.3/src/transforms/Voronoi.js'),
	  wordcloud:    __jupyter_require__('vega@~2.6.3/src/transforms/Wordcloud.js')
	};
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/index.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Aggregate.js **/
jupyter.define('vega@2.6.3/src/transforms/Aggregate.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    ChangeSet = df.ChangeSet,
	    Tuple = df.Tuple,
	    Deps = df.Dependencies,
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    Facetor = __jupyter_require__('vega@~2.6.3/src/transforms/Facetor.js');
	
	function Aggregate(graph) {
	  Transform.prototype.init.call(this, graph);
	
	  Transform.addParameters(this, {
	    groupby: {type: 'array<field>'},
	    summarize: {
	      type: 'custom',
	      set: function(summarize) {
	        var signalDeps = {},
	            tx = this._transform,
	            i, len, f, fields, name, ops;
	
	        if (!dl.isArray(fields = summarize)) { // Object syntax from dl
	          fields = [];
	          for (name in summarize) {
	            ops = dl.array(summarize[name]);
	            fields.push({field: name, ops: ops});
	          }
	        }
	
	        function sg(x) { if (x.signal) signalDeps[x.signal] = 1; }
	
	        for (i=0, len=fields.length; i<len; ++i) {
	          f = fields[i];
	          if (f.field.signal) { signalDeps[f.field.signal] = 1; }
	          dl.array(f.ops).forEach(sg);
	          dl.array(f.as).forEach(sg);
	        }
	
	        tx._fields = fields;
	        tx._aggr = null;
	        tx.dependency(Deps.SIGNALS, dl.keys(signalDeps));
	        return tx;
	      }
	    }
	  });
	
	  this._aggr  = null; // dl.Aggregator
	  this._input = null; // Used by Facetor._on_keep.
	  this._args  = null; // To cull re-computation.
	  this._fields = [];
	  this._out = [];
	
	  this._type = TYPES.TUPLE;
	  this._acc = {groupby: dl.true, value: dl.true};
	
	  return this.router(true).produces(true);
	}
	
	var prototype = (Aggregate.prototype = Object.create(Transform.prototype));
	prototype.constructor = Aggregate;
	
	var TYPES = Aggregate.TYPES = {
	  VALUE: 1,
	  TUPLE: 2,
	  MULTI: 3
	};
	
	Aggregate.VALID_OPS = [
	  'values', 'count', 'valid', 'missing', 'distinct',
	  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev',
	  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max',
	  'argmin', 'argmax'
	];
	
	prototype.type = function(type) {
	  return (this._type = type, this);
	};
	
	prototype.accessors = function(groupby, value) {
	  var acc = this._acc;
	  acc.groupby = dl.$(groupby) || dl.true;
	  acc.value = dl.$(value) || dl.true;
	};
	
	prototype.aggr = function() {
	  if (this._aggr) return this._aggr;
	
	  var g = this._graph,
	      hasGetter = false,
	      args = [],
	      groupby = this.param('groupby').field,
	      value = function(x) { return x.signal ? g.signalRef(x.signal) : x; };
	
	  // Prepare summarize fields.
	  var fields = this._fields.map(function(f) {
	    var field = {
	      name: value(f.field),
	      as:   dl.array(f.as),
	      ops:  dl.array(value(f.ops)).map(value),
	      get:  f.get
	    };
	    hasGetter = hasGetter || field.get != null;
	    args.push(field.name);
	    return field;
	  });
	
	  // If there is an arbitrary getter, all bets are off.
	  // Otherwise, we can check argument fields to cull re-computation.
	  groupby.forEach(function(g) {
	    if (g.get) hasGetter = true;
	    args.push(g.name || g);
	  });
	  this._args = hasGetter || !fields.length ? null : args;
	
	  if (!fields.length) fields = {'*': 'values'};
	
	  // Instantiate our aggregator instance.
	  // Facetor is a special subclass that can facet into data pipelines.
	  var aggr = this._aggr = new Facetor()
	    .groupby(groupby)
	    .stream(true)
	    .summarize(fields);
	
	  // Collect output fields sets by this aggregate.
	  this._out = getFields(aggr);
	
	  // If we are processing tuples, key them by '_id'.
	  if (this._type !== TYPES.VALUE) { aggr.key('_id'); }
	
	  return aggr;
	};
	
	function getFields(aggr) {
	  // Collect the output fields set by this aggregate.
	  var f = [], i, n, j, m, dims, vals, meas;
	
	  dims = aggr._dims;
	  for (i=0, n=dims.length; i<n; ++i) {
	    f.push(dims[i].name);
	  }
	
	  vals = aggr._aggr;
	  for (i=0, n=vals.length; i<n; ++i) {
	    meas = vals[i].measures.fields;
	    for (j=0, m=meas.length; j<m; ++j) {
	      f.push(meas[j]);
	    }
	  }
	
	  return f;
	}
	
	prototype.transform = function(input, reset) {
	  log.debug(input, ['aggregate']);
	
	  var output = ChangeSet.create(input),
	      aggr = this.aggr(),
	      out = this._out,
	      args = this._args,
	      reeval = true,
	      p = Tuple.prev,
	      add, rem, mod, mark, i;
	
	  // Upon reset, retract prior tuples and re-initialize.
	  if (reset) {
	    output.rem.push.apply(output.rem, aggr.result());
	    aggr.clear();
	    this._aggr = null;
	    aggr = this.aggr();
	  }
	
	  // Get update methods according to input type.
	  if (this._type === TYPES.TUPLE) {
	    add  = function(x) { aggr._add(x); Tuple.prev_init(x); };
	    rem  = function(x) { aggr._rem(p(x)); };
	    mod  = function(x) { aggr._mod(x, p(x)); };
	    mark = function(x) { aggr._markMod(x, p(x)); };
	  } else {
	    var gby = this._acc.groupby,
	        val = this._acc.value,
	        get = this._type === TYPES.VALUE ? val : function(x) {
	          return { _id: x._id, groupby: gby(x), value: val(x) };
	        };
	    add  = function(x) { aggr._add(get(x)); Tuple.prev_init(x); };
	    rem  = function(x) { aggr._rem(get(p(x))); };
	    mod  = function(x) { aggr._mod(get(x), get(p(x))); };
	    mark = function(x) { aggr._mark(get(x), get(p(x))); };
	  }
	
	  input.add.forEach(add);
	  if (reset) {
	    // A signal change triggered reflow. Add everything.
	    // No need for rem, we cleared the aggregator.
	    input.mod.forEach(add);
	  } else {
	    input.rem.forEach(rem);
	
	    // If possible, check argument fields to see if we need to re-process mods.
	    if (args) for (i=0, reeval=false; i<args.length; ++i) {
	      if (input.fields[args[i]]) { reeval = true; break; }
	    }
	    input.mod.forEach(reeval ? mod : mark);
	  }
	
	  // Indicate output fields and return aggregate tuples.
	  for (i=0; i<out.length; ++i) {
	    output.fields[out[i]] = 1;
	  }
	  return (aggr._input = input, aggr.changes(output));
	};
	
	module.exports = Aggregate;
	
	var VALID_OPS = Aggregate.VALID_OPS;
	
	Aggregate.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Aggregate transform",
	  "description": "Compute summary aggregate statistics",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["aggregate"]},
	    "groupby": {
	      "type": "array",
	      "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]},
	      "description": "A list of fields to split the data into groups."
	    },
	    "summarize": {
	      "oneOf": [
	        {
	          "type": "object",
	          "additionalProperties": {
	            "type": "array",
	            "description": "An array of aggregate functions.",
	            "items": {"oneOf": [{"enum": VALID_OPS}, {"$ref": "#/refs/signal"}]}
	          }
	        },
	        {
	          "type": "array",
	          "items": {
	            "type": "object",
	            "properties": {
	              "field": {
	                "description": "The name of the field to aggregate.",
	                "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	              },
	              "ops": {
	                "type": "array",
	                "description": "An array of aggregate functions.",
	                "items": {"oneOf": [{"enum": VALID_OPS}, {"$ref": "#/refs/signal"}]}
	              },
	              "as": {
	                "type": "array",
	                "description": "An optional array of names to use for the output fields.",
	                "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	              }
	            },
	            "additionalProperties": false,
	            "required": ["field", "ops"]
	          }
	        }
	      ]
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Aggregate.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Transform.js **/
jupyter.define('vega@2.6.3/src/transforms/Transform.js', function (module, exports, __jupyter_require__) {
	var df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Base = df.Node.prototype, // jshint ignore:line
	    Deps = df.Dependencies,
	    Parameter = __jupyter_require__('vega@~2.6.3/src/transforms/Parameter.js');
	
	function Transform(graph) {
	  if (graph) Base.init.call(this, graph);
	}
	
	Transform.addParameters = function(proto, params) {
	  proto._parameters = proto._parameters || {};
	  for (var name in params) {
	    var p = params[name],
	        param = new Parameter(name, p.type, proto);
	
	    proto._parameters[name] = param;
	
	    if (p.type === 'custom') {
	      if (p.set) param.set = p.set.bind(param);
	      if (p.get) param.get = p.get.bind(param);
	    }
	
	    if (p.hasOwnProperty('default')) param.set(p.default);
	  }
	};
	
	var prototype = (Transform.prototype = Object.create(Base));
	prototype.constructor = Transform;
	
	prototype.param = function(name, value) {
	  var param = this._parameters[name];
	  return (param === undefined) ? this :
	    (arguments.length === 1) ? param.get() : param.set(value);
	};
	
	// Perform transformation. Subclasses should override.
	prototype.transform = function(input/*, reset */) {
	  return input;
	};
	
	prototype.evaluate = function(input) {
	  // Many transforms store caches that must be invalidated if
	  // a signal value has changed.
	  var reset = this._stamp < input.stamp &&
	    this.dependency(Deps.SIGNALS).reduce(function(c, s) {
	      return c += input.signals[s] ? 1 : 0;
	    }, 0);
	  return this.transform(input, reset);
	};
	
	prototype.output = function(map) {
	  for (var key in this._output) {
	    if (map[key] !== undefined) {
	      this._output[key] = map[key];
	    }
	  }
	  return this;
	};
	
	module.exports = Transform;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Transform.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Parameter.js **/
jupyter.define('vega@2.6.3/src/transforms/Parameter.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Deps = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Dependencies;
	
	var arrayType = /array/i,
	    dataType  = /data/i,
	    fieldType = /field/i,
	    exprType  = /expr/i,
	    valType   = /value/i;
	
	function Parameter(name, type, transform) {
	  this._name = name;
	  this._type = type;
	  this._transform = transform;
	
	  // If parameter is defined w/signals, it must be resolved
	  // on every pulse.
	  this._value = [];
	  this._accessors = [];
	  this._resolution = false;
	  this._signals = [];
	}
	
	var prototype = Parameter.prototype;
	
	function get() {
	  var isArray = arrayType.test(this._type),
	      isData  = dataType.test(this._type),
	      isField = fieldType.test(this._type);
	
	  var val = isArray ? this._value : this._value[0],
	      acc = isArray ? this._accessors : this._accessors[0];
	
	  if (!dl.isValid(acc) && valType.test(this._type)) {
	    return val;
	  } else {
	    return isData ? { name: val, source: acc } :
	    isField ? { field: val, accessor: acc } : val;
	  }
	}
	
	prototype.get = function() {
	  var graph = this._transform._graph,
	      isData  = dataType.test(this._type),
	      isField = fieldType.test(this._type),
	      i, n, sig, idx, val;
	
	  // If we don't require resolution, return the value immediately.
	  if (!this._resolution) return get.call(this);
	
	  if (isData) {
	    this._accessors = this._value.map(function(v) { return graph.data(v); });
	    return get.call(this); // TODO: support signal as dataTypes
	  }
	
	  for (i=0, n=this._signals.length; i<n; ++i) {
	    sig = this._signals[i];
	    idx = sig.index;
	    val = sig.value(graph);
	
	    if (isField) {
	      this._accessors[idx] = this._value[idx] != val ?
	        dl.accessor(val) : this._accessors[idx];
	    }
	
	    this._value[idx] = val;
	  }
	
	  return get.call(this);
	};
	
	prototype.set = function(value) {
	  var p = this,
	      graph = p._transform._graph,
	      isExpr = exprType.test(this._type),
	      isData  = dataType.test(this._type),
	      isField = fieldType.test(this._type);
	
	  p._signals = [];
	  this._value = dl.array(value).map(function(v, i) {
	    var e;
	    if (dl.isString(v)) {
	      if (isExpr) {
	        e = graph.expr(v);
	        p._transform.dependency(Deps.FIELDS,  e.fields);
	        p._transform.dependency(Deps.SIGNALS, e.globals);
	        p._transform.dependency(Deps.DATA,    e.dataSources);
	        return e.fn;
	      } else if (isField) {  // Backwards compatibility
	        p._accessors[i] = dl.accessor(v);
	        p._transform.dependency(Deps.FIELDS, dl.field(v));
	      } else if (isData) {
	        p._resolution = true;
	        p._transform.dependency(Deps.DATA, v);
	      }
	      return v;
	    } else if (v.value !== undefined) {
	      return v.value;
	    } else if (v.field !== undefined) {
	      p._accessors[i] = dl.accessor(v.field);
	      p._transform.dependency(Deps.FIELDS, dl.field(v.field));
	      return v.field;
	    } else if (v.signal !== undefined) {
	      p._resolution = true;
	      p._transform.dependency(Deps.SIGNALS, dl.field(v.signal)[0]);
	      p._signals.push({
	        index: i,
	        value: function(graph) { return graph.signalRef(v.signal); }
	      });
	      return v.signal;
	    } else if (v.expr !== undefined) {
	      p._resolution = true;
	      e = graph.expr(v.expr);
	      p._transform.dependency(Deps.SIGNALS, e.globals);
	      p._signals.push({
	        index: i,
	        value: function() { return e.fn(); }
	      });
	      return v.expr;
	    }
	
	    return v;
	  });
	
	  return p._transform;
	};
	
	module.exports = Parameter;
	
	// Schema for field|value-type parameters.
	Parameter.schema = {
	  "type": "object",
	  "oneOf": [{
	    "properties": {"field": {"type": "string"}},
	    "required": ["field"]
	  }, {
	    "properties": {"value": {"type": "string"}},
	    "required": ["value"]
	  }]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Parameter.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Facetor.js **/
jupyter.define('vega@2.6.3/src/transforms/Facetor.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Aggregator = dl.Aggregator,
	    Base = Aggregator.prototype,
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Tuple = df.Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    facetID = 0;
	
	function Facetor() {
	  Aggregator.call(this);
	  this._facet = null;
	  this._facetID = ++facetID;
	}
	
	var prototype = (Facetor.prototype = Object.create(Base));
	prototype.constructor = Facetor;
	
	prototype.facet = function(f) {
	  return arguments.length ? (this._facet = f, this) : this._facet;
	};
	
	prototype._ingest = function(t) {
	  return Tuple.ingest(t, null);
	};
	
	prototype._assign = Tuple.set;
	
	function disconnect_cell(facet) {
	  log.debug({}, ['disconnecting cell', this.tuple._id]);
	  var pipeline = this.ds.pipeline();
	  facet.removeListener(pipeline[0]);
	  facet._graph.removeListener(pipeline[0]);
	  facet._graph.disconnect(pipeline);
	}
	
	prototype._newcell = function(x, key) {
	  var cell  = Base._newcell.call(this, x, key),
	      facet = this._facet;
	
	  if (facet) {
	    var graph = facet._graph,
	        tuple = cell.tuple,
	        pipeline = facet.param('transform');
	    cell.ds = graph.data(tuple._facetID, pipeline, tuple);
	    cell.disconnect = disconnect_cell;
	    facet.addListener(pipeline[0]);
	  }
	
	  return cell;
	};
	
	prototype._newtuple = function(x, key) {
	  var t = Base._newtuple.call(this, x);
	  if (this._facet) {
	    Tuple.set(t, 'key', key);
	    Tuple.set(t, '_facetID', this._facetID + '_' + key);
	  }
	  return t;
	};
	
	prototype.clear = function() {
	  if (this._facet) {
	    for (var k in this._cells) {
	      this._cells[k].disconnect(this._facet);
	    }
	  }
	  return Base.clear.call(this);
	};
	
	prototype._on_add = function(x, cell) {
	  if (this._facet) cell.ds._input.add.push(x);
	};
	
	prototype._on_rem = function(x, cell) {
	  if (this._facet) cell.ds._input.rem.push(x);
	};
	
	prototype._on_mod = function(x, prev, cell0, cell1) {
	  if (this._facet) { // Propagate tuples
	    if (cell0 === cell1) {
	      cell0.ds._input.mod.push(x);
	    } else {
	      cell0.ds._input.rem.push(x);
	      cell1.ds._input.add.push(x);
	    }
	  }
	};
	
	prototype._on_drop = function(cell) {
	  if (this._facet) cell.disconnect(this._facet);
	};
	
	prototype._on_keep = function(cell) {
	  // propagate sort, signals, fields, etc.
	  if (this._facet) df.ChangeSet.copy(this._input, cell.ds._input);
	};
	
	module.exports = Facetor;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Facetor.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Bin.js **/
jupyter.define('vega@2.6.3/src/transforms/Bin.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Bin(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    field: {type: 'field'},
	    min: {type: 'value'},
	    max: {type: 'value'},
	    base: {type: 'value', default: 10},
	    maxbins: {type: 'value', default: 20},
	    step: {type: 'value'},
	    steps: {type: 'value'},
	    minstep: {type: 'value'},
	    div: {type: 'array<value>', default: [5, 2]}
	  });
	
	  this._output = {
	    start: 'bin_start',
	    end:   'bin_end',
	    mid:   'bin_mid'
	  };
	  return this.mutates(true);
	}
	
	var prototype = (Bin.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Bin;
	
	prototype.extent = function(data) {
	  // TODO only recompute extent upon data or field change?
	  var e = [this.param('min'), this.param('max')], d;
	  if (e[0] == null || e[1] == null) {
	    d = dl.extent(data, this.param('field').accessor);
	    if (e[0] == null) e[0] = d[0];
	    if (e[1] == null) e[1] = d[1];
	  }
	  return e;
	};
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['binning']);
	
	  var extent  = this.extent(data),
	      output  = this._output,
	      step    = this.param('step'),
	      steps   = this.param('steps'),
	      minstep = this.param('minstep'),
	      get     = this.param('field').accessor,
	      opt = {
	        min: extent[0],
	        max: extent[1],
	        base: this.param('base'),
	        maxbins: this.param('maxbins'),
	        div: this.param('div')
	      };
	
	  if (step) opt.step = step;
	  if (steps) opt.steps = steps;
	  if (minstep) opt.minstep = minstep;
	  var b = dl.bins(opt),
	      s = b.step;
	
	  function update(d) {
	    var v = get(d);
	    v = v == null ? null
	      : b.start + s * ~~((v - b.start) / s);
	    Tuple.set(d, output.start, v);
	    Tuple.set(d, output.end, v + s);
	    Tuple.set(d, output.mid, v + s/2);
	  }
	  input.add.forEach(update);
	  input.mod.forEach(update);
	  input.rem.forEach(update);
	
	  input.fields[output.start] = 1;
	  input.fields[output.end] = 1;
	  input.fields[output.mid] = 1;
	  return input;
	};
	
	module.exports = Bin;
	
	Bin.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Bin transform",
	  "description": "Bins values into quantitative bins (e.g., for a histogram).",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["bin"]},
	    "field": {
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "description": "The name of the field to bin values from."
	    },
	    "min": {
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "description": "The minimum bin value to consider."
	    },
	    "max": {
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "description": "The maximum bin value to consider."
	    },
	    "base": {
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "description": "The number base to use for automatic bin determination.",
	      "default": 10
	    },
	    "maxbins": {
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "description": "The maximum number of allowable bins.",
	      "default": 20
	    },
	    "step": {
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "description": "An exact step size to use between bins. If provided, options such as maxbins will be ignored."
	    },
	    "steps": {
	      "description": "An array of allowable step sizes to choose from.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"type": "number"}
	        },
	        {"$ref": "#/refs/signal"}
	      ]
	    },
	    "minstep": {
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "description": "A minimum allowable step size (particularly useful for integer values)."
	    },
	    "div": {
	      "description": "An array of scale factors indicating allowable subdivisions.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"type": "number"},
	          "default": [5, 2]
	        },
	        {"$ref": "#/refs/signal"}
	      ]
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "start": {"type": "string", "default": "bin_start"},
	        "end": {"type": "string", "default": "bin_end"},
	        "mid": {"type": "string", "default": "bin_mid"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type", "field"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Bin.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/BatchTransform.js **/
jupyter.define('vega@2.6.3/src/transforms/BatchTransform.js', function (module, exports, __jupyter_require__) {
	var Base = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js').prototype;
	
	function BatchTransform() {
	  // Nearest appropriate collector.
	  // Set by the dataflow Graph during connection.
	  this._collector = null;
	}
	
	var prototype = (BatchTransform.prototype = Object.create(Base));
	prototype.constructor = BatchTransform;
	
	prototype.init = function(graph) {
	  Base.init.call(this, graph);
	  return this.batch(true);
	};
	
	prototype.transform = function(input, reset) {
	  return this.batchTransform(input, this._collector.data(), reset);
	};
	
	prototype.batchTransform = function(/* input, data, reset */) {
	};
	
	module.exports = BatchTransform;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/BatchTransform.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Cross.js **/
jupyter.define('vega@2.6.3/src/transforms/Cross.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    ChangeSet = df.ChangeSet,
	    Tuple = df.Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Cross(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    with: {type: 'data'},
	    diagonal: {type: 'value', default: 'true'},
	    filter: {type: 'expr'}
	  });
	
	  this._output = {'left': 'a', 'right': 'b'};
	  this._lastWith = null; // Last time we crossed w/with-ds.
	  this._cids  = {};
	  this._cache = {};
	
	  return this.router(true).produces(true);
	}
	
	var prototype = (Cross.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Cross;
	
	// Each cached incoming tuple also has a flag to determine whether
	// any tuples were filtered.
	function _cache(x, t) {
	  var c = this._cache,
	      cross = c[x._id] || (c[x._id] = {c: [], f: false});
	  cross.c.push(t);
	}
	
	function _cid(left, x, y) {
	  return left ? x._id+'_'+y._id : y._id+'_'+x._id;
	}
	
	function add(output, left, data, diag, test, mids, x) {
	  var as = this._output,
	      cache = this._cache,
	      cids  = this._cids,
	      oadd  = output.add,
	      fltrd = false,
	      i = 0, len = data.length,
	      t = {}, y, cid;
	
	  for (; i<len; ++i) {
	    y = data[i];
	    cid = _cid(left, x, y);
	    if (cids[cid]) continue;
	    if (x._id === y._id && !diag) continue;
	
	    Tuple.set(t, as.left, left ? x : y);
	    Tuple.set(t, as.right, left ? y : x);
	
	    // Only ingest a tuple if we keep it around. Otherwise, flag the
	    // caches as filtered.
	    if (!test || test(t)) {
	      oadd.push(t=Tuple.ingest(t));
	      _cache.call(this, x, t);
	      if (x._id !== y._id) _cache.call(this, y, t);
	      mids[t._id] = 1;
	      cids[cid] = true;
	      t = {};
	    } else {
	      if (cache[y._id]) cache[y._id].f = true;
	      fltrd = true;
	    }
	  }
	
	  if (cache[x._id]) cache[x._id].f = fltrd;
	}
	
	function mod(output, left, data, diag, test, mids, rids, x) {
	  var as = this._output,
	      cache = this._cache,
	      cids  = this._cids,
	      cross = cache[x._id],
	      tpls  = cross && cross.c,
	      fltrd = !cross || cross.f,
	      omod  = output.mod,
	      orem  = output.rem,
	      i, t, y, l, cid;
	
	  // If we have cached values, iterate through them for lazy
	  // removal, and to re-run the filter.
	  if (tpls) {
	    for (i=tpls.length-1; i>=0; --i) {
	      t = tpls[i];
	      l = x === t[as.left]; // Cache has tpls w/x both on left & right.
	      y = l ? t[as.right] : t[as.left];
	      cid = _cid(l, x, y);
	
	      // Lazy removal: y was previously rem'd, so clean up the cache.
	      if (!cache[y._id]) {
	        cids[cid] = false;
	        tpls.splice(i, 1);
	        continue;
	      }
	
	      if (!test || test(t)) {
	        if (mids[t._id]) continue;
	        omod.push(t);
	        mids[t._id] = 1;
	      } else {
	        if (!rids[t._id]) orem.push.apply(orem, tpls.splice(i, 1));
	        rids[t._id] = 1;
	        cids[cid] = false;
	        cross.f = true;
	      }
	    }
	  }
	
	  // If we have a filter param, call add to catch any tuples that may
	  // have previously been filtered.
	  if (test && fltrd) add.call(this, output, left, data, diag, test, mids, x);
	}
	
	function rem(output, left, rids, x) {
	  var as = this._output,
	      cross = this._cache[x._id],
	      cids  = this._cids,
	      orem  = output.rem,
	      i, len, t, y, l;
	  if (!cross) return;
	
	  for (i=0, len=cross.c.length; i<len; ++i) {
	    t = cross.c[i];
	    l = x === t[as.left];
	    y = l ? t[as.right] : t[as.left];
	    cids[_cid(l, x, y)] = false;
	    if (!rids[t._id]) {
	      orem.push(t);
	      rids[t._id] = 1;
	    }
	  }
	
	  this._cache[x._id] = null;
	}
	
	function purge(output, rids) {
	  var cache = this._cache,
	      keys  = dl.keys(cache),
	      rem = output.rem,
	      i, len, j, jlen, cross, t;
	
	  for (i=0, len=keys.length; i<len; ++i) {
	    cross = cache[keys[i]];
	    for (j=0, jlen=cross.c.length; j<jlen; ++j) {
	      t = cross.c[j];
	      if (rids[t._id]) continue;
	      rem.push(t);
	      rids[t._id] = 1;
	    }
	  }
	
	  this._cache = {};
	  this._cids = {};
	  this._lastWith = null;
	}
	
	prototype.batchTransform = function(input, data, reset) {
	  log.debug(input, ['crossing']);
	
	  var w = this.param('with'),
	      diag = this.param('diagonal'),
	      as = this._output,
	      test = this.param('filter') || null,
	      selfCross = (!w.name),
	      woutput = selfCross ? input : w.source.last(),
	      wdata   = selfCross ? data : w.source.values(),
	      output  = ChangeSet.create(input),
	      mids = {}, rids = {}; // Track IDs to prevent dupe mod/rem tuples.
	
	  // If signal values (for diag or test) have changed, purge the cache
	  // and re-run cross in batch mode. Otherwise stream cross values.
	  if (reset) {
	    purge.call(this, output, rids);
	    data.forEach(add.bind(this, output, true, wdata, diag, test, mids));
	    this._lastWith = woutput.stamp;
	  } else {
	    input.rem.forEach(rem.bind(this, output, true, rids));
	    input.add.forEach(add.bind(this, output, true, wdata, diag, test, mids));
	
	    if (woutput.stamp > this._lastWith) {
	      woutput.rem.forEach(rem.bind(this, output, false, rids));
	      woutput.add.forEach(add.bind(this, output, false, data, diag, test, mids));
	      woutput.mod.forEach(mod.bind(this, output, false, data, diag, test, mids, rids));
	      this._lastWith = woutput.stamp;
	    }
	
	    // Mods need to come after all removals have been run.
	    input.mod.forEach(mod.bind(this, output, true, wdata, diag, test, mids, rids));
	  }
	
	  output.fields[as.left]  = 1;
	  output.fields[as.right] = 1;
	  return output;
	};
	
	module.exports = Cross;
	
	Cross.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Cross transform",
	  "description": "Compute the cross-product of two data sets.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["cross"]},
	    "with": {
	      "type": "string",
	      "description": "The name of the secondary data set to cross with the primary data. " +
	        "If unspecified, the primary data is crossed with itself."
	    },
	    "diagonal": {
	      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
	      "description": "If false, items along the \"diagonal\" of the cross-product " +
	        "(those elements with the same index in their respective array) " +
	        "will not be included in the output.",
	      "default": true
	    },
	    "filter": {
	      "type": "string",
	      "description": "A string containing an expression (in JavaScript syntax) " +
	        "to filter the resulting data elements."
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "left": {"type": "string", "default": "a"},
	        "right": {"type": "string", "default": "b"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Cross.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/CountPattern.js **/
jupyter.define('vega@2.6.3/src/transforms/CountPattern.js', function (module, exports, __jupyter_require__) {
	var df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Tuple = df.Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function CountPattern(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    field:     {type: 'field', default: 'data'},
	    pattern:   {type: 'value', default: '[\\w\']+'},
	    case:      {type: 'value', default: 'lower'},
	    stopwords: {type: 'value', default: ''}
	  });
	
	  this._output = {text: 'text', count: 'count'};
	
	  return this.router(true).produces(true);
	}
	
	var prototype = (CountPattern.prototype = Object.create(Transform.prototype));
	prototype.constructor = CountPattern;
	
	prototype.transform = function(input, reset) {
	  log.debug(input, ['countpattern']);
	
	  var get = this.param('field').accessor,
	      pattern = this.param('pattern'),
	      stop = this.param('stopwords'),
	      rem = false;
	
	  // update parameters
	  if (this._stop !== stop) {
	    this._stop = stop;
	    this._stop_re = new RegExp('^' + stop + '$', 'i');
	    reset = true;
	  }
	
	  if (this._pattern !== pattern) {
	    this._pattern = pattern;
	    this._match = new RegExp(this._pattern, 'g');
	    reset = true;
	  }
	
	  if (reset) this._counts = {};
	
	  function curr(t) { return (Tuple.prev_init(t), get(t)); }
	  function prev(t) { return get(Tuple.prev(t)); }
	
	  this._add(input.add, curr);
	  if (!reset) this._rem(input.rem, prev);
	  if (reset || (rem = input.fields[get.field])) {
	    if (rem) this._rem(input.mod, prev);
	    this._add(input.mod, curr);
	  }
	
	  // generate output tuples
	  return this._changeset(input);
	};
	
	prototype._changeset = function(input) {
	  var counts = this._counts,
	      tuples = this._tuples || (this._tuples = {}),
	      change = df.ChangeSet.create(input),
	      out = this._output, w, t, c;
	
	  for (w in counts) {
	    t = tuples[w];
	    c = counts[w] || 0;
	    if (!t && c) {
	      tuples[w] = (t = Tuple.ingest({}));
	      t[out.text] = w;
	      t[out.count] = c;
	      change.add.push(t);
	    } else if (c === 0) {
	      if (t) change.rem.push(t);
	      delete counts[w];
	      delete tuples[w];
	    } else if (t[out.count] !== c) {
	      Tuple.set(t, out.count, c);
	      change.mod.push(t);
	    }
	  }
	  return change;
	};
	
	prototype._tokenize = function(text) {
	  switch (this.param('case')) {
	    case 'upper': text = text.toUpperCase(); break;
	    case 'lower': text = text.toLowerCase(); break;
	  }
	  return text.match(this._match);
	};
	
	prototype._add = function(tuples, get) {
	  var counts = this._counts,
	      stop = this._stop_re,
	      tok, i, j, t;
	
	  for (j=0; j<tuples.length; ++j) {
	    tok = this._tokenize(get(tuples[j]));
	    for (i=0; i<tok.length; ++i) {
	      if (!stop.test(t=tok[i])) {
	        counts[t] = 1 + (counts[t] || 0);
	      }
	    }
	  }
	};
	
	prototype._rem = function(tuples, get) {
	  var counts = this._counts,
	      stop = this._stop_re,
	      tok, i, j, t;
	
	  for (j=0; j<tuples.length; ++j) {
	    tok = this._tokenize(get(tuples[j]));
	    for (i=0; i<tok.length; ++i) {
	      if (!stop.test(t=tok[i])) {
	        counts[t] -= 1;
	      }
	    }
	  }
	};
	
	module.exports = CountPattern;
	
	CountPattern.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "CountPattern transform",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["countpattern"]},
	    "field": {
	      "description": "The field containing the text to analyze.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": 'data'
	    },
	    "pattern": {
	      "description": "A regexp pattern for matching words in text.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "[\\w\']+"
	    },
	    "case": {
	      "description": "Text case transformation to apply.",
	      "oneOf": [{"enum": ["lower", "upper", "none"]}, {"$ref": "#/refs/signal"}],
	      "default": "lower"
	    },
	    "stopwords": {
	      "description": "A regexp pattern for matching stopwords to omit.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": ""
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "text": {"type": "string", "default": "text"},
	        "count": {"type": "string", "default": "count"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/CountPattern.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/LinkPath.js **/
jupyter.define('vega@2.6.3/src/transforms/LinkPath.js', function (module, exports, __jupyter_require__) {
	var Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function LinkPath(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    sourceX:  {type: 'field', default: '_source.layout_x'},
	    sourceY:  {type: 'field', default: '_source.layout_y'},
	    targetX:  {type: 'field', default: '_target.layout_x'},
	    targetY:  {type: 'field', default: '_target.layout_y'},
	    tension:  {type: 'value', default: 0.2},
	    shape:    {type: 'value', default: 'line'}
	  });
	
	  this._output = {'path': 'layout_path'};
	  return this.mutates(true);
	}
	
	var prototype = (LinkPath.prototype = Object.create(Transform.prototype));
	prototype.constructor = LinkPath;
	
	function line(sx, sy, tx, ty) {
	  return 'M' + sx + ',' + sy +
	         'L' + tx + ',' + ty;
	}
	
	function curve(sx, sy, tx, ty, tension) {
	  var dx = tx - sx,
	      dy = ty - sy,
	      ix = tension * (dx + dy),
	      iy = tension * (dy - dx);
	  return 'M' + sx + ',' + sy +
	         'C' + (sx+ix) + ',' + (sy+iy) +
	         ' ' + (tx+iy) + ',' + (ty-ix) +
	         ' ' + tx + ',' + ty;
	}
	
	function cornerX(sx, sy, tx, ty) {
	  return 'M' + sx + ',' + sy +
	         'V' + ty + 'H' + tx;
	}
	
	function cornerY(sx, sy, tx, ty) {
	  return 'M' + sx + ',' + sy +
	         'H' + tx + 'V' + ty;
	}
	
	function cornerR(sa, sr, ta, tr) {
	  var sc = Math.cos(sa),
	      ss = Math.sin(sa),
	      tc = Math.cos(ta),
	      ts = Math.sin(ta),
	      sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;
	  return 'M' + (sr*sc) + ',' + (sr*ss) +
	         'A' + sr + ',' + sr + ' 0 0,' + (sf?1:0) +
	         ' ' + (sr*tc) + ',' + (sr*ts) +
	         'L' + (tr*tc) + ',' + (tr*ts);
	}
	
	function diagonalX(sx, sy, tx, ty) {
	  var m = (sx + tx) / 2;
	  return 'M' + sx + ',' + sy +
	         'C' + m  + ',' + sy +
	         ' ' + m  + ',' + ty +
	         ' ' + tx + ',' + ty;
	}
	
	function diagonalY(sx, sy, tx, ty) {
	  var m = (sy + ty) / 2;
	  return 'M' + sx + ',' + sy +
	         'C' + sx + ',' + m +
	         ' ' + tx + ',' + m +
	         ' ' + tx + ',' + ty;
	}
	
	function diagonalR(sa, sr, ta, tr) {
	  var sc = Math.cos(sa),
	      ss = Math.sin(sa),
	      tc = Math.cos(ta),
	      ts = Math.sin(ta),
	      mr = (sr + tr) / 2;
	  return 'M' + (sr*sc) + ',' + (sr*ss) +
	         'C' + (mr*sc) + ',' + (mr*ss) +
	         ' ' + (mr*tc) + ',' + (mr*ts) +
	         ' ' + (tr*tc) + ',' + (tr*ts);
	}
	
	var shapes = {
	  line:      line,
	  curve:     curve,
	  cornerX:   cornerX,
	  cornerY:   cornerY,
	  cornerR:   cornerR,
	  diagonalX: diagonalX,
	  diagonalY: diagonalY,
	  diagonalR: diagonalR
	};
	
	prototype.transform = function(input) {
	  log.debug(input, ['linkpath']);
	
	  var output = this._output,
	      shape = shapes[this.param('shape')] || shapes.line,
	      sourceX = this.param('sourceX').accessor,
	      sourceY = this.param('sourceY').accessor,
	      targetX = this.param('targetX').accessor,
	      targetY = this.param('targetY').accessor,
	      tension = this.param('tension');
	
	  function set(t) {
	    var path = shape(sourceX(t), sourceY(t), targetX(t), targetY(t), tension);
	    Tuple.set(t, output.path, path);
	  }
	
	  input.add.forEach(set);
	  if (this.reevaluate(input)) {
	    input.mod.forEach(set);
	    input.rem.forEach(set);
	  }
	
	  input.fields[output.path] = 1;
	  return input;
	};
	
	module.exports = LinkPath;
	
	LinkPath.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "LinkPath transform",
	  "description": "Computes a path definition for connecting nodes within a node-link network or tree diagram.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["linkpath"]},
	    "sourceX": {
	      "description": "The data field that references the source x-coordinate for this link.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "_source"
	    },
	    "sourceY": {
	      "description": "The data field that references the source y-coordinate for this link.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "_source"
	    },
	    "targetX": {
	      "description": "The data field that references the target x-coordinate for this link.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "_target"
	    },
	    "targetY": {
	      "description": "The data field that references the target y-coordinate for this link.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "_target"
	    },
	    "tension": {
	      "description": "A tension parameter for the \"tightness\" of \"curve\"-shaped links.",
	      "oneOf": [
	        {
	          "type": "number",
	          "minimum": 0,
	          "maximum": 1
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": 0.2
	    },
	    "shape": {
	      "description": "The path shape to use",
	      "oneOf": [
	        {"enum": ["line", "curve", "cornerX", "cornerY", "cornerR", "diagonalX", "diagonalY", "diagonalR"]},
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": "line"
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "path": {"type": "string", "default": "layout_path"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/LinkPath.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Facet.js **/
jupyter.define('vega@2.6.3/src/transforms/Facet.js', function (module, exports, __jupyter_require__) {
	var Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    Aggregate = __jupyter_require__('vega@~2.6.3/src/transforms/Aggregate.js');
	
	function Facet(graph) {
	  Transform.addParameters(this, {
	    transform: {
	      type: "custom",
	      set: function(pipeline) {
	        return (this._transform._pipeline = pipeline, this._transform);
	      },
	      get: function() {
	        var parse = __jupyter_require__('vega@~2.6.3/src/parse/transforms.js'),
	            facet = this._transform;
	        return facet._pipeline.map(function(t) {
	          return parse(facet._graph, t);
	        });
	      }
	    }
	  });
	
	  this._pipeline = [];
	  return Aggregate.call(this, graph);
	}
	
	var prototype = (Facet.prototype = Object.create(Aggregate.prototype));
	prototype.constructor = Facet;
	
	prototype.aggr = function() {
	  return Aggregate.prototype.aggr.call(this).facet(this);
	};
	
	prototype.transform = function(input, reset) {
	  var output  = Aggregate.prototype.transform.call(this, input, reset);
	
	  // New facet cells should trigger a re-ranking of the dataflow graph.
	  // This ensures facet datasources are computed before scenegraph nodes.
	  // We rerank the Facet's first listener, which is the next node in the
	  // datasource's pipeline.
	  if (input.add.length) {
	    this.listeners()[0].rerank();
	  }
	
	  return output;
	};
	
	module.exports = Facet;
	
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js');
	
	Facet.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Facet transform",
	  "description": "A special aggregate transform that organizes a data set into groups or \"facets\".",
	  "type": "object",
	  "properties": dl.extend({}, Aggregate.schema.properties, {
	    "type": {"enum": ["facet"]},
	    "transform": {"$ref": "#/defs/transform"}
	  }),
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Facet.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Filter.js **/
jupyter.define('vega@2.6.3/src/transforms/Filter.js', function (module, exports, __jupyter_require__) {
	var df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function Filter(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {test: {type: 'expr'}});
	
	  this._skip = {};
	  return this.router(true);
	}
	
	var prototype = (Filter.prototype = Object.create(Transform.prototype));
	prototype.constructor = Filter;
	
	prototype.transform = function(input) {
	  log.debug(input, ['filtering']);
	
	  var output = df.ChangeSet.create(input),
	      skip = this._skip,
	      test = this.param('test');
	
	  input.rem.forEach(function(x) {
	    if (skip[x._id] !== 1) output.rem.push(x);
	    else skip[x._id] = 0;
	  });
	
	  input.add.forEach(function(x) {
	    if (test(x)) output.add.push(x);
	    else skip[x._id] = 1;
	  });
	
	  input.mod.forEach(function(x) {
	    var b = test(x),
	        s = (skip[x._id] === 1);
	    if (b && s) {
	      skip[x._id] = 0;
	      output.add.push(x);
	    } else if (b && !s) {
	      output.mod.push(x);
	    } else if (!b && s) {
	      // do nothing, keep skip true
	    } else { // !b && !s
	      output.rem.push(x);
	      skip[x._id] = 1;
	    }
	  });
	
	  return output;
	};
	
	module.exports = Filter;
	
	Filter.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Filter transform",
	  "description": "Filters elements from a data set to remove unwanted items.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["filter"]},
	    "test": {
	      "type": "string",
	      "description": "A string containing an expression (in JavaScript syntax) for the filter predicate."
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type", "test"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Filter.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Fold.js **/
jupyter.define('vega@2.6.3/src/transforms/Fold.js', function (module, exports, __jupyter_require__) {
	var df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Tuple = df.Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function Fold(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    fields: {type: 'array<field>'}
	  });
	
	  this._output = {key: 'key', value: 'value'};
	  this._cache = {};
	
	  return this.router(true).produces(true);
	}
	
	var prototype = (Fold.prototype = Object.create(Transform.prototype));
	prototype.constructor = Fold;
	
	prototype._reset = function(input, output) {
	  for (var id in this._cache) {
	    output.rem.push.apply(output.rem, this._cache[id]);
	  }
	  this._cache = {};
	};
	
	prototype._tuple = function(x, i, len) {
	  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));
	  return list[i] ? Tuple.rederive(x, list[i]) : (list[i] = Tuple.derive(x));
	};
	
	prototype._fn = function(data, on, out) {
	  var i, j, n, m, d, t;
	  for (i=0, n=data.length; i<n; ++i) {
	    d = data[i];
	    for (j=0, m=on.field.length; j<m; ++j) {
	      t = this._tuple(d, j, m);
	      Tuple.set(t, this._output.key, on.field[j]);
	      Tuple.set(t, this._output.value, on.accessor[j](d));
	      out.push(t);
	    }
	  }
	};
	
	prototype.transform = function(input, reset) {
	  log.debug(input, ['folding']);
	
	  var fold = this,
	      on = this.param('fields'),
	      output = df.ChangeSet.create(input);
	
	  if (reset) this._reset(input, output);
	
	  this._fn(input.add, on, output.add);
	  this._fn(input.mod, on, reset ? output.add : output.mod);
	  input.rem.forEach(function(x) {
	    output.rem.push.apply(output.rem, fold._cache[x._id]);
	    fold._cache[x._id] = null;
	  });
	
	  // If we're only propagating values, don't mark key/value as updated.
	  if (input.add.length || input.rem.length ||
	      on.field.some(function(f) { return !!input.fields[f]; })) {
	    output.fields[this._output.key] = 1;
	    output.fields[this._output.value] = 1;
	  }
	  return output;
	};
	
	module.exports = Fold;
	
	Fold.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Fold transform",
	  "description": "Collapse (\"fold\") one or more data properties into two properties.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["fold"]},
	    "fields": {
	      "oneOf": [
	        {
	          "type": "array",
	          "description": "An array of field references indicating the data properties to fold.",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]},
	          "minItems": 1,
	          "uniqueItems": true
	        },
	        {"$ref": "#/refs/signal"}
	      ]
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "key": {"type": "string", "default": "key"},
	        "value": {"type": "string", "default": "value"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type", "fields"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Fold.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Force.js **/
jupyter.define('vega@2.6.3/src/transforms/Force.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Tuple = df.Tuple,
	    ChangeSet = df.ChangeSet,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function Force(graph) {
	  Transform.prototype.init.call(this, graph);
	
	  this._prev = null;
	  this._interactive = false;
	  this._setup = true;
	  this._nodes  = [];
	  this._links = [];
	  this._layout = d3.layout.force();
	
	  Transform.addParameters(this, {
	    size: {type: 'array<value>', default: __jupyter_require__('vega@~2.6.3/src/transforms/screen.js').size},
	    bound: {type: 'value', default: true},
	    links: {type: 'data'},
	
	    // TODO: for now force these to be value params only (pun-intended)
	    // Can update to include fields after Parameter refactoring.
	    linkStrength: {type: 'value', default: 1},
	    linkDistance: {type: 'value', default: 20},
	    charge: {type: 'value', default: -30},
	
	    chargeDistance: {type: 'value', default: Infinity},
	    friction: {type: 'value', default: 0.9},
	    theta: {type: 'value', default: 0.8},
	    gravity: {type: 'value', default: 0.1},
	    alpha: {type: 'value', default: 0.1},
	    iterations: {type: 'value', default: 500},
	
	    interactive: {type: 'value', default: this._interactive},
	    active: {type: 'value', default: this._prev},
	    fixed: {type: 'data'}
	  });
	
	  this._output = {
	    'x': 'layout_x',
	    'y': 'layout_y'
	  };
	
	  return this.mutates(true);
	}
	
	var prototype = (Force.prototype = Object.create(Transform.prototype));
	prototype.constructor = Force;
	
	prototype.transform = function(nodeInput, reset) {
	  log.debug(nodeInput, ['force']);
	  reset = reset - (nodeInput.signals.active ? 1 : 0);
	
	  // get variables
	  var interactive = this.param('interactive'),
	      linkSource = this.param('links').source,
	      linkInput = linkSource.last(),
	      active = this.param('active'),
	      output = this._output,
	      layout = this._layout,
	      nodes = this._nodes,
	      links = this._links;
	
	  // configure nodes, links and layout
	  if (linkInput.stamp < nodeInput.stamp) linkInput = null;
	  this.configure(nodeInput, linkInput, interactive, reset);
	
	  // run batch layout
	  if (!interactive) {
	    var iterations = this.param('iterations');
	    for (var i=0; i<iterations; ++i) layout.tick();
	    layout.stop();
	  }
	
	  // update node positions
	  this.update(active);
	
	  // re-up alpha on parameter change
	  if (reset || active !== this._prev && active && active.update) {
	    layout.alpha(this.param('alpha')); // re-start layout
	  }
	
	  // update active node status,
	  if (active !== this._prev) {
	    this._prev = active;
	  }
	
	  // process removed nodes or edges
	  if (nodeInput.rem.length) {
	    layout.nodes(this._nodes = Tuple.idFilter(nodes, nodeInput.rem));
	  }
	  if (linkInput && linkInput.rem.length) {
	    layout.links(this._links = Tuple.idFilter(links, linkInput.rem));
	  }
	
	  // return changeset
	  nodeInput.fields[output.x] = 1;
	  nodeInput.fields[output.y] = 1;
	  return nodeInput;
	};
	
	prototype.configure = function(nodeInput, linkInput, interactive, reset) {
	  // check if we need to run configuration
	  var layout = this._layout,
	      update = this._setup || nodeInput.add.length ||
	            linkInput && linkInput.add.length ||
	            interactive !== this._interactive ||
	            this.param('charge') !== layout.charge() ||
	            this.param('linkStrength') !== layout.linkStrength() ||
	            this.param('linkDistance') !== layout.linkDistance();
	
	  if (update || reset) {
	    // a parameter changed, so update tick-only parameters
	    layout
	      .size(this.param('size'))
	      .chargeDistance(this.param('chargeDistance'))
	      .theta(this.param('theta'))
	      .gravity(this.param('gravity'))
	      .friction(this.param('friction'));
	  }
	
	  if (!update) return; // if no more updates needed, return now
	
	  this._setup = false;
	  this._interactive = interactive;
	
	  var force = this,
	      graph = this._graph,
	      nodes = this._nodes,
	      links = this._links, a, i;
	
	  // process added nodes
	  for (a=nodeInput.add, i=0; i<a.length; ++i) {
	    nodes.push({tuple: a[i]});
	  }
	
	  // process added edges
	  if (linkInput) for (a=linkInput.add, i=0; i<a.length; ++i) {
	    // TODO add configurable source/target accessors
	    // TODO support lookup by node id
	    // TODO process 'mod' of edge source or target?
	    links.push({
	      tuple:  a[i],
	      source: nodes[a[i].source],
	      target: nodes[a[i].target]
	    });
	  }
	
	  // setup handler for force layout tick events
	  var tickHandler = !interactive ? null : function() {
	    // re-schedule the transform, force reflow
	    graph.propagate(ChangeSet.create(null, true), force);
	  };
	
	  // configure the rest of the layout
	  layout
	    .linkStrength(this.param('linkStrength'))
	    .linkDistance(this.param('linkDistance'))
	    .charge(this.param('charge'))
	    .nodes(nodes)
	    .links(links)
	    .on('tick', tickHandler)
	    .start().alpha(this.param('alpha'));
	};
	
	prototype.update = function(active) {
	  var output = this._output,
	      bound = this.param('bound'),
	      fixed = this.param('fixed'),
	      size = this.param('size'),
	      nodes = this._nodes,
	      lut = {}, id, i, n, t, x, y;
	
	  if (fixed && fixed.source) {
	    // TODO: could cache and update as needed?
	    fixed = fixed.source.values();
	    for (i=0, n=fixed.length; i<n; ++i) {
	      lut[fixed[i].id] = 1;
	    }
	  }
	
	  for (i=0; i<nodes.length; ++i) {
	    n = nodes[i];
	    t = n.tuple;
	    id = t._id;
	
	    if (active && active.id === id) {
	      n.fixed = 1;
	      if (active.update) {
	        n.x = n.px = active.x;
	        n.y = n.py = active.y;
	      }
	    } else {
	      n.fixed = lut[id] || 0;
	    }
	
	    x = bound ? Math.max(0, Math.min(n.x, size[0])) : n.x;
	    y = bound ? Math.max(0, Math.min(n.y, size[1])) : n.y;
	    Tuple.set(t, output.x, x);
	    Tuple.set(t, output.y, y);
	  }
	};
	
	module.exports = Force;
	
	Force.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Force transform",
	  "description": "Performs force-directed layout for network data.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["force"]},
	    "size": {
	      "description": "The dimensions [width, height] of this force layout.",
	      "oneOf": [
	        {
	          "type": "array",
	          "minItems": 2,
	          "maxItems": 2,
	          "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	
	      "default": [500, 500]
	    },
	    "links": {
	      "type": "string",
	      "description": "The name of the link (edge) data set."
	    },
	    "linkDistance": {
	      "description": "Determines the length of edges, in pixels.",
	      "oneOf": [{"type": "number"}, {"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": 20
	    },
	    "linkStrength": {
	      "oneOf": [{"type": "number"}, {"type": "string"}, {"$ref": "#/refs/signal"}],
	      "description": "Determines the tension of edges (the spring constant).",
	      "default": 1
	    },
	    "charge": {
	      "oneOf": [{"type": "number"}, {"type": "string"}, {"$ref": "#/refs/signal"}],
	      "description": "The strength of the charge each node exerts.",
	      "default": -30
	    },
	    "chargeDistance": {
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "description": "The maximum distance over which charge forces are applied.",
	      "default": Infinity
	    },
	    "iterations": {
	      "description": "The number of iterations to run the force directed layout.",
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "default": 500
	    },
	    "friction": {
	      "description": "The strength of the friction force used to stabilize the layout.",
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "default": 0.9
	    },
	    "theta": {
	      "description": "The theta parameter for the Barnes-Hut algorithm, which is used to compute charge forces between nodes.",
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "default": 0.8
	    },
	    "gravity": {
	      "description": "The strength of the pseudo-gravity force that pulls nodes towards the center of the layout area.",
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "default": 0.1
	    },
	    "alpha": {
	      "description": "A \"temperature\" parameter that determines how much node positions are adjusted at each step.",
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "default": 0.1
	    },
	    "interactive": {
	      "description": "Enables an interactive force-directed layout.",
	      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
	      "default": false
	    },
	    "active": {
	      "description": "A signal representing the active node.",
	      "$ref": "#/refs/signal"
	    },
	    "fixed": {
	      "description": "The name of a datasource containing the IDs of nodes with fixed positions.",
	      "type": "string"
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "x": {"type": "string", "default": "layout_x"},
	        "y": {"type": "string", "default": "layout_y"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type", "links"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Force.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/screen.js **/
jupyter.define('vega@2.6.3/src/transforms/screen.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  size:   [{signal: 'width'}, {signal: 'height'}],
	  mid:    [{expr: 'width/2'}, {expr: 'height/2'}],
	  extent: [
	    {expr: '[-padding.left, -padding.top]'},
	    {expr: '[width+padding.right, height+padding.bottom]'}
	  ]
	};
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/screen.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Formula.js **/
jupyter.define('vega@2.6.3/src/transforms/Formula.js', function (module, exports, __jupyter_require__) {
	var df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Tuple = df.Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function Formula(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    field: {type: 'value'},
	    expr:  {type: 'expr'}
	  });
	
	  return this.mutates(true);
	}
	
	var prototype = (Formula.prototype = Object.create(Transform.prototype));
	prototype.constructor = Formula;
	
	prototype.transform = function(input) {
	  log.debug(input, ['formulating']);
	
	  var field = this.param('field'),
	      expr = this.param('expr'),
	      updated = false;
	
	  function set(x) {
	    Tuple.set(x, field, expr(x));
	    updated = true;
	  }
	
	  input.add.forEach(set);
	
	  if (this.reevaluate(input)) {
	    input.mod.forEach(set);
	  }
	
	  if (updated) input.fields[field] = 1;
	  return input;
	};
	
	module.exports = Formula;
	
	Formula.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Formula transform",
	  "description": "Extends data elements with new values according to a calculation formula.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["formula"]},
	    "field": {
	      "type": "string",
	      "description": "The property name in which to store the computed formula value."
	    },
	    "expr": {
	      "type": "string",
	      "description": "A string containing an expression (in JavaScript syntax) for the formula."
	    }
	  },
	  "required": ["type", "field", "expr"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Formula.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Geo.js **/
jupyter.define('vega@2.6.3/src/transforms/Geo.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function Geo(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, Geo.Parameters);
	  Transform.addParameters(this, {
	    lon: {type: 'field'},
	    lat: {type: 'field'}
	  });
	
	  this._output = {
	    'x': 'layout_x',
	    'y': 'layout_y'
	  };
	  return this.mutates(true);
	}
	
	Geo.Parameters = {
	  projection: {type: 'value', default: 'mercator'},
	  center:     {type: 'array<value>'},
	  translate:  {type: 'array<value>', default: __jupyter_require__('vega@~2.6.3/src/transforms/screen.js').center},
	  rotate:     {type: 'array<value>'},
	  scale:      {type: 'value'},
	  precision:  {type: 'value'},
	  clipAngle:  {type: 'value'},
	  clipExtent: {type: 'value'}
	};
	
	Geo.d3Projection = function() {
	  var p = this.param('projection'),
	      param = Geo.Parameters,
	      proj, name, value;
	
	  if (p !== this._mode) {
	    this._mode = p;
	    this._projection = d3.geo[p]();
	  }
	  proj = this._projection;
	
	  for (name in param) {
	    if (name === 'projection' || !proj[name]) continue;
	    value = this.param(name);
	    if (value === undefined || (dl.isArray(value) && value.length === 0)) {
	      continue;
	    }
	    if (value !== proj[name]()) {
	      proj[name](value);
	    }
	  }
	
	  return proj;
	};
	
	var prototype = (Geo.prototype = Object.create(Transform.prototype));
	prototype.constructor = Geo;
	
	prototype.transform = function(input) {
	  log.debug(input, ['geo']);
	
	  var output = this._output,
	      lon = this.param('lon').accessor,
	      lat = this.param('lat').accessor,
	      proj = Geo.d3Projection.call(this);
	
	  function set(t) {
	    var ll = [lon(t), lat(t)];
	    var xy = proj(ll) || [null, null];
	    Tuple.set(t, output.x, xy[0]);
	    Tuple.set(t, output.y, xy[1]);
	  }
	
	  input.add.forEach(set);
	  if (this.reevaluate(input)) {
	    input.mod.forEach(set);
	    input.rem.forEach(set);
	  }
	
	  input.fields[output.x] = 1;
	  input.fields[output.y] = 1;
	  return input;
	};
	
	module.exports = Geo;
	
	Geo.baseSchema = {
	  "projection": {
	    "description": "The type of cartographic projection to use.",
	    "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	    "default": "mercator"
	  },
	  "center": {
	    "description": "The center of the projection.",
	    "oneOf": [
	      {
	        "type": "array",
	        "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	        "minItems": 2,
	        "maxItems": 2
	      },
	      {"$ref": "#/refs/signal"}
	    ]
	  },
	  "translate": {
	    "description": "The translation of the projection.",
	    "oneOf": [
	      {
	        "type": "array",
	        "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	        "minItems": 2,
	        "maxItems": 2
	      },
	      {"$ref": "#/refs/signal"}
	    ]
	  },
	  "rotate": {
	    "description": "The rotation of the projection.",
	    "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	  },
	  "scale": {
	    "description": "The scale of the projection.",
	    "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	  },
	  "precision": {
	    "description": "The desired precision of the projection.",
	    "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	  },
	  "clipAngle": {
	    "description": "The clip angle of the projection.",
	    "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	  },
	  "clipExtent": {
	    "description": "The clip extent of the projection.",
	    "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	  }
	};
	
	Geo.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Geo transform",
	  "description": "Performs a cartographic projection. Given longitude and latitude values, sets corresponding x and y properties for a mark.",
	  "type": "object",
	  "properties": dl.extend({
	    "type": {"enum": ["geo"]},
	    "lon": {
	      "description": "The input longitude values.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "lat": {
	      "description": "The input latitude values.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "x": {"type": "string", "default": "layout_x"},
	        "y": {"type": "string", "default": "layout_y"}
	      },
	      "additionalProperties": false
	    }
	  }, Geo.baseSchema),
	  "required": ["type", "lon", "lat"],
	  "additionalProperties": false
	};
	
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Geo.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/GeoPath.js **/
jupyter.define('vega@2.6.3/src/transforms/GeoPath.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Geo = __jupyter_require__('vega@~2.6.3/src/transforms/Geo.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function GeoPath(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, Geo.Parameters);
	  Transform.addParameters(this, {
	    field: {type: 'field', default: null},
	  });
	
	  this._output = {
	    'path': 'layout_path'
	  };
	  return this.mutates(true);
	}
	
	var prototype = (GeoPath.prototype = Object.create(Transform.prototype));
	prototype.constructor = GeoPath;
	
	prototype.transform = function(input) {
	  log.debug(input, ['geopath']);
	
	  var output = this._output,
	      geojson = this.param('field').accessor || dl.identity,
	      proj = Geo.d3Projection.call(this),
	      path = d3.geo.path().projection(proj);
	
	  function set(t) {
	    Tuple.set(t, output.path, path(geojson(t)));
	  }
	
	  input.add.forEach(set);
	  if (this.reevaluate(input)) {
	    input.mod.forEach(set);
	    input.rem.forEach(set);
	  }
	
	  input.fields[output.path] = 1;
	  return input;
	};
	
	module.exports = GeoPath;
	
	GeoPath.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "GeoPath transform",
	  "description": "Creates paths for geographic regions, such as countries, states and counties.",
	  "type": "object",
	  "properties": dl.extend({
	    "type": {"enum": ["geopath"]},
	    "field": {
	      "description": "The data field containing GeoJSON Feature data.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "path": {"type": "string", "default": "layout_path"}
	      },
	      "additionalProperties": false
	    }
	  }, Geo.baseSchema),
	  "required": ["type"],
	  "additionalProperties": false
	};
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/GeoPath.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Hierarchy.js **/
jupyter.define('vega@2.6.3/src/transforms/Hierarchy.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Hierarchy(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    // hierarchy parameters
	    sort: {type: 'array<field>', default: null},
	    children: {type: 'field', default: 'children'},
	    parent: {type: 'field', default: 'parent'},
	    field: {type: 'value', default: null},
	    // layout parameters
	    mode: {type: 'value', default: 'tidy'}, // tidy, cluster, partition
	    size: {type: 'array<value>', default: __jupyter_require__('vega@~2.6.3/src/transforms/screen.js').size},
	    nodesize: {type: 'array<value>', default: null},
	    orient: {type: 'value', default: 'cartesian'}
	  });
	
	  this._mode = null;
	  this._output = {
	    'x':      'layout_x',
	    'y':      'layout_y',
	    'width':  'layout_width',
	    'height': 'layout_height',
	    'depth':  'layout_depth'
	  };
	  return this.mutates(true);
	}
	
	var PARTITION = 'partition';
	
	var SEPARATION = {
	  cartesian: function(a, b) { return (a.parent === b.parent ? 1 : 2); },
	  radial: function(a, b) { return (a.parent === b.parent ? 1 : 2) / a.depth; }
	};
	
	var prototype = (Hierarchy.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Hierarchy;
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['hierarchy layout']);
	
	  // get variables
	  var layout = this._layout,
	      output = this._output,
	      mode   = this.param('mode'),
	      sort   = this.param('sort'),
	      nodesz = this.param('nodesize'),
	      parent = this.param('parent').accessor,
	      root = data.filter(function(d) { return parent(d) === null; })[0];
	
	  if (mode !== this._mode) {
	    this._mode = mode;
	    if (mode === 'tidy') mode = 'tree';
	    layout = (this._layout = d3.layout[mode]());
	  }
	
	  input.fields[output.x] = 1;
	  input.fields[output.y] = 1;
	  input.fields[output.depth] = 1;
	  if (mode === PARTITION) {
	    input.fields[output.width] = 1;
	    input.fields[output.height] = 1;
	    layout.value(this.param('field').accessor);
	  } else {
	    layout.separation(SEPARATION[this.param('orient')]);
	  }
	
	  if (nodesz.length && mode !== PARTITION) {
	    layout.nodeSize(nodesz);
	  } else {
	    layout.size(this.param('size'));
	  }
	
	  layout
	    .sort(sort.field.length ? dl.comparator(sort.field) : null)
	    .children(this.param('children').accessor)
	    .nodes(root);
	
	  // copy layout values to nodes
	  data.forEach(function(n) {
	    Tuple.set(n, output.x, n.x);
	    Tuple.set(n, output.y, n.y);
	    Tuple.set(n, output.depth, n.depth);
	    if (mode === PARTITION) {
	      Tuple.set(n, output.width, n.dx);
	      Tuple.set(n, output.height, n.dy);
	    }
	  });
	
	  // return changeset
	  return input;
	};
	
	module.exports = Hierarchy;
	
	Hierarchy.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Hierarchy transform",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["hierarchy"]},
	    "sort": {
	      "description": "A list of fields to use as sort criteria for sibling nodes.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ]
	    },
	    "children": {
	      "description": "The data field for the children node array",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "children"
	    },
	    "parent": {
	      "description": "The data field for the parent node",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "parent"
	    },
	    "field": {
	      "description": "The value for the area of each leaf-level node for partition layouts.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "mode": {
	      "description": "The layout algorithm mode to use.",
	      "oneOf": [
	        {"enum": ["tidy", "cluster", "partition"]},
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": "tidy"
	    },
	    "orient": {
	      "description": "The layout orientation to use.",
	      "oneOf": [
	        {"enum": ["cartesian", "radial"]},
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": "cartesian"
	    },
	    "size": {
	      "description": "The dimensions of the tree layout",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	          "minItems": 2,
	          "maxItems": 2
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": [500, 500]
	    },
	    "nodesize": {
	      "description": "Sets a fixed x,y size for each node (overrides the size parameter)",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	          "minItems": 2,
	          "maxItems": 2
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": null
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "x": {"type": "string", "default": "layout_x"},
	        "y": {"type": "string", "default": "layout_y"},
	        "width": {"type": "string", "default": "layout_width"},
	        "height": {"type": "string", "default": "layout_height"},
	        "depth": {"type": "string", "default": "layout_depth"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Hierarchy.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Impute.js **/
jupyter.define('vega@2.6.3/src/transforms/Impute.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Impute(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    groupby: {type: 'array<field>'},
	    orderby: {type: 'array<field>'},
	    field:   {type: 'field'},
	    method:  {type: 'value', default: 'value'},
	    value:   {type: 'value', default: 0}
	  });
	
	  return this.router(true).produces(true);
	}
	
	var prototype = (Impute.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Impute;
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['imputing']);
	
	  var groupby = this.param('groupby'),
	      orderby = this.param('orderby'),
	      method = this.param('method'),
	      value = this.param('value'),
	      field = this.param('field'),
	      get = field.accessor,
	      name = field.field,
	      prev = this._imputed || [], curr = [],
	      groups = partition(data, groupby.accessor, orderby.accessor),
	      domain = groups.domain,
	      group, i, j, n, m, t;
	
	  function getval(x) {
	    return x == null ? null : get(x);
	  }
	
	  for (j=0, m=groups.length; j<m; ++j) {
	    group = groups[j];
	
	    // determine imputation value
	    if (method !== 'value') {
	      value = dl[method](group, getval);
	    }
	
	    // add tuples for missing values
	    for (i=0, n=group.length; i<n; ++i) {
	      if (group[i] == null) {
	        t = tuple(groupby.field, group.values, orderby.field, domain[i]);
	        t[name] = value;
	        curr.push(t);
	      }
	    }
	  }
	
	  // update changeset with imputed tuples
	  for (i=0, n=curr.length; i<n; ++i) {
	    input.add.push(curr[i]);
	  }
	  for (i=0, n=prev.length; i<n; ++i) {
	    input.rem.push(prev[i]);
	  }
	  this._imputed = curr;
	
	  return input;
	};
	
	function tuple(gb, gv, ob, ov) {
	  var t = {_imputed: true}, i;
	  for (i=0; i<gv.length; ++i) t[gb[i]] = gv[i];
	  for (i=0; i<ov.length; ++i) t[ob[i]] = ov[i];
	  return Tuple.ingest(t);
	}
	
	function partition(data, groupby, orderby) {
	  var groups = [],
	      get = function(f) { return f(x); },
	      val = function(d) { return (x=d, orderby.map(get)); },
	      map, i, x, k, g, domain, lut, N;
	
	  domain = groups.domain = dl.unique(data, val);
	  N = domain.length;
	  lut = domain.reduce(function(m, d, i) {
	    return (m[d] = {value:d, index:i}, m);
	  }, {});
	
	  // partition data points into groups
	  for (map={}, i=0; i<data.length; ++i) {
	    x = data[i];
	    k = groupby == null ? [] : groupby.map(get);
	    g = map[k] || (groups.push(map[k] = Array(N)), map[k].values = k, map[k]);
	    g[lut[val(x)].index] = x;
	  }
	
	  return groups;
	}
	
	module.exports = Impute;
	
	Impute.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Impute transform",
	  "description": "Performs imputation of missing values.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["impute"]},
	    "method": {
	      "description": "The imputation method to use.",
	      "oneOf": [
	        {"enum": ["value", "mean", "median", "min", "max"]},
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": "value"
	    },
	    "value": {
	      "description": "The value to use for missing data if the method is 'value'.",
	      "oneOf": [
	        {"type": "number"},
	        {"type": "string"},
	        {"type": "boolean"},
	        {"type": "null"},
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": 0
	    },
	    "field": {
	      "description": "The data field to impute.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "groupby": {
	      "description": "A list of fields to group the data into series.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	    },
	    "orderby": {
	      "description": "A list of fields to determine ordering within series.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type", "groupby", "orderby", "field"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Impute.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Lookup.js **/
jupyter.define('vega@2.6.3/src/transforms/Lookup.js', function (module, exports, __jupyter_require__) {
	var Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function Lookup(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    on:      {type: 'data'},
	    onKey:   {type: 'field', default: null},
	    as:      {type: 'array<value>'},
	    keys:    {type: 'array<field>', default: ['data']},
	    default: {type: 'value'}
	  });
	
	  return this.mutates(true);
	}
	
	var prototype = (Lookup.prototype = Object.create(Transform.prototype));
	prototype.constructor = Lookup;
	
	prototype.transform = function(input, reset) {
	  log.debug(input, ['lookup']);
	
	  var on = this.param('on'),
	      onLast = on.source.last(),
	      onData = on.source.values(),
	      onKey = this.param('onKey'),
	      onF = onKey.field,
	      keys = this.param('keys'),
	      get = keys.accessor,
	      as = this.param('as'),
	      defaultValue = this.param('default'),
	      lut = this._lut,
	      i, v;
	
	  // build lookup table on init, withKey modified, or tuple add/rem
	  if (lut == null || this._on !== onF || onF && onLast.fields[onF] ||
	      onLast.add.length || onLast.rem.length)
	  {
	    if (onF) { // build hash from withKey field
	      onKey = onKey.accessor;
	      for (lut={}, i=0; i<onData.length; ++i) {
	        lut[onKey(v = onData[i])] = v;
	      }
	    } else { // otherwise, use index-based lookup
	      lut = onData;
	    }
	    this._lut = lut;
	    this._on = onF;
	    reset = true;
	  }
	
	  function set(t) {
	    for (var i=0; i<get.length; ++i) {
	      var v = lut[get[i](t)] || defaultValue;
	      Tuple.set(t, as[i], v);
	    }
	  }
	
	  input.add.forEach(set);
	  var run = keys.field.some(function(f) { return input.fields[f]; });
	  if (run || reset) {
	    input.mod.forEach(set);
	    input.rem.forEach(set);
	  }
	
	  as.forEach(function(k) { input.fields[k] = 1; });
	  return input;
	};
	
	module.exports = Lookup;
	
	Lookup.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Lookup transform",
	  "description": "Extends a data set by looking up values in another data set.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["lookup"]},
	    "on": {
	      "type": "string",
	      "description": "The name of the secondary data set on which to lookup values."
	    },
	    "onKey": {
	      "description": "The key field to lookup, or null for index-based lookup.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "keys": {
	      "description": "One or more fields in the primary data set to match against the secondary data set.",
	      "type": "array",
	      "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	    },
	    "as": {
	      "type": "array",
	      "description": "The names of the fields in which to store looked-up values.",
	      "items": {"type": "string"}
	    },
	    "default": {
	      // "type": "any",
	      "description": "The default value to use if a lookup match fails."
	    }
	  },
	  "required": ["type", "on", "as", "keys"],
	  "additionalProperties": false
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Lookup.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Pie.js **/
jupyter.define('vega@2.6.3/src/transforms/Pie.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Pie(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    field:      {type: 'field', default: null},
	    startAngle: {type: 'value', default: 0},
	    endAngle:   {type: 'value', default: 2 * Math.PI},
	    sort:       {type: 'value', default: false}
	  });
	
	  this._output = {
	    'start': 'layout_start',
	    'end':   'layout_end',
	    'mid':   'layout_mid'
	  };
	
	  return this.mutates(true);
	}
	
	var prototype = (Pie.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Pie;
	
	function ones() { return 1; }
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['pie']);
	
	  var output = this._output,
	      field = this.param('field').accessor || ones,
	      start = this.param('startAngle'),
	      stop = this.param('endAngle'),
	      sort = this.param('sort');
	
	  var values = data.map(field),
	      a = start,
	      k = (stop - start) / dl.sum(values),
	      index = dl.range(data.length),
	      i, t, v;
	
	  if (sort) {
	    index.sort(function(a, b) {
	      return values[a] - values[b];
	    });
	  }
	
	  for (i=0; i<index.length; ++i) {
	    t = data[index[i]];
	    v = values[index[i]];
	    Tuple.set(t, output.start, a);
	    Tuple.set(t, output.mid, (a + 0.5 * v * k));
	    Tuple.set(t, output.end, (a += v * k));
	  }
	
	  input.fields[output.start] = 1;
	  input.fields[output.end] = 1;
	  input.fields[output.mid] = 1;
	  return input;
	};
	
	module.exports = Pie;
	
	Pie.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Pie transform",
	  "description": "Computes a pie chart layout.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["pie"]},
	    "field": {
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "description": "The data values to encode as angular spans. " +
	        "If this property is omitted, all pie slices will have equal spans."
	    },
	    "startAngle": {
	      "oneOf": [
	        {
	          "type": "number",
	          "minimum": 0,
	          "maximum": 2 * Math.PI
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": 0
	    },
	    "endAngle": {
	      "oneOf": [
	        {
	          "type": "number",
	          "minimum": 0,
	          "maximum": 2 * Math.PI
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": 2 * Math.PI,
	    },
	    "sort": {
	      "description": " If true, will sort the data prior to computing angles.",
	      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
	      "default": false
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "start": {"type": "string", "default": "layout_start"},
	        "end": {"type": "string", "default": "layout_end"},
	        "mid": {"type": "string", "default": "layout_mid"}
	      }
	    }
	  },
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Pie.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Rank.js **/
jupyter.define('vega@2.6.3/src/transforms/Rank.js', function (module, exports, __jupyter_require__) {
	var Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Rank(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    field: {type: 'field', default: null},
	    normalize: {type: 'value', default: false}
	  });
	
	  this._output = {
	    'rank': 'rank'
	  };
	
	  return this.mutates(true);
	}
	
	var prototype = (Rank.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Rank;
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['rank']);
	
	  var rank  = this._output.rank,
	      norm  = this.param('normalize'),
	      field = this.param('field').accessor,
	      keys = {}, 
	      i, len = data.length, klen, d, f;
	
	  // If we have a field accessor, first compile distinct keys.
	  if (field) {
	    for (i=0, klen=0; i<len; ++i) {
	      d = data[i];
	      keys[f=field(d)] = keys[f] || (keys[f] = ++klen);
	    }
	  }
	
	  // Assign ranks to all tuples.
	  for (i=0; i<len && (d=data[i]); ++i) {
	    if (field && (f=field(d))) {
	      Tuple.set(d, rank, norm ? keys[f] / klen : keys[f]);
	    } else {
	      Tuple.set(d, rank, norm ? (i+1) / len : (i+1));
	    }
	  }
	
	  input.fields[rank] = 1;
	  return input;
	};
	
	module.exports = Rank;
	
	Rank.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Rank transform",
	  "description": "Computes ascending rank scores for data tuples.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["rank"]},
	    "field": {
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "description": "A key field to used to rank tuples. " +
	        "If undefined, tuples will be ranked in their observed order."
	    },
	    "normalize": {
	      "description": "If true, values of the output field will lie in the range [0, 1].",
	      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
	      "default": false
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "rank": {"type": "string", "default": "rank"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Rank.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Sort.js **/
jupyter.define('vega@2.6.3/src/transforms/Sort.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log  = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js');
	
	function Sort(graph) {
	  Transform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {by: {type: 'array<field>'} });
	  this.router(true);
	}
	
	var prototype = (Sort.prototype = Object.create(Transform.prototype));
	prototype.constructor = Sort;
	
	prototype.transform = function(input) {
	  log.debug(input, ['sorting']);
	
	  if (input.add.length || input.mod.length || input.rem.length) {
	    input.sort = dl.comparator(this.param('by').field);
	  }
	  return input;
	};
	
	module.exports = Sort;
	
	Sort.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Sort transform",
	  "description": "Sorts the values of a data set.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["sort"]},
	    "by": {
	      "oneOf": [
	        {"type": "string"},
	        {"type": "array", "items": {"type": "string"}}
	      ],
	      "description": "A list of fields to use as sort criteria."
	    }
	  },
	  "required": ["type", "by"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Sort.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Stack.js **/
jupyter.define('vega@2.6.3/src/transforms/Stack.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Stack(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    groupby: {type: 'array<field>'},
	    sortby: {type: 'array<field>'},
	    field: {type: 'field'},
	    offset: {type: 'value', default: 'zero'}
	  });
	
	  this._output = {
	    'start': 'layout_start',
	    'end':   'layout_end',
	    'mid':   'layout_mid'
	  };
	  return this.mutates(true);
	}
	
	var prototype = (Stack.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Stack;
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['stacking']);
	
	  var groupby = this.param('groupby').accessor,
	      sortby = dl.comparator(this.param('sortby').field),
	      field = this.param('field').accessor,
	      offset = this.param('offset'),
	      output = this._output;
	
	  // partition, sum, and sort the stack groups
	  var groups = partition(data, groupby, sortby, field);
	
	  // compute stack layouts per group
	  for (var i=0, max=groups.max; i<groups.length; ++i) {
	    var group = groups[i],
	        sum = group.sum,
	        off = offset==='center' ? (max - sum)/2 : 0,
	        scale = offset==='normalize' ? (1/sum) : 1,
	        j, x, a, b = off, v = 0;
	
	    // set stack coordinates for each datum in group
	    for (j=0; j<group.length; ++j) {
	      x = group[j];
	      a = b; // use previous value for start point
	      v += field(x);
	      b = scale * v + off; // compute end point
	      Tuple.set(x, output.start, a);
	      Tuple.set(x, output.end, b);
	      Tuple.set(x, output.mid, 0.5 * (a + b));
	    }
	  }
	
	  input.fields[output.start] = 1;
	  input.fields[output.end] = 1;
	  input.fields[output.mid] = 1;
	  return input;
	};
	
	function partition(data, groupby, sortby, field) {
	  var groups = [],
	      get = function(f) { return f(x); },
	      map, i, x, k, g, s, max;
	
	  // partition data points into stack groups
	  if (groupby == null) {
	    groups.push(data.slice());
	  } else {
	    for (map={}, i=0; i<data.length; ++i) {
	      x = data[i];
	      k = groupby.map(get);
	      g = map[k] || (groups.push(map[k] = []), map[k]);
	      g.push(x);
	    }
	  }
	
	  // compute sums of groups, sort groups as needed
	  for (k=0, max=0; k<groups.length; ++k) {
	    g = groups[k];
	    for (i=0, s=0; i<g.length; ++i) {
	      s += field(g[i]);
	    }
	    g.sum = s;
	    if (s > max) max = s;
	    if (sortby != null) g.sort(sortby);
	  }
	  groups.max = max;
	
	  return groups;
	}
	
	module.exports = Stack;
	
	Stack.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Stack transform",
	  "description": "Computes layout values for stacked graphs, as in stacked bar charts or stream graphs.",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["stack"]},
	    "groupby": {
	      "description": "A list of fields to split the data into groups (stacks).",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	    },
	    "sortby": {
	      "description": "A list of fields to determine the sort order of stacks.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	    },
	    "field": {
	      "description": "The data field that determines the thickness/height of stacks.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "offset": {
	      "description": "The baseline offset",
	      "oneOf": [{"enum": ["zero", "center", "normalize"]}, {"$ref": "#/refs/signal"}],
	      "default": "zero"
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "start": {"type": "string", "default": "layout_start"},
	        "end": {"type": "string", "default": "layout_end"},
	        "mid": {"type": "string", "default": "layout_mid"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type", "groupby", "field"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Stack.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Treeify.js **/
jupyter.define('vega@2.6.3/src/transforms/Treeify.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Treeify(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    groupby: {type: 'array<field>'}
	  });
	
	  this._output = {
	    'children': 'children',
	    'parent':   'parent'
	  };
	  return this.router(true).produces(true);
	}
	
	var prototype = (Treeify.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Treeify;
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['treeifying']);
	
	  var fields = this.param('groupby').field,
	      childField = this._output.children,
	      parentField = this._output.parent,
	      summary = [{name:'*', ops: ['values'], as: [childField]}],
	      aggrs = fields.map(function(f) {
	        return dl.groupby(f).summarize(summary);
	      }),
	      prev = this._internal || [], curr = [], i, n;
	
	  function level(index, node, values) {
	    var vals = aggrs[index].execute(values);
	
	    node[childField] = vals;
	    vals.forEach(function(n) {
	      n[parentField] = node;
	      curr.push(Tuple.ingest(n));
	      if (index+1 < fields.length) level(index+1, n, n[childField]);
	      else n[childField].forEach(function(c) { c[parentField] = n; });
	    });
	  }
	
	  var root = Tuple.ingest({});
	  root[parentField] = null;
	  curr.push(root);
	  level(0, root, data);
	
	  // update changeset with internal nodes
	  for (i=0, n=curr.length; i<n; ++i) {
	    input.add.push(curr[i]);
	  }
	  for (i=0, n=prev.length; i<n; ++i) {
	    input.rem.push(prev[i]);
	  }
	  this._internal = curr;
	
	  return input;
	};
	
	module.exports = Treeify;
	
	Treeify.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Treeify transform",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["treeify"]},
	    "groupby": {
	      "description": "An ordered list of fields by which to group tuples into a tree.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ]
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "children": {"type": "string", "default": "children"},
	        "parent": {"type": "string", "default": "parent"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type", "groupby"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Treeify.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Treemap.js **/
jupyter.define('vega@2.6.3/src/transforms/Treemap.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	var defaultRatio = 0.5 * (1 + Math.sqrt(5));
	
	function Treemap(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    // hierarchy parameters
	    sort: {type: 'array<field>', default: ['-value']},
	    children: {type: 'field', default: 'children'},
	    parent: {type: 'field', default: 'parent'},
	    field: {type: 'field', default: 'value'},
	    // treemap parameters
	    size: {type: 'array<value>', default: __jupyter_require__('vega@~2.6.3/src/transforms/screen.js').size},
	    round: {type: 'value', default: true},
	    sticky: {type: 'value', default: false},
	    ratio: {type: 'value', default: defaultRatio},
	    padding: {type: 'value', default: null},
	    mode: {type: 'value', default: 'squarify'}
	  });
	
	  this._layout = d3.layout.treemap();
	
	  this._output = {
	    'x':      'layout_x',
	    'y':      'layout_y',
	    'width':  'layout_width',
	    'height': 'layout_height',
	    'depth':  'layout_depth',
	  };
	  return this.mutates(true);
	}
	
	var prototype = (Treemap.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Treemap;
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['treemap']);
	
	  // get variables
	  var layout = this._layout,
	      output = this._output,
	      sticky = this.param('sticky'),
	      parent = this.param('parent').accessor,
	      root = data.filter(function(d) { return parent(d) === null; })[0];
	
	  // layout.sticky resets state _regardless_ of input value
	  // so, we perform out own check first
	  if (layout.sticky() !== sticky) { layout.sticky(sticky); }
	
	  // configure layout
	  layout
	    .sort(dl.comparator(this.param('sort').field))
	    .children(this.param('children').accessor)
	    .value(this.param('field').accessor)
	    .size(this.param('size'))
	    .round(this.param('round'))
	    .ratio(this.param('ratio'))
	    .padding(this.param('padding'))
	    .mode(this.param('mode'))
	    .nodes(root);
	
	  // copy layout values to nodes
	  data.forEach(function(n) {
	    Tuple.set(n, output.x, n.x);
	    Tuple.set(n, output.y, n.y);
	    Tuple.set(n, output.width, n.dx);
	    Tuple.set(n, output.height, n.dy);
	    Tuple.set(n, output.depth, n.depth);
	  });
	
	  // return changeset
	  input.fields[output.x] = 1;
	  input.fields[output.y] = 1;
	  input.fields[output.width] = 1;
	  input.fields[output.height] = 1;
	  input.fields[output.depth] = 1;
	  return input;
	};
	
	module.exports = Treemap;
	
	Treemap.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Treemap transform",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["treemap"]},
	    "sort": {
	      "description": "A list of fields to use as sort criteria for sibling nodes.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]}
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": ["-value"]
	    },
	    "children": {
	      "description": "The data field for the children node array",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "children"
	    },
	    "parent": {
	      "description": "The data field for the parent node",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": "parent"
	    },
	    "field": {
	      "description": "The values to use to determine the area of each leaf-level treemap cell.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "mode": {
	      "description": "The treemap layout algorithm to use.",
	      "oneOf": [
	        {"enum": ["squarify", "slice", "dice", "slice-dice"]},
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": "squarify"
	    },
	    "size": {
	      "description": "The dimensions of the treemap layout",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	          "minItems": 2,
	          "maxItems": 2
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": [500, 500]
	    },
	    "round": {
	      "description": "If true, treemap cell dimensions will be rounded to integer pixels.",
	      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
	      "default": true
	    },
	    "sticky": {
	      "description": "If true, repeated runs of the treemap will use cached partition boundaries.",
	      "oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}],
	      "default": false
	    },
	    "ratio": {
	      "description": "The target aspect ratio for the layout to optimize.",
	      "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}],
	      "default": defaultRatio
	    },
	    "padding": {
	      "oneOf": [
	        {"type": "number"},
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	          "minItems": 4,
	          "maxItems": 4
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "description": "he padding (in pixels) to provide around internal nodes in the treemap."
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "x": {"type": "string", "default": "layout_x"},
	        "y": {"type": "string", "default": "layout_y"},
	        "width": {"type": "string", "default": "layout_width"},
	        "height": {"type": "string", "default": "layout_height"},
	        "depth": {"type": "string", "default": "layout_depth"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Treemap.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Voronoi.js **/
jupyter.define('vega@2.6.3/src/transforms/Voronoi.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    Tuple = __jupyter_require__('vega-dataflow@~1.4.3/src/Tuple.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Voronoi(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    clipExtent: {type: 'array<value>', default: __jupyter_require__('vega@~2.6.3/src/transforms/screen.js').extent},
	    x: {type: 'field', default: 'layout_x'},
	    y: {type: 'field', default: 'layout_y'}
	  });
	
	  this._layout = d3.geom.voronoi();
	  this._output = {'path': 'layout_path'};
	
	  return this.mutates(true);
	}
	
	var prototype = (Voronoi.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Voronoi;
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['voronoi']);
	
	  // get variables
	  var pathname = this._output.path;
	
	  // configure layout
	  var polygons = this._layout
	    .clipExtent(this.param('clipExtent'))
	    .x(this.param('x').accessor)
	    .y(this.param('y').accessor)
	    (data);
	
	  // build and assign path strings
	  for (var i=0; i<data.length; ++i) {
	    if (polygons[i]) Tuple.set(data[i], pathname, 'M' + polygons[i].join('L') + 'Z');
	  }
	
	  // return changeset
	  input.fields[pathname] = 1;
	  return input;
	};
	
	module.exports = Voronoi;
	
	Voronoi.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Voronoi transform",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["voronoi"]},
	    "clipExtent": {
	      "description": "The min and max points at which to clip the voronoi diagram.",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {
	            "oneOf": [
	              {
	                "type": "array",
	                "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	                "minItems": 2,
	                "maxItems": 2
	              },
	              {"$ref": "#/refs/signal"}
	            ]
	          },
	          "minItems": 2,
	          "maxItems": 2
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": [[-1e5,-1e5],[1e5,1e5]]
	    },
	    "x": {
	      "description": "The input x coordinates.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "y": {
	      "description": "The input y coordinates.",
	      "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "path": {"type": "string", "default": "layout_path"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Voronoi.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/transforms/Wordcloud.js **/
jupyter.define('vega@2.6.3/src/transforms/Wordcloud.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    d3_cloud = __jupyter_require__('d3-cloud@^1.2.1/index.js'),
	    canvas = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').canvas,
	    Tuple = __jupyter_require__('vega-dataflow@~1.4.3/src/Tuple.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Transform = __jupyter_require__('vega@~2.6.3/src/transforms/Transform.js'),
	    BatchTransform = __jupyter_require__('vega@~2.6.3/src/transforms/BatchTransform.js');
	
	function Wordcloud(graph) {
	  BatchTransform.prototype.init.call(this, graph);
	  Transform.addParameters(this, {
	    size: {type: 'array<value>', default: __jupyter_require__('vega@~2.6.3/src/transforms/screen.js').size},
	    text: {type: 'field', default: 'data'},
	    rotate: {type: 'field|value', default: 0},
	    font: {type: 'field|value', default: {value: 'sans-serif'}},
	    fontSize: {type: 'field|value', default: 14},
	    fontStyle: {type: 'field|value', default: {value: 'normal'}},
	    fontWeight: {type: 'field|value', default: {value: 'normal'}},
	    fontScale: {type: 'array<value>', default: [10, 50]},
	    padding: {type: 'value', default: 1},
	    spiral: {type: 'value', default: 'archimedean'}
	  });
	
	  this._layout = d3_cloud().canvas(canvas.instance);
	
	  this._output = {
	    'x':          'layout_x',
	    'y':          'layout_y',
	    'font':       'layout_font',
	    'fontSize':   'layout_fontSize',
	    'fontStyle':  'layout_fontStyle',
	    'fontWeight': 'layout_fontWeight',
	    'rotate':     'layout_rotate',
	  };
	
	  return this.mutates(true);
	}
	
	var prototype = (Wordcloud.prototype = Object.create(BatchTransform.prototype));
	prototype.constructor = Wordcloud;
	
	function get(p) {
	  return (p && p.accessor) || p;
	}
	
	function wrap(tuple) {
	  var x = Object.create(tuple);
	  x._tuple = tuple;
	  return x;
	}
	
	prototype.batchTransform = function(input, data) {
	  log.debug(input, ['wordcloud']);
	
	  // get variables
	  var layout = this._layout,
	      output = this._output,
	      fontSize = this.param('fontSize'),
	      range = fontSize.accessor && this.param('fontScale'),
	      size, scale;
	  fontSize = fontSize.accessor || d3.functor(fontSize);
	
	  // create font size scaling function as needed
	  if (range.length) {
	    scale = d3.scale.sqrt()
	      .domain(dl.extent(data, size=fontSize))
	      .range(range);
	    fontSize = function(x) { return scale(size(x)); };
	  }
	
	  // configure layout
	  layout
	    .size(this.param('size'))
	    .text(get(this.param('text')))
	    .padding(this.param('padding'))
	    .spiral(this.param('spiral'))
	    .rotate(get(this.param('rotate')))
	    .font(get(this.param('font')))
	    .fontStyle(get(this.param('fontStyle')))
	    .fontWeight(get(this.param('fontWeight')))
	    .fontSize(fontSize)
	    .words(data.map(wrap)) // wrap to avoid tuple writes
	    .on('end', function(words) {
	      var size = layout.size(),
	          dx = size[0] >> 1,
	          dy = size[1] >> 1,
	          w, t, i, len;
	
	      for (i=0, len=words.length; i<len; ++i) {
	        w = words[i];
	        t = w._tuple;
	        Tuple.set(t, output.x, w.x + dx);
	        Tuple.set(t, output.y, w.y + dy);
	        Tuple.set(t, output.font, w.font);
	        Tuple.set(t, output.fontSize, w.size);
	        Tuple.set(t, output.fontStyle, w.style);
	        Tuple.set(t, output.fontWeight, w.weight);
	        Tuple.set(t, output.rotate, w.rotate);
	      }
	    })
	    .start();
	
	  // return changeset
	  for (var key in output) input.fields[output[key]] = 1;
	  return input;
	};
	
	module.exports = Wordcloud;
	
	var Parameter = __jupyter_require__('vega@~2.6.3/src/transforms/Parameter.js');
	Wordcloud.schema = {
	  "$schema": "http://json-schema.org/draft-04/schema#",
	  "title": "Wordcloud transform",
	  "type": "object",
	  "properties": {
	    "type": {"enum": ["wordcloud"]},
	    "size": {
	      "description": "The dimensions of the wordcloud layout",
	      "oneOf": [
	        {
	          "type": "array",
	          "items": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	          "minItems": 2,
	          "maxItems": 2
	        },
	        {"$ref": "#/refs/signal"}
	      ],
	      "default": [900, 500]
	    },
	    "font": {
	      "description": "The font face to use for a word.",
	      "oneOf": [{"type": "string"}, Parameter.schema, {"$ref": "#/refs/signal"}],
	      "default": "sans-serif"
	    },
	    "fontStyle": {
	      "description": "The font style to use for a word.",
	      "oneOf": [{"type": "string"}, Parameter.schema, {"$ref": "#/refs/signal"}],
	      "default": "normal"
	    },
	    "fontWeight": {
	      "description": "The font weight to use for a word.",
	      "oneOf": [{"type": "string"}, Parameter.schema, {"$ref": "#/refs/signal"}],
	      "default": "normal"
	    },
	    "fontSize": {
	      "description": "The font size to use for a word.",
	      "oneOf": [{"type": "number"}, Parameter.schema, {"type": "string"}, {"$ref": "#/refs/signal"}],
	      "default": 14
	    },
	    "fontScale": {
	      "description": "The minimum and maximum scaled font sizes, or null to prevent scaling.",
	      "oneOf": [
	        { "type": "null" },
	        {
	          "type": "array",
	          "minItems": 2,
	          "maxItems": 2,
	          "items": {"oneOf": [{"type":"number"}, {"$ref": "#/refs/signal"}]}
	        }
	      ],
	      "default": [10, 50]
	    },
	    "rotate": {
	      "description": "The field or number to set the roration angle (in degrees).",
	      "oneOf": [
	        {"type": "number"}, {"type": "string"},
	        Parameter.schema, {"$ref": "#/refs/signal"}
	      ],
	      "default": 0
	    },
	    "text": {
	      "description": "The field containing the text to use for each word.",
	      "oneOf": [{"type": "string"}, Parameter.schema, {"$ref": "#/refs/signal"}],
	      "default": 'data'
	    },
	    "spiral": {
	      "description": "The type of spiral used for positioning words, either 'archimedean' or 'rectangular'.",
	      "oneOf": [{"enum": ["archimedean", "rectangular"]}, Parameter.schema, {"$ref": "#/refs/signal"}],
	      "default": "archimedean"
	    },
	    "padding": {
	      "description": "The padding around each word.",
	      "oneOf": [{"type": "number"}, Parameter.schema, {"$ref": "#/refs/signal"}],
	      "default": 1
	    },
	    "output": {
	      "type": "object",
	      "description": "Rename the output data fields",
	      "properties": {
	        "x": {"type": "string", "default": "layout_x"},
	        "y": {"type": "string", "default": "layout_y"},
	        "font": {"type": "string", "default": "layout_font"},
	        "fontSize": {"type": "string", "default": "layout_fontSize"},
	        "fontStyle": {"type": "string", "default": "layout_fontStyle"},
	        "fontWeight": {"type": "string", "default": "layout_fontWeight"},
	        "rotate": {"type": "string", "default": "layout_rotate"}
	      },
	      "additionalProperties": false
	    }
	  },
	  "additionalProperties": false,
	  "required": ["type"]
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/transforms/Wordcloud.js **/


/** START DEFINE BLOCK for d3-cloud@1.2.1/index.js **/
jupyter.define('d3-cloud@1.2.1/index.js', function (module, exports, __jupyter_require__) {
	// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
	// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf
	
	var dispatch = __jupyter_require__('d3-dispatch@0.2.x/build/d3-dispatch.js').dispatch;
	
	var cloudRadians = Math.PI / 180,
	    cw = 1 << 11 >> 5,
	    ch = 1 << 11;
	
	module.exports = function() {
	  var size = [256, 256],
	      text = cloudText,
	      font = cloudFont,
	      fontSize = cloudFontSize,
	      fontStyle = cloudFontNormal,
	      fontWeight = cloudFontNormal,
	      rotate = cloudRotate,
	      padding = cloudPadding,
	      spiral = archimedeanSpiral,
	      words = [],
	      timeInterval = Infinity,
	      event = dispatch("word", "end"),
	      timer = null,
	      random = Math.random,
	      cloud = {},
	      canvas = cloudCanvas;
	
	  cloud.canvas = function(_) {
	    return arguments.length ? (canvas = functor(_), cloud) : canvas;
	  };
	
	  cloud.start = function() {
	    var contextAndRatio = getContext(canvas()),
	        board = zeroArray((size[0] >> 5) * size[1]),
	        bounds = null,
	        n = words.length,
	        i = -1,
	        tags = [],
	        data = words.map(function(d, i) {
	          d.text = text.call(this, d, i);
	          d.font = font.call(this, d, i);
	          d.style = fontStyle.call(this, d, i);
	          d.weight = fontWeight.call(this, d, i);
	          d.rotate = rotate.call(this, d, i);
	          d.size = ~~fontSize.call(this, d, i);
	          d.padding = padding.call(this, d, i);
	          return d;
	        }).sort(function(a, b) { return b.size - a.size; });
	
	    if (timer) clearInterval(timer);
	    timer = setInterval(step, 0);
	    step();
	
	    return cloud;
	
	    function step() {
	      var start = Date.now();
	      while (Date.now() - start < timeInterval && ++i < n && timer) {
	        var d = data[i];
	        d.x = (size[0] * (random() + .5)) >> 1;
	        d.y = (size[1] * (random() + .5)) >> 1;
	        cloudSprite(contextAndRatio, d, data, i);
	        if (d.hasText && place(board, d, bounds)) {
	          tags.push(d);
	          event.word(d);
	          if (bounds) cloudBounds(bounds, d);
	          else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];
	          // Temporary hack
	          d.x -= size[0] >> 1;
	          d.y -= size[1] >> 1;
	        }
	      }
	      if (i >= n) {
	        cloud.stop();
	        event.end(tags, bounds);
	      }
	    }
	  }
	
	  cloud.stop = function() {
	    if (timer) {
	      clearInterval(timer);
	      timer = null;
	    }
	    return cloud;
	  };
	
	  function getContext(canvas) {
	    canvas.width = canvas.height = 1;
	    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
	    canvas.width = (cw << 5) / ratio;
	    canvas.height = ch / ratio;
	
	    var context = canvas.getContext("2d");
	    context.fillStyle = context.strokeStyle = "red";
	    context.textAlign = "center";
	
	    return {context: context, ratio: ratio};
	  }
	
	  function place(board, tag, bounds) {
	    var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],
	        startX = tag.x,
	        startY = tag.y,
	        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
	        s = spiral(size),
	        dt = random() < .5 ? 1 : -1,
	        t = -dt,
	        dxdy,
	        dx,
	        dy;
	
	    while (dxdy = s(t += dt)) {
	      dx = ~~dxdy[0];
	      dy = ~~dxdy[1];
	
	      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
	
	      tag.x = startX + dx;
	      tag.y = startY + dy;
	
	      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
	          tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
	      // TODO only check for collisions within current bounds.
	      if (!bounds || !cloudCollide(tag, board, size[0])) {
	        if (!bounds || collideRects(tag, bounds)) {
	          var sprite = tag.sprite,
	              w = tag.width >> 5,
	              sw = size[0] >> 5,
	              lx = tag.x - (w << 4),
	              sx = lx & 0x7f,
	              msx = 32 - sx,
	              h = tag.y1 - tag.y0,
	              x = (tag.y + tag.y0) * sw + (lx >> 5),
	              last;
	          for (var j = 0; j < h; j++) {
	            last = 0;
	            for (var i = 0; i <= w; i++) {
	              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
	            }
	            x += sw;
	          }
	          delete tag.sprite;
	          return true;
	        }
	      }
	    }
	    return false;
	  }
	
	  cloud.timeInterval = function(_) {
	    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
	  };
	
	  cloud.words = function(_) {
	    return arguments.length ? (words = _, cloud) : words;
	  };
	
	  cloud.size = function(_) {
	    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
	  };
	
	  cloud.font = function(_) {
	    return arguments.length ? (font = functor(_), cloud) : font;
	  };
	
	  cloud.fontStyle = function(_) {
	    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
	  };
	
	  cloud.fontWeight = function(_) {
	    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
	  };
	
	  cloud.rotate = function(_) {
	    return arguments.length ? (rotate = functor(_), cloud) : rotate;
	  };
	
	  cloud.text = function(_) {
	    return arguments.length ? (text = functor(_), cloud) : text;
	  };
	
	  cloud.spiral = function(_) {
	    return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
	  };
	
	  cloud.fontSize = function(_) {
	    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
	  };
	
	  cloud.padding = function(_) {
	    return arguments.length ? (padding = functor(_), cloud) : padding;
	  };
	
	  cloud.random = function(_) {
	    return arguments.length ? (random = _, cloud) : random;
	  };
	
	  cloud.on = function() {
	    var value = event.on.apply(event, arguments);
	    return value === event ? cloud : value;
	  };
	
	  return cloud;
	};
	
	function cloudText(d) {
	  return d.text;
	}
	
	function cloudFont() {
	  return "serif";
	}
	
	function cloudFontNormal() {
	  return "normal";
	}
	
	function cloudFontSize(d) {
	  return Math.sqrt(d.value);
	}
	
	function cloudRotate() {
	  return (~~(Math.random() * 6) - 3) * 30;
	}
	
	function cloudPadding() {
	  return 1;
	}
	
	// Fetches a monochrome sprite bitmap for the specified text.
	// Load in batches for speed.
	function cloudSprite(contextAndRatio, d, data, di) {
	  if (d.sprite) return;
	  var c = contextAndRatio.context,
	      ratio = contextAndRatio.ratio;
	
	  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
	  var x = 0,
	      y = 0,
	      maxh = 0,
	      n = data.length;
	  --di;
	  while (++di < n) {
	    d = data[di];
	    c.save();
	    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
	    var w = c.measureText(d.text + "m").width * ratio,
	        h = d.size << 1;
	    if (d.rotate) {
	      var sr = Math.sin(d.rotate * cloudRadians),
	          cr = Math.cos(d.rotate * cloudRadians),
	          wcr = w * cr,
	          wsr = w * sr,
	          hcr = h * cr,
	          hsr = h * sr;
	      w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
	      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
	    } else {
	      w = (w + 0x1f) >> 5 << 5;
	    }
	    if (h > maxh) maxh = h;
	    if (x + w >= (cw << 5)) {
	      x = 0;
	      y += maxh;
	      maxh = 0;
	    }
	    if (y + h >= ch) break;
	    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
	    if (d.rotate) c.rotate(d.rotate * cloudRadians);
	    c.fillText(d.text, 0, 0);
	    if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);
	    c.restore();
	    d.width = w;
	    d.height = h;
	    d.xoff = x;
	    d.yoff = y;
	    d.x1 = w >> 1;
	    d.y1 = h >> 1;
	    d.x0 = -d.x1;
	    d.y0 = -d.y1;
	    d.hasText = true;
	    x += w;
	  }
	  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
	      sprite = [];
	  while (--di >= 0) {
	    d = data[di];
	    if (!d.hasText) continue;
	    var w = d.width,
	        w32 = w >> 5,
	        h = d.y1 - d.y0;
	    // Zero the buffer
	    for (var i = 0; i < h * w32; i++) sprite[i] = 0;
	    x = d.xoff;
	    if (x == null) return;
	    y = d.yoff;
	    var seen = 0,
	        seenRow = -1;
	    for (var j = 0; j < h; j++) {
	      for (var i = 0; i < w; i++) {
	        var k = w32 * j + (i >> 5),
	            m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
	        sprite[k] |= m;
	        seen |= m;
	      }
	      if (seen) seenRow = j;
	      else {
	        d.y0++;
	        h--;
	        j--;
	        y++;
	      }
	    }
	    d.y1 = d.y0 + seenRow;
	    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
	  }
	}
	
	// Use mask-based collision detection.
	function cloudCollide(tag, board, sw) {
	  sw >>= 5;
	  var sprite = tag.sprite,
	      w = tag.width >> 5,
	      lx = tag.x - (w << 4),
	      sx = lx & 0x7f,
	      msx = 32 - sx,
	      h = tag.y1 - tag.y0,
	      x = (tag.y + tag.y0) * sw + (lx >> 5),
	      last;
	  for (var j = 0; j < h; j++) {
	    last = 0;
	    for (var i = 0; i <= w; i++) {
	      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))
	          & board[x + i]) return true;
	    }
	    x += sw;
	  }
	  return false;
	}
	
	function cloudBounds(bounds, d) {
	  var b0 = bounds[0],
	      b1 = bounds[1];
	  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
	  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
	  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
	  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
	}
	
	function collideRects(a, b) {
	  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
	}
	
	function archimedeanSpiral(size) {
	  var e = size[0] / size[1];
	  return function(t) {
	    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
	  };
	}
	
	function rectangularSpiral(size) {
	  var dy = 4,
	      dx = dy * size[0] / size[1],
	      x = 0,
	      y = 0;
	  return function(t) {
	    var sign = t < 0 ? -1 : 1;
	    // See triangular numbers: T_n = n * (n + 1) / 2.
	    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
	      case 0:  x += dx; break;
	      case 1:  y += dy; break;
	      case 2:  x -= dx; break;
	      default: y -= dy; break;
	    }
	    return [x, y];
	  };
	}
	
	// TODO reuse arrays?
	function zeroArray(n) {
	  var a = [],
	      i = -1;
	  while (++i < n) a[i] = 0;
	  return a;
	}
	
	function cloudCanvas() {
	  return document.createElement("canvas");
	}
	
	function functor(d) {
	  return typeof d === "function" ? d : function() { return d; };
	}
	
	var spirals = {
	  archimedean: archimedeanSpiral,
	  rectangular: rectangularSpiral
	};
	
})
/** END DEFINE BLOCK for d3-cloud@1.2.1/index.js **/


/** START DEFINE BLOCK for d3-dispatch@0.2.6/build/d3-dispatch.js **/
jupyter.define('d3-dispatch@0.2.6/build/d3-dispatch.js', function (module, exports, __jupyter_require__) {
	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.d3_dispatch = {})));
	}(this, function (exports) { 'use strict';
	
	  function dispatch() {
	    return new Dispatch(arguments);
	  }
	
	  function Dispatch(types) {
	    var i = -1,
	        n = types.length,
	        callbacksByType = {},
	        callbackByName = {},
	        type,
	        that = this;
	
	    that.on = function(type, callback) {
	      type = parseType(type);
	
	      // Return the current callback, if any.
	      if (arguments.length < 2) {
	        return (callback = callbackByName[type.name]) && callback.value;
	      }
	
	      // If a type was specified…
	      if (type.type) {
	        var callbacks = callbacksByType[type.type],
	            callback0 = callbackByName[type.name],
	            i;
	
	        // Remove the current callback, if any, using copy-on-remove.
	        if (callback0) {
	          callback0.value = null;
	          i = callbacks.indexOf(callback0);
	          callbacksByType[type.type] = callbacks = callbacks.slice(0, i).concat(callbacks.slice(i + 1));
	          delete callbackByName[type.name];
	        }
	
	        // Add the new callback, if any.
	        if (callback) {
	          callback = {value: callback};
	          callbackByName[type.name] = callback;
	          callbacks.push(callback);
	        }
	      }
	
	      // Otherwise, if a null callback was specified, remove all callbacks with the given name.
	      else if (callback == null) {
	        for (var otherType in callbacksByType) {
	          if (callback = callbackByName[otherType + type.name]) {
	            callback.value = null;
	            callbacks = callbacksByType[otherType];
	            i = callbacks.indexOf(callback);
	            callbacksByType[otherType] = callbacks.slice(0, i).concat(callbacks.slice(i + 1));
	            delete callbackByName[callback.name];
	          }
	        }
	      }
	
	      return that;
	    };
	
	    while (++i < n) {
	      type = types[i] + "";
	      if (!type || (type in that)) throw new Error("illegal or duplicate type: " + type);
	      callbacksByType[type] = [];
	      that[type] = applier(type);
	    }
	
	    function parseType(type) {
	      var i = (type += "").indexOf("."), name = type;
	      if (i >= 0) type = type.slice(0, i); else name += ".";
	      if (type && !callbacksByType.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	      return {type: type, name: name};
	    }
	
	    function applier(type) {
	      return function() {
	        var callbacks = callbacksByType[type], // Defensive reference; copy-on-remove.
	            callbackValue,
	            i = -1,
	            n = callbacks.length;
	
	        while (++i < n) {
	          if (callbackValue = callbacks[i].value) {
	            callbackValue.apply(this, arguments);
	          }
	        }
	
	        return that;
	      };
	    }
	  }
	
	  dispatch.prototype = Dispatch.prototype;
	
	  var version = "0.2.6";
	
	  exports.version = version;
	  exports.dispatch = dispatch;
	
	}));
})
/** END DEFINE BLOCK for d3-dispatch@0.2.6/build/d3-dispatch.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/modify.js **/
jupyter.define('vega@2.6.3/src/parse/modify.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Node = df.Node, // jshint ignore:line
	    Tuple = df.Tuple,
	    Deps = df.Dependencies;
	
	var Types = {
	  INSERT: "insert",
	  REMOVE: "remove",
	  UPSERT: "upsert",
	  TOGGLE: "toggle",
	  CLEAR:  "clear"
	};
	
	var EMPTY = [];
	
	function filter(fields, value, src, dest) {
	  var splice = true, len = fields.length, i, j, f, v;
	  for (i = src.length - 1; i >= 0; --i) {
	    for (j=0; j<len; ++j) {
	      f = fields[j];
	      v = value && f(value) || value;
	      if (f(src[i]) !== v) {
	        splice = false;
	        break;
	      }
	    }
	
	    if (splice) dest.push.apply(dest, src.splice(i, 1));
	    splice = true;
	  }
	}
	
	function insert(input, datum, source) {
	  var t = Tuple.ingest(datum);
	  input.add.push(t);
	  source._data.push(t);
	}
	
	function parseModify(model, def, ds) {
	  var signal = def.signal ? dl.field(def.signal) : null,
	      signalName  = signal ? signal[0] : null,
	      predicate   = def.predicate ? model.predicate(def.predicate.name || def.predicate) : null,
	      exprTrigger = def.test ? model.expr(def.test) : null,
	      reeval  = (predicate === null && exprTrigger === null),
	      isClear = def.type === Types.CLEAR,
	      fields  = dl.array(def.field || 'data'),
	      getters = fields.map(dl.accessor),
	      setters = fields.map(dl.mutator),
	      node = new Node(model).router(isClear);
	
	  node.evaluate = function(input) {
	    var db, sg;
	
	    if (predicate !== null) {  // TODO: predicate args
	      db = model.values(Deps.DATA, predicate.data || EMPTY);
	      sg = model.values(Deps.SIGNALS, predicate.signals || EMPTY);
	      reeval = predicate.call(predicate, {}, db, sg, model._predicates);
	    }
	
	    if (exprTrigger !== null) {
	      sg = model.values(Deps.SIGNALS, exprTrigger.globals || EMPTY);
	      reeval = exprTrigger.fn();
	    }
	
	    log.debug(input, [def.type+"ing", reeval]);
	    if (!reeval || (!isClear && !input.signals[signalName])) return input;
	
	    var value = signal ? model.signalRef(def.signal) : null,
	        d = model.data(ds.name),
	        t = null, add = [], rem = [], up = 0, datum;
	
	    if (dl.isObject(value)) {
	      datum = value;
	      if (!def.field) {
	        fields = dl.keys(datum);
	        getters = fields.map(dl.accessor);
	        setters = fields.map(dl.mutator);
	      }
	    } else {
	      datum = {};
	      setters.forEach(function(f) { f(datum, value); });
	    }
	
	    // We have to modify ds._data so that subsequent pulses contain
	    // our dynamic data. W/o modifying ds._data, only the output
	    // collector will contain dynamic tuples.
	    if (def.type === Types.INSERT) {
	      insert(input, datum, d);
	    } else if (def.type === Types.REMOVE) {
	      filter(getters, value, input.mod, input.rem);
	      filter(getters, value, input.add, rem);
	      filter(getters, value, d._data, rem);
	    } else if (def.type === Types.UPSERT) {
	      input.mod.forEach(function(x) {
	        var every = getters.every(function(f) {
	          return f(x) === f(datum);
	        });
	
	        if (every) up = (dl.extend(x, datum), up+1);
	      });
	
	      if (up === 0) insert(input, datum, d);
	    } else if (def.type === Types.TOGGLE) {
	      // If tuples are in mod, remove them.
	      filter(getters, value, input.mod, rem);
	      input.rem.push.apply(input.rem, rem);
	
	      // If tuples are in add, they've been added to backing data source,
	      // but no downstream operators will have seen it yet.
	      filter(getters, value, input.add, add);
	
	      if (add.length || rem.length) {
	        d._data = d._data.filter(function(x) {
	          return rem.indexOf(x) < 0 && add.indexOf(x) < 0;
	        });
	      } else {
	        // If the tuples aren't seen in the changeset, add a new tuple.
	        // Note, tuple might be in input.rem, but we ignore this and just
	        // re-add a new tuple for simplicity.
	        input.add.push(t=Tuple.ingest(datum));
	        d._data.push(t);
	      }
	    } else if (def.type === Types.CLEAR) {
	      input.rem.push.apply(input.rem, input.mod.splice(0));
	      input.add.splice(0);
	      d._data.splice(0);
	    }
	
	    fields.forEach(function(f) { input.fields[f] = 1; });
	    return input;
	  };
	
	  if (signalName) node.dependency(Deps.SIGNALS, signalName);
	
	  if (predicate) {
	    node.dependency(Deps.DATA, predicate.data);
	    node.dependency(Deps.SIGNALS, predicate.signals);
	  }
	
	  if (exprTrigger) {
	    node.dependency(Deps.SIGNALS, exprTrigger.globals);
	    node.dependency(Deps.DATA,    exprTrigger.dataSources);
	  }
	
	  return node;
	}
	
	module.exports = parseModify;
	parseModify.schema = {
	  "defs": {
	    "modify": {
	      "type": "array",
	      "items": {
	        "type": "object",
	        "oneOf": [{
	          "properties": {
	            "type": {"enum": [
	              Types.INSERT, Types.REMOVE, Types.UPSERT, Types.TOGGLE
	            ]},
	            "signal": {"type": "string"},
	            "field": {"type": "string"}
	          },
	          "required": ["type", "signal"]
	        }, {
	          "properties": {
	            "type": {"enum": [Types.CLEAR]},
	            "predicate": {"type": "string"}  // TODO predicate args
	          },
	          "required": ["type", "predicate"]
	        },
	        {
	          "properties": {
	            "type": {"enum": [Types.CLEAR]},
	            "test": {"type": "string"}
	          },
	          "required": ["type", "test"]
	        }]
	      }
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/modify.js **/


/** START DEFINE BLOCK for vega-event-selector@1.1.0/index.js **/
jupyter.define('vega-event-selector@1.1.0/index.js', function (module, exports, __jupyter_require__) {
	module.exports = (function() {
	  "use strict";
	
	  /*
	   * Generated by PEG.js 0.9.0.
	   *
	   * http://pegjs.org/
	   */
	
	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }
	
	  function peg$SyntaxError(message, expected, found, location) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.location = location;
	    this.name     = "SyntaxError";
	
	    if (typeof Error.captureStackTrace === "function") {
	      Error.captureStackTrace(this, peg$SyntaxError);
	    }
	  }
	
	  peg$subclass(peg$SyntaxError, Error);
	
	  function peg$parse(input) {
	    var options = arguments.length > 1 ? arguments[1] : {},
	        parser  = this,
	
	        peg$FAILED = {},
	
	        peg$startRuleFunctions = { start: peg$parsestart },
	        peg$startRuleFunction  = peg$parsestart,
	
	        peg$c0 = ",",
	        peg$c1 = { type: "literal", value: ",", description: "\",\"" },
	        peg$c2 = function(o, m) { return [o].concat(m); },
	        peg$c3 = function(o) { return [o]; },
	        peg$c4 = "[",
	        peg$c5 = { type: "literal", value: "[", description: "\"[\"" },
	        peg$c6 = "]",
	        peg$c7 = { type: "literal", value: "]", description: "\"]\"" },
	        peg$c8 = ">",
	        peg$c9 = { type: "literal", value: ">", description: "\">\"" },
	        peg$c10 = function(f1, f2, o) {
	            return {
	              start: f1, middle: o, end: f2,
	              str: '['+f1.str+', '+f2.str+'] > '+o.str};
	            },
	        peg$c11 = function(s, f) {
	            s.filters = f;
	            s.str += f.map(function(x) { return '['+x+']'; }).join('');
	            return s;
	          },
	        peg$c12 = function(s) { return s; },
	        peg$c13 = "(",
	        peg$c14 = { type: "literal", value: "(", description: "\"(\"" },
	        peg$c15 = ")",
	        peg$c16 = { type: "literal", value: ")", description: "\")\"" },
	        peg$c17 = function(m) {
	            return {
	              stream: m,
	              str: '('+m.map(function(m) { return m.str; }).join(', ')+')'
	            };
	          },
	        peg$c18 = "@",
	        peg$c19 = { type: "literal", value: "@", description: "\"@\"" },
	        peg$c20 = ":",
	        peg$c21 = { type: "literal", value: ":", description: "\":\"" },
	        peg$c22 = function(n, e) { return {event: e, name: n, str: '@'+n+':'+e}; },
	        peg$c23 = function(m, e) { return {event: e, mark: m, str: m+':'+e}; },
	        peg$c24 = function(t, e) { return {event: e, target: t, str: t+':'+e}; },
	        peg$c25 = function(e) { return {event: e, str: e}; },
	        peg$c26 = function(s) { return {signal: s, str: s}; },
	        peg$c27 = "rect",
	        peg$c28 = { type: "literal", value: "rect", description: "\"rect\"" },
	        peg$c29 = "symbol",
	        peg$c30 = { type: "literal", value: "symbol", description: "\"symbol\"" },
	        peg$c31 = "path",
	        peg$c32 = { type: "literal", value: "path", description: "\"path\"" },
	        peg$c33 = "arc",
	        peg$c34 = { type: "literal", value: "arc", description: "\"arc\"" },
	        peg$c35 = "area",
	        peg$c36 = { type: "literal", value: "area", description: "\"area\"" },
	        peg$c37 = "line",
	        peg$c38 = { type: "literal", value: "line", description: "\"line\"" },
	        peg$c39 = "rule",
	        peg$c40 = { type: "literal", value: "rule", description: "\"rule\"" },
	        peg$c41 = "image",
	        peg$c42 = { type: "literal", value: "image", description: "\"image\"" },
	        peg$c43 = "text",
	        peg$c44 = { type: "literal", value: "text", description: "\"text\"" },
	        peg$c45 = "group",
	        peg$c46 = { type: "literal", value: "group", description: "\"group\"" },
	        peg$c47 = "mousedown",
	        peg$c48 = { type: "literal", value: "mousedown", description: "\"mousedown\"" },
	        peg$c49 = "mouseup",
	        peg$c50 = { type: "literal", value: "mouseup", description: "\"mouseup\"" },
	        peg$c51 = "click",
	        peg$c52 = { type: "literal", value: "click", description: "\"click\"" },
	        peg$c53 = "dblclick",
	        peg$c54 = { type: "literal", value: "dblclick", description: "\"dblclick\"" },
	        peg$c55 = "wheel",
	        peg$c56 = { type: "literal", value: "wheel", description: "\"wheel\"" },
	        peg$c57 = "keydown",
	        peg$c58 = { type: "literal", value: "keydown", description: "\"keydown\"" },
	        peg$c59 = "keypress",
	        peg$c60 = { type: "literal", value: "keypress", description: "\"keypress\"" },
	        peg$c61 = "keyup",
	        peg$c62 = { type: "literal", value: "keyup", description: "\"keyup\"" },
	        peg$c63 = "mousewheel",
	        peg$c64 = { type: "literal", value: "mousewheel", description: "\"mousewheel\"" },
	        peg$c65 = "mousemove",
	        peg$c66 = { type: "literal", value: "mousemove", description: "\"mousemove\"" },
	        peg$c67 = "mouseout",
	        peg$c68 = { type: "literal", value: "mouseout", description: "\"mouseout\"" },
	        peg$c69 = "mouseover",
	        peg$c70 = { type: "literal", value: "mouseover", description: "\"mouseover\"" },
	        peg$c71 = "mouseenter",
	        peg$c72 = { type: "literal", value: "mouseenter", description: "\"mouseenter\"" },
	        peg$c73 = "touchstart",
	        peg$c74 = { type: "literal", value: "touchstart", description: "\"touchstart\"" },
	        peg$c75 = "touchmove",
	        peg$c76 = { type: "literal", value: "touchmove", description: "\"touchmove\"" },
	        peg$c77 = "touchend",
	        peg$c78 = { type: "literal", value: "touchend", description: "\"touchend\"" },
	        peg$c79 = "dragenter",
	        peg$c80 = { type: "literal", value: "dragenter", description: "\"dragenter\"" },
	        peg$c81 = "dragover",
	        peg$c82 = { type: "literal", value: "dragover", description: "\"dragover\"" },
	        peg$c83 = "dragleave",
	        peg$c84 = { type: "literal", value: "dragleave", description: "\"dragleave\"" },
	        peg$c85 = function(e) { return e; },
	        peg$c86 = /^[a-zA-Z0-9_\-]/,
	        peg$c87 = { type: "class", value: "[a-zA-Z0-9_-]", description: "[a-zA-Z0-9_-]" },
	        peg$c88 = function(n) { return n.join(''); },
	        peg$c89 = /^[a-zA-Z0-9\-_  #.>+~[\]=|\^$*]/,
	        peg$c90 = { type: "class", value: "[a-zA-Z0-9-_  #\\.\\>\\+~\\[\\]=|\\^\\$\\*]", description: "[a-zA-Z0-9-_  #\\.\\>\\+~\\[\\]=|\\^\\$\\*]" },
	        peg$c91 = function(c) { return c.join(''); },
	        peg$c92 = /^['"a-zA-Z0-9_().><=! \t-&|~]/,
	        peg$c93 = { type: "class", value: "['\"a-zA-Z0-9_\\(\\)\\.\\>\\<\\=\\! \\t-&|~]", description: "['\"a-zA-Z0-9_\\(\\)\\.\\>\\<\\=\\! \\t-&|~]" },
	        peg$c94 = function(v) { return v.join(''); },
	        peg$c95 = /^[ \t\r\n]/,
	        peg$c96 = { type: "class", value: "[ \\t\\r\\n]", description: "[ \\t\\r\\n]" },
	
	        peg$currPos          = 0,
	        peg$savedPos         = 0,
	        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,
	
	        peg$result;
	
	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }
	
	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }
	
	    function text() {
	      return input.substring(peg$savedPos, peg$currPos);
	    }
	
	    function location() {
	      return peg$computeLocation(peg$savedPos, peg$currPos);
	    }
	
	    function expected(description) {
	      throw peg$buildException(
	        null,
	        [{ type: "other", description: description }],
	        input.substring(peg$savedPos, peg$currPos),
	        peg$computeLocation(peg$savedPos, peg$currPos)
	      );
	    }
	
	    function error(message) {
	      throw peg$buildException(
	        message,
	        null,
	        input.substring(peg$savedPos, peg$currPos),
	        peg$computeLocation(peg$savedPos, peg$currPos)
	      );
	    }
	
	    function peg$computePosDetails(pos) {
	      var details = peg$posDetailsCache[pos],
	          p, ch;
	
	      if (details) {
	        return details;
	      } else {
	        p = pos - 1;
	        while (!peg$posDetailsCache[p]) {
	          p--;
	        }
	
	        details = peg$posDetailsCache[p];
	        details = {
	          line:   details.line,
	          column: details.column,
	          seenCR: details.seenCR
	        };
	
	        while (p < pos) {
	          ch = input.charAt(p);
	          if (ch === "\n") {
	            if (!details.seenCR) { details.line++; }
	            details.column = 1;
	            details.seenCR = false;
	          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	            details.line++;
	            details.column = 1;
	            details.seenCR = true;
	          } else {
	            details.column++;
	            details.seenCR = false;
	          }
	
	          p++;
	        }
	
	        peg$posDetailsCache[pos] = details;
	        return details;
	      }
	    }
	
	    function peg$computeLocation(startPos, endPos) {
	      var startPosDetails = peg$computePosDetails(startPos),
	          endPosDetails   = peg$computePosDetails(endPos);
	
	      return {
	        start: {
	          offset: startPos,
	          line:   startPosDetails.line,
	          column: startPosDetails.column
	        },
	        end: {
	          offset: endPos,
	          line:   endPosDetails.line,
	          column: endPosDetails.column
	        }
	      };
	    }
	
	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }
	
	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }
	
	      peg$maxFailExpected.push(expected);
	    }
	
	    function peg$buildException(message, expected, found, location) {
	      function cleanupExpected(expected) {
	        var i = 1;
	
	        expected.sort(function(a, b) {
	          if (a.description < b.description) {
	            return -1;
	          } else if (a.description > b.description) {
	            return 1;
	          } else {
	            return 0;
	          }
	        });
	
	        while (i < expected.length) {
	          if (expected[i - 1] === expected[i]) {
	            expected.splice(i, 1);
	          } else {
	            i++;
	          }
	        }
	      }
	
	      function buildMessage(expected, found) {
	        function stringEscape(s) {
	          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }
	
	          return s
	            .replace(/\\/g,   '\\\\')
	            .replace(/"/g,    '\\"')
	            .replace(/\x08/g, '\\b')
	            .replace(/\t/g,   '\\t')
	            .replace(/\n/g,   '\\n')
	            .replace(/\f/g,   '\\f')
	            .replace(/\r/g,   '\\r')
	            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
	            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
	            .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
	            .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
	        }
	
	        var expectedDescs = new Array(expected.length),
	            expectedDesc, foundDesc, i;
	
	        for (i = 0; i < expected.length; i++) {
	          expectedDescs[i] = expected[i].description;
	        }
	
	        expectedDesc = expected.length > 1
	          ? expectedDescs.slice(0, -1).join(", ")
	              + " or "
	              + expectedDescs[expected.length - 1]
	          : expectedDescs[0];
	
	        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	
	        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	      }
	
	      if (expected !== null) {
	        cleanupExpected(expected);
	      }
	
	      return new peg$SyntaxError(
	        message !== null ? message : buildMessage(expected, found),
	        expected,
	        found,
	        location
	      );
	    }
	
	    function peg$parsestart() {
	      var s0;
	
	      s0 = peg$parsemerged();
	
	      return s0;
	    }
	
	    function peg$parsemerged() {
	      var s0, s1, s2, s3, s4, s5;
	
	      s0 = peg$currPos;
	      s1 = peg$parseordered();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parsesep();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 44) {
	            s3 = peg$c0;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c1); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parsesep();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parsemerged();
	              if (s5 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c2(s1, s5);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parseordered();
	        if (s1 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c3(s1);
	        }
	        s0 = s1;
	      }
	
	      return s0;
	    }
	
	    function peg$parseordered() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
	
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 91) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parsesep();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parsefiltered();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parsesep();
	            if (s4 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 44) {
	                s5 = peg$c0;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c1); }
	              }
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parsesep();
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parsefiltered();
	                  if (s7 !== peg$FAILED) {
	                    s8 = peg$parsesep();
	                    if (s8 !== peg$FAILED) {
	                      if (input.charCodeAt(peg$currPos) === 93) {
	                        s9 = peg$c6;
	                        peg$currPos++;
	                      } else {
	                        s9 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c7); }
	                      }
	                      if (s9 !== peg$FAILED) {
	                        s10 = peg$parsesep();
	                        if (s10 !== peg$FAILED) {
	                          if (input.charCodeAt(peg$currPos) === 62) {
	                            s11 = peg$c8;
	                            peg$currPos++;
	                          } else {
	                            s11 = peg$FAILED;
	                            if (peg$silentFails === 0) { peg$fail(peg$c9); }
	                          }
	                          if (s11 !== peg$FAILED) {
	                            s12 = peg$parsesep();
	                            if (s12 !== peg$FAILED) {
	                              s13 = peg$parseordered();
	                              if (s13 !== peg$FAILED) {
	                                peg$savedPos = s0;
	                                s1 = peg$c10(s3, s7, s13);
	                                s0 = s1;
	                              } else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                              }
	                            } else {
	                              peg$currPos = s0;
	                              s0 = peg$FAILED;
	                            }
	                          } else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                          }
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$parsefiltered();
	      }
	
	      return s0;
	    }
	
	    function peg$parsefiltered() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      s1 = peg$parsestream();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parsefilter();
	        if (s3 !== peg$FAILED) {
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$parsefilter();
	          }
	        } else {
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c11(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parsestream();
	        if (s1 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c12(s1);
	        }
	        s0 = s1;
	      }
	
	      return s0;
	    }
	
	    function peg$parsestream() {
	      var s0, s1, s2, s3, s4;
	
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 40) {
	        s1 = peg$c13;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c14); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parsemerged();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 41) {
	            s3 = peg$c15;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c16); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c17(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 64) {
	          s1 = peg$c18;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c19); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = peg$parsename();
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	              s3 = peg$c20;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c21); }
	            }
	            if (s3 !== peg$FAILED) {
	              s4 = peg$parseeventType();
	              if (s4 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c22(s2, s4);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	        if (s0 === peg$FAILED) {
	          s0 = peg$currPos;
	          s1 = peg$parsemarkType();
	          if (s1 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 58) {
	              s2 = peg$c20;
	              peg$currPos++;
	            } else {
	              s2 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c21); }
	            }
	            if (s2 !== peg$FAILED) {
	              s3 = peg$parseeventType();
	              if (s3 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c23(s1, s3);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	          if (s0 === peg$FAILED) {
	            s0 = peg$currPos;
	            s1 = peg$parsecss();
	            if (s1 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 58) {
	                s2 = peg$c20;
	                peg$currPos++;
	              } else {
	                s2 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c21); }
	              }
	              if (s2 !== peg$FAILED) {
	                s3 = peg$parseeventType();
	                if (s3 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c24(s1, s3);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	              s0 = peg$currPos;
	              s1 = peg$parseeventType();
	              if (s1 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c25(s1);
	              }
	              s0 = s1;
	              if (s0 === peg$FAILED) {
	                s0 = peg$currPos;
	                s1 = peg$parsename();
	                if (s1 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c26(s1);
	                }
	                s0 = s1;
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parsemarkType() {
	      var s0;
	
	      if (input.substr(peg$currPos, 4) === peg$c27) {
	        s0 = peg$c27;
	        peg$currPos += 4;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c28); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 6) === peg$c29) {
	          s0 = peg$c29;
	          peg$currPos += 6;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c30); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.substr(peg$currPos, 4) === peg$c31) {
	            s0 = peg$c31;
	            peg$currPos += 4;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c32); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 3) === peg$c33) {
	              s0 = peg$c33;
	              peg$currPos += 3;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c34); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.substr(peg$currPos, 4) === peg$c35) {
	                s0 = peg$c35;
	                peg$currPos += 4;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c36); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.substr(peg$currPos, 4) === peg$c37) {
	                  s0 = peg$c37;
	                  peg$currPos += 4;
	                } else {
	                  s0 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c38); }
	                }
	                if (s0 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 4) === peg$c39) {
	                    s0 = peg$c39;
	                    peg$currPos += 4;
	                  } else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c40); }
	                  }
	                  if (s0 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 5) === peg$c41) {
	                      s0 = peg$c41;
	                      peg$currPos += 5;
	                    } else {
	                      s0 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c42); }
	                    }
	                    if (s0 === peg$FAILED) {
	                      if (input.substr(peg$currPos, 4) === peg$c43) {
	                        s0 = peg$c43;
	                        peg$currPos += 4;
	                      } else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c44); }
	                      }
	                      if (s0 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 5) === peg$c45) {
	                          s0 = peg$c45;
	                          peg$currPos += 5;
	                        } else {
	                          s0 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c46); }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parseeventType() {
	      var s0;
	
	      if (input.substr(peg$currPos, 9) === peg$c47) {
	        s0 = peg$c47;
	        peg$currPos += 9;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c48); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 7) === peg$c49) {
	          s0 = peg$c49;
	          peg$currPos += 7;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c50); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.substr(peg$currPos, 5) === peg$c51) {
	            s0 = peg$c51;
	            peg$currPos += 5;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c52); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 8) === peg$c53) {
	              s0 = peg$c53;
	              peg$currPos += 8;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c54); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.substr(peg$currPos, 5) === peg$c55) {
	                s0 = peg$c55;
	                peg$currPos += 5;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c56); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.substr(peg$currPos, 7) === peg$c57) {
	                  s0 = peg$c57;
	                  peg$currPos += 7;
	                } else {
	                  s0 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c58); }
	                }
	                if (s0 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 8) === peg$c59) {
	                    s0 = peg$c59;
	                    peg$currPos += 8;
	                  } else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c60); }
	                  }
	                  if (s0 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 5) === peg$c61) {
	                      s0 = peg$c61;
	                      peg$currPos += 5;
	                    } else {
	                      s0 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c62); }
	                    }
	                    if (s0 === peg$FAILED) {
	                      if (input.substr(peg$currPos, 10) === peg$c63) {
	                        s0 = peg$c63;
	                        peg$currPos += 10;
	                      } else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c64); }
	                      }
	                      if (s0 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 9) === peg$c65) {
	                          s0 = peg$c65;
	                          peg$currPos += 9;
	                        } else {
	                          s0 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c66); }
	                        }
	                        if (s0 === peg$FAILED) {
	                          if (input.substr(peg$currPos, 8) === peg$c67) {
	                            s0 = peg$c67;
	                            peg$currPos += 8;
	                          } else {
	                            s0 = peg$FAILED;
	                            if (peg$silentFails === 0) { peg$fail(peg$c68); }
	                          }
	                          if (s0 === peg$FAILED) {
	                            if (input.substr(peg$currPos, 9) === peg$c69) {
	                              s0 = peg$c69;
	                              peg$currPos += 9;
	                            } else {
	                              s0 = peg$FAILED;
	                              if (peg$silentFails === 0) { peg$fail(peg$c70); }
	                            }
	                            if (s0 === peg$FAILED) {
	                              if (input.substr(peg$currPos, 10) === peg$c71) {
	                                s0 = peg$c71;
	                                peg$currPos += 10;
	                              } else {
	                                s0 = peg$FAILED;
	                                if (peg$silentFails === 0) { peg$fail(peg$c72); }
	                              }
	                              if (s0 === peg$FAILED) {
	                                if (input.substr(peg$currPos, 10) === peg$c73) {
	                                  s0 = peg$c73;
	                                  peg$currPos += 10;
	                                } else {
	                                  s0 = peg$FAILED;
	                                  if (peg$silentFails === 0) { peg$fail(peg$c74); }
	                                }
	                                if (s0 === peg$FAILED) {
	                                  if (input.substr(peg$currPos, 9) === peg$c75) {
	                                    s0 = peg$c75;
	                                    peg$currPos += 9;
	                                  } else {
	                                    s0 = peg$FAILED;
	                                    if (peg$silentFails === 0) { peg$fail(peg$c76); }
	                                  }
	                                  if (s0 === peg$FAILED) {
	                                    if (input.substr(peg$currPos, 8) === peg$c77) {
	                                      s0 = peg$c77;
	                                      peg$currPos += 8;
	                                    } else {
	                                      s0 = peg$FAILED;
	                                      if (peg$silentFails === 0) { peg$fail(peg$c78); }
	                                    }
	                                    if (s0 === peg$FAILED) {
	                                      if (input.substr(peg$currPos, 9) === peg$c79) {
	                                        s0 = peg$c79;
	                                        peg$currPos += 9;
	                                      } else {
	                                        s0 = peg$FAILED;
	                                        if (peg$silentFails === 0) { peg$fail(peg$c80); }
	                                      }
	                                      if (s0 === peg$FAILED) {
	                                        if (input.substr(peg$currPos, 8) === peg$c81) {
	                                          s0 = peg$c81;
	                                          peg$currPos += 8;
	                                        } else {
	                                          s0 = peg$FAILED;
	                                          if (peg$silentFails === 0) { peg$fail(peg$c82); }
	                                        }
	                                        if (s0 === peg$FAILED) {
	                                          if (input.substr(peg$currPos, 9) === peg$c83) {
	                                            s0 = peg$c83;
	                                            peg$currPos += 9;
	                                          } else {
	                                            s0 = peg$FAILED;
	                                            if (peg$silentFails === 0) { peg$fail(peg$c84); }
	                                          }
	                                        }
	                                      }
	                                    }
	                                  }
	                                }
	                              }
	                            }
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }
	
	      return s0;
	    }
	
	    function peg$parsefilter() {
	      var s0, s1, s2, s3;
	
	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 91) {
	        s1 = peg$c4;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseexpr();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 93) {
	            s3 = peg$c6;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c7); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c85(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	
	      return s0;
	    }
	
	    function peg$parsename() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c86.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c87); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c86.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c87); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c88(s1);
	      }
	      s0 = s1;
	
	      return s0;
	    }
	
	    function peg$parsecss() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c89.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c90); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c89.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c90); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c91(s1);
	      }
	      s0 = s1;
	
	      return s0;
	    }
	
	    function peg$parseexpr() {
	      var s0, s1, s2;
	
	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c92.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c93); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c92.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c93); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c94(s1);
	      }
	      s0 = s1;
	
	      return s0;
	    }
	
	    function peg$parsesep() {
	      var s0, s1;
	
	      s0 = [];
	      if (peg$c95.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c96); }
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        if (peg$c95.test(input.charAt(peg$currPos))) {
	          s1 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c96); }
	        }
	      }
	
	      return s0;
	    }
	
	    peg$result = peg$startRuleFunction();
	
	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail({ type: "end", description: "end of input" });
	      }
	
	      throw peg$buildException(
	        null,
	        peg$maxFailExpected,
	        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
	        peg$maxFailPos < input.length
	          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	      );
	    }
	  }
	
	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();
	
})
/** END DEFINE BLOCK for vega-event-selector@1.1.0/index.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/expr.js **/
jupyter.define('vega@2.6.3/src/parse/expr.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    template = dl.template,
	    expr = __jupyter_require__('vega-expression@^1.2.0/src/index.js'),
	    args = ['datum', 'parent', 'event', 'signals'];
	
	var compile = expr.compiler(args, {
	  idWhiteList: args,
	  fieldVar:    args[0],
	  globalVar:   function(id) {
	    return 'this.sig[' + dl.str(id) + ']._value';
	  },
	  functions:   function(codegen) {
	    var fn = expr.functions(codegen);
	    fn.eventItem  = 'event.vg.getItem';
	    fn.eventGroup = 'event.vg.getGroup';
	    fn.eventX     = 'event.vg.getX';
	    fn.eventY     = 'event.vg.getY';
	    fn.open       = openGen(codegen);
	    fn.scale      = scaleGen(codegen, false);
	    fn.iscale     = scaleGen(codegen, true);
	    fn.inrange    = 'this.defs.inrange';
	    fn.indata     = indataGen(codegen);
	    fn.format     = 'this.defs.format';
	    fn.timeFormat = 'this.defs.timeFormat';
	    fn.utcFormat  = 'this.defs.utcFormat';
	    return fn;
	  },
	  functionDefs: function(/*codegen*/) {
	    return {
	      'scale':      scale,
	      'inrange':    inrange,
	      'indata':     indata,
	      'format':     numberFormat,
	      'timeFormat': timeFormat,
	      'utcFormat':  utcFormat,
	      'open':       windowOpen
	    };
	  }
	});
	
	function openGen(codegen) {
	  return function (args) {
	    args = args.map(codegen);
	    var n = args.length;
	    if (n < 1 || n > 2) {
	      throw Error("open takes exactly 1 or 2 arguments.");
	    }
	    return 'this.defs.open(this.model, ' +
	      args[0] + (n > 1 ? ',' + args[1] : '') + ')';
	  };
	}
	
	function windowOpen(model, url, name) {
	  if (typeof window !== 'undefined' && window && window.open) {
	    var opt = dl.extend({type: 'open', url: url, name: name}, model.config().load),
	        uri = dl.load.sanitizeUrl(opt);
	    if (uri) {
	      window.open(uri, name);
	    } else {
	      throw Error('Invalid URL: ' + opt.url);
	    }
	  } else {
	    throw Error('Open function can only be invoked in a browser.');
	  }
	}
	
	function scaleGen(codegen, invert) {
	  return function(args) {
	    args = args.map(codegen);
	    var n = args.length;
	    if (n < 2 || n > 3) {
	      throw Error("scale takes exactly 2 or 3 arguments.");
	    }
	    return 'this.defs.scale(this.model, ' + invert + ', ' +
	      args[0] + ',' + args[1] + (n > 2 ? ',' + args[2] : '') + ')';
	  };
	}
	
	function scale(model, invert, name, value, scope) {
	  if (!scope || !scope.scale) {
	    scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];
	  }
	  // Verify scope is valid
	  if (model.group(scope._id) !== scope) {
	    throw Error('Scope for scale "'+name+'" is not a valid group item.');
	  }
	  var s = scope.scale(name);
	  return !s ? value : (invert ? s.invert(value) : s(value));
	}
	
	function inrange(val, a, b, exclusive) {
	  var min = a, max = b;
	  if (a > b) { min = b; max = a; }
	  return exclusive ?
	    (min < val && max > val) :
	    (min <= val && max >= val);
	}
	
	function indataGen(codegen) {
	  return function(args, globals, fields, dataSources) {
	    var data;
	    if (args.length !== 3) {
	      throw Error("indata takes 3 arguments.");
	    }
	    if (args[0].type !== 'Literal') {
	      throw Error("Data source name must be a literal for indata.");
	    }
	
	    data = args[0].value;
	    dataSources[data] = 1;
	    if (args[2].type === 'Literal') {
	      indataGen.model.requestIndex(data, args[2].value);
	    }
	
	    args = args.map(codegen);
	    return 'this.defs.indata(this.model,' +
	      args[0] + ',' + args[1] + ',' + args[2] + ')';
	  };
	}
	
	function indata(model, dataname, val, field) {
	  var data = model.data(dataname),
	      index = data.getIndex(field);
	  return index[val] > 0;
	}
	
	function numberFormat(specifier, v) {
	  return template.format(specifier, 'number')(v);
	}
	
	function timeFormat(specifier, d) {
	  return template.format(specifier, 'time')(d);
	}
	
	function utcFormat(specifier, d) {
	  return template.format(specifier, 'utc')(d);
	}
	
	function wrap(model) {
	  return function(str) {
	    indataGen.model = model;
	    var x = compile(str);
	    x.model = model;
	    x.sig = model ? model._signals : {};
	    return x;
	  };
	}
	
	wrap.scale = scale;
	wrap.codegen = compile.codegen;
	module.exports = wrap;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/expr.js **/


/** START DEFINE BLOCK for vega-expression@1.2.0/src/index.js **/
jupyter.define('vega-expression@1.2.0/src/index.js', function (module, exports, __jupyter_require__) {
	var parser = __jupyter_require__('vega-expression@~1.2.0/src/parser.js'),
	    codegen = __jupyter_require__('vega-expression@~1.2.0/src/codegen.js');
	
	var expr = module.exports = {
	  parse: function(input, opt) {
	      return parser.parse('('+input+')', opt);
	    },
	  code: function(opt) {
	      return codegen(opt);
	    },
	  compiler: function(args, opt) {
	      args = args.slice();
	      var generator = codegen(opt),
	          len = args.length,
	          compile = function(str) {
	            var value = generator(expr.parse(str));
	            args[len] = '"use strict"; return (' + value.code + ');';
	            var fn = Function.apply(null, args);
	            value.fn = (args.length > 8) ?
	              function() { return fn.apply(value, arguments); } :
	              function(a, b, c, d, e, f, g) {
	                return fn.call(value, a, b, c, d, e, f, g);
	              }; // call often faster than apply, use if args low enough
	            return value;
	          };
	      compile.codegen = generator;
	      return compile;
	    },
	  functions: __jupyter_require__('vega-expression@~1.2.0/src/functions.js'),
	  constants: __jupyter_require__('vega-expression@~1.2.0/src/constants.js')
	};
})
/** END DEFINE BLOCK for vega-expression@1.2.0/src/index.js **/


/** START DEFINE BLOCK for vega-expression@1.2.0/src/parser.js **/
jupyter.define('vega-expression@1.2.0/src/parser.js', function (module, exports, __jupyter_require__) {
	/*
	  The following expression parser is based on Esprima (http://esprima.org/).
	  Original header comment and license for Esprima is included here:
	
	  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
	  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
	  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
	  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
	  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
	  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	/* istanbul ignore next */
	module.exports = (function() {
	  'use strict';
	
	  var Token,
	      TokenName,
	      Syntax,
	      PropertyKind,
	      Messages,
	      Regex,
	      source,
	      strict,
	      index,
	      lineNumber,
	      lineStart,
	      length,
	      lookahead,
	      state,
	      extra;
	
	  Token = {
	      BooleanLiteral: 1,
	      EOF: 2,
	      Identifier: 3,
	      Keyword: 4,
	      NullLiteral: 5,
	      NumericLiteral: 6,
	      Punctuator: 7,
	      StringLiteral: 8,
	      RegularExpression: 9
	  };
	
	  TokenName = {};
	  TokenName[Token.BooleanLiteral] = 'Boolean';
	  TokenName[Token.EOF] = '<end>';
	  TokenName[Token.Identifier] = 'Identifier';
	  TokenName[Token.Keyword] = 'Keyword';
	  TokenName[Token.NullLiteral] = 'Null';
	  TokenName[Token.NumericLiteral] = 'Numeric';
	  TokenName[Token.Punctuator] = 'Punctuator';
	  TokenName[Token.StringLiteral] = 'String';
	  TokenName[Token.RegularExpression] = 'RegularExpression';
	
	  Syntax = {
	      AssignmentExpression: 'AssignmentExpression',
	      ArrayExpression: 'ArrayExpression',
	      BinaryExpression: 'BinaryExpression',
	      CallExpression: 'CallExpression',
	      ConditionalExpression: 'ConditionalExpression',
	      ExpressionStatement: 'ExpressionStatement',
	      Identifier: 'Identifier',
	      Literal: 'Literal',
	      LogicalExpression: 'LogicalExpression',
	      MemberExpression: 'MemberExpression',
	      ObjectExpression: 'ObjectExpression',
	      Program: 'Program',
	      Property: 'Property',
	      UnaryExpression: 'UnaryExpression'
	  };
	
	  PropertyKind = {
	      Data: 1,
	      Get: 2,
	      Set: 4
	  };
	
	  // Error messages should be identical to V8.
	  Messages = {
	      UnexpectedToken:  'Unexpected token %0',
	      UnexpectedNumber:  'Unexpected number',
	      UnexpectedString:  'Unexpected string',
	      UnexpectedIdentifier:  'Unexpected identifier',
	      UnexpectedReserved:  'Unexpected reserved word',
	      UnexpectedEOS:  'Unexpected end of input',
	      NewlineAfterThrow:  'Illegal newline after throw',
	      InvalidRegExp: 'Invalid regular expression',
	      UnterminatedRegExp:  'Invalid regular expression: missing /',
	      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
	      InvalidLHSInForIn:  'Invalid left-hand side in for-in',
	      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	      NoCatchOrFinally:  'Missing catch or finally after try',
	      UnknownLabel: 'Undefined label \'%0\'',
	      Redeclaration: '%0 \'%1\' has already been declared',
	      IllegalContinue: 'Illegal continue statement',
	      IllegalBreak: 'Illegal break statement',
	      IllegalReturn: 'Illegal return statement',
	      StrictModeWith:  'Strict mode code may not include a with statement',
	      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
	      StrictVarName:  'Variable name may not be eval or arguments in strict mode',
	      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
	      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
	      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
	      StrictDelete:  'Delete of an unqualified identifier in strict mode.',
	      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
	      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
	      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
	      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
	      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	      StrictReservedWord:  'Use of future reserved word in strict mode'
	  };
	
	  // See also tools/generate-unicode-regex.py.
	  Regex = {
	      NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
	      NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
	  };
	
	  // Ensure the condition is true, otherwise throw an error.
	  // This is only to have a better contract semantic, i.e. another safety net
	  // to catch a logic error. The condition shall be fulfilled in normal case.
	  // Do NOT use this to enforce a certain condition on any user input.
	
	  function assert(condition, message) {
	      if (!condition) {
	          throw new Error('ASSERT: ' + message);
	      }
	  }
	
	  function isDecimalDigit(ch) {
	      return (ch >= 0x30 && ch <= 0x39);   // 0..9
	  }
	
	  function isHexDigit(ch) {
	      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	  }
	
	  function isOctalDigit(ch) {
	      return '01234567'.indexOf(ch) >= 0;
	  }
	
	  // 7.2 White Space
	
	  function isWhiteSpace(ch) {
	      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	  }
	
	  // 7.3 Line Terminators
	
	  function isLineTerminator(ch) {
	      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	  }
	
	  // 7.6 Identifier Names and Identifiers
	
	  function isIdentifierStart(ch) {
	      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	          (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	          (ch === 0x5C) ||                      // \ (backslash)
	          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
	  }
	
	  function isIdentifierPart(ch) {
	      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	          (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	          (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	          (ch === 0x5C) ||                      // \ (backslash)
	          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
	  }
	
	  // 7.6.1.2 Future Reserved Words
	
	  function isFutureReservedWord(id) {
	      switch (id) {
	      case 'class':
	      case 'enum':
	      case 'export':
	      case 'extends':
	      case 'import':
	      case 'super':
	          return true;
	      default:
	          return false;
	      }
	  }
	
	  function isStrictModeReservedWord(id) {
	      switch (id) {
	      case 'implements':
	      case 'interface':
	      case 'package':
	      case 'private':
	      case 'protected':
	      case 'public':
	      case 'static':
	      case 'yield':
	      case 'let':
	          return true;
	      default:
	          return false;
	      }
	  }
	
	  // 7.6.1.1 Keywords
	
	  function isKeyword(id) {
	      if (strict && isStrictModeReservedWord(id)) {
	          return true;
	      }
	
	      // 'const' is specialized as Keyword in V8.
	      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
	      // Some others are from future reserved words.
	
	      switch (id.length) {
	      case 2:
	          return (id === 'if') || (id === 'in') || (id === 'do');
	      case 3:
	          return (id === 'var') || (id === 'for') || (id === 'new') ||
	              (id === 'try') || (id === 'let');
	      case 4:
	          return (id === 'this') || (id === 'else') || (id === 'case') ||
	              (id === 'void') || (id === 'with') || (id === 'enum');
	      case 5:
	          return (id === 'while') || (id === 'break') || (id === 'catch') ||
	              (id === 'throw') || (id === 'const') || (id === 'yield') ||
	              (id === 'class') || (id === 'super');
	      case 6:
	          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	              (id === 'switch') || (id === 'export') || (id === 'import');
	      case 7:
	          return (id === 'default') || (id === 'finally') || (id === 'extends');
	      case 8:
	          return (id === 'function') || (id === 'continue') || (id === 'debugger');
	      case 10:
	          return (id === 'instanceof');
	      default:
	          return false;
	      }
	  }
	
	  function skipComment() {
	      var ch, start;
	
	      start = (index === 0);
	      while (index < length) {
	          ch = source.charCodeAt(index);
	
	          if (isWhiteSpace(ch)) {
	              ++index;
	          } else if (isLineTerminator(ch)) {
	              ++index;
	              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                  ++index;
	              }
	              ++lineNumber;
	              lineStart = index;
	              start = true;
	          } else {
	              break;
	          }
	      }
	  }
	
	  function scanHexEscape(prefix) {
	      var i, len, ch, code = 0;
	
	      len = (prefix === 'u') ? 4 : 2;
	      for (i = 0; i < len; ++i) {
	          if (index < length && isHexDigit(source[index])) {
	              ch = source[index++];
	              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	          } else {
	              return '';
	          }
	      }
	      return String.fromCharCode(code);
	  }
	
	  function scanUnicodeCodePointEscape() {
	      var ch, code, cu1, cu2;
	
	      ch = source[index];
	      code = 0;
	
	      // At least, one hex digit is required.
	      if (ch === '}') {
	          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	      }
	
	      while (index < length) {
	          ch = source[index++];
	          if (!isHexDigit(ch)) {
	              break;
	          }
	          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	      }
	
	      if (code > 0x10FFFF || ch !== '}') {
	          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	      }
	
	      // UTF-16 Encoding
	      if (code <= 0xFFFF) {
	          return String.fromCharCode(code);
	      }
	      cu1 = ((code - 0x10000) >> 10) + 0xD800;
	      cu2 = ((code - 0x10000) & 1023) + 0xDC00;
	      return String.fromCharCode(cu1, cu2);
	  }
	
	  function getEscapedIdentifier() {
	      var ch, id;
	
	      ch = source.charCodeAt(index++);
	      id = String.fromCharCode(ch);
	
	      // '\u' (U+005C, U+0075) denotes an escaped character.
	      if (ch === 0x5C) {
	          if (source.charCodeAt(index) !== 0x75) {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	          }
	          ++index;
	          ch = scanHexEscape('u');
	          if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	          }
	          id = ch;
	      }
	
	      while (index < length) {
	          ch = source.charCodeAt(index);
	          if (!isIdentifierPart(ch)) {
	              break;
	          }
	          ++index;
	          id += String.fromCharCode(ch);
	
	          // '\u' (U+005C, U+0075) denotes an escaped character.
	          if (ch === 0x5C) {
	              id = id.substr(0, id.length - 1);
	              if (source.charCodeAt(index) !== 0x75) {
	                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	              }
	              ++index;
	              ch = scanHexEscape('u');
	              if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
	                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	              }
	              id += ch;
	          }
	      }
	
	      return id;
	  }
	
	  function getIdentifier() {
	      var start, ch;
	
	      start = index++;
	      while (index < length) {
	          ch = source.charCodeAt(index);
	          if (ch === 0x5C) {
	              // Blackslash (U+005C) marks Unicode escape sequence.
	              index = start;
	              return getEscapedIdentifier();
	          }
	          if (isIdentifierPart(ch)) {
	              ++index;
	          } else {
	              break;
	          }
	      }
	
	      return source.slice(start, index);
	  }
	
	  function scanIdentifier() {
	      var start, id, type;
	
	      start = index;
	
	      // Backslash (U+005C) starts an escaped character.
	      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();
	
	      // There is no keyword or literal with only one character.
	      // Thus, it must be an identifier.
	      if (id.length === 1) {
	          type = Token.Identifier;
	      } else if (isKeyword(id)) {
	          type = Token.Keyword;
	      } else if (id === 'null') {
	          type = Token.NullLiteral;
	      } else if (id === 'true' || id === 'false') {
	          type = Token.BooleanLiteral;
	      } else {
	          type = Token.Identifier;
	      }
	
	      return {
	          type: type,
	          value: id,
	          lineNumber: lineNumber,
	          lineStart: lineStart,
	          start: start,
	          end: index
	      };
	  }
	
	  // 7.7 Punctuators
	
	  function scanPunctuator() {
	      var start = index,
	          code = source.charCodeAt(index),
	          code2,
	          ch1 = source[index],
	          ch2,
	          ch3,
	          ch4;
	
	      switch (code) {
	
	      // Check for most common single-character punctuators.
	      case 0x2E:  // . dot
	      case 0x28:  // ( open bracket
	      case 0x29:  // ) close bracket
	      case 0x3B:  // ; semicolon
	      case 0x2C:  // , comma
	      case 0x7B:  // { open curly brace
	      case 0x7D:  // } close curly brace
	      case 0x5B:  // [
	      case 0x5D:  // ]
	      case 0x3A:  // :
	      case 0x3F:  // ?
	      case 0x7E:  // ~
	          ++index;
	          if (extra.tokenize) {
	              if (code === 0x28) {
	                  extra.openParenToken = extra.tokens.length;
	              } else if (code === 0x7B) {
	                  extra.openCurlyToken = extra.tokens.length;
	              }
	          }
	          return {
	              type: Token.Punctuator,
	              value: String.fromCharCode(code),
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	          };
	
	      default:
	          code2 = source.charCodeAt(index + 1);
	
	          // '=' (U+003D) marks an assignment or comparison operator.
	          if (code2 === 0x3D) {
	              switch (code) {
	              case 0x2B:  // +
	              case 0x2D:  // -
	              case 0x2F:  // /
	              case 0x3C:  // <
	              case 0x3E:  // >
	              case 0x5E:  // ^
	              case 0x7C:  // |
	              case 0x25:  // %
	              case 0x26:  // &
	              case 0x2A:  // *
	                  index += 2;
	                  return {
	                      type: Token.Punctuator,
	                      value: String.fromCharCode(code) + String.fromCharCode(code2),
	                      lineNumber: lineNumber,
	                      lineStart: lineStart,
	                      start: start,
	                      end: index
	                  };
	
	              case 0x21: // !
	              case 0x3D: // =
	                  index += 2;
	
	                  // !== and ===
	                  if (source.charCodeAt(index) === 0x3D) {
	                      ++index;
	                  }
	                  return {
	                      type: Token.Punctuator,
	                      value: source.slice(start, index),
	                      lineNumber: lineNumber,
	                      lineStart: lineStart,
	                      start: start,
	                      end: index
	                  };
	              }
	          }
	      }
	
	      // 4-character punctuator: >>>=
	
	      ch4 = source.substr(index, 4);
	
	      if (ch4 === '>>>=') {
	          index += 4;
	          return {
	              type: Token.Punctuator,
	              value: ch4,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	          };
	      }
	
	      // 3-character punctuators: === !== >>> <<= >>=
	
	      ch3 = ch4.substr(0, 3);
	
	      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
	          index += 3;
	          return {
	              type: Token.Punctuator,
	              value: ch3,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	          };
	      }
	
	      // Other 2-character punctuators: ++ -- << >> && ||
	      ch2 = ch3.substr(0, 2);
	
	      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
	          index += 2;
	          return {
	              type: Token.Punctuator,
	              value: ch2,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	          };
	      }
	
	      // 1-character punctuators: < > = ! + - * % & | ^ /
	
	      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
	          ++index;
	          return {
	              type: Token.Punctuator,
	              value: ch1,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	          };
	      }
	
	      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	  }
	
	  // 7.8.3 Numeric Literals
	
	  function scanHexLiteral(start) {
	      var number = '';
	
	      while (index < length) {
	          if (!isHexDigit(source[index])) {
	              break;
	          }
	          number += source[index++];
	      }
	
	      if (number.length === 0) {
	          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	      }
	
	      if (isIdentifierStart(source.charCodeAt(index))) {
	          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	      }
	
	      return {
	          type: Token.NumericLiteral,
	          value: parseInt('0x' + number, 16),
	          lineNumber: lineNumber,
	          lineStart: lineStart,
	          start: start,
	          end: index
	      };
	  }
	
	  function scanOctalLiteral(start) {
	      var number = '0' + source[index++];
	      while (index < length) {
	          if (!isOctalDigit(source[index])) {
	              break;
	          }
	          number += source[index++];
	      }
	
	      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	      }
	
	      return {
	          type: Token.NumericLiteral,
	          value: parseInt(number, 8),
	          octal: true,
	          lineNumber: lineNumber,
	          lineStart: lineStart,
	          start: start,
	          end: index
	      };
	  }
	
	  function scanNumericLiteral() {
	      var number, start, ch;
	
	      ch = source[index];
	      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	          'Numeric literal must start with a decimal digit or a decimal point');
	
	      start = index;
	      number = '';
	      if (ch !== '.') {
	          number = source[index++];
	          ch = source[index];
	
	          // Hex number starts with '0x'.
	          // Octal number starts with '0'.
	          if (number === '0') {
	              if (ch === 'x' || ch === 'X') {
	                  ++index;
	                  return scanHexLiteral(start);
	              }
	              if (isOctalDigit(ch)) {
	                  return scanOctalLiteral(start);
	              }
	
	              // decimal number starts with '0' such as '09' is illegal.
	              if (ch && isDecimalDigit(ch.charCodeAt(0))) {
	                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	              }
	          }
	
	          while (isDecimalDigit(source.charCodeAt(index))) {
	              number += source[index++];
	          }
	          ch = source[index];
	      }
	
	      if (ch === '.') {
	          number += source[index++];
	          while (isDecimalDigit(source.charCodeAt(index))) {
	              number += source[index++];
	          }
	          ch = source[index];
	      }
	
	      if (ch === 'e' || ch === 'E') {
	          number += source[index++];
	
	          ch = source[index];
	          if (ch === '+' || ch === '-') {
	              number += source[index++];
	          }
	          if (isDecimalDigit(source.charCodeAt(index))) {
	              while (isDecimalDigit(source.charCodeAt(index))) {
	                  number += source[index++];
	              }
	          } else {
	              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	          }
	      }
	
	      if (isIdentifierStart(source.charCodeAt(index))) {
	          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	      }
	
	      return {
	          type: Token.NumericLiteral,
	          value: parseFloat(number),
	          lineNumber: lineNumber,
	          lineStart: lineStart,
	          start: start,
	          end: index
	      };
	  }
	
	  // 7.8.4 String Literals
	
	  function scanStringLiteral() {
	      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
	      startLineNumber = lineNumber;
	      startLineStart = lineStart;
	
	      quote = source[index];
	      assert((quote === '\'' || quote === '"'),
	          'String literal must starts with a quote');
	
	      start = index;
	      ++index;
	
	      while (index < length) {
	          ch = source[index++];
	
	          if (ch === quote) {
	              quote = '';
	              break;
	          } else if (ch === '\\') {
	              ch = source[index++];
	              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                  switch (ch) {
	                  case 'u':
	                  case 'x':
	                      if (source[index] === '{') {
	                          ++index;
	                          str += scanUnicodeCodePointEscape();
	                      } else {
	                          restore = index;
	                          unescaped = scanHexEscape(ch);
	                          if (unescaped) {
	                              str += unescaped;
	                          } else {
	                              index = restore;
	                              str += ch;
	                          }
	                      }
	                      break;
	                  case 'n':
	                      str += '\n';
	                      break;
	                  case 'r':
	                      str += '\r';
	                      break;
	                  case 't':
	                      str += '\t';
	                      break;
	                  case 'b':
	                      str += '\b';
	                      break;
	                  case 'f':
	                      str += '\f';
	                      break;
	                  case 'v':
	                      str += '\x0B';
	                      break;
	
	                  default:
	                      if (isOctalDigit(ch)) {
	                          code = '01234567'.indexOf(ch);
	
	                          // \0 is not octal escape sequence
	                          if (code !== 0) {
	                              octal = true;
	                          }
	
	                          if (index < length && isOctalDigit(source[index])) {
	                              octal = true;
	                              code = code * 8 + '01234567'.indexOf(source[index++]);
	
	                              // 3 digits are only allowed when string starts
	                              // with 0, 1, 2, 3
	                              if ('0123'.indexOf(ch) >= 0 &&
	                                      index < length &&
	                                      isOctalDigit(source[index])) {
	                                  code = code * 8 + '01234567'.indexOf(source[index++]);
	                              }
	                          }
	                          str += String.fromCharCode(code);
	                      } else {
	                          str += ch;
	                      }
	                      break;
	                  }
	              } else {
	                  ++lineNumber;
	                  if (ch ===  '\r' && source[index] === '\n') {
	                      ++index;
	                  }
	                  lineStart = index;
	              }
	          } else if (isLineTerminator(ch.charCodeAt(0))) {
	              break;
	          } else {
	              str += ch;
	          }
	      }
	
	      if (quote !== '') {
	          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
	      }
	
	      return {
	          type: Token.StringLiteral,
	          value: str,
	          octal: octal,
	          startLineNumber: startLineNumber,
	          startLineStart: startLineStart,
	          lineNumber: lineNumber,
	          lineStart: lineStart,
	          start: start,
	          end: index
	      };
	  }
	
	  function testRegExp(pattern, flags) {
	      var tmp = pattern,
	          value;
	
	      if (flags.indexOf('u') >= 0) {
	          // Replace each astral symbol and every Unicode code point
	          // escape sequence with a single ASCII symbol to avoid throwing on
	          // regular expressions that are only valid in combination with the
	          // `/u` flag.
	          // Note: replacing with the ASCII symbol `x` might cause false
	          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	          // perfectly valid pattern that is equivalent to `[a-b]`, but it
	          // would be replaced by `[x-b]` which throws an error.
	          tmp = tmp
	              .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
	                  if (parseInt($1, 16) <= 0x10FFFF) {
	                      return 'x';
	                  }
	                  throwError({}, Messages.InvalidRegExp);
	              })
	              .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
	      }
	
	      // First, detect invalid regular expressions.
	      try {
	          value = new RegExp(tmp);
	      } catch (e) {
	          throwError({}, Messages.InvalidRegExp);
	      }
	
	      // Return a regular expression object for this pattern-flag pair, or
	      // `null` in case the current environment doesn't support the flags it
	      // uses.
	      try {
	          return new RegExp(pattern, flags);
	      } catch (exception) {
	          return null;
	      }
	  }
	
	  function scanRegExpBody() {
	      var ch, str, classMarker, terminated, body;
	
	      ch = source[index];
	      assert(ch === '/', 'Regular expression literal must start with a slash');
	      str = source[index++];
	
	      classMarker = false;
	      terminated = false;
	      while (index < length) {
	          ch = source[index++];
	          str += ch;
	          if (ch === '\\') {
	              ch = source[index++];
	              // ECMA-262 7.8.5
	              if (isLineTerminator(ch.charCodeAt(0))) {
	                  throwError({}, Messages.UnterminatedRegExp);
	              }
	              str += ch;
	          } else if (isLineTerminator(ch.charCodeAt(0))) {
	              throwError({}, Messages.UnterminatedRegExp);
	          } else if (classMarker) {
	              if (ch === ']') {
	                  classMarker = false;
	              }
	          } else {
	              if (ch === '/') {
	                  terminated = true;
	                  break;
	              } else if (ch === '[') {
	                  classMarker = true;
	              }
	          }
	      }
	
	      if (!terminated) {
	          throwError({}, Messages.UnterminatedRegExp);
	      }
	
	      // Exclude leading and trailing slash.
	      body = str.substr(1, str.length - 2);
	      return {
	          value: body,
	          literal: str
	      };
	  }
	
	  function scanRegExpFlags() {
	      var ch, str, flags, restore;
	
	      str = '';
	      flags = '';
	      while (index < length) {
	          ch = source[index];
	          if (!isIdentifierPart(ch.charCodeAt(0))) {
	              break;
	          }
	
	          ++index;
	          if (ch === '\\' && index < length) {
	              ch = source[index];
	              if (ch === 'u') {
	                  ++index;
	                  restore = index;
	                  ch = scanHexEscape('u');
	                  if (ch) {
	                      flags += ch;
	                      for (str += '\\u'; restore < index; ++restore) {
	                          str += source[restore];
	                      }
	                  } else {
	                      index = restore;
	                      flags += 'u';
	                      str += '\\u';
	                  }
	                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	              } else {
	                  str += '\\';
	                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
	              }
	          } else {
	              flags += ch;
	              str += ch;
	          }
	      }
	
	      return {
	          value: flags,
	          literal: str
	      };
	  }
	
	  function scanRegExp() {
	      var start, body, flags, value;
	
	      lookahead = null;
	      skipComment();
	      start = index;
	
	      body = scanRegExpBody();
	      flags = scanRegExpFlags();
	      value = testRegExp(body.value, flags.value);
	
	      if (extra.tokenize) {
	          return {
	              type: Token.RegularExpression,
	              value: value,
	              regex: {
	                  pattern: body.value,
	                  flags: flags.value
	              },
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: start,
	              end: index
	          };
	      }
	
	      return {
	          literal: body.literal + flags.literal,
	          value: value,
	          regex: {
	              pattern: body.value,
	              flags: flags.value
	          },
	          start: start,
	          end: index
	      };
	  }
	
	  function collectRegex() {
	      var pos, loc, regex, token;
	
	      skipComment();
	
	      pos = index;
	      loc = {
	          start: {
	              line: lineNumber,
	              column: index - lineStart
	          }
	      };
	
	      regex = scanRegExp();
	
	      loc.end = {
	          line: lineNumber,
	          column: index - lineStart
	      };
	
	      if (!extra.tokenize) {
	          // Pop the previous token, which is likely '/' or '/='
	          if (extra.tokens.length > 0) {
	              token = extra.tokens[extra.tokens.length - 1];
	              if (token.range[0] === pos && token.type === 'Punctuator') {
	                  if (token.value === '/' || token.value === '/=') {
	                      extra.tokens.pop();
	                  }
	              }
	          }
	
	          extra.tokens.push({
	              type: 'RegularExpression',
	              value: regex.literal,
	              regex: regex.regex,
	              range: [pos, index],
	              loc: loc
	          });
	      }
	
	      return regex;
	  }
	
	  function isIdentifierName(token) {
	      return token.type === Token.Identifier ||
	          token.type === Token.Keyword ||
	          token.type === Token.BooleanLiteral ||
	          token.type === Token.NullLiteral;
	  }
	
	  function advanceSlash() {
	      var prevToken,
	          checkToken;
	      // Using the following algorithm:
	      // https://github.com/mozilla/sweet.js/wiki/design
	      prevToken = extra.tokens[extra.tokens.length - 1];
	      if (!prevToken) {
	          // Nothing before that: it cannot be a division.
	          return collectRegex();
	      }
	      if (prevToken.type === 'Punctuator') {
	          if (prevToken.value === ']') {
	              return scanPunctuator();
	          }
	          if (prevToken.value === ')') {
	              checkToken = extra.tokens[extra.openParenToken - 1];
	              if (checkToken &&
	                      checkToken.type === 'Keyword' &&
	                      (checkToken.value === 'if' ||
	                       checkToken.value === 'while' ||
	                       checkToken.value === 'for' ||
	                       checkToken.value === 'with')) {
	                  return collectRegex();
	              }
	              return scanPunctuator();
	          }
	          if (prevToken.value === '}') {
	              // Dividing a function by anything makes little sense,
	              // but we have to check for that.
	              if (extra.tokens[extra.openCurlyToken - 3] &&
	                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
	                  // Anonymous function.
	                  checkToken = extra.tokens[extra.openCurlyToken - 4];
	                  if (!checkToken) {
	                      return scanPunctuator();
	                  }
	              } else if (extra.tokens[extra.openCurlyToken - 4] &&
	                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
	                  // Named function.
	                  checkToken = extra.tokens[extra.openCurlyToken - 5];
	                  if (!checkToken) {
	                      return collectRegex();
	                  }
	              } else {
	                  return scanPunctuator();
	              }
	              return scanPunctuator();
	          }
	          return collectRegex();
	      }
	      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
	          return collectRegex();
	      }
	      return scanPunctuator();
	  }
	
	  function advance() {
	      var ch;
	
	      skipComment();
	
	      if (index >= length) {
	          return {
	              type: Token.EOF,
	              lineNumber: lineNumber,
	              lineStart: lineStart,
	              start: index,
	              end: index
	          };
	      }
	
	      ch = source.charCodeAt(index);
	
	      if (isIdentifierStart(ch)) {
	          return scanIdentifier();
	      }
	
	      // Very common: ( and ) and ;
	      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
	          return scanPunctuator();
	      }
	
	      // String literal starts with single quote (U+0027) or double quote (U+0022).
	      if (ch === 0x27 || ch === 0x22) {
	          return scanStringLiteral();
	      }
	
	
	      // Dot (.) U+002E can also start a floating-point number, hence the need
	      // to check the next character.
	      if (ch === 0x2E) {
	          if (isDecimalDigit(source.charCodeAt(index + 1))) {
	              return scanNumericLiteral();
	          }
	          return scanPunctuator();
	      }
	
	      if (isDecimalDigit(ch)) {
	          return scanNumericLiteral();
	      }
	
	      // Slash (/) U+002F can also start a regex.
	      if (extra.tokenize && ch === 0x2F) {
	          return advanceSlash();
	      }
	
	      return scanPunctuator();
	  }
	
	  function collectToken() {
	      var loc, token, value, entry;
	
	      skipComment();
	      loc = {
	          start: {
	              line: lineNumber,
	              column: index - lineStart
	          }
	      };
	
	      token = advance();
	      loc.end = {
	          line: lineNumber,
	          column: index - lineStart
	      };
	
	      if (token.type !== Token.EOF) {
	          value = source.slice(token.start, token.end);
	          entry = {
	              type: TokenName[token.type],
	              value: value,
	              range: [token.start, token.end],
	              loc: loc
	          };
	          if (token.regex) {
	              entry.regex = {
	                  pattern: token.regex.pattern,
	                  flags: token.regex.flags
	              };
	          }
	          extra.tokens.push(entry);
	      }
	
	      return token;
	  }
	
	  function lex() {
	      var token;
	
	      token = lookahead;
	      index = token.end;
	      lineNumber = token.lineNumber;
	      lineStart = token.lineStart;
	
	      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	
	      index = token.end;
	      lineNumber = token.lineNumber;
	      lineStart = token.lineStart;
	
	      return token;
	  }
	
	  function peek() {
	      var pos, line, start;
	
	      pos = index;
	      line = lineNumber;
	      start = lineStart;
	      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	      index = pos;
	      lineNumber = line;
	      lineStart = start;
	  }
	
	  function Position() {
	      this.line = lineNumber;
	      this.column = index - lineStart;
	  }
	
	  function SourceLocation() {
	      this.start = new Position();
	      this.end = null;
	  }
	
	  function WrappingSourceLocation(startToken) {
	      if (startToken.type === Token.StringLiteral) {
	          this.start = {
	              line: startToken.startLineNumber,
	              column: startToken.start - startToken.startLineStart
	          };
	      } else {
	          this.start = {
	              line: startToken.lineNumber,
	              column: startToken.start - startToken.lineStart
	          };
	      }
	      this.end = null;
	  }
	
	  function Node() {
	      // Skip comment.
	      index = lookahead.start;
	      if (lookahead.type === Token.StringLiteral) {
	          lineNumber = lookahead.startLineNumber;
	          lineStart = lookahead.startLineStart;
	      } else {
	          lineNumber = lookahead.lineNumber;
	          lineStart = lookahead.lineStart;
	      }
	      if (extra.range) {
	          this.range = [index, 0];
	      }
	      if (extra.loc) {
	          this.loc = new SourceLocation();
	      }
	  }
	
	  function WrappingNode(startToken) {
	      if (extra.range) {
	          this.range = [startToken.start, 0];
	      }
	      if (extra.loc) {
	          this.loc = new WrappingSourceLocation(startToken);
	      }
	  }
	
	  WrappingNode.prototype = Node.prototype = {
	
	      finish: function () {
	          if (extra.range) {
	              this.range[1] = index;
	          }
	          if (extra.loc) {
	              this.loc.end = new Position();
	              if (extra.source) {
	                  this.loc.source = extra.source;
	              }
	          }
	      },
	
	      finishArrayExpression: function (elements) {
	          this.type = Syntax.ArrayExpression;
	          this.elements = elements;
	          this.finish();
	          return this;
	      },
	
	      finishAssignmentExpression: function (operator, left, right) {
	          this.type = Syntax.AssignmentExpression;
	          this.operator = operator;
	          this.left = left;
	          this.right = right;
	          this.finish();
	          return this;
	      },
	
	      finishBinaryExpression: function (operator, left, right) {
	          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
	          this.operator = operator;
	          this.left = left;
	          this.right = right;
	          this.finish();
	          return this;
	      },
	
	      finishCallExpression: function (callee, args) {
	          this.type = Syntax.CallExpression;
	          this.callee = callee;
	          this.arguments = args;
	          this.finish();
	          return this;
	      },
	
	      finishConditionalExpression: function (test, consequent, alternate) {
	          this.type = Syntax.ConditionalExpression;
	          this.test = test;
	          this.consequent = consequent;
	          this.alternate = alternate;
	          this.finish();
	          return this;
	      },
	
	      finishExpressionStatement: function (expression) {
	          this.type = Syntax.ExpressionStatement;
	          this.expression = expression;
	          this.finish();
	          return this;
	      },
	
	      finishIdentifier: function (name) {
	          this.type = Syntax.Identifier;
	          this.name = name;
	          this.finish();
	          return this;
	      },
	
	      finishLiteral: function (token) {
	          this.type = Syntax.Literal;
	          this.value = token.value;
	          this.raw = source.slice(token.start, token.end);
	          if (token.regex) {
	              if (this.raw == '//') {
	                this.raw = '/(?:)/';
	              }
	              this.regex = token.regex;
	          }
	          this.finish();
	          return this;
	      },
	
	      finishMemberExpression: function (accessor, object, property) {
	          this.type = Syntax.MemberExpression;
	          this.computed = accessor === '[';
	          this.object = object;
	          this.property = property;
	          this.finish();
	          return this;
	      },
	
	      finishObjectExpression: function (properties) {
	          this.type = Syntax.ObjectExpression;
	          this.properties = properties;
	          this.finish();
	          return this;
	      },
	
	      finishProgram: function (body) {
	          this.type = Syntax.Program;
	          this.body = body;
	          this.finish();
	          return this;
	      },
	
	      finishProperty: function (kind, key, value) {
	          this.type = Syntax.Property;
	          this.key = key;
	          this.value = value;
	          this.kind = kind;
	          this.finish();
	          return this;
	      },
	
	      finishUnaryExpression: function (operator, argument) {
	          this.type = Syntax.UnaryExpression;
	          this.operator = operator;
	          this.argument = argument;
	          this.prefix = true;
	          this.finish();
	          return this;
	      }
	  };
	
	  // Return true if there is a line terminator before the next token.
	
	  function peekLineTerminator() {
	      var pos, line, start, found;
	
	      pos = index;
	      line = lineNumber;
	      start = lineStart;
	      skipComment();
	      found = lineNumber !== line;
	      index = pos;
	      lineNumber = line;
	      lineStart = start;
	
	      return found;
	  }
	
	  // Throw an exception
	
	  function throwError(token, messageFormat) {
	      var error,
	          args = Array.prototype.slice.call(arguments, 2),
	          msg = messageFormat.replace(
	              /%(\d)/g,
	              function (whole, index) {
	                  assert(index < args.length, 'Message reference must be in range');
	                  return args[index];
	              }
	          );
	
	      if (typeof token.lineNumber === 'number') {
	          error = new Error('Line ' + token.lineNumber + ': ' + msg);
	          error.index = token.start;
	          error.lineNumber = token.lineNumber;
	          error.column = token.start - lineStart + 1;
	      } else {
	          error = new Error('Line ' + lineNumber + ': ' + msg);
	          error.index = index;
	          error.lineNumber = lineNumber;
	          error.column = index - lineStart + 1;
	      }
	
	      error.description = msg;
	      throw error;
	  }
	
	  function throwErrorTolerant() {
	      try {
	          throwError.apply(null, arguments);
	      } catch (e) {
	          if (extra.errors) {
	              extra.errors.push(e);
	          } else {
	              throw e;
	          }
	      }
	  }
	
	
	  // Throw an exception because of the token.
	
	  function throwUnexpected(token) {
	      if (token.type === Token.EOF) {
	          throwError(token, Messages.UnexpectedEOS);
	      }
	
	      if (token.type === Token.NumericLiteral) {
	          throwError(token, Messages.UnexpectedNumber);
	      }
	
	      if (token.type === Token.StringLiteral) {
	          throwError(token, Messages.UnexpectedString);
	      }
	
	      if (token.type === Token.Identifier) {
	          throwError(token, Messages.UnexpectedIdentifier);
	      }
	
	      if (token.type === Token.Keyword) {
	          if (isFutureReservedWord(token.value)) {
	              throwError(token, Messages.UnexpectedReserved);
	          } else if (strict && isStrictModeReservedWord(token.value)) {
	              throwErrorTolerant(token, Messages.StrictReservedWord);
	              return;
	          }
	          throwError(token, Messages.UnexpectedToken, token.value);
	      }
	
	      // BooleanLiteral, NullLiteral, or Punctuator.
	      throwError(token, Messages.UnexpectedToken, token.value);
	  }
	
	  // Expect the next token to match the specified punctuator.
	  // If not, an exception will be thrown.
	
	  function expect(value) {
	      var token = lex();
	      if (token.type !== Token.Punctuator || token.value !== value) {
	          throwUnexpected(token);
	      }
	  }
	
	  /**
	   * @name expectTolerant
	   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates
	   * to <code>expect(value)</code>
	   * @param {String} value The value we are expecting the lookahead token to have
	   * @since 2.0
	   */
	  function expectTolerant(value) {
	      if (extra.errors) {
	          var token = lookahead;
	          if (token.type !== Token.Punctuator && token.value !== value) {
	              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
	          } else {
	              lex();
	          }
	      } else {
	          expect(value);
	      }
	  }
	
	  // Return true if the next token matches the specified punctuator.
	
	  function match(value) {
	      return lookahead.type === Token.Punctuator && lookahead.value === value;
	  }
	
	  // Return true if the next token matches the specified keyword
	
	  function matchKeyword(keyword) {
	      return lookahead.type === Token.Keyword && lookahead.value === keyword;
	  }
	
	  function consumeSemicolon() {
	      var line;
	
	      // Catch the very common case first: immediately a semicolon (U+003B).
	      if (source.charCodeAt(index) === 0x3B || match(';')) {
	          lex();
	          return;
	      }
	
	      line = lineNumber;
	      skipComment();
	      if (lineNumber !== line) {
	          return;
	      }
	
	      if (lookahead.type !== Token.EOF && !match('}')) {
	          throwUnexpected(lookahead);
	      }
	  }
	
	  // 11.1.4 Array Initialiser
	
	  function parseArrayInitialiser() {
	      var elements = [], node = new Node();
	
	      expect('[');
	
	      while (!match(']')) {
	          if (match(',')) {
	              lex();
	              elements.push(null);
	          } else {
	              elements.push(parseAssignmentExpression());
	
	              if (!match(']')) {
	                  expect(',');
	              }
	          }
	      }
	
	      lex();
	
	      return node.finishArrayExpression(elements);
	  }
	
	  // 11.1.5 Object Initialiser
	
	  function parseObjectPropertyKey() {
	      var token, node = new Node();
	
	      token = lex();
	
	      // Note: This function is called only from parseObjectProperty(), where
	      // EOF and Punctuator tokens are already filtered out.
	
	      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
	          if (strict && token.octal) {
	              throwErrorTolerant(token, Messages.StrictOctalLiteral);
	          }
	          return node.finishLiteral(token);
	      }
	
	      return node.finishIdentifier(token.value);
	  }
	
	  function parseObjectProperty() {
	      var token, key, id, value, node = new Node();
	
	      token = lookahead;
	
	      if (token.type === Token.Identifier) {
	          id = parseObjectPropertyKey();
	          expect(':');
	          value = parseAssignmentExpression();
	          return node.finishProperty('init', id, value);
	      }
	      if (token.type === Token.EOF || token.type === Token.Punctuator) {
	          throwUnexpected(token);
	      } else {
	          key = parseObjectPropertyKey();
	          expect(':');
	          value = parseAssignmentExpression();
	          return node.finishProperty('init', key, value);
	      }
	  }
	
	  function parseObjectInitialiser() {
	      var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();
	
	      expect('{');
	
	      while (!match('}')) {
	          property = parseObjectProperty();
	
	          if (property.key.type === Syntax.Identifier) {
	              name = property.key.name;
	          } else {
	              name = toString(property.key.value);
	          }
	          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
	
	          key = '$' + name;
	          if (Object.prototype.hasOwnProperty.call(map, key)) {
	              if (map[key] === PropertyKind.Data) {
	                  if (strict && kind === PropertyKind.Data) {
	                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);
	                  } else if (kind !== PropertyKind.Data) {
	                      throwErrorTolerant({}, Messages.AccessorDataProperty);
	                  }
	              } else {
	                  if (kind === PropertyKind.Data) {
	                      throwErrorTolerant({}, Messages.AccessorDataProperty);
	                  } else if (map[key] & kind) {
	                      throwErrorTolerant({}, Messages.AccessorGetSet);
	                  }
	              }
	              map[key] |= kind;
	          } else {
	              map[key] = kind;
	          }
	
	          properties.push(property);
	
	          if (!match('}')) {
	              expectTolerant(',');
	          }
	      }
	
	      expect('}');
	
	      return node.finishObjectExpression(properties);
	  }
	
	  // 11.1.6 The Grouping Operator
	
	  function parseGroupExpression() {
	      var expr;
	
	      expect('(');
	
	      ++state.parenthesisCount;
	
	      expr = parseExpression();
	
	      expect(')');
	
	      return expr;
	  }
	
	
	  // 11.1 Primary Expressions
	
	  var legalKeywords = {"if":1, "this":1};
	
	  function parsePrimaryExpression() {
	      var type, token, expr, node;
	
	      if (match('(')) {
	          return parseGroupExpression();
	      }
	
	      if (match('[')) {
	          return parseArrayInitialiser();
	      }
	
	      if (match('{')) {
	          return parseObjectInitialiser();
	      }
	
	      type = lookahead.type;
	      node = new Node();
	
	      if (type === Token.Identifier || legalKeywords[lookahead.value]) {
	          expr = node.finishIdentifier(lex().value);
	      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	          if (strict && lookahead.octal) {
	              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
	          }
	          expr = node.finishLiteral(lex());
	      } else if (type === Token.Keyword) {
	          throw new Error("Disabled.");
	      } else if (type === Token.BooleanLiteral) {
	          token = lex();
	          token.value = (token.value === 'true');
	          expr = node.finishLiteral(token);
	      } else if (type === Token.NullLiteral) {
	          token = lex();
	          token.value = null;
	          expr = node.finishLiteral(token);
	      } else if (match('/') || match('/=')) {
	          if (typeof extra.tokens !== 'undefined') {
	              expr = node.finishLiteral(collectRegex());
	          } else {
	              expr = node.finishLiteral(scanRegExp());
	          }
	          peek();
	      } else {
	          throwUnexpected(lex());
	      }
	
	      return expr;
	  }
	
	  // 11.2 Left-Hand-Side Expressions
	
	  function parseArguments() {
	      var args = [];
	
	      expect('(');
	
	      if (!match(')')) {
	          while (index < length) {
	              args.push(parseAssignmentExpression());
	              if (match(')')) {
	                  break;
	              }
	              expectTolerant(',');
	          }
	      }
	
	      expect(')');
	
	      return args;
	  }
	
	  function parseNonComputedProperty() {
	      var token, node = new Node();
	
	      token = lex();
	
	      if (!isIdentifierName(token)) {
	          throwUnexpected(token);
	      }
	
	      return node.finishIdentifier(token.value);
	  }
	
	  function parseNonComputedMember() {
	      expect('.');
	
	      return parseNonComputedProperty();
	  }
	
	  function parseComputedMember() {
	      var expr;
	
	      expect('[');
	
	      expr = parseExpression();
	
	      expect(']');
	
	      return expr;
	  }
	
	  function parseLeftHandSideExpressionAllowCall() {
	      var expr, args, property, startToken, previousAllowIn = state.allowIn;
	
	      startToken = lookahead;
	      state.allowIn = true;
	      expr = parsePrimaryExpression();
	
	      for (;;) {
	          if (match('.')) {
	              property = parseNonComputedMember();
	              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	          } else if (match('(')) {
	              args = parseArguments();
	              expr = new WrappingNode(startToken).finishCallExpression(expr, args);
	          } else if (match('[')) {
	              property = parseComputedMember();
	              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	          } else {
	              break;
	          }
	      }
	      state.allowIn = previousAllowIn;
	
	      return expr;
	  }
	
	  // 11.3 Postfix Expressions
	
	  function parsePostfixExpression() {
	      var expr = parseLeftHandSideExpressionAllowCall();
	
	      if (lookahead.type === Token.Punctuator) {
	          if ((match('++') || match('--')) && !peekLineTerminator()) {
	              throw new Error("Disabled.");
	          }
	      }
	
	      return expr;
	  }
	
	  // 11.4 Unary Operators
	
	  function parseUnaryExpression() {
	      var token, expr, startToken;
	
	      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	          expr = parsePostfixExpression();
	      } else if (match('++') || match('--')) {
	          throw new Error("Disabled.");
	      } else if (match('+') || match('-') || match('~') || match('!')) {
	          startToken = lookahead;
	          token = lex();
	          expr = parseUnaryExpression();
	          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	          throw new Error("Disabled.");
	      } else {
	          expr = parsePostfixExpression();
	      }
	
	      return expr;
	  }
	
	  function binaryPrecedence(token, allowIn) {
	      var prec = 0;
	
	      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	          return 0;
	      }
	
	      switch (token.value) {
	      case '||':
	          prec = 1;
	          break;
	
	      case '&&':
	          prec = 2;
	          break;
	
	      case '|':
	          prec = 3;
	          break;
	
	      case '^':
	          prec = 4;
	          break;
	
	      case '&':
	          prec = 5;
	          break;
	
	      case '==':
	      case '!=':
	      case '===':
	      case '!==':
	          prec = 6;
	          break;
	
	      case '<':
	      case '>':
	      case '<=':
	      case '>=':
	      case 'instanceof':
	          prec = 7;
	          break;
	
	      case 'in':
	          prec = allowIn ? 7 : 0;
	          break;
	
	      case '<<':
	      case '>>':
	      case '>>>':
	          prec = 8;
	          break;
	
	      case '+':
	      case '-':
	          prec = 9;
	          break;
	
	      case '*':
	      case '/':
	      case '%':
	          prec = 11;
	          break;
	
	      default:
	          break;
	      }
	
	      return prec;
	  }
	
	  // 11.5 Multiplicative Operators
	  // 11.6 Additive Operators
	  // 11.7 Bitwise Shift Operators
	  // 11.8 Relational Operators
	  // 11.9 Equality Operators
	  // 11.10 Binary Bitwise Operators
	  // 11.11 Binary Logical Operators
	
	  function parseBinaryExpression() {
	      var marker, markers, expr, token, prec, stack, right, operator, left, i;
	
	      marker = lookahead;
	      left = parseUnaryExpression();
	
	      token = lookahead;
	      prec = binaryPrecedence(token, state.allowIn);
	      if (prec === 0) {
	          return left;
	      }
	      token.prec = prec;
	      lex();
	
	      markers = [marker, lookahead];
	      right = parseUnaryExpression();
	
	      stack = [left, token, right];
	
	      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {
	
	          // Reduce: make a binary expression from the three topmost entries.
	          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	              right = stack.pop();
	              operator = stack.pop().value;
	              left = stack.pop();
	              markers.pop();
	              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
	              stack.push(expr);
	          }
	
	          // Shift.
	          token = lex();
	          token.prec = prec;
	          stack.push(token);
	          markers.push(lookahead);
	          expr = parseUnaryExpression();
	          stack.push(expr);
	      }
	
	      // Final reduce to clean-up the stack.
	      i = stack.length - 1;
	      expr = stack[i];
	      markers.pop();
	      while (i > 1) {
	          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	          i -= 2;
	      }
	
	      return expr;
	  }
	
	  // 11.12 Conditional Operator
	
	  function parseConditionalExpression() {
	      var expr, previousAllowIn, consequent, alternate, startToken;
	
	      startToken = lookahead;
	
	      expr = parseBinaryExpression();
	
	      if (match('?')) {
	          lex();
	          previousAllowIn = state.allowIn;
	          state.allowIn = true;
	          consequent = parseAssignmentExpression();
	          state.allowIn = previousAllowIn;
	          expect(':');
	          alternate = parseAssignmentExpression();
	
	          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
	      }
	
	      return expr;
	  }
	
	  // 11.13 Assignment Operators
	
	  function parseAssignmentExpression() {
	      var oldParenthesisCount, token, expr, startToken;
	
	      oldParenthesisCount = state.parenthesisCount;
	
	      startToken = lookahead;
	      token = lookahead;
	
	      expr = parseConditionalExpression();
	
	      return expr;
	  }
	
	  // 11.14 Comma Operator
	
	  function parseExpression() {
	      var expr = parseAssignmentExpression();
	
	      if (match(',')) {
	          throw new Error("Disabled."); // no sequence expressions
	      }
	
	      return expr;
	  }
	
	  // 12.4 Expression Statement
	
	  function parseExpressionStatement(node) {
	      var expr = parseExpression();
	      consumeSemicolon();
	      return node.finishExpressionStatement(expr);
	  }
	
	  // 12 Statements
	
	  function parseStatement() {
	      var type = lookahead.type,
	          expr,
	          node;
	
	      if (type === Token.EOF) {
	          throwUnexpected(lookahead);
	      }
	
	      if (type === Token.Punctuator && lookahead.value === '{') {
	          throw new Error("Disabled."); // block statement
	      }
	
	      node = new Node();
	
	      if (type === Token.Punctuator) {
	          switch (lookahead.value) {
	          case ';':
	              throw new Error("Disabled."); // empty statement
	          case '(':
	              return parseExpressionStatement(node);
	          default:
	              break;
	          }
	      } else if (type === Token.Keyword) {
	          throw new Error("Disabled."); // keyword
	      }
	
	      expr = parseExpression();
	      consumeSemicolon();
	      return node.finishExpressionStatement(expr);
	  }
	
	  // 14 Program
	
	  function parseSourceElement() {
	      if (lookahead.type === Token.Keyword) {
	          switch (lookahead.value) {
	          case 'const':
	          case 'let':
	              throw new Error("Disabled.");
	          case 'function':
	              throw new Error("Disabled.");
	          default:
	              return parseStatement();
	          }
	      }
	
	      if (lookahead.type !== Token.EOF) {
	          return parseStatement();
	      }
	  }
	
	  function parseSourceElements() {
	      var sourceElement, sourceElements = [], token, directive, firstRestricted;
	
	      while (index < length) {
	          token = lookahead;
	          if (token.type !== Token.StringLiteral) {
	              break;
	          }
	
	          sourceElement = parseSourceElement();
	          sourceElements.push(sourceElement);
	          if (sourceElement.expression.type !== Syntax.Literal) {
	              // this is not directive
	              break;
	          }
	          directive = source.slice(token.start + 1, token.end - 1);
	          if (directive === 'use strict') {
	              strict = true;
	              if (firstRestricted) {
	                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
	              }
	          } else {
	              if (!firstRestricted && token.octal) {
	                  firstRestricted = token;
	              }
	          }
	      }
	
	      while (index < length) {
	          sourceElement = parseSourceElement();
	          if (typeof sourceElement === 'undefined') {
	              break;
	          }
	          sourceElements.push(sourceElement);
	      }
	      return sourceElements;
	  }
	
	  function parseProgram() {
	      var body, node;
	
	      skipComment();
	      peek();
	      node = new Node();
	      strict = true; // assume strict
	
	      body = parseSourceElements();
	      return node.finishProgram(body);
	  }
	
	  function filterTokenLocation() {
	      var i, entry, token, tokens = [];
	
	      for (i = 0; i < extra.tokens.length; ++i) {
	          entry = extra.tokens[i];
	          token = {
	              type: entry.type,
	              value: entry.value
	          };
	          if (entry.regex) {
	              token.regex = {
	                  pattern: entry.regex.pattern,
	                  flags: entry.regex.flags
	              };
	          }
	          if (extra.range) {
	              token.range = entry.range;
	          }
	          if (extra.loc) {
	              token.loc = entry.loc;
	          }
	          tokens.push(token);
	      }
	
	      extra.tokens = tokens;
	  }
	
	  function tokenize(code, options) {
	      var toString,
	          tokens;
	
	      toString = String;
	      if (typeof code !== 'string' && !(code instanceof String)) {
	          code = toString(code);
	      }
	
	      source = code;
	      index = 0;
	      lineNumber = (source.length > 0) ? 1 : 0;
	      lineStart = 0;
	      length = source.length;
	      lookahead = null;
	      state = {
	          allowIn: true,
	          labelSet: {},
	          inFunctionBody: false,
	          inIteration: false,
	          inSwitch: false,
	          lastCommentStart: -1
	      };
	
	      extra = {};
	
	      // Options matching.
	      options = options || {};
	
	      // Of course we collect tokens here.
	      options.tokens = true;
	      extra.tokens = [];
	      extra.tokenize = true;
	      // The following two fields are necessary to compute the Regex tokens.
	      extra.openParenToken = -1;
	      extra.openCurlyToken = -1;
	
	      extra.range = (typeof options.range === 'boolean') && options.range;
	      extra.loc = (typeof options.loc === 'boolean') && options.loc;
	
	      if (typeof options.tolerant === 'boolean' && options.tolerant) {
	          extra.errors = [];
	      }
	
	      try {
	          peek();
	          if (lookahead.type === Token.EOF) {
	              return extra.tokens;
	          }
	
	          lex();
	          while (lookahead.type !== Token.EOF) {
	              try {
	                  lex();
	              } catch (lexError) {
	                  if (extra.errors) {
	                      extra.errors.push(lexError);
	                      // We have to break on the first error
	                      // to avoid infinite loops.
	                      break;
	                  } else {
	                      throw lexError;
	                  }
	              }
	          }
	
	          filterTokenLocation();
	          tokens = extra.tokens;
	          if (typeof extra.errors !== 'undefined') {
	              tokens.errors = extra.errors;
	          }
	      } catch (e) {
	          throw e;
	      } finally {
	          extra = {};
	      }
	      return tokens;
	  }
	
	  function parse(code, options) {
	      var program, toString;
	
	      toString = String;
	      if (typeof code !== 'string' && !(code instanceof String)) {
	          code = toString(code);
	      }
	
	      source = code;
	      index = 0;
	      lineNumber = (source.length > 0) ? 1 : 0;
	      lineStart = 0;
	      length = source.length;
	      lookahead = null;
	      state = {
	          allowIn: true,
	          labelSet: {},
	          parenthesisCount: 0,
	          inFunctionBody: false,
	          inIteration: false,
	          inSwitch: false,
	          lastCommentStart: -1
	      };
	
	      extra = {};
	      if (typeof options !== 'undefined') {
	          extra.range = (typeof options.range === 'boolean') && options.range;
	          extra.loc = (typeof options.loc === 'boolean') && options.loc;
	
	          if (extra.loc && options.source !== null && options.source !== undefined) {
	              extra.source = toString(options.source);
	          }
	
	          if (typeof options.tokens === 'boolean' && options.tokens) {
	              extra.tokens = [];
	          }
	          if (typeof options.tolerant === 'boolean' && options.tolerant) {
	              extra.errors = [];
	          }
	      }
	
	      try {
	          program = parseProgram();
	          if (typeof extra.tokens !== 'undefined') {
	              filterTokenLocation();
	              program.tokens = extra.tokens;
	          }
	          if (typeof extra.errors !== 'undefined') {
	              program.errors = extra.errors;
	          }
	      } catch (e) {
	          throw e;
	      } finally {
	          extra = {};
	      }
	
	      return program;
	  }
	
	  return {
	    tokenize: tokenize,
	    parse: parse
	  };
	
	})();
})
/** END DEFINE BLOCK for vega-expression@1.2.0/src/parser.js **/


/** START DEFINE BLOCK for vega-expression@1.2.0/src/codegen.js **/
jupyter.define('vega-expression@1.2.0/src/codegen.js', function (module, exports, __jupyter_require__) {
	function toMap(list) {
	  var map = {}, i, n;
	  for (i=0, n=list.length; i<n; ++i) map[list[i]] = 1;
	  return map;
	}
	
	function keys(object) {
	  var list = [], k;
	  for (k in object) list.push(k);
	  return list;
	}
	
	module.exports = function(opt) {
	  opt = opt || {};
	  var constants = opt.constants || __jupyter_require__('vega-expression@~1.2.0/src/constants.js'),
	      functions = (opt.functions || __jupyter_require__('vega-expression@~1.2.0/src/functions.js'))(codegen),
	      functionDefs = opt.functionDefs ? opt.functionDefs(codegen) : {},
	      idWhiteList = opt.idWhiteList ? toMap(opt.idWhiteList) : null,
	      idBlackList = opt.idBlackList ? toMap(opt.idBlackList) : null,
	      memberDepth = 0,
	      FIELD_VAR = opt.fieldVar || 'datum',
	      GLOBAL_VAR = opt.globalVar || 'signals',
	      globals = {},
	      fields = {},
	      dataSources = {};
	
	  function codegen_wrap(ast) {
	    var retval = {
	      code: codegen(ast),
	      globals: keys(globals),
	      fields: keys(fields),
	      dataSources: keys(dataSources),
	      defs: functionDefs
	    };
	    globals = {};
	    fields = {};
	    dataSources = {};
	    return retval;
	  }
	
	  /* istanbul ignore next */
	  var lookupGlobal = typeof GLOBAL_VAR === 'function' ? GLOBAL_VAR :
	    function (id) {
	      return GLOBAL_VAR + '["' + id + '"]';
	    };
	
	  function codegen(ast) {
	    if (typeof ast === 'string') return ast;
	    var generator = CODEGEN_TYPES[ast.type];
	    if (generator == null) {
	      throw new Error('Unsupported type: ' + ast.type);
	    }
	    return generator(ast);
	  }
	
	  var CODEGEN_TYPES = {
	    'Literal': function(n) {
	        return n.raw;
	      },
	    'Identifier': function(n) {
	        var id = n.name;
	        if (memberDepth > 0) {
	          return id;
	        }
	        if (constants.hasOwnProperty(id)) {
	          return constants[id];
	        }
	        if (idWhiteList) {
	          if (idWhiteList.hasOwnProperty(id)) {
	            return id;
	          } else {
	            globals[id] = 1;
	            return lookupGlobal(id);
	          }
	        }
	        if (idBlackList && idBlackList.hasOwnProperty(id)) {
	          throw new Error('Illegal identifier: ' + id);
	        }
	        return id;
	      },
	    'Program': function(n) {
	        return n.body.map(codegen).join('\n');
	      },
	    'MemberExpression': function(n) {
	        var d = !n.computed;
	        var o = codegen(n.object);
	        if (d) memberDepth += 1;
	        var p = codegen(n.property);
	        if (o === FIELD_VAR) { fields[p] = 1; } // HACKish...
	        if (d) memberDepth -= 1;
	        return o + (d ? '.'+p : '['+p+']');
	      },
	    'CallExpression': function(n) {
	        if (n.callee.type !== 'Identifier') {
	          throw new Error('Illegal callee type: ' + n.callee.type);
	        }
	        var callee = n.callee.name;
	        var args = n.arguments;
	        var fn = functions.hasOwnProperty(callee) && functions[callee];
	        if (!fn) throw new Error('Unrecognized function: ' + callee);
	        return fn instanceof Function ?
	          fn(args, globals, fields, dataSources) :
	          fn + '(' + args.map(codegen).join(',') + ')';
	      },
	    'ArrayExpression': function(n) {
	        return '[' + n.elements.map(codegen).join(',') + ']';
	      },
	    'BinaryExpression': function(n) {
	        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';
	      },
	    'UnaryExpression': function(n) {
	        return '(' + n.operator + codegen(n.argument) + ')';
	      },
	    'ConditionalExpression': function(n) {
	        return '(' + codegen(n.test) +
	          '?' + codegen(n.consequent) +
	          ':' + codegen(n.alternate) +
	          ')';
	      },
	    'LogicalExpression': function(n) {
	        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';
	      },
	    'ObjectExpression': function(n) {
	        return '{' + n.properties.map(codegen).join(',') + '}';
	      },
	    'Property': function(n) {
	        memberDepth += 1;
	        var k = codegen(n.key);
	        memberDepth -= 1;
	        return k + ':' + codegen(n.value);
	      },
	    'ExpressionStatement': function(n) {
	        return codegen(n.expression);
	      }
	  };
	
	  codegen_wrap.functions = functions;
	  codegen_wrap.functionDefs = functionDefs;
	  codegen_wrap.constants = constants;
	  return codegen_wrap;
	};
	
})
/** END DEFINE BLOCK for vega-expression@1.2.0/src/codegen.js **/


/** START DEFINE BLOCK for vega-expression@1.2.0/src/constants.js **/
jupyter.define('vega-expression@1.2.0/src/constants.js', function (module, exports, __jupyter_require__) {
	module.exports = {
	  'NaN':     'NaN',
	  'E':       'Math.E',
	  'LN2':     'Math.LN2',
	  'LN10':    'Math.LN10',
	  'LOG2E':   'Math.LOG2E',
	  'LOG10E':  'Math.LOG10E',
	  'PI':      'Math.PI',
	  'SQRT1_2': 'Math.SQRT1_2',
	  'SQRT2':   'Math.SQRT2'
	};
})
/** END DEFINE BLOCK for vega-expression@1.2.0/src/constants.js **/


/** START DEFINE BLOCK for vega-expression@1.2.0/src/functions.js **/
jupyter.define('vega-expression@1.2.0/src/functions.js', function (module, exports, __jupyter_require__) {
	module.exports = function(codegen) {
	
	  function fncall(name, args, cast, type) {
	    var obj = codegen(args[0]);
	    if (cast) {
	      obj = cast + '(' + obj + ')';
	      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
	    }
	    return obj + '.' + name + (type < 0 ? '' : type === 0 ?
	      '()' :
	      '(' + args.slice(1).map(codegen).join(',') + ')');
	  }
	
	  function fn(name, cast, type) {
	    return function(args) {
	      return fncall(name, args, cast, type);
	    };
	  }
	
	  var DATE = 'new Date',
	      STRING = 'String',
	      REGEXP = 'RegExp';
	
	  return {
	    // MATH functions
	    'isNaN':    'isNaN',
	    'isFinite': 'isFinite',
	    'abs':      'Math.abs',
	    'acos':     'Math.acos',
	    'asin':     'Math.asin',
	    'atan':     'Math.atan',
	    'atan2':    'Math.atan2',
	    'ceil':     'Math.ceil',
	    'cos':      'Math.cos',
	    'exp':      'Math.exp',
	    'floor':    'Math.floor',
	    'log':      'Math.log',
	    'max':      'Math.max',
	    'min':      'Math.min',
	    'pow':      'Math.pow',
	    'random':   'Math.random',
	    'round':    'Math.round',
	    'sin':      'Math.sin',
	    'sqrt':     'Math.sqrt',
	    'tan':      'Math.tan',
	
	    'clamp': function(args) {
	      if (args.length < 3)
	        throw new Error('Missing arguments to clamp function.');
	      if (args.length > 3)
	        throw new Error('Too many arguments to clamp function.');
	      var a = args.map(codegen);
	      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';
	    },
	
	    // DATE functions
	    'now':             'Date.now',
	    'utc':             'Date.UTC',
	    'datetime':        DATE,
	    'date':            fn('getDate', DATE, 0),
	    'day':             fn('getDay', DATE, 0),
	    'year':            fn('getFullYear', DATE, 0),
	    'month':           fn('getMonth', DATE, 0),
	    'hours':           fn('getHours', DATE, 0),
	    'minutes':         fn('getMinutes', DATE, 0),
	    'seconds':         fn('getSeconds', DATE, 0),
	    'milliseconds':    fn('getMilliseconds', DATE, 0),
	    'time':            fn('getTime', DATE, 0),
	    'timezoneoffset':  fn('getTimezoneOffset', DATE, 0),
	    'utcdate':         fn('getUTCDate', DATE, 0),
	    'utcday':          fn('getUTCDay', DATE, 0),
	    'utcyear':         fn('getUTCFullYear', DATE, 0),
	    'utcmonth':        fn('getUTCMonth', DATE, 0),
	    'utchours':        fn('getUTCHours', DATE, 0),
	    'utcminutes':      fn('getUTCMinutes', DATE, 0),
	    'utcseconds':      fn('getUTCSeconds', DATE, 0),
	    'utcmilliseconds': fn('getUTCMilliseconds', DATE, 0),
	
	    // shared sequence functions
	    'length':      fn('length', null, -1),
	    'indexof':     fn('indexOf', null),
	    'lastindexof': fn('lastIndexOf', null),
	
	    // STRING functions
	    'parseFloat':  'parseFloat',
	    'parseInt':    'parseInt',
	    'upper':       fn('toUpperCase', STRING, 0),
	    'lower':       fn('toLowerCase', STRING, 0),
	    'slice':       fn('slice', STRING),
	    'substring':   fn('substring', STRING),
	    'replace':     fn('replace', STRING),
	
	    // REGEXP functions
	    'regexp':  REGEXP,
	    'test':    fn('test', REGEXP),
	
	    // Control Flow functions
	    'if': function(args) {
	        if (args.length < 3)
	          throw new Error('Missing arguments to if function.');
	        if (args.length > 3)
	          throw new Error('Too many arguments to if function.');
	        var a = args.map(codegen);
	        return a[0]+'?'+a[1]+':'+a[2];
	      }
	  };
	};
	
})
/** END DEFINE BLOCK for vega-expression@1.2.0/src/functions.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/legends.js **/
jupyter.define('vega@2.6.3/src/parse/legends.js', function (module, exports, __jupyter_require__) {
	var lgnd = __jupyter_require__('vega@~2.6.3/src/scene/legend.js');
	
	function parseLegends(model, spec, legends, group) {
	  (spec || []).forEach(function(def, index) {
	    legends[index] = legends[index] || lgnd(model);
	    parseLegend(def, index, legends[index], group);
	  });
	}
	
	function parseLegend(def, index, legend, group) {
	  // legend scales
	  legend.size   (def.size    ? group.scale(def.size)    : null);
	  legend.shape  (def.shape   ? group.scale(def.shape)   : null);
	  legend.fill   (def.fill    ? group.scale(def.fill)    : null);
	  legend.stroke (def.stroke  ? group.scale(def.stroke)  : null);
	  legend.opacity(def.opacity ? group.scale(def.opacity) : null);
	
	  // legend orientation
	  if (def.orient) legend.orient(def.orient);
	
	  // legend offset
	  if (def.offset != null) legend.offset(def.offset);
	
	  // legend title
	  legend.title(def.title || null);
	
	  // legend values
	  legend.values(def.values || null);
	
	  // legend label formatting
	  legend.format(def.format !== undefined ? def.format : null);
	  legend.formatType(def.formatType || null);
	
	  // style properties
	  var p = def.properties;
	  legend.titleProperties(p && p.title || {});
	  legend.labelProperties(p && p.labels || {});
	  legend.legendProperties(p && p.legend || {});
	  legend.symbolProperties(p && p.symbols || {});
	  legend.gradientProperties(p && p.gradient || {});
	}
	
	module.exports = parseLegends;
	
	parseLegends.schema = {
	  "defs": {
	    "legend": {
	      "type": "object",
	      "properties": {
	        "size": {"type": "string"},
	        "shape": {"type": "string"},
	        "fill": {"type": "string"},
	        "stroke": {"type": "string"},
	        "opacity": {"type": "string"},
	        "orient": {"enum": ["left", "right"], "default": "right"},
	        "offset": {"type": "number"},
	        "title": {"type": "string"},
	        "values": {"type": "array"},
	        "format": {"type": "string"},
	        "formatType": {"enum": ["time", "utc", "string", "number"]},
	        "properties": {
	          "type": "object",
	          "properties": {
	            "title": {"$ref": "#/defs/propset"},
	            "labels": {"$ref": "#/defs/propset"},
	            "legend": {"$ref": "#/defs/propset"},
	            "symbols": {"$ref": "#/defs/propset"},
	            "gradient": {"$ref": "#/defs/propset"}
	          },
	          "additionalProperties": false
	        }
	      },
	      "additionalProperties": false,
	      "anyOf": [
	        {"required": ["size"]},
	        {"required": ["shape"]},
	        {"required": ["fill"]},
	        {"required": ["stroke"]},
	        {"required": ["opacity"]}
	      ]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/legends.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/legend.js **/
jupyter.define('vega@2.6.3/src/scene/legend.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    Gradient = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').Gradient,
	    parseProperties = __jupyter_require__('vega@~2.6.3/src/parse/properties.js'),
	    parseMark = __jupyter_require__('vega@~2.6.3/src/parse/mark.js'),
	    util = __jupyter_require__('vega@~2.6.3/src/util/index.js');
	
	function lgnd(model) {
	  var size  = null,
	      shape = null,
	      fill  = null,
	      stroke  = null,
	      opacity = null,
	      spacing = null,
	      values  = null,
	      formatString = null,
	      formatType   = null,
	      title  = null,
	      config = model.config().legend,
	      orient = config.orient,
	      offset = config.offset,
	      padding = config.padding,
	      tickArguments = [5],
	      legendStyle = {},
	      symbolStyle = {},
	      gradientStyle = {},
	      titleStyle = {},
	      labelStyle = {},
	      m = { // Legend marks as references for updates
	        titles:  {},
	        symbols: {},
	        labels:  {},
	        gradient: {}
	      };
	
	  var legend = {},
	      legendDef = {};
	
	  function reset() { legendDef.type = null; }
	  function ingest(d, i) { return {data: d, index: i}; }
	
	  legend.def = function() {
	    var scale = size || shape || fill || stroke || opacity;
	
	    if (!legendDef.type) {
	      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type) ?
	        quantDef(scale) : ordinalDef(scale);
	    }
	    legendDef.orient = orient;
	    legendDef.offset = offset;
	    legendDef.padding = padding;
	    legendDef.margin = config.margin;
	    return legendDef;
	  };
	
	  function discrete(type) {
	    return type==='ordinal' || type==='quantize' ||
	           type==='quantile' || type==='threshold';
	  }
	
	  function ordinalDef(scale) {
	    var def = o_legend_def(size, shape, fill, stroke, opacity);
	
	    // generate data
	    var data = (values == null ?
	      (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) :
	      values).map(ingest);
	
	    var fmt = util.getTickFormat(scale, data.length, formatType, formatString);
	
	    // determine spacing between legend entries
	    var fs, range, offset, pad=5, domain = d3.range(data.length);
	    if (size) {
	      range = data.map(function(x) { return Math.sqrt(size(x.data)); });
	      offset = d3.max(range);
	      range = range.reduce(function(a,b,i,z) {
	          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;
	          return (a[i] += b/2, a); }, [0]).map(Math.round);
	    } else {
	      offset = Math.round(Math.sqrt(config.symbolSize));
	      range = spacing ||
	        (fs = labelStyle.fontSize) && (fs.value + pad) ||
	        (config.labelFontSize + pad);
	      range = domain.map(function(d,i) {
	        return Math.round(offset/2 + i*range);
	      });
	    }
	
	    // account for padding and title size
	    var sz = padding, ts;
	    if (title) {
	      ts = titleStyle.fontSize;
	      sz += 5 + ((ts && ts.value) || config.titleFontSize);
	    }
	    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;
	
	    // build scale for label layout
	    def.scales = def.scales || [{}];
	    dl.extend(def.scales[0], {
	      name: 'legend',
	      type: 'ordinal',
	      points: true,
	      domain: domain,
	      range: range
	    });
	
	    // update legend def
	    var tdata = (title ? [title] : []).map(ingest);
	    data.forEach(function(d) {
	      d.label = fmt(d.data);
	      d.offset = offset;
	    });
	    def.marks[0].from = function() { return tdata; };
	    def.marks[1].from = function() { return data; };
	    def.marks[2].from = def.marks[1].from;
	
	    return def;
	  }
	
	  function o_legend_def(size, shape, fill, stroke, opacity) {
	    // setup legend marks
	    var titles  = dl.extend(m.titles, legendTitle(config)),
	        symbols = dl.extend(m.symbols, legendSymbols(config)),
	        labels  = dl.extend(m.labels, vLegendLabels(config));
	
	    // extend legend marks
	    legendSymbolExtend(symbols, size, shape, fill, stroke, opacity);
	
	    // add / override custom style properties
	    dl.extend(titles.properties.update,  titleStyle);
	    dl.extend(symbols.properties.update, symbolStyle);
	    dl.extend(labels.properties.update,  labelStyle);
	
	    // padding from legend border
	    titles.properties.enter.x.value += padding;
	    titles.properties.enter.y.value += padding;
	    labels.properties.enter.x.offset += padding + 1;
	    symbols.properties.enter.x.offset = padding + 1;
	    labels.properties.update.x.offset += padding + 1;
	    symbols.properties.update.x.offset = padding + 1;
	
	    dl.extend(legendDef, {
	      type: 'group',
	      interactive: false,
	      properties: {
	        enter: parseProperties(model, 'group', legendStyle),
	        legendPosition: {
	          encode: legendPosition.bind(null, config),
	          signals: [], scales:[], data: [], fields: []
	        }
	      }
	    });
	
	    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });
	    return legendDef;
	  }
	
	  function quantDef(scale) {
	    var def = q_legend_def(scale),
	        dom = scale.domain(),
	        data  = (values == null ? dom : values).map(ingest),
	        width = (gradientStyle.width && gradientStyle.width.value) || config.gradientWidth,
	        fmt = util.getTickFormat(scale, data.length, formatType, formatString);
	
	    // build scale for label layout
	    def.scales = def.scales || [{}];
	    var layoutSpec = dl.extend(def.scales[0], {
	      name: 'legend',
	      type: scale.type,
	      round: true,
	      zero: false,
	      domain: [dom[0], dom[dom.length-1]],
	      range: [padding, width+padding]
	    });
	    if (scale.type==='pow') layoutSpec.exponent = scale.exponent();
	
	    // update legend def
	    var tdata = (title ? [title] : []).map(ingest);
	    data.forEach(function(d,i) {
	      d.label = fmt(d.data);
	      d.align = i==(data.length-1) ? 'right' : i===0 ? 'left' : 'center';
	    });
	
	    def.marks[0].from = function() { return tdata; };
	    def.marks[1].from = function() { return [1]; };
	    def.marks[2].from = function() { return data; };
	    return def;
	  }
	
	  function q_legend_def(scale) {
	    // setup legend marks
	    var titles = dl.extend(m.titles, legendTitle(config)),
	        gradient = dl.extend(m.gradient, legendGradient(config)),
	        labels = dl.extend(m.labels, hLegendLabels(config)),
	        grad = new Gradient();
	
	    // setup color gradient
	    var dom = scale.domain(),
	        min = dom[0],
	        max = dom[dom.length-1],
	        f = scale.copy().domain([min, max]).range([0,1]);
	
	    var stops = (scale.type !== 'linear' && scale.ticks) ?
	      scale.ticks.call(scale, 15) : dom;
	    if (min !== stops[0]) stops.unshift(min);
	    if (max !== stops[stops.length-1]) stops.push(max);
	
	    for (var i=0, n=stops.length; i<n; ++i) {
	      grad.stop(f(stops[i]), scale(stops[i]));
	    }
	    gradient.properties.enter.fill = {value: grad};
	
	    // add / override custom style properties
	    dl.extend(titles.properties.update, titleStyle);
	    dl.extend(gradient.properties.update, gradientStyle);
	    dl.extend(labels.properties.update, labelStyle);
	
	    // account for gradient size
	    var gp = gradient.properties, gh = gradientStyle.height,
	        hh = (gh && gh.value) || gp.enter.height.value;
	    labels.properties.enter.y.value = hh;
	    labels.properties.update.y.value = hh;
	
	    // account for title size as needed
	    if (title) {
	      var tp = titles.properties, fs = titleStyle.fontSize,
	          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);
	      gradient.properties.enter.y.value += sz;
	      labels.properties.enter.y.value += sz;
	      gradient.properties.update.y.value += sz;
	      labels.properties.update.y.value += sz;
	    }
	
	    // padding from legend border
	    titles.properties.enter.x.value += padding;
	    titles.properties.enter.y.value += padding;
	    gradient.properties.enter.x.value += padding;
	    gradient.properties.enter.y.value += padding;
	    labels.properties.enter.y.value += padding;
	    gradient.properties.update.x.value += padding;
	    gradient.properties.update.y.value += padding;
	    labels.properties.update.y.value += padding;
	
	    dl.extend(legendDef, {
	      type: 'group',
	      interactive: false,
	      properties: {
	        enter: parseProperties(model, 'group', legendStyle),
	        legendPosition: {
	          encode: legendPosition.bind(null, config),
	          signals: [], scales: [], data: [], fields: []
	        }
	      }
	    });
	
	    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });
	    return legendDef;
	  }
	
	  legend.size = function(x) {
	    if (!arguments.length) return size;
	    if (size !== x) { size = x; reset(); }
	    return legend;
	  };
	
	  legend.shape = function(x) {
	    if (!arguments.length) return shape;
	    if (shape !== x) { shape = x; reset(); }
	    return legend;
	  };
	
	  legend.fill = function(x) {
	    if (!arguments.length) return fill;
	    if (fill !== x) { fill = x; reset(); }
	    return legend;
	  };
	
	  legend.stroke = function(x) {
	    if (!arguments.length) return stroke;
	    if (stroke !== x) { stroke = x; reset(); }
	    return legend;
	  };
	
	  legend.opacity = function(x) {
	    if (!arguments.length) return opacity;
	    if (opacity !== x) { opacity = x; reset(); }
	    return legend;
	  };
	
	  legend.title = function(x) {
	    if (!arguments.length) return title;
	    if (title !== x) { title = x; reset(); }
	    return legend;
	  };
	
	  legend.format = function(x) {
	    if (!arguments.length) return formatString;
	    if (formatString !== x) {
	      formatString = x;
	      reset();
	    }
	    return legend;
	  };
	
	  legend.formatType = function(x) {
	    if (!arguments.length) return formatType;
	    if (formatType !== x) {
	      formatType = x;
	      reset();
	    }
	    return legend;
	  };
	
	  legend.spacing = function(x) {
	    if (!arguments.length) return spacing;
	    if (spacing !== +x) { spacing = +x; reset(); }
	    return legend;
	  };
	
	  legend.orient = function(x) {
	    if (!arguments.length) return orient;
	    orient = x in LEGEND_ORIENT ? x + '' : config.orient;
	    return legend;
	  };
	
	  legend.offset = function(x) {
	    if (!arguments.length) return offset;
	    offset = +x;
	    return legend;
	  };
	
	  legend.values = function(x) {
	    if (!arguments.length) return values;
	    values = x;
	    return legend;
	  };
	
	  legend.legendProperties = function(x) {
	    if (!arguments.length) return legendStyle;
	    legendStyle = x;
	    return legend;
	  };
	
	  legend.symbolProperties = function(x) {
	    if (!arguments.length) return symbolStyle;
	    symbolStyle = x;
	    return legend;
	  };
	
	  legend.gradientProperties = function(x) {
	    if (!arguments.length) return gradientStyle;
	    gradientStyle = x;
	    return legend;
	  };
	
	  legend.labelProperties = function(x) {
	    if (!arguments.length) return labelStyle;
	    labelStyle = x;
	    return legend;
	  };
	
	  legend.titleProperties = function(x) {
	    if (!arguments.length) return titleStyle;
	    titleStyle = x;
	    return legend;
	  };
	
	  legend.reset = function() {
	    reset();
	    return legend;
	  };
	
	  return legend;
	}
	
	var LEGEND_ORIENT = {
	  'left': 'x1',
	  'right': 'x2',
	  'top-left': 'x1',
	  'top-right': 'x2',
	  'bottom-left': 'x1',
	  'bottom-right': 'x2'
	};
	
	function legendPosition(config, item, group, trans, db, signals, predicates) {
	  var o = trans ? {} : item, i,
	      def = item.mark.def,
	      offset = def.offset,
	      orient = def.orient,
	      pad = def.padding * 2,
	      ao  = orient === 'left' ? 0 : group.width,
	      lw  = ~~item.bounds.width() + (item.width ? 0 : pad),
	      lh  = ~~item.bounds.height() + (item.height ? 0 : pad),
	      pos = group._legendPositions ||
	        (group._legendPositions = {right: 0.5, left: 0.5});
	
	  o.x = 0.5;
	  o.y = 0.5;
	  o.width = lw;
	  o.height = lh;
	
	  if (orient === 'left' || orient === 'right') {
	    o.y = pos[orient];
	    pos[orient] += lh + def.margin;
	
	    // Calculate axis offset.
	    var axes  = group.axes,
	        items = group.axisItems,
	        bound = LEGEND_ORIENT[orient];
	    for (i=0; i<axes.length; ++i) {
	      if (axes[i].orient() === orient) {
	        ao = Math.max(ao, Math.abs(items[i].bounds[bound]));
	      }
	    }
	  }
	
	  switch (orient) {
	    case 'left':
	      o.x -= ao + offset + lw;
	      break;
	    case 'right':
	      o.x += ao + offset;
	      break;
	    case 'top-left':
	      o.x += offset;
	      o.y += offset;
	      break;
	    case 'top-right':
	      o.x += group.width - lw - offset;
	      o.y += offset;
	      break;
	    case 'bottom-left':
	      o.x += offset;
	      o.y += group.height - lh - offset;
	      break;
	    case 'bottom-right':
	      o.x += group.width - lw - offset;
	      o.y += group.height - lh - offset;
	      break;
	  }
	
	  var baseline = config.baseline,
	      totalHeight = 0;
	  for (i=0; i<group.legendItems.length; i++) {
	    var currItem = group.legendItems[i];
	    totalHeight += currItem.bounds.height() + (item.height ? 0 : pad);
	  }
	
	  if (baseline === 'middle') {
	    o.y += offset + (group.height / 2) - (totalHeight / 2);
	  } else if (baseline === 'bottom') {
	    o.y += offset + group.height - totalHeight;
	  }
	
	  if (trans) trans.interpolate(item, o);
	  var enc = item.mark.def.properties.enter.encode;
	  enc.call(enc, item, group, trans, db, signals, predicates);
	  return true;
	}
	
	function legendSymbolExtend(mark, size, shape, fill, stroke, opacity) {
	  var e = mark.properties.enter,
	      u = mark.properties.update;
	  if (size)    e.size    = u.size    = {scale: size.scaleName,   field: 'data'};
	  if (shape)   e.shape   = u.shape   = {scale: shape.scaleName,  field: 'data'};
	  if (fill)    e.fill    = u.fill    = {scale: fill.scaleName,   field: 'data'};
	  if (stroke)  e.stroke  = u.stroke  = {scale: stroke.scaleName, field: 'data'};
	  if (opacity) u.opacity = {scale: opacity.scaleName, field: 'data'};
	}
	
	function legendTitle(config) {
	  return {
	    type: 'text',
	    interactive: false,
	    key: 'data',
	    properties: {
	      enter: {
	        x: {value: 0},
	        y: {value: 0},
	        fill: {value: config.titleColor},
	        font: {value: config.titleFont},
	        fontSize: {value: config.titleFontSize},
	        fontWeight: {value: config.titleFontWeight},
	        baseline: {value: 'top'},
	        text: {field: 'data'},
	        opacity: {value: 1e-6}
	      },
	      exit: { opacity: {value: 1e-6} },
	      update: { opacity: {value: 1} }
	    }
	  };
	}
	
	function legendSymbols(config) {
	  return {
	    type: 'symbol',
	    interactive: false,
	    key: 'data',
	    properties: {
	      enter: {
	        x: {field: 'offset', mult: 0.5},
	        y: {scale: 'legend', field: 'index'},
	        shape: {value: config.symbolShape},
	        size: {value: config.symbolSize},
	        stroke: {value: config.symbolColor},
	        strokeWidth: {value: config.symbolStrokeWidth},
	        opacity: {value: 1e-6}
	      },
	      exit: { opacity: {value: 1e-6} },
	      update: {
	        x: {field: 'offset', mult: 0.5},
	        y: {scale: 'legend', field: 'index'},
	        opacity: {value: 1}
	      }
	    }
	  };
	}
	
	function vLegendLabels(config) {
	  return {
	    type: 'text',
	    interactive: false,
	    key: 'data',
	    properties: {
	      enter: {
	        x: {field: 'offset', offset: 5},
	        y: {scale: 'legend', field: 'index'},
	        fill: {value: config.labelColor},
	        font: {value: config.labelFont},
	        fontSize: {value: config.labelFontSize},
	        align: {value: config.labelAlign},
	        baseline: {value: config.labelBaseline},
	        text: {field: 'label'},
	        opacity: {value: 1e-6}
	      },
	      exit: { opacity: {value: 1e-6} },
	      update: {
	        opacity: {value: 1},
	        x: {field: 'offset', offset: 5},
	        y: {scale: 'legend', field: 'index'},
	      }
	    }
	  };
	}
	
	function legendGradient(config) {
	  return {
	    type: 'rect',
	    interactive: false,
	    properties: {
	      enter: {
	        x: {value: 0},
	        y: {value: 0},
	        width: {value: config.gradientWidth},
	        height: {value: config.gradientHeight},
	        stroke: {value: config.gradientStrokeColor},
	        strokeWidth: {value: config.gradientStrokeWidth},
	        opacity: {value: 1e-6}
	      },
	      exit: { opacity: {value: 1e-6} },
	      update: {
	        x: {value: 0},
	        y: {value: 0},
	        opacity: {value: 1}
	      }
	    }
	  };
	}
	
	function hLegendLabels(config) {
	  return {
	    type: 'text',
	    interactive: false,
	    key: 'data',
	    properties: {
	      enter: {
	        x: {scale: 'legend', field: 'data'},
	        y: {value: 20},
	        dy: {value: 2},
	        fill: {value: config.labelColor},
	        font: {value: config.labelFont},
	        fontSize: {value: config.labelFontSize},
	        align: {field: 'align'},
	        baseline: {value: 'top'},
	        text: {field: 'label'},
	        opacity: {value: 1e-6}
	      },
	      exit: { opacity: {value: 1e-6} },
	      update: {
	        x: {scale: 'legend', field: 'data'},
	        y: {value: 20},
	        opacity: {value: 1}
	      }
	    }
	  };
	}
	
	module.exports = lgnd;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/legend.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/marks.js **/
jupyter.define('vega@2.6.3/src/parse/marks.js', function (module, exports, __jupyter_require__) {
	var parseMark = __jupyter_require__('vega@~2.6.3/src/parse/mark.js'),
	    parseProperties = __jupyter_require__('vega@~2.6.3/src/parse/properties.js');
	
	function parseRootMark(model, spec, width, height) {
	  return {
	    type:       'group',
	    width:      width,
	    height:     height,
	    properties: defaults(spec.scene || {}, model),
	    scales:     spec.scales  || [],
	    axes:       spec.axes    || [],
	    legends:    spec.legends || [],
	    marks:      (spec.marks || []).map(function(m) { return parseMark(model, m, true); })
	  };
	}
	
	var PROPERTIES = [
	  'fill', 'fillOpacity', 'stroke', 'strokeOpacity',
	  'strokeWidth', 'strokeDash', 'strokeDashOffset'
	];
	
	function defaults(spec, model) {
	  var config = model.config().scene,
	      props = {}, i, n, m, p, s;
	
	  for (i=0, n=m=PROPERTIES.length; i<n; ++i) {
	    p = PROPERTIES[i];
	    if ((s=spec[p]) !== undefined) {
	      props[p] = s.signal ? s : {value: s};
	    } else if (config[p]) {
	      props[p] = {value: config[p]};
	    } else {
	      --m;
	    }
	  }
	
	  return m ? {update: parseProperties(model, 'group', props)} : {};
	}
	
	module.exports = parseRootMark;
	
	parseRootMark.schema = {
	  "defs": {
	    "container": {
	      "type": "object",
	      "properties": {
	        "scene": {
	          "type": "object",
	          "properties": {
	            "fill": {
	              "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	            },
	            "fillOpacity": {
	              "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	            },
	            "stroke": {
	              "oneOf": [{"type": "string"}, {"$ref": "#/refs/signal"}]
	            },
	            "strokeOpacity": {
	              "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	            },
	            "strokeWidth": {
	              "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	            },
	            "strokeDash": {
	              "oneOf": [
	                {"type": "array", "items": {"type": "number"}}, 
	                {"$ref": "#/refs/signal"}
	              ]
	            },
	            "strokeDashOffset": {
	              "oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]
	            },
	          }
	        },
	        "scales": {
	          "type": "array",
	          "items": {"$ref": "#/defs/scale"}
	        },
	        "axes": {
	          "type": "array",
	          "items": {"$ref": "#/defs/axis"}
	        },
	        "legends": {
	          "type": "array",
	          "items": {"$ref": "#/defs/legend"}
	        },
	        "marks": {
	          "type": "array",
	          "items": {"oneOf":[{"$ref": "#/defs/groupMark"}, {"$ref": "#/defs/visualMark"}]}
	        }
	      }
	    },
	
	
	    "groupMark": {
	      "allOf": [
	        {
	          "properties": { "type": {"enum": ["group"]} },
	          "required": ["type"]
	        },
	        {"$ref": "#/defs/mark"},
	        {"$ref": "#/defs/container"}
	      ]
	    },
	
	    "visualMark": {
	      "allOf": [
	        {
	          "not": { "properties": { "type": {"enum": ["group"]} } },
	        },
	        {"$ref": "#/defs/mark"}
	      ]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/marks.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/padding.js **/
jupyter.define('vega@2.6.3/src/parse/padding.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js');
	
	function parsePadding(pad) {
	  return pad == null ? 'auto' :
	    dl.isObject(pad) ? pad :
	    dl.isNumber(pad) ? {top:pad, left:pad, right:pad, bottom:pad} :
	    pad === 'strict' ? pad : 'auto';
	}
	
	module.exports = parsePadding;
	parsePadding.schema = {
	  "defs": {
	    "padding": {
	      "oneOf": [{
	        "enum": ["strict", "auto"]
	      }, {
	        "type": "number"
	      }, {
	        "type": "object",
	        "properties": {
	          "top": {"type": "number"},
	          "bottom": {"type": "number"},
	          "left": {"type": "number"},
	          "right": {"type": "number"}
	        },
	        "additionalProperties": false
	      }]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/padding.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/predicates.js **/
jupyter.define('vega@2.6.3/src/parse/predicates.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js');
	
	var types = {
	  '=':   parseComparator,
	  '==':  parseComparator,
	  '!=':  parseComparator,
	  '>':   parseComparator,
	  '>=':  parseComparator,
	  '<':   parseComparator,
	  '<=':  parseComparator,
	  'and': parseLogical,
	  '&&':  parseLogical,
	  'or':  parseLogical,
	  '||':  parseLogical,
	  'in':  parseIn
	};
	
	var nullScale = function() { return 0; };
	nullScale.invert = nullScale;
	
	function parsePredicates(model, spec) {
	  (spec || []).forEach(function(s) {
	    var parse = types[s.type](model, s);
	
	    /* jshint evil:true */
	    var pred  = Function("args", "db", "signals", "predicates", parse.code);
	    pred.root = function() { return model.scene().items[0]; }; // For global scales
	    pred.nullScale = nullScale;
	    pred.isFunction = dl.isFunction;
	    pred.signals = parse.signals;
	    pred.data = parse.data;
	
	    model.predicate(s.name, pred);
	  });
	
	  return spec;
	}
	
	function parseSignal(signal, signals) {
	  var s = dl.field(signal),
	      code = "signals["+s.map(dl.str).join("][")+"]";
	  signals[s[0]] = 1;
	  return code;
	}
	
	function parseOperands(model, operands) {
	  var decl = [], defs = [],
	      signals = {}, db = {};
	
	  function setSignal(s) { signals[s] = 1; }
	  function setData(d) { db[d] = 1; }
	
	  dl.array(operands).forEach(function(o, i) {
	    var name = "o" + i,
	        def = "";
	
	    if (o.value !== undefined) {
	      def = dl.str(o.value);
	    } else if (o.arg) {
	      def = "args["+dl.str(o.arg)+"]";
	    } else if (o.signal) {
	      def = parseSignal(o.signal, signals);
	    } else if (o.predicate) {
	      var ref = o.predicate,
	          predName = ref && (ref.name || ref),
	          pred = model.predicate(predName),
	          p = "predicates["+dl.str(predName)+"]";
	
	      pred.signals.forEach(setSignal);
	      pred.data.forEach(setData);
	
	      if (dl.isObject(ref)) {
	        dl.keys(ref).forEach(function(k) {
	          if (k === "name") return;
	          var i = ref[k];
	          def += "args["+dl.str(k)+"] = ";
	          if (i.signal) {
	            def += parseSignal(i.signal, signals);
	          } else if (i.arg) {
	            def += "args["+dl.str(i.arg)+"]";
	          }
	          def += ", ";
	        });
	      }
	
	      def += p+".call("+p+", args, db, signals, predicates)";
	    }
	
	    decl.push(name);
	    defs.push(name+"=("+def+")");
	  });
	
	  return {
	    code: "var " + decl.join(", ") + ";\n" + defs.join(";\n") + ";\n",
	    signals: dl.keys(signals),
	    data: dl.keys(db)
	  };
	}
	
	function parseComparator(model, spec) {
	  var ops = parseOperands(model, spec.operands);
	  if (spec.type === '=') spec.type = '==';
	
	  ops.code += "o0 = o0 instanceof Date ? o0.getTime() : o0;\n" +
	    "o1 = o1 instanceof Date ? o1.getTime() : o1;\n";
	
	  return {
	    code: ops.code + "return " + ["o0", "o1"].join(spec.type) + ";",
	    signals: ops.signals,
	    data: ops.data
	  };
	}
	
	function parseLogical(model, spec) {
	  var ops = parseOperands(model, spec.operands),
	      o = [], i = 0, len = spec.operands.length;
	
	  while (o.push("o"+i++) < len);
	  if (spec.type === 'and') spec.type = '&&';
	  else if (spec.type === 'or') spec.type = '||';
	
	  return {
	    code: ops.code + "return " + o.join(spec.type) + ";",
	    signals: ops.signals,
	    data: ops.data
	  };
	}
	
	function parseIn(model, spec) {
	  var o = [spec.item], code = "";
	  if (spec.range) o.push.apply(o, spec.range);
	  if (spec.scale) {
	    code = parseScale(spec.scale, o);
	  }
	
	  var ops = parseOperands(model, o);
	  code = ops.code + code + "\n  var ordSet = null;\n";
	
	  if (spec.data) {
	    var field = dl.field(spec.field).map(dl.str);
	    code += "var where = function(d) { return d["+field.join("][")+"] == o0 };\n";
	    code += "return db["+dl.str(spec.data)+"].filter(where).length > 0;";
	  } else if (spec.range) {
	    // TODO: inclusive/exclusive range?
	    if (spec.scale) {
	      code += "if (scale.length == 2) {\n" + // inverting ordinal scales
	        "  ordSet = scale(o1, o2);\n" +
	        "} else {\n" +
	        "  o1 = scale(o1);\no2 = scale(o2);\n" +
	        "}";
	    }
	
	    code += "return ordSet !== null ? ordSet.indexOf(o0) !== -1 :\n" +
	      "  o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1;";
	  }
	
	  return {
	    code: code,
	    signals: ops.signals,
	    data: ops.data.concat(spec.data ? [spec.data] : [])
	  };
	}
	
	// Populate ops such that ultimate scale/inversion function will be in `scale` var.
	function parseScale(spec, ops) {
	  var code = "var scale = ",
	      idx  = ops.length;
	
	  if (dl.isString(spec)) {
	    ops.push({ value: spec });
	    code += "this.root().scale(o"+idx+")";
	  } else if (spec.arg) {  // Scale function is being passed as an arg
	    ops.push(spec);
	    code += "o"+idx;
	  } else if (spec.name) { // Full scale parameter {name: ..}
	    ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);
	    code += "(this.isFunction(o"+idx+") ? o"+idx+" : ";
	    if (spec.scope) {
	      ops.push(spec.scope);
	      code += "((o"+(idx+1)+".scale || this.root().scale)(o"+idx+") || this.nullScale)";
	    } else {
	      code += "this.root().scale(o"+idx+")";
	    }
	    code += ")";
	  }
	
	  if (spec.invert === true) {  // Allow spec.invert.arg?
	    code += ".invert";
	  }
	
	  return code+";\n";
	}
	
	module.exports = parsePredicates;
	parsePredicates.schema = {
	  "refs": {
	    "operand": {
	      "type": "object",
	      "oneOf": [
	        {
	          "properties": {"value": {}},
	          "required": ["value"]
	        },
	        {
	          "properties": {"arg": {"type": "string"}},
	          "required": ["arg"]
	        },
	        {"$ref": "#/refs/signal"},
	        {
	          "properties": {
	            "predicate": {
	              "oneOf": [
	                {"type": "string"},
	                {
	                  "type": "object",
	                  "properties": {"name": {"type": "string"}},
	                  "required": ["name"]
	                }
	              ]
	            }
	          },
	          "required": ["predicate"]
	        }
	      ]
	    }
	  },
	
	  "defs": {
	    "predicate": {
	      "type": "object",
	      "oneOf": [{
	        "properties": {
	          "name": {"type": "string"},
	          "type": {"enum": ["==", "!=", ">", "<", ">=", "<="]},
	          "operands": {
	            "type": "array",
	            "items": {"$ref": "#/refs/operand"},
	            "minItems": 2,
	            "maxItems": 2
	          }
	        },
	        "required": ["name", "type", "operands"]
	      }, {
	        "properties": {
	          "name": {"type": "string"},
	          "type": {"enum": ["and", "&&", "or", "||"]},
	          "operands": {
	            "type": "array",
	            "items": {"$ref": "#/refs/operand"},
	            "minItems": 2
	          }
	        },
	        "required": ["name", "type", "operands"]
	      }, {
	        "properties": {
	          "name": {"type": "string"},
	          "type": {"enum": ["in"]},
	          "item": {"$ref": "#/refs/operand"}
	        },
	
	        "oneOf": [
	          {
	            "properties": {
	              "range": {
	                "type": "array",
	                "items": {"$ref": "#/refs/operand"},
	                "minItems": 2
	              },
	              "scale": {"$ref": "#/refs/scopedScale"}
	            },
	            "required": ["range"]
	          },
	          {
	            "properties": {
	              "data": {"type": "string"},
	              "field": {"type": "string"}
	            },
	            "required": ["data", "field"]
	          }
	        ],
	
	        "required": ["name", "type", "item"]
	      }]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/predicates.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/signals.js **/
jupyter.define('vega@2.6.3/src/parse/signals.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    expr = __jupyter_require__('vega@~2.6.3/src/parse/expr.js'),
	    SIGNALS = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Dependencies.SIGNALS;
	
	var RESERVED = ['datum', 'event', 'signals', 'width', 'height', 'padding']
	    .concat(dl.keys(expr.codegen.functions));
	
	function parseSignals(model, spec) {
	  // process each signal definition
	  (spec || []).forEach(function(s) {
	    if (RESERVED.indexOf(s.name) !== -1) {
	      throw Error('Signal name "'+s.name+'" is a '+
	        'reserved keyword ('+RESERVED.join(', ')+').');
	    }
	
	    var signal = model.signal(s.name, s.init)
	      .verbose(s.verbose);
	
	    if (s.init && s.init.expr) {
	      s.init.expr = model.expr(s.init.expr);
	      signal.value(exprVal(model, s.init));
	    }
	
	    if (s.expr) {
	      s.expr = model.expr(s.expr);
	      signal.evaluate = function(input) {
	        var val = exprVal(model, s),
	            sg  = input.signals;
	        if (val !== signal.value() || signal.verbose()) {
	          signal.value(val);
	          sg[s.name] = 1;
	        }
	        return sg[s.name] ? input : model.doNotPropagate;
	      };
	      signal.dependency(SIGNALS, s.expr.globals);
	      s.expr.globals.forEach(function(dep) {
	        model.signal(dep).addListener(signal);
	      });
	    }
	  });
	
	  return spec;
	}
	
	function exprVal(model, spec) {
	  var e = spec.expr, v = e.fn();
	  return spec.scale ? parseSignals.scale(model, spec, v) : v;
	}
	
	parseSignals.scale = function scale(model, spec, value, datum, evt) {
	  var def = spec.scale,
	      name  = def.name || def.signal || def,
	      scope = def.scope, e;
	
	  if (scope) {
	    if (scope.signal) {
	      scope = model.signalRef(scope.signal);
	    } else if (dl.isString(scope)) { // Scope is an expression
	      e = def._expr = (def._expr || model.expr(scope));
	      scope = e.fn(datum, evt);
	    }
	  }
	
	  return expr.scale(model, def.invert, name, value, scope);
	};
	
	module.exports = parseSignals;
	parseSignals.schema = {
	  "refs": {
	    "signal": {
	      "title": "SignalRef",
	      "type": "object",
	      "properties": {"signal": {"type": "string"}},
	      "required": ["signal"]
	    },
	
	    "scopedScale": {
	      "oneOf": [
	        {"type": "string"},
	        {
	          "type": "object",
	          "properties": {
	            "name": {
	              "oneOf": [{"$ref": "#/refs/signal"}, {"type": "string"}]
	            },
	            "scope": {
	              "oneOf": [
	                {"$ref": "#/refs/signal"},
	                {"type": "string"}
	              ]
	            },
	            "invert": {"type": "boolean", "default": false}
	          },
	
	          "additionalProperties": false,
	          "required": ["name"]
	        }
	      ]
	    }
	  },
	
	  "defs": {
	    "signal": {
	      "type": "object",
	
	      "properties": {
	        "name": {
	          "type": "string",
	          "not": {"enum": RESERVED}
	        },
	        "init": {},
	        "verbose": {"type": "boolean", "default": false},
	        "expr": {"type": "string"},
	        "scale": {"$ref": "#/refs/scopedScale"},
	        "streams": {"$ref": "#/defs/streams"}
	      },
	
	      "additionalProperties": false,
	      "required": ["name"]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/signals.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/spec.js **/
jupyter.define('vega@2.6.3/src/parse/spec.js', function (module, exports, __jupyter_require__) {
	var dl  = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    themeVal = __jupyter_require__('vega@~2.6.3/src/util/theme-val.js'),
	    Model = __jupyter_require__('vega@~2.6.3/src/core/Model.js'),
	    View  = __jupyter_require__('vega@~2.6.3/src/core/View.js');
	
	/**
	 * Parse graph specification
	 * @param spec (object)
	 * @param config (optional object)
	 * @param viewFactory (optional function)
	 * @param callback (error, model)
	 */
	 function parseSpec(spec /*, [config,] [viewFactory,] callback */) {
	  // do not assign any values to callback, as it will change arguments
	  var arglen = arguments.length,
	      argidx = 2,
	      cb = arguments[arglen-1],
	      model = new Model(),
	      viewFactory = View.factory,
	      config;
	
	  if (arglen > argidx && dl.isFunction(arguments[arglen - argidx])) {
	    viewFactory = arguments[arglen - argidx];
	    ++argidx;
	  }
	
	  if (arglen > argidx && dl.isObject(arguments[arglen - argidx])) {
	    model.config(arguments[arglen - argidx]);
	  }
	
	  config = model.config();
	  if (dl.isObject(spec)) {
	    parse(spec);
	  } else if (dl.isString(spec)) {
	    var opts = dl.extend({url: spec}, config.load);
	    dl.json(opts, function(err, spec) {
	      if (err) done('SPECIFICATION LOAD FAILED: ' + err);
	      else parse(spec);
	    });
	  } else {
	    done('INVALID SPECIFICATION: Must be a valid JSON object or URL.');
	  }
	
	  function parse(spec) {
	    try {
	      // protect against subsequent spec modification
	      spec = dl.duplicate(spec);
	
	      var parsers = __jupyter_require__('vega@~2.6.3/src/parse/index.js'),
	          width   = themeVal(spec, config, 'width', 500),
	          height  = themeVal(spec, config, 'height', 500),
	          padding = parsers.padding(themeVal(spec, config, 'padding')),
	          background = themeVal(spec, config, 'background');
	
	      // create signals for width, height, padding, and cursor
	      model.signal('width', width);
	      model.signal('height', height);
	      model.signal('padding', padding);
	      cursor(spec);
	
	      // initialize model
	      model.defs({
	        width:      width,
	        height:     height,
	        padding:    padding,
	        viewport:   spec.viewport || null,
	        background: parsers.background(background),
	        signals:    parsers.signals(model, spec.signals),
	        predicates: parsers.predicates(model, spec.predicates),
	        marks:      parsers.marks(model, spec, width, height),
	        data:       parsers.data(model, spec.data, done)
	      });
	    } catch (err) { done(err); }
	  }
	
	  function cursor(spec) {
	    var signals = spec.signals || (spec.signals=[]),  def;
	    signals.some(function(sg) {
	      return (sg.name === 'cursor') ? (def=sg, true) : false;
	    });
	
	    if (!def) signals.push(def={name: 'cursor', streams: []});
	
	    // Add a stream def at the head, so that custom defs can override it.
	    def.init = def.init || {};
	    def.streams.unshift({
	      type: 'mousemove',
	      expr: 'eventItem().cursor === cursor.default ? cursor : {default: eventItem().cursor}'
	    });
	  }
	
	  function done(err) {
	    var view;
	    if (err) {
	      log.error(err);
	    } else {
	      view = viewFactory(model.buildIndexes());
	    }
	
	    if (cb) {
	      if (cb.length > 1) cb(err, view);
	      else if (!err) cb(view);
	      cb = null;
	    }
	  }
	}
	
	module.exports = parseSpec;
	
	parseSpec.schema = {
	  "defs": {
	    "spec": {
	      "title": "Vega visualization specification",
	      "type": "object",
	
	      "allOf": [{"$ref": "#/defs/container"}, {
	        "properties": {
	          "width": {"type": "number"},
	          "height": {"type": "number"},
	          "viewport": {
	            "type": "array",
	            "items": {"type": "number"},
	            "maxItems": 2
	          },
	
	          "background": {"$ref": "#/defs/background"},
	          "padding": {"$ref": "#/defs/padding"},
	
	          "signals": {
	            "type": "array",
	            "items": {"$ref": "#/defs/signal"}
	          },
	
	          "predicates": {
	            "type": "array",
	            "items": {"$ref": "#/defs/predicate"}
	          },
	
	          "data": {
	            "type": "array",
	            "items": {"$ref": "#/defs/data"}
	          }
	        }
	      }]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/spec.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/core/Model.js **/
jupyter.define('vega@2.6.3/src/core/Model.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    ChangeSet = df.ChangeSet,
	    Base = df.Graph.prototype,
	    Node  = df.Node, // jshint ignore:line
	    GroupBuilder = __jupyter_require__('vega@~2.6.3/src/scene/GroupBuilder.js'),
	    visit = __jupyter_require__('vega@~2.6.3/src/scene/visit.js'),
	    compiler = __jupyter_require__('vega@~2.6.3/src/parse/expr.js'),
	    config = __jupyter_require__('vega@~2.6.3/src/core/config.js');
	
	function Model(cfg) {
	  this._defs = {};
	  this._predicates = {};
	
	  this._scene  = null;  // Root scenegraph node.
	  this._groups = null;  // Index of group items.
	
	  this._node = null;
	  this._builder = null; // Top-level scenegraph builder.
	
	  this._reset = {axes: false, legends: false};
	
	  this.config(cfg);
	  this.expr = compiler(this);
	  Base.init.call(this);
	}
	
	var prototype = (Model.prototype = Object.create(Base));
	prototype.constructor = Model;
	
	prototype.defs = function(defs) {
	  if (!arguments.length) return this._defs;
	  this._defs = defs;
	  return this;
	};
	
	prototype.config = function(cfg) {
	  if (!arguments.length) return this._config;
	  this._config = Object.create(config);
	  for (var name in cfg) {
	    var x = cfg[name], y = this._config[name];
	    if (dl.isObject(x) && dl.isObject(y)) {
	      this._config[name] = dl.extend({}, y, x);
	    } else {
	      this._config[name] = x;
	    }
	  }
	
	  return this;
	};
	
	prototype.width = function(width) {
	  if (this._defs) this._defs.width = width;
	  if (this._defs && this._defs.marks) this._defs.marks.width = width;
	  if (this._scene) {
	    this._scene.items[0].width = width;
	    this._scene.items[0]._dirty = true;
	  }
	  this._reset.axes = true;
	  return this;
	};
	
	prototype.height = function(height) {
	  if (this._defs) this._defs.height = height;
	  if (this._defs && this._defs.marks) this._defs.marks.height = height;
	  if (this._scene) {
	    this._scene.items[0].height = height;
	    this._scene.items[0]._dirty = true;
	  }
	  this._reset.axes = true;
	  return this;
	};
	
	prototype.node = function() {
	  return this._node || (this._node = new Node(this));
	};
	
	prototype.data = function() {
	  var data = Base.data.apply(this, arguments);
	  if (arguments.length > 1) {  // new Datasource
	    this.node().addListener(data.pipeline()[0]);
	  }
	  return data;
	};
	
	function predicates(name) {
	  var m = this, pred = {};
	  if (!dl.isArray(name)) return this._predicates[name];
	  name.forEach(function(n) { pred[n] = m._predicates[n]; });
	  return pred;
	}
	
	prototype.predicate = function(name, predicate) {
	  if (arguments.length === 1) return predicates.call(this, name);
	  return (this._predicates[name] = predicate);
	};
	
	prototype.predicates = function() { return this._predicates; };
	
	prototype.scene = function(renderer) {
	  if (!arguments.length) return this._scene;
	
	  if (this._builder) {
	    this.node().removeListener(this._builder);
	    this._builder._groupBuilder.disconnect();
	  }
	
	  var m = this,
	      b = this._builder = new Node(this);
	
	  b.evaluate = function(input) {
	    if (b._groupBuilder) return input;
	
	    var gb = b._groupBuilder = new GroupBuilder(m, m._defs.marks, m._scene={}),
	        p  = gb.pipeline();
	
	    m._groups = {};
	    this.addListener(gb.connect());
	    p[p.length-1].addListener(renderer);
	    return input;
	  };
	
	  this.addListener(b);
	  return this;
	};
	
	prototype.group = function(id, item) {
	  var groups = this._groups;
	  if (arguments.length === 1) return groups[id];
	  return (groups[id] = item, this);
	};
	
	prototype.reset = function() {
	  if (this._scene && this._reset.axes) {
	    visit(this._scene, function(item) {
	      if (item.axes) item.axes.forEach(function(axis) { axis.reset(); });
	    });
	    this._reset.axes = false;
	  }
	  if (this._scene && this._reset.legends) {
	    visit(this._scene, function(item) {
	      if (item.legends) item.legends.forEach(function(l) { l.reset(); });
	    });
	    this._reset.legends = false;
	  }
	  return this;
	};
	
	prototype.addListener = function(l) {
	  this.node().addListener(l);
	};
	
	prototype.removeListener = function(l) {
	  this.node().removeListener(l);
	};
	
	prototype.fire = function(cs) {
	  if (!cs) cs = ChangeSet.create();
	  this.propagate(cs, this.node());
	};
	
	module.exports = Model;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/core/Model.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/GroupBuilder.js **/
jupyter.define('vega@2.6.3/src/scene/GroupBuilder.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Node  = df.Node, // jshint ignore:line
	    Deps  = df.Dependencies,
	    Tuple = df.Tuple,
	    Collector = df.Collector,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Builder = __jupyter_require__('vega@~2.6.3/src/scene/Builder.js'),
	    Scale = __jupyter_require__('vega@~2.6.3/src/scene/Scale.js'),
	    parseAxes = __jupyter_require__('vega@~2.6.3/src/parse/axes.js'),
	    parseLegends = __jupyter_require__('vega@~2.6.3/src/parse/legends.js');
	
	function GroupBuilder() {
	  this._children = {};
	  this._scaler = null;
	  this._recursor = null;
	
	  this._scales = {};
	  this.scale = scale.bind(this);
	  return arguments.length ? this.init.apply(this, arguments) : this;
	}
	
	var Types = GroupBuilder.TYPES = {
	  GROUP:  "group",
	  MARK:   "mark",
	  AXIS:   "axis",
	  LEGEND: "legend"
	};
	
	var proto = (GroupBuilder.prototype = new Builder());
	
	proto.init = function(graph, def) {
	  var builder = this, name;
	
	  this._scaler = new Node(graph);
	
	  (def.scales||[]).forEach(function(s) {
	    s = builder.scale((name=s.name), new Scale(graph, s, builder));
	    builder.scale(name+":prev", s);
	    builder._scaler.addListener(s);  // Scales should be computed after group is encoded
	  });
	
	  this._recursor = new Node(graph);
	  this._recursor.evaluate = recurse.bind(this);
	
	  var scales = (def.axes||[]).reduce(function(acc, x) {
	    acc[x.scale] = 1;
	    return acc;
	  }, {});
	
	  scales = (def.legends||[]).reduce(function(acc, x) {
	    acc[x.size || x.shape || x.fill || x.stroke || x.opacity] = 1;
	    return acc;
	  }, scales);
	
	  this._recursor.dependency(Deps.SCALES, dl.keys(scales));
	
	  // We only need a collector for up-propagation of bounds calculation,
	  // so only GroupBuilders, and not regular Builders, have collectors.
	  this._collector = new Collector(graph);
	
	  return Builder.prototype.init.apply(this, arguments);
	};
	
	proto.evaluate = function() {
	  var output  = Builder.prototype.evaluate.apply(this, arguments),
	      model   = this._graph,
	      builder = this,
	      scales = this._scales,
	      items  = this._mark.items;
	
	  // If scales need to be reevaluated, we need to send all group items forward.
	  if (output.mod.length < items.length) {
	    var fullUpdate = dl.keys(scales).some(function(s) {
	      return scales[s].reevaluate(output);
	    });
	
	    if (!fullUpdate && this._def.axes) {
	      fullUpdate = this._def.axes.reduce(function(acc, a) {
	        return acc || output.scales[a.scale];
	      }, false);
	    }
	
	    if (!fullUpdate && this._def.legends) {
	      fullUpdate = this._def.legends.reduce(function(acc, l) {
	        return acc || output.scales[l.size || l.shape || l.fill || l.stroke];
	      }, false);
	    }
	
	    if (fullUpdate) {
	      output.mod = output.mod.concat(Tuple.idFilter(items,
	          output.mod, output.add, output.rem));
	    }
	  }
	
	  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });
	  output.rem.forEach(function(group) { model.group(group._id, null); });
	  return output;
	};
	
	proto.pipeline = function() {
	  return [this, this._scaler, this._recursor, this._collector, this._bounder];
	};
	
	proto.disconnect = function() {
	  var builder = this;
	  dl.keys(builder._children).forEach(function(group_id) {
	    builder._children[group_id].forEach(function(c) {
	      builder._recursor.removeListener(c.builder);
	      c.builder.disconnect();
	    });
	  });
	
	  builder._children = {};
	  return Builder.prototype.disconnect.call(this);
	};
	
	proto.child = function(name, group_id) {
	  var children = this._children[group_id],
	      i = 0, len = children.length,
	      child;
	
	  for (; i<len; ++i) {
	    child = children[i];
	    if (child.type == Types.MARK && child.builder._def.name == name) break;
	  }
	
	  return child.builder;
	};
	
	function recurse(input) {
	  var builder = this,
	      hasMarks = dl.array(this._def.marks).length > 0,
	      hasAxes = dl.array(this._def.axes).length > 0,
	      hasLegends = dl.array(this._def.legends).length > 0,
	      i, j, c, len, group, pipeline, def, inline = false;
	
	  for (i=0, len=input.add.length; i<len; ++i) {
	    group = input.add[i];
	    if (hasMarks) buildMarks.call(this, input, group);
	    if (hasAxes)  buildAxes.call(this, input, group);
	    if (hasLegends) buildLegends.call(this, input, group);
	  }
	
	  // Wire up new children builders in reverse to minimize graph rewrites.
	  for (i=input.add.length-1; i>=0; --i) {
	    group = input.add[i];
	    for (j=this._children[group._id].length-1; j>=0; --j) {
	      c = this._children[group._id][j];
	      c.builder.connect();
	      pipeline = c.builder.pipeline();
	      def = c.builder._def;
	
	      // This new child needs to be built during this propagation cycle.
	      // We could add its builder as a listener off the _recursor node,
	      // but try to inline it if we can to minimize graph dispatches.
	      inline = (def.type !== Types.GROUP);
	      inline = inline && (this._graph.data(c.from) !== undefined);
	      inline = inline && (pipeline[pipeline.length-1].listeners().length === 1); // Reactive geom source
	      inline = inline && (def.from && !def.from.mark); // Reactive geom target
	      c.inline = inline;
	
	      if (inline) this._graph.evaluate(input, c.builder);
	      else this._recursor.addListener(c.builder);
	    }
	  }
	
	  function removeTemp(c) {
	    if (c.type == Types.MARK && !c.inline &&
	        builder._graph.data(c.from) !== undefined) {
	      builder._recursor.removeListener(c.builder);
	    }
	  }
	
	  function updateAxis(a) {
	    var scale = a.scale();
	    if (!input.scales[scale.scaleName]) return;
	    a.reset().def();
	  }
	
	  function updateLegend(l) {
	    var scale = l.size() || l.shape() || l.fill() || l.stroke() || l.opacity();
	    if (!input.scales[scale.scaleName]) return;
	    l.reset().def();
	  }
	
	  for (i=0, len=input.mod.length; i<len; ++i) {
	    group = input.mod[i];
	
	    // Remove temporary connection for marks that draw from a source
	    if (hasMarks) builder._children[group._id].forEach(removeTemp);
	
	    // Update axis data defs
	    if (hasAxes) group.axes.forEach(updateAxis);
	
	    // Update legend data defs
	    if (hasLegends) group.legends.forEach(updateLegend);
	  }
	
	  function disconnectChildren(c) {
	    builder._recursor.removeListener(c.builder);
	    c.builder.disconnect();
	  }
	
	  for (i=0, len=input.rem.length; i<len; ++i) {
	    group = input.rem[i];
	    // For deleted groups, disconnect their children
	    builder._children[group._id].forEach(disconnectChildren);
	    delete builder._children[group._id];
	  }
	
	  return input;
	}
	
	function scale(name, x) {
	  var group = this, s = null;
	  if (arguments.length === 2) return (group._scales[name] = x, x);
	  while (s == null) {
	    s = group._scales[name];
	    group = group.mark ? group.mark.group : group._parent;
	    if (!group) break;
	  }
	  return s;
	}
	
	function buildGroup(input, group) {
	  log.debug(input, ["building group", group._id]);
	
	  group._scales = group._scales || {};
	  group.scale = scale.bind(group);
	
	  group.items = group.items || [];
	  this._children[group._id] = this._children[group._id] || [];
	
	  group.axes = group.axes || [];
	  group.axisItems = group.axisItems || [];
	
	  group.legends = group.legends || [];
	  group.legendItems = group.legendItems || [];
	
	  // Index group by ID to enable safe scoped scale lookups.
	  this._graph.group(group._id, group);
	}
	
	function buildMarks(input, group) {
	  log.debug(input, ["building children marks #"+group._id]);
	  var marks = this._def.marks,
	      mark, from, inherit, i, len, b;
	
	  for (i=0, len=marks.length; i<len; ++i) {
	    mark = marks[i];
	    from = mark.from || {};
	    inherit = group.datum._facetID;
	    group.items[i] = {group: group, _scaleRefs: {}};
	    b = (mark.type === Types.GROUP) ? new GroupBuilder() : new Builder();
	    b.init(this._graph, mark, group.items[i], this, group._id, inherit);
	    this._children[group._id].push({
	      builder: b,
	      from: from.data || (from.mark ? ("vg_" + group._id + "_" + from.mark) : inherit),
	      type: Types.MARK
	    });
	  }
	}
	
	function buildAxes(input, group) {
	  var axes = group.axes,
	      axisItems = group.axisItems,
	      builder = this;
	
	  parseAxes(this._graph, this._def.axes, axes, group);
	  axes.forEach(function(a, i) {
	    var scale = builder._def.axes[i].scale,
	        def = a.def(),
	        b = null;
	
	    axisItems[i] = {group: group, axis: a, layer: def.layer};
	    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();
	    b.init(builder._graph, def, axisItems[i], builder)
	      .dependency(Deps.SCALES, scale);
	    builder._children[group._id].push({ builder: b, type: Types.AXIS, scale: scale });
	  });
	}
	
	function buildLegends(input, group) {
	  var legends = group.legends,
	      legendItems = group.legendItems,
	      builder = this;
	
	  parseLegends(this._graph, this._def.legends, legends, group);
	  legends.forEach(function(l, i) {
	    var scale = l.size() || l.shape() || l.fill() || l.stroke() || l.opacity(),
	        def = l.def(),
	        b = null;
	
	    legendItems[i] = {group: group, legend: l};
	    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();
	    b.init(builder._graph, def, legendItems[i], builder)
	      .dependency(Deps.SCALES, scale);
	    builder._children[group._id].push({ builder: b, type: Types.LEGEND, scale: scale });
	  });
	}
	
	module.exports = GroupBuilder;
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/GroupBuilder.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/Builder.js **/
jupyter.define('vega@2.6.3/src/scene/Builder.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Item = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').Item,
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Node = df.Node, // jshint ignore:line
	    Deps = df.Dependencies,
	    Tuple = df.Tuple,
	    ChangeSet = df.ChangeSet,
	    Sentinel = {},
	    Encoder  = __jupyter_require__('vega@~2.6.3/src/scene/Encoder.js'),
	    Bounder  = __jupyter_require__('vega@~2.6.3/src/scene/Bounder.js'),
	    parseData = __jupyter_require__('vega@~2.6.3/src/parse/data.js');
	
	function Builder() {
	  return arguments.length ? this.init.apply(this, arguments) : this;
	}
	
	var Status = Builder.STATUS = {
	  ENTER:  'enter',
	  UPDATE: 'update',
	  EXIT:   'exit'
	};
	
	var CONNECTED = 1, DISCONNECTED = 2;
	
	var proto = (Builder.prototype = new Node());
	
	proto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {
	  Node.prototype.init.call(this, graph)
	    .router(true)
	    .collector(true);
	
	  this._def   = def;
	  this._mark  = mark;
	  this._from  = (def.from ? def.from.data : null) || inheritFrom;
	  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;
	  this._map   = {};
	  this._status = null; // Connected or disconnected?
	
	  mark.def = def;
	  mark.marktype = def.type;
	  mark.interactive = (def.interactive !== false);
	  mark.items = [];
	  if (dl.isValid(def.name)) mark.name = def.name;
	
	  this._parent = parent;
	  this._parent_id = parent_id;
	
	  if (def.from && (def.from.mark || def.from.transform || def.from.modify)) {
	    inlineDs.call(this);
	  }
	
	  // Non-group mark builders are super nodes. Encoder and Bounder remain
	  // separate operators but are embedded and called by Builder.evaluate.
	  this._isSuper = (this._def.type !== 'group');
	  this._encoder = new Encoder(this._graph, this._mark, this);
	  this._bounder = new Bounder(this._graph, this._mark);
	  this._output  = null; // Output changeset for reactive geom as Bounder reflows
	
	  if (this._ds) { this._encoder.dependency(Deps.DATA, this._from); }
	
	  // Since Builders are super nodes, copy over encoder dependencies
	  // (bounder has no registered dependencies).
	  this.dependency(Deps.DATA, this._encoder.dependency(Deps.DATA));
	  this.dependency(Deps.SCALES, this._encoder.dependency(Deps.SCALES));
	  this.dependency(Deps.SIGNALS, this._encoder.dependency(Deps.SIGNALS));
	
	  return this;
	};
	
	// Reactive geometry and mark-level transformations are handled here
	// because they need their group's data-joined context.
	function inlineDs() {
	  var from = this._def.from,
	      geom = from.mark,
	      src, name, spec, sibling, output, input, node;
	
	  if (geom) {
	    sibling = this.sibling(geom);
	    src  = sibling._isSuper ? sibling : sibling._bounder;
	    name = ['vg', this._parent_id, geom, src.listeners(true).length].join('_');
	    spec = {
	      name: name,
	      transform: from.transform,
	      modify: from.modify
	    };
	  } else {
	    src = this._graph.data(this._from);
	    if (!src) throw Error('Data source "'+this._from+'" is not defined.');
	    name = ['vg', this._from, this._def.type, src.listeners(true).length].join('_');
	    spec = {
	      name: name,
	      source: this._from,
	      transform: from.transform,
	      modify: from.modify
	    };
	  }
	
	  this._from = name;
	  this._ds = parseData.datasource(this._graph, spec);
	
	  if (geom) {
	    // Bounder reflows, so we need an intermediary node to propagate
	    // the output constructed by the Builder.
	    node = new Node(this._graph).addListener(this._ds.listener());
	    node.evaluate = function(input) {
	      var out  = ChangeSet.create(input),
	          sout = sibling._output;
	
	      out.add = sout.add;
	      out.mod = sout.mod;
	      out.rem = sout.rem;
	      return out;
	    };
	    src.addListener(node);
	  } else {
	    // At this point, we have a new datasource but it is empty as
	    // the propagation cycle has already crossed the datasources.
	    // So, we repulse just this datasource. This should be safe
	    // as the ds isn't connected to the scenegraph yet.
	    output = this._ds.source().last();
	    input  = ChangeSet.create(output);
	
	    input.add = output.add;
	    input.mod = output.mod;
	    input.rem = output.rem;
	    input.stamp = null;
	    this._graph.propagate(input, this._ds.listener(), output.stamp);
	  }
	}
	
	proto.ds = function() { return this._ds; };
	proto.parent   = function() { return this._parent; };
	proto.encoder  = function() { return this._encoder; };
	proto.pipeline = function() { return [this]; };
	
	proto.connect = function() {
	  var builder = this;
	
	  this._graph.connect(this.pipeline());
	  this._encoder._scales.forEach(function(s) {
	    if (!(s = builder._parent.scale(s))) return;
	    s.addListener(builder);
	  });
	
	  if (this._parent) {
	    if (this._isSuper) this.addListener(this._parent._collector);
	    else this._bounder.addListener(this._parent._collector);
	  }
	
	  return (this._status = CONNECTED, this);
	};
	
	proto.disconnect = function() {
	  var builder = this;
	  if (!this._listeners.length) return this;
	
	  function disconnectScales(scales) {
	    for(var i=0, len=scales.length, s; i<len; ++i) {
	      if (!(s = builder._parent.scale(scales[i]))) continue;
	      s.removeListener(builder);
	    }
	  }
	
	  Node.prototype.disconnect.call(this);
	  this._graph.disconnect(this.pipeline());
	  disconnectScales(this._encoder._scales);
	  disconnectScales(dl.keys(this._mark._scaleRefs));
	
	  return (this._status = DISCONNECTED, this);
	};
	
	proto.sibling = function(name) {
	  return this._parent.child(name, this._parent_id);
	};
	
	proto.evaluate = function(input) {
	  log.debug(input, ['building', (this._from || this._def.from), this._def.type]);
	
	  var self = this,
	      def = this._mark.def,
	      props  = def.properties || {},
	      update = props.update   || {},
	      output = ChangeSet.create(input),
	      fullUpdate, fcs, data, name;
	
	  if (this._ds) {
	    // We need to determine if any encoder dependencies have been updated.
	    // However, the encoder's data source will likely be updated, and shouldn't
	    // trigger all items to mod.
	    data = output.data[(name=this._ds.name())];
	    output.data[name] = null;
	    fullUpdate = this._encoder.reevaluate(output);
	    output.data[name] = data;
	
	    fcs = this._ds.last();
	    if (!fcs) throw Error('Builder evaluated before backing DataSource.');
	    if (fcs.stamp > this._stamp) {
	      join.call(this, fcs, output, this._ds.values(), true, fullUpdate);
	    } else if (fullUpdate) {
	      output.mod = this._mark.items.slice();
	    }
	  } else {
	    data = dl.isFunction(this._def.from) ? this._def.from() : [Sentinel];
	    join.call(this, input, output, data);
	  }
	
	  // Stash output before Bounder for downstream reactive geometry.
	  this._output = output = this._graph.evaluate(output, this._encoder);
	
	  // Add any new scale references to the dependency list, and ensure
	  // they're connected.
	  if (update.nested && update.nested.length && this._status === CONNECTED) {
	    dl.keys(this._mark._scaleRefs).forEach(function(s) {
	      var scale = self._parent.scale(s);
	      if (!scale) return;
	
	      scale.addListener(self);
	      self.dependency(Deps.SCALES, s);
	      self._encoder.dependency(Deps.SCALES, s);
	    });
	  }
	
	  // Supernodes calculate bounds too, but only on items marked dirty.
	  if (this._isSuper) {
	    output.mod = output.mod.filter(function(x) { return x._dirty; });
	    output = this._graph.evaluate(output, this._bounder);
	  }
	
	  return output;
	};
	
	function newItem() {
	  var item = Tuple.ingest(new Item(this._mark));
	
	  // For the root node's item
	  if (this._def.width)  Tuple.set(item, 'width',  this._def.width);
	  if (this._def.height) Tuple.set(item, 'height', this._def.height);
	  return item;
	}
	
	function join(input, output, data, ds, fullUpdate) {
	  var keyf = keyFunction(this._def.key || (ds ? '_id' : null)),
	      prev = this._mark.items || [],
	      rem  = ds ? input.rem : prev,
	      mod  = Tuple.idMap((!ds || fullUpdate) ? data : input.mod),
	      next = [],
	      i, key, len, item, datum, enter, diff;
	
	  // Only mark rems as exiting. Due to keyf, there may be an add/mod
	  // tuple that replaces it.
	  for (i=0, len=rem.length; i<len; ++i) {
	    item = (rem[i] === prev[i]) ? prev[i] :
	      keyf ? this._map[keyf(rem[i])] : rem[i];
	    item.status = Status.EXIT;
	  }
	
	  for(i=0, len=data.length; i<len; ++i) {
	    datum = data[i];
	    item  = keyf ? this._map[key = keyf(datum)] : prev[i];
	    enter = item ? false : (item = newItem.call(this), true);
	    item.status = enter ? Status.ENTER : Status.UPDATE;
	    diff = !enter && item.datum !== datum;
	    item.datum = datum;
	
	    if (keyf) {
	      Tuple.set(item, 'key', key);
	      this._map[key] = item;
	    }
	
	    if (enter) {
	      output.add.push(item);
	    } else if (diff || mod[datum._id]) {
	      output.mod.push(item);
	    }
	
	    next.push(item);
	  }
	
	  for (i=0, len=rem.length; i<len; ++i) {
	    item = (rem[i] === prev[i]) ? prev[i] :
	      keyf ? this._map[key = keyf(rem[i])] : rem[i];
	    if (item.status === Status.EXIT) {
	      item._dirty = true;
	      input.dirty.push(item);
	      next.push(item);
	      output.rem.push(item);
	      if (keyf) this._map[key] = null;
	    }
	  }
	
	  return (this._mark.items = next, output);
	}
	
	function keyFunction(key) {
	  if (key == null) return null;
	  var f = dl.array(key).map(dl.accessor);
	  return function(d) {
	    for (var s='', i=0, n=f.length; i<n; ++i) {
	      if (i>0) s += '|';
	      s += String(f[i](d));
	    }
	    return s;
	  };
	}
	
	module.exports = Builder;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/Builder.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/Encoder.js **/
jupyter.define('vega@2.6.3/src/scene/Encoder.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    Node = df.Node, // jshint ignore:line
	    Deps = df.Dependencies,
	    bound = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').bound;
	
	var EMPTY = {};
	
	function Encoder(graph, mark, builder) {
	  var props  = mark.def.properties || {},
	      enter  = props.enter,
	      update = props.update,
	      exit   = props.exit;
	
	  Node.prototype.init.call(this, graph);
	
	  this._mark = mark;
	  this._builder = builder;
	  var s = this._scales = [];
	
	  // Only scales used in the 'update' property set are set as
	  // encoder depedencies to have targeted reevaluations. However,
	  // we still want scales in 'enter' and 'exit' to be evaluated
	  // before the encoder.
	  if (enter) s.push.apply(s, enter.scales);
	
	  if (update) {
	    this.dependency(Deps.DATA, update.data);
	    this.dependency(Deps.SIGNALS, update.signals);
	    this.dependency(Deps.FIELDS, update.fields);
	    this.dependency(Deps.SCALES, update.scales);
	    s.push.apply(s, update.scales);
	  }
	
	  if (exit) s.push.apply(s, exit.scales);
	
	  return this.mutates(true);
	}
	
	var proto = (Encoder.prototype = new Node());
	
	proto.evaluate = function(input) {
	  log.debug(input, ['encoding', this._mark.def.type]);
	  var graph = this._graph,
	      props = this._mark.def.properties || {},
	      items = this._mark.items,
	      enter  = props.enter,
	      update = props.update,
	      exit   = props.exit,
	      dirty  = input.dirty,
	      preds  = graph.predicates(),
	      req = input.request,
	      group = this._mark.group,
	      guide = group && (group.mark.axis || group.mark.legend),
	      db = EMPTY, sg = EMPTY, i, len, item, prop;
	
	  if (req && !guide) {
	    if ((prop = props[req]) && input.mod.length) {
	      db = prop.data ? graph.values(Deps.DATA, prop.data) : null;
	      sg = prop.signals ? graph.values(Deps.SIGNALS, prop.signals) : null;
	
	      for (i=0, len=input.mod.length; i<len; ++i) {
	        item = input.mod[i];
	        encode.call(this, prop, item, input.trans, db, sg, preds, dirty);
	      }
	    }
	
	    return input; // exit early if given request
	  }
	
	  db = values(Deps.DATA, graph, input, props);
	  sg = values(Deps.SIGNALS, graph, input, props);
	
	  // Items marked for removal are at the tail of items. Process them first.
	  for (i=0, len=input.rem.length; i<len; ++i) {
	    item = input.rem[i];
	    if (exit) encode.call(this, exit, item, input.trans, db, sg, preds, dirty);
	    if (input.trans && !exit) input.trans.interpolate(item, EMPTY);
	    else if (!input.trans) items.pop();
	  }
	
	  var update_status = __jupyter_require__('vega@~2.6.3/src/scene/Builder.js').STATUS.UPDATE;
	  for (i=0, len=input.add.length; i<len; ++i) {
	    item = input.add[i];
	    if (enter)  encode.call(this, enter,  item, input.trans, db, sg, preds, dirty);
	    if (update) encode.call(this, update, item, input.trans, db, sg, preds, dirty);
	    item.status = update_status;
	  }
	
	  if (update) {
	    for (i=0, len=input.mod.length; i<len; ++i) {
	      item = input.mod[i];
	      encode.call(this, update, item, input.trans, db, sg, preds, dirty);
	    }
	  }
	
	  return input;
	};
	
	// Only marshal necessary data and signal values
	function values(type, graph, input, props) {
	  var p, x, o, add = input.add.length;
	  if ((p=props.enter) && (x=p[type]).length && add) {
	    o = graph.values(type, x, (o=o||{}));
	  }
	  if ((p=props.exit) && (x=p[type]).length && input.rem.length) {
	    o = graph.values(type, x, (o=o||{}));
	  }
	  if ((p=props.update) && (x=p[type]).length && (add || input.mod.length)) {
	    o = graph.values(type, x, (o=o||{}));
	  }
	  return o || EMPTY;
	}
	
	function encode(prop, item, trans, db, sg, preds, dirty) {
	  var enc = prop.encode,
	      wasDirty = item._dirty,
	      isDirty  = enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);
	
	  item._dirty = isDirty || wasDirty;
	  if (isDirty && !wasDirty) dirty.push(item);
	}
	
	// If a specified property set called, or update property set
	// uses nested fieldrefs, reevaluate all items.
	proto.reevaluate = function(pulse) {
	  var def = this._mark.def,
	      props = def.properties || {},
	      reeval = dl.isFunction(def.from) || def.orient || pulse.request ||
	        Node.prototype.reevaluate.call(this, pulse);
	
	  return reeval || (props.update ? nestedRefs.call(this) : false);
	};
	
	// Test if any nested refs trigger a reflow of mark items.
	function nestedRefs() {
	  var refs = this._mark.def.properties.update.nested,
	      parent = this._builder,
	      level = 0,
	      i = 0, len = refs.length,
	      ref, ds, stamp;
	
	  for (; i<len; ++i) {
	    ref = refs[i];
	
	    // Scale references are resolved via this._mark._scaleRefs which are
	    // added to dependency lists + connected in Builder.evaluate.
	    if (ref.scale) continue;
	
	    for (; level<ref.level; ++level) {
	      parent = parent.parent();
	      ds = parent.ds();
	    }
	
	    // Compare stamps to determine if a change in a group's properties
	    // or data should trigger a reeval. We cannot check anything fancier
	    // (e.g., pulse.fields) as the ref may use item.datum.
	    stamp = (ref.group ? parent.encoder() : ds.last())._stamp;
	    if (stamp > this._stamp) return true;
	  }
	
	  return false;
	}
	
	// Short-circuit encoder if user specifies items
	Encoder.update = function(graph, trans, request, items, dirty) {
	  items = dl.array(items);
	  var preds = graph.predicates(),
	      db = graph.values(Deps.DATA),
	      sg = graph.values(Deps.SIGNALS),
	      i, len, item, props, prop;
	
	  for (i=0, len=items.length; i<len; ++i) {
	    item = items[i];
	    props = item.mark.def.properties;
	    prop = props && props[request];
	    if (prop) {
	      encode.call(null, prop, item, trans, db, sg, preds, dirty);
	      bound.item(item);
	    }
	  }
	
	};
	
	module.exports = Encoder;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/Encoder.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/Bounder.js **/
jupyter.define('vega@2.6.3/src/scene/Bounder.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    scene = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js'),
	    Node = df.Node, // jshint ignore:line
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    bound = scene.bound,
	    Bounds = scene.Bounds,
	    Encoder = __jupyter_require__('vega@~2.6.3/src/scene/Encoder.js');
	
	function Bounder(graph, mark) {
	  this._mark = mark;
	  return Node.prototype.init.call(this, graph)
	    .router(true)
	    .reflows(true)
	    .mutates(true);
	}
	
	var proto = (Bounder.prototype = new Node());
	
	proto.evaluate = function(input) {
	  log.debug(input, ['bounds', this._mark.marktype]);
	
	  var mark  = this._mark,
	      type  = mark.marktype,
	      isGrp = type === 'group',
	      items = mark.items,
	      hasLegends = dl.array(mark.def.legends).length > 0,
	      bounds  = mark.bounds,
	      rebound = !bounds || input.rem.length,
	      i, ilen, j, jlen, group, legend;
	
	  if (type === 'line' || type === 'area') {
	    bound.mark(mark, null, isGrp && !hasLegends);
	  } else {
	    input.add.forEach(function(item) {
	      bound.item(item);
	      rebound = rebound || (bounds && !bounds.encloses(item.bounds));
	    });
	
	    input.mod.forEach(function(item) {
	      rebound = rebound || (bounds && bounds.alignsWith(item.bounds));
	      bound.item(item);
	    });
	
	    if (rebound) {
	      bounds = mark.bounds && mark.bounds.clear() || (mark.bounds = new Bounds());
	      for (i=0, ilen=items.length; i<ilen; ++i) bounds.union(items[i].bounds);
	    }
	  }
	
	  if (isGrp && hasLegends) {
	    for (i=0, ilen=items.length; i<ilen; ++i) {
	      group = items[i];
	      group._legendPositions = null;
	      for (j=0, jlen=group.legendItems.length; j<jlen; ++j) {
	        legend = group.legendItems[j];
	        Encoder.update(this._graph, input.trans, 'legendPosition', legend.items, input.dirty);
	        bound.mark(legend, null, false);
	      }
	    }
	
	    bound.mark(mark, null, true);
	  }
	
	  return df.ChangeSet.create(input, true);
	};
	
	module.exports = Bounder;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/Bounder.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/Scale.js **/
jupyter.define('vega@2.6.3/src/scene/Scale.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Node = df.Node, // jshint ignore:line
	    Deps = df.Dependencies,
	    Aggregate = __jupyter_require__('vega@~2.6.3/src/transforms/Aggregate.js');
	
	var Properties = {
	  width: 1,
	  height: 1
	};
	
	var Types = {
	  LINEAR: 'linear',
	  ORDINAL: 'ordinal',
	  LOG: 'log',
	  POWER: 'pow',
	  SQRT: 'sqrt',
	  TIME: 'time',
	  TIME_UTC: 'utc',
	  QUANTILE: 'quantile',
	  QUANTIZE: 'quantize',
	  THRESHOLD: 'threshold'
	};
	
	var DataRef = {
	  DOMAIN: 'domain',
	  RANGE: 'range',
	
	  COUNT: 'count',
	  GROUPBY: 'groupby',
	  MIN: 'min',
	  MAX: 'max',
	  VALUE: 'value',
	
	  ASC: 'asc',
	  DESC: 'desc'
	};
	
	function Scale(graph, def, parent) {
	  this._def     = def;
	  this._parent  = parent;
	  this._updated = false;
	  return Node.prototype.init.call(this, graph).reflows(true);
	}
	
	var proto = (Scale.prototype = new Node());
	
	proto.evaluate = function(input) {
	  var self = this,
	      fn = function(group) { scale.call(self, group); };
	
	  this._updated = false;
	  input.add.forEach(fn);
	  input.mod.forEach(fn);
	
	  // Scales are at the end of an encoding pipeline, so they should forward a
	  // reflow pulse. Thus, if multiple scales update in the parent group, we don't
	  // reevaluate child marks multiple times.
	  if (this._updated) {
	    input.scales[this._def.name] = 1;
	    log.debug(input, ["scale", this._def.name]);
	  }
	  return df.ChangeSet.create(input, true);
	};
	
	// All of a scale's dependencies are registered during propagation as we parse
	// dataRefs. So a scale must be responsible for connecting itself to dependents.
	proto.dependency = function(type, deps) {
	  if (arguments.length == 2) {
	    var method = (type === Deps.DATA ? 'data' : 'signal');
	    deps = dl.array(deps);
	    for (var i=0, len=deps.length; i<len; ++i) {
	      this._graph[method](deps[i]).addListener(this._parent);
	    }
	  }
	
	  return Node.prototype.dependency.call(this, type, deps);
	};
	
	function scale(group) {
	  var name = this._def.name,
	      prev = name + ':prev',
	      s = instance.call(this, group.scale(name)),
	      m = s.type===Types.ORDINAL ? ordinal : quantitative,
	      rng = range.call(this, group);
	
	  m.call(this, s, rng, group);
	
	  group.scale(name, s);
	  group.scale(prev, group.scale(prev) || s);
	
	  return s;
	}
	
	function instance(scale) {
	  var config = this._graph.config(),
	      type = this._def.type || Types.LINEAR;
	  if (!scale || type !== scale.type) {
	    var ctor = config.scale[type] || d3.scale[type];
	    if (!ctor) throw Error('Unrecognized scale type: ' + type);
	    (scale = ctor()).type = scale.type || type;
	    scale.scaleName = this._def.name;
	    scale._prev = {};
	  }
	  return scale;
	}
	
	function ordinal(scale, rng, group) {
	  var def = this._def,
	      prev = scale._prev,
	      dataDrivenRange = false,
	      pad = signal.call(this, def.padding) || 0,
	      outer  = def.outerPadding == null ? pad : signal.call(this, def.outerPadding),
	      points = def.points && signal.call(this, def.points),
	      round  = signal.call(this, def.round) || def.round == null,
	      domain, str, spatial=true;
	
	  // range pre-processing for data-driven ranges
	  if (dl.isObject(def.range) && !dl.isArray(def.range)) {
	    dataDrivenRange = true;
	    rng = dataRef.call(this, DataRef.RANGE, def.range, scale, group);
	  }
	
	  // domain
	  domain = dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);
	  if (domain && !dl.equal(prev.domain, domain)) {
	    scale.domain(domain);
	    prev.domain = domain;
	    this._updated = true;
	  }
	
	  // range
	  if (!dl.equal(prev.range, rng)) {
	    // width-defined range
	    if (def.bandSize) {
	      var bw = signal.call(this, def.bandSize),
	          len = domain.length,
	          space = def.points ? (pad*bw) : (pad*bw*(len-1) + 2*outer),
	          start;
	      if (rng[0] > rng[1]) {
	        start = rng[1] || 0;
	        rng = [start + (bw * len + space), start];
	      } else {
	        start = rng[0] || 0;
	        rng = [start, start + (bw * len + space)];
	      }
	
	      if (def.reverse) rng = rng.reverse();
	    }
	
	    str = typeof rng[0] === 'string';
	    if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {
	      scale.range(rng); // color or shape values
	      spatial = false;
	    } else if (points && round) {
	      scale.rangeRoundPoints(rng, pad);
	    } else if (points) {
	      scale.rangePoints(rng, pad);
	    } else if (round) {
	      scale.rangeRoundBands(rng, pad, outer);
	    } else {
	      scale.rangeBands(rng, pad, outer);
	    }
	
	    prev.range = rng;
	    this._updated = true;
	  }
	
	  if (!scale.invert && spatial) invertOrdinal(scale);
	}
	
	// "Polyfill" ordinal scale inversion. Currently, only ordinal scales
	// with ordered numeric ranges are supported.
	var bisect = d3.bisector(dl.numcmp).right,
	    findAsc = function(a, x) { return bisect(a,x) - 1; },
	    findDsc = d3.bisector(function(a,b) { return -1 * dl.numcmp(a,b); }).left;
	
	function invertOrdinal(scale) {
	  scale.invert = function(x, y) {
	    var rng = scale.range(),
	        asc = rng[0] < rng[1],
	        find = asc ? findAsc : findDsc;
	
	    if (arguments.length === 1) {
	      if (!dl.isNumber(x)) {
	        throw Error('Ordinal scale inversion is only supported for numeric input ('+x+').');
	      }
	      return scale.domain()[find(rng, x)];
	
	    } else if (arguments.length === 2) {  // Invert extents
	      if (!dl.isNumber(x) || !dl.isNumber(y)) {
	        throw Error('Extents to ordinal invert are not numbers ('+x+', '+y+').');
	      }
	
	      var domain = scale.domain(),
	          a = find(rng, x),
	          b = find(rng, y),
	          n = rng.length - 1, r;
	      if (b < a) { r = a; a = b; b = a; } // ensure a <= b
	      if (a < 0) a = 0;
	      if (b > n) b = n;
	
	      return (asc ? dl.range(a, b+1) : dl.range(b, a-1, -1))
	        .map(function(i) { return domain[i]; });
	    }
	  };
	}
	
	function quantitative(scale, rng, group) {
	  var def = this._def,
	      prev = scale._prev,
	      round = signal.call(this, def.round),
	      exponent = signal.call(this, def.exponent),
	      clamp = signal.call(this, def.clamp),
	      nice = signal.call(this, def.nice),
	      domain, interval;
	
	  // domain
	  domain = (def.type === Types.QUANTILE) ?
	    dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group) :
	    domainMinMax.call(this, scale, group);
	  if (domain && !dl.equal(prev.domain, domain)) {
	    scale.domain(domain);
	    prev.domain = domain;
	    this._updated = true;
	  }
	
	  // range
	  // vertical scales should flip by default, so use XOR here
	  if (signal.call(this, def.range) === 'height') rng = rng.reverse();
	  if (rng && !dl.equal(prev.range, rng)) {
	    scale[round && scale.rangeRound ? 'rangeRound' : 'range'](rng);
	    prev.range = rng;
	    this._updated = true;
	  }
	
	  if (exponent && def.type===Types.POWER) scale.exponent(exponent);
	  if (clamp) scale.clamp(true);
	  if (nice) {
	    if (def.type === Types.TIME) {
	      interval = d3.time[nice];
	      if (!interval) log.error('Unrecognized interval: ' + interval);
	      scale.nice(interval);
	    } else {
	      scale.nice();
	    }
	  }
	}
	
	function isUniques(scale) {
	  return scale.type === Types.ORDINAL || scale.type === Types.QUANTILE;
	}
	
	function getRefs(def) {
	  return def.fields || dl.array(def);
	}
	
	function inherits(refs) {
	  return refs.some(function(r) {
	    if (!r.data) return true;
	    return r.data && dl.array(r.field).some(function(f) {
	      return f.parent;
	    });
	  });
	}
	
	function getFields(ref, group) {
	  return dl.array(ref.field).map(function(f) {
	    return f.parent ?
	      dl.accessor(f.parent)(group.datum) :
	      f; // String or {'signal'}
	  });
	}
	
	// Scale datarefs can be computed over multiple schema types.
	// This function determines the type of aggregator created, and
	// what data is sent to it: values, tuples, or multi-tuples that must
	// be standardized into a consistent schema.
	function aggrType(def, scale) {
	  var refs = getRefs(def);
	
	  // If we're operating over only a single domain, send full tuples
	  // through for efficiency (fewer accessor creations/calls)
	  if (refs.length == 1 && dl.array(refs[0].field).length == 1) {
	    return Aggregate.TYPES.TUPLE;
	  }
	
	  // With quantitative scales, we only care about min/max.
	  if (!isUniques(scale)) return Aggregate.TYPES.VALUE;
	
	  // If we don't sort, then we can send values directly to aggrs as well
	  if (!dl.isObject(def.sort)) return Aggregate.TYPES.VALUE;
	
	  return Aggregate.TYPES.MULTI;
	}
	
	function getCache(which, def, scale, group) {
	  var refs = getRefs(def),
	      inherit = inherits(refs),
	      atype = aggrType(def, scale),
	      uniques = isUniques(scale),
	      sort = def.sort,
	      ck = '_'+which,
	      fields = getFields(refs[0], group);
	
	  if (scale[ck] || this[ck]) return scale[ck] || this[ck];
	
	  var cache = new Aggregate(this._graph).type(atype),
	      groupby, summarize;
	
	  // If a scale's dataref doesn't inherit data from the group, we can
	  // store the dataref aggregator at the Scale (dataflow node) level.
	  if (inherit) {
	    scale[ck] = cache;
	  } else {
	    this[ck]  = cache;
	  }
	
	  if (uniques) {
	    if (atype === Aggregate.TYPES.VALUE) {
	      groupby = [{ name: DataRef.GROUPBY, get: dl.identity }];
	      summarize = {'*': DataRef.COUNT};
	    } else if (atype === Aggregate.TYPES.TUPLE) {
	      groupby = [{ name: DataRef.GROUPBY, get: dl.$(fields[0]) }];
	      summarize = dl.isObject(sort) ? [{
	        field: DataRef.VALUE,
	        get:  dl.$(sort.field),
	        ops: [sort.op]
	      }] : {'*': DataRef.COUNT};
	    } else {  // atype === Aggregate.TYPES.MULTI
	      groupby   = DataRef.GROUPBY;
	      summarize = [{ field: DataRef.VALUE, ops: [sort.op] }];
	    }
	  } else {
	    groupby = [];
	    summarize = [{
	      field: DataRef.VALUE,
	      get: (atype == Aggregate.TYPES.TUPLE) ? dl.$(fields[0]) : dl.identity,
	      ops: [DataRef.MIN, DataRef.MAX],
	      as:  [DataRef.MIN, DataRef.MAX]
	    }];
	  }
	
	  cache.param('groupby', groupby)
	    .param('summarize', summarize);
	
	  return (cache._lastUpdate = -1, cache);
	}
	
	function dataRef(which, def, scale, group) {
	  if (def == null) { return []; }
	  if (dl.isArray(def)) return def.map(signal.bind(this));
	
	  var self = this, graph = this._graph,
	      refs = getRefs(def),
	      inherit = inherits(refs),
	      atype = aggrType(def, scale),
	      cache = getCache.apply(this, arguments),
	      sort  = def.sort,
	      uniques = isUniques(scale),
	      i, rlen, j, flen, ref, fields, field, data, from, cmp;
	
	  function addDep(s) {
	    self.dependency(Deps.SIGNALS, s);
	  }
	
	  if (inherit || (!inherit && cache._lastUpdate < this._stamp)) {
	    for (i=0, rlen=refs.length; i<rlen; ++i) {
	      ref = refs[i];
	      from = ref.data || group.datum._facetID;
	      data = graph.data(from).last();
	
	      if (data.stamp <= this._stamp) continue;
	
	      fields = getFields(ref, group);
	      for (j=0, flen=fields.length; j<flen; ++j) {
	        field = fields[j];
	
	        if (atype === Aggregate.TYPES.VALUE) {
	          cache.accessors(null, field);
	        } else if (atype === Aggregate.TYPES.MULTI) {
	          cache.accessors(field, ref.sort || sort.field);
	        } // Else (Tuple-case) is handled by the aggregator accessors by default
	
	        cache.evaluate(data);
	      }
	
	      this.dependency(Deps.DATA, from);
	      cache.dependency(Deps.SIGNALS).forEach(addDep);
	    }
	
	    cache._lastUpdate = this._stamp;
	
	    data = cache.aggr().result();
	    if (uniques) {
	      if (dl.isObject(sort)) {
	        cmp = sort.op + '_' + DataRef.VALUE;
	        cmp = dl.comparator(cmp);
	      } else if (sort === true) {
	        cmp = dl.comparator(DataRef.GROUPBY);
	      }
	
	      if (cmp) data = data.sort(cmp);
	      cache._values = data.map(function(d) { return d[DataRef.GROUPBY]; });
	    } else {
	      data = data[0];
	      cache._values = !dl.isValid(data) ? [] : [data[DataRef.MIN], data[DataRef.MAX]];
	    }
	  }
	
	  return cache._values;
	}
	
	function signal(v) {
	  if (!v || !v.signal) return v;
	  var s = v.signal, ref;
	  this.dependency(Deps.SIGNALS, (ref = dl.field(s))[0]);
	  return this._graph.signalRef(ref);
	}
	
	function domainMinMax(scale, group) {
	  var def = this._def,
	      domain = [null, null], s, z;
	
	  if (def.domain !== undefined) {
	    domain = (!dl.isObject(def.domain)) ? domain :
	      dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);
	  }
	
	  z = domain.length - 1;
	  if (def.domainMin !== undefined) {
	    if (dl.isObject(def.domainMin)) {
	      if (def.domainMin.signal) {
	        domain[0] = dl.isValid(s=signal.call(this, def.domainMin)) ? s : domain[0];
	      } else {
	        domain[0] = dataRef.call(this, DataRef.DOMAIN+DataRef.MIN, def.domainMin, scale, group)[0];
	      }
	    } else {
	      domain[0] = def.domainMin;
	    }
	  }
	  if (def.domainMax !== undefined) {
	    if (dl.isObject(def.domainMax)) {
	      if (def.domainMax.signal) {
	        domain[z] = dl.isValid(s=signal.call(this, def.domainMax)) ? s : domain[z];
	      } else {
	        domain[z] = dataRef.call(this, DataRef.DOMAIN+DataRef.MAX, def.domainMax, scale, group)[1];
	      }
	    } else {
	      domain[z] = def.domainMax;
	    }
	  }
	  if (def.type !== Types.LOG && def.type !== Types.TIME && (def.zero || def.zero===undefined)) {
	    domain[0] = Math.min(0, domain[0]);
	    domain[z] = Math.max(0, domain[z]);
	  }
	  return domain;
	}
	
	function range(group) {
	  var def = this._def,
	      config = this._graph.config(),
	      rangeVal = signal.call(this, def.range),
	      rng = [null, null];
	
	  if (rangeVal !== undefined) {
	    if (typeof rangeVal === 'string') {
	      if (Properties[rangeVal]) {
	        rng = [0, group[rangeVal]];
	      } else if (config.range[rangeVal]) {
	        rng = config.range[rangeVal];
	      } else {
	        log.error('Unrecogized range: ' + rangeVal);
	        return rng;
	      }
	    } else if (dl.isArray(rangeVal)) {
	      rng = dl.duplicate(rangeVal).map(signal.bind(this));
	    } else if (dl.isObject(rangeVal)) {
	      return null; // early exit
	    } else {
	      rng = [0, rangeVal];
	    }
	  }
	  if (def.rangeMin !== undefined) {
	    rng[0] = def.rangeMin.signal ?
	      signal.call(this, def.rangeMin) :
	      def.rangeMin;
	  }
	  if (def.rangeMax !== undefined) {
	    rng[rng.length-1] = def.rangeMax.signal ?
	      signal.call(this, def.rangeMax) :
	      def.rangeMax;
	  }
	
	  if (def.reverse !== undefined) {
	    var rev = signal.call(this, def.reverse);
	    if (dl.isObject(rev)) {
	      rev = dl.accessor(rev.field)(group.datum);
	    }
	    if (rev) rng = rng.reverse();
	  }
	
	  return rng;
	}
	
	module.exports = Scale;
	
	var rangeDef = [
	  {"enum": ["width", "height", "shapes", "category10", "category20", "category20b", "category20c"]},
	  {
	    "type": "array",
	    "items": {"oneOf": [{"type":"string"}, {"type": "number"}, {"$ref": "#/refs/signal"}]}
	  },
	  {"$ref": "#/refs/signal"}
	];
	
	Scale.schema = {
	  "refs": {
	    "data": {
	      "type": "object",
	      "properties": {
	        "data": {
	          "oneOf": [
	            {"type": "string"},
	            {
	              "type": "object",
	              "properties": {
	                "fields": {
	                  "type": "array",
	                  "items": {"$ref": "#/refs/data"}
	                }
	              },
	              "required": ["fields"]
	            }
	          ]
	        },
	        "field": {
	          "oneOf": [
	            {"type": "string"},
	            {
	              "type": "array",
	              "items": {"type": "string"}
	            },
	            {
	              "type": "object",
	              "properties": {
	                "parent": {"type": "string"}
	              },
	              "required": ["parent"]
	            },
	            {
	              "type": "array",
	              "items": {
	                "type": "object",
	                "properties": {
	                  "parent": {"type": "string"}
	                },
	                "required": ["parent"]
	              }
	            }
	          ]
	        },
	        "sort": {
	          "oneOf": [{"type": "boolean"}, {
	            "type": "object",
	            "properties": {
	              "field": {"type": "string"},
	              "op": {"enum": __jupyter_require__('vega@~2.6.3/src/transforms/Aggregate.js').VALID_OPS}
	            }
	          }]
	        }
	      },
	      "additionalProperties": false
	    }
	  },
	
	  "defs": {
	    "scale": {
	      "title": "Scale function",
	      "type": "object",
	
	      "allOf": [{
	        "properties": {
	          "name": {"type": "string"},
	
	          "type": {
	            "enum": [Types.LINEAR, Types.ORDINAL, Types.TIME, Types.TIME_UTC, Types.LOG,
	              Types.POWER, Types.SQRT, Types.QUANTILE, Types.QUANTIZE, Types.THRESHOLD],
	            "default": Types.LINEAR
	          },
	
	          "domain": {
	            "oneOf": [
	              {
	                "type": "array",
	                "items": {
	                  "oneOf": [
	                    {"type":"string"},
	                    {"type": "number"},
	                    {"$ref": "#/refs/signal"}
	                  ]
	                }
	              },
	              {"$ref": "#/refs/data"},
	              {
	                "type": "object",
	                "properties": {
	                  "fields": {
	                    "type": "array",
	                    "items": {"$ref": "#/refs/data"}
	                  }
	                },
	                "required": ["fields"],
	              }
	            ]
	          },
	
	          "domainMin": {
	            "oneOf": [
	              {"type": "number"},
	              {"$ref": "#/refs/data"},
	              {"$ref": "#/refs/signal"}
	            ]
	          },
	
	          "domainMax": {
	            "oneOf": [
	              {"type": "number"},
	              {"$ref": "#/refs/data"},
	              {"$ref": "#/refs/signal"}
	            ]
	          },
	
	          "rangeMin": {
	            "oneOf": [
	              {"type":"string"},
	              {"type": "number"},
	              {"$ref": "#/refs/signal"}
	            ]
	          },
	
	          "rangeMax": {
	            "oneOf": [
	              {"type":"string"},
	              {"type": "number"},
	              {"$ref": "#/refs/signal"}
	            ]
	          },
	
	          "reverse": {
	            "oneOf": [
	              {"type": "boolean"},
	              {"$ref": "#/refs/data"}
	            ],
	          },
	          "round": {"type": "boolean"}
	        },
	
	        "required": ["name"]
	      }, {
	        "oneOf": [{
	          "properties": {
	            "type": {"enum": [Types.ORDINAL]},
	
	            "range": {
	              "oneOf": rangeDef.concat({"$ref": "#/refs/data"})
	            },
	
	            "points": {"oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}]},
	            "padding": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	            "outerPadding": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]},
	            "bandSize": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]}
	          },
	          "required": ["type"]
	        }, {
	          "properties": {
	            "type": {"enum": [Types.TIME, Types.TIME_UTC]},
	            "range": {"oneOf": rangeDef},
	            "clamp": {"oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}]},
	            "nice": {"oneOf": [{"enum": ["second", "minute", "hour",
	              "day", "week", "month", "year"]}, {"$ref": "#/refs/signal"}]}
	          },
	          "required": ["type"]
	        }, {
	          "anyOf": [{
	            "properties": {
	              "type": {"enum": [Types.LINEAR, Types.LOG, Types.POWER, Types.SQRT,
	                Types.QUANTILE, Types.QUANTIZE, Types.THRESHOLD], "default": Types.LINEAR},
	              "range": {"oneOf": rangeDef},
	              "clamp": {"oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}]},
	              "nice": {"oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}]},
	              "zero": {"oneOf": [{"type": "boolean"}, {"$ref": "#/refs/signal"}]}
	            }
	          }, {
	            "properties": {
	              "type": {"enum": [Types.POWER]},
	              "exponent": {"oneOf": [{"type": "number"}, {"$ref": "#/refs/signal"}]}
	            },
	            "required": ["type"]
	          }]
	        }]
	      }]
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/Scale.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/visit.js **/
jupyter.define('vega@2.6.3/src/scene/visit.js', function (module, exports, __jupyter_require__) {
	module.exports = function visit(node, func) {
	  var i, n, s, m, items;
	  if (func(node)) return true;
	
	  var sets = ['items', 'axisItems', 'legendItems'];
	  for (s=0, m=sets.length; s<m; ++s) {
	    if ((items = node[sets[s]])) {
	      for (i=0, n=items.length; i<n; ++i) {
	        if (visit(items[i], func)) return true;
	      }
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/visit.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/core/config.js **/
jupyter.define('vega@2.6.3/src/core/config.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    config = {};
	
	config.load = {
	  // base url for loading external data files
	  // used only for server-side operation
	  baseURL: '',
	  // Allows domain restriction when using data loading via XHR.
	  // To enable, set it to a list of allowed domains
	  // e.g., ['wikipedia.org', 'eff.org']
	  domainWhiteList: false
	};
	
	// inset padding for automatic padding calculation
	config.autopadInset = 5;
	
	// extensible scale lookup table
	// all d3.scale.* instances also supported
	config.scale = {
	  time: d3.time.scale,
	  utc:  d3.time.scale.utc
	};
	
	// default rendering settings
	config.render = {
	  retina: true
	};
	
	// root scenegraph group
	config.scene = {
	  fill: undefined,
	  fillOpacity: undefined,
	  stroke: undefined,
	  strokeOpacity: undefined,
	  strokeWidth: undefined,
	  strokeDash: undefined,
	  strokeDashOffset: undefined
	};
	
	// default axis properties
	config.axis = {
	  layer: 'back',
	  ticks: 10,
	  padding: 3,
	  axisColor: '#000',
	  axisWidth: 1,
	  gridColor: '#000',
	  gridOpacity: 0.15,
	  tickColor: '#000',
	  tickLabelColor: '#000',
	  tickWidth: 1,
	  tickSize: 6,
	  tickLabelFontSize: 11,
	  tickLabelFont: 'sans-serif',
	  titleColor: '#000',
	  titleFont: 'sans-serif',
	  titleFontSize: 11,
	  titleFontWeight: 'bold',
	  titleOffset: 'auto',
	  titleOffsetAutoMin: 30,
	  titleOffsetAutoMax: 10000,
	  titleOffsetAutoMargin: 4
	};
	
	// default legend properties
	config.legend = {
	  orient: 'right',
	  offset: 20,
	  padding: 3, // padding between legend items and border
	  margin: 2,  // extra margin between two consecutive legends
	  gradientStrokeColor: '#888',
	  gradientStrokeWidth: 1,
	  gradientHeight: 16,
	  gradientWidth: 100,
	  labelColor: '#000',
	  labelFontSize: 10,
	  labelFont: 'sans-serif',
	  labelAlign: 'left',
	  labelBaseline: 'middle',
	  labelOffset: 8,
	  symbolShape: 'circle',
	  symbolSize: 50,
	  symbolColor: '#888',
	  symbolStrokeWidth: 1,
	  titleColor: '#000',
	  titleFont: 'sans-serif',
	  titleFontSize: 11,
	  titleFontWeight: 'bold'
	};
	
	// default color values
	config.color = {
	  rgb: [128, 128, 128],
	  lab: [50, 0, 0],
	  hcl: [0, 0, 50],
	  hsl: [0, 0, 0.5]
	};
	
	// default scale ranges
	config.range = {
	  category10:  d3.scale.category10().range(),
	  category20:  d3.scale.category20().range(),
	  category20b: d3.scale.category20b().range(),
	  category20c: d3.scale.category20c().range(),
	  shapes: [
	    'circle',
	    'cross',
	    'diamond',
	    'square',
	    'triangle-down',
	    'triangle-up'
	  ]
	};
	
	module.exports = config;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/core/config.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/core/View.js **/
jupyter.define('vega@2.6.3/src/core/View.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    sg = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').render,
	    log = __jupyter_require__('vega-logging@^1.0.1/index.js'),
	    Deps = df.Dependencies,
	    parseStreams = __jupyter_require__('vega@~2.6.3/src/parse/streams.js'),
	    Encoder = __jupyter_require__('vega@~2.6.3/src/scene/Encoder.js'),
	    Transition = __jupyter_require__('vega@~2.6.3/src/scene/Transition.js');
	
	function View(el, width, height) {
	  this._el    = null;
	  this._model = null;
	  this._width   = this.__width = width || 500;
	  this._height  = this.__height = height || 300;
	  this._bgcolor = null;
	  this._cursor  = true; // Set cursor based on hover propset?
	  this._autopad = 1;
	  this._padding = {top:0, left:0, bottom:0, right:0};
	  this._viewport = null;
	  this._renderer = null;
	  this._handler  = null;
	  this._streamer = null; // Targeted update for streaming changes
	  this._skipSignals = false; // Batch set signals can skip reevaluation.
	  this._changeset = null;
	  this._repaint = true; // Full re-render on every re-init
	  this._renderers = sg;
	  this._io  = null;
	  this._api = {}; // Stash streaming data API sandboxes.
	}
	
	var prototype = View.prototype;
	
	prototype.model = function(model) {
	  if (!arguments.length) return this._model;
	  if (this._model !== model) {
	    this._model = model;
	    this._streamer = new df.Node(model);
	    this._streamer._rank = -1;  // HACK: To reduce re-ranking churn.
	    this._changeset = df.ChangeSet.create();
	    if (this._handler) this._handler.model(model);
	  }
	  return this;
	};
	
	// Sandboxed streaming data API
	function streaming(src) {
	  var view = this,
	      ds = this._model.data(src);
	  if (!ds) return log.error('Data source "'+src+'" is not defined.');
	
	  var listener = ds.pipeline()[0],
	      streamer = this._streamer,
	      api = {};
	
	  // If we have it stashed, don't create a new closure.
	  if (this._api[src]) return this._api[src];
	
	  api.insert = function(vals) {
	    ds.insert(dl.duplicate(vals));  // Don't pollute the environment
	    streamer.addListener(listener);
	    view._changeset.data[src] = 1;
	    return api;
	  };
	
	  api.update = function() {
	    streamer.addListener(listener);
	    view._changeset.data[src] = 1;
	    return (ds.update.apply(ds, arguments), api);
	  };
	
	  api.remove = function() {
	    streamer.addListener(listener);
	    view._changeset.data[src] = 1;
	    return (ds.remove.apply(ds, arguments), api);
	  };
	
	  api.values = function() { return ds.values(); };
	
	  return (this._api[src] = api);
	}
	
	prototype.data = function(data) {
	  var v = this;
	  if (!arguments.length) return v._model.values();
	  else if (dl.isString(data)) return streaming.call(v, data);
	  else if (dl.isObject(data)) {
	    dl.keys(data).forEach(function(k) {
	      var api = streaming.call(v, k);
	      data[k](api);
	    });
	  }
	  return this;
	};
	
	var VIEW_SIGNALS = dl.toMap(['width', 'height', 'padding']);
	
	prototype.signal = function(name, value, skip) {
	  var m = this._model,
	      key, values;
	
	  // Getter. Returns the value for the specified signal, or
	  // returns all signal values.
	  if (!arguments.length) {
	    return m.values(Deps.SIGNALS);
	  } else if (arguments.length === 1 && dl.isString(name)) {
	    return m.values(Deps.SIGNALS, name);
	  }
	
	  // Setter. Can be done in batch or individually. In either case,
	  // the final argument determines if set signals should be skipped.
	  if (dl.isObject(name)) {
	    values = name;
	    skip = value;
	  } else {
	    values = {};
	    values[name] = value;
	  }
	  for (key in values) {
	    if (VIEW_SIGNALS[key]) {
	      this[key](values[key]);
	    } else {
	      setSignal.call(this, key, values[key]);
	    }
	  }
	  return (this._skipSignals = skip, this);
	};
	
	function setSignal(name, value) {
	  var cs = this._changeset,
	      sg = this._model.signal(name);
	  if (!sg) return log.error('Signal "'+name+'" is not defined.');
	
	  this._streamer.addListener(sg.value(value));
	  cs.signals[name] = 1;
	  cs.reflow = true;
	}
	
	prototype.width = function(width) {
	  if (!arguments.length) return this.__width;
	  if (this.__width !== width) {
	    this._width = this.__width = width;
	    this.model().width(width);
	    this.initialize();
	    if (this._strict) this._autopad = 1;
	    setSignal.call(this, 'width', width);
	  }
	  return this;
	};
	
	prototype.height = function(height) {
	  if (!arguments.length) return this.__height;
	  if (this.__height !== height) {
	    this._height = this.__height = height;
	    this.model().height(height);
	    this.initialize();
	    if (this._strict) this._autopad = 1;
	    setSignal.call(this, 'height', height);
	  }
	  return this;
	};
	
	prototype.background = function(bgcolor) {
	  if (!arguments.length) return this._bgcolor;
	  if (this._bgcolor !== bgcolor) {
	    this._bgcolor = bgcolor;
	    this.initialize();
	  }
	  return this;
	};
	
	prototype.padding = function(pad) {
	  if (!arguments.length) return this._padding;
	  if (this._padding !== pad) {
	    if (dl.isString(pad)) {
	      this._autopad = 1;
	      this._padding = {top:0, left:0, bottom:0, right:0};
	      this._strict = (pad === 'strict');
	    } else {
	      this._autopad = 0;
	      this._padding = pad;
	      this._strict = false;
	    }
	    if (this._renderer) this._renderer.resize(this._width, this._height, this._padding);
	    if (this._handler)  this._handler.padding(this._padding);
	    setSignal.call(this, 'padding', this._padding);
	  }
	  return (this._repaint = true, this);
	};
	
	prototype.autopad = function(opt) {
	  if (this._autopad < 1) return this;
	  else this._autopad = 0;
	
	  var b = this.model().scene().bounds,
	      pad = this._padding,
	      config = this.model().config(),
	      inset = config.autopadInset,
	      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,
	      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,
	      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0;
	  b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;
	  pad = {left:l, top:t, right:r, bottom:b};
	
	  if (this._strict) {
	    this._autopad = 0;
	    this._padding = pad;
	    this._width = Math.max(0, this.__width - (l+r));
	    this._height = Math.max(0, this.__height - (t+b));
	
	    this._model.width(this._width).height(this._height).reset();
	    setSignal.call(this, 'width', this._width);
	    setSignal.call(this, 'height', this._height);
	    setSignal.call(this, 'padding', pad);
	
	    this.initialize().update({props:'enter'}).update({props:'update'});
	  } else {
	    this.padding(pad).update(opt);
	  }
	  return this;
	};
	
	prototype.viewport = function(size) {
	  if (!arguments.length) return this._viewport;
	  if (this._viewport !== size) {
	    this._viewport = size;
	    this.initialize();
	  }
	  return this;
	};
	
	prototype.renderer = function(type) {
	  if (!arguments.length) return this._renderer;
	  if (this._renderers[type]) type = this._renderers[type];
	  else if (dl.isString(type)) throw new Error('Unknown renderer: ' + type);
	  else if (!type) throw new Error('No renderer specified');
	
	  if (this._io !== type) {
	    this._io = type;
	    this._renderer = null;
	    this.initialize();
	    if (this._build) this.render();
	  }
	  return this;
	};
	
	prototype.initialize = function(el) {
	  var v = this, prevHandler,
	      w = v._width, h = v._height, pad = v._padding, bg = v._bgcolor,
	      config = this.model().config();
	
	  if (!arguments.length || el === null) {
	    el = this._el ? this._el.parentNode : null;
	    if (!el) return this;  // This View cannot init w/o an
	  }
	
	  // clear pre-existing container
	  d3.select(el).select('div.vega').remove();
	
	  // add div container
	  this._el = el = d3.select(el)
	    .append('div')
	    .attr('class', 'vega')
	    .style('position', 'relative')
	    .node();
	  if (v._viewport) {
	    d3.select(el)
	      .style('width',  (v._viewport[0] || w)+'px')
	      .style('height', (v._viewport[1] || h)+'px')
	      .style('overflow', 'auto');
	  }
	
	  // renderer
	  sg.canvas.Renderer.RETINA = config.render.retina;
	  v._renderer = (v._renderer || new this._io.Renderer(config.load))
	    .initialize(el, w, h, pad)
	    .background(bg);
	
	  // input handler
	  prevHandler = v._handler;
	  v._handler = new this._io.Handler()
	    .initialize(el, pad, v);
	
	  if (prevHandler) {
	    prevHandler.handlers().forEach(function(h) {
	      v._handler.on(h.type, h.handler);
	    });
	  } else {
	    // Register event listeners for signal stream definitions.
	    v._detach = parseStreams(this);
	  }
	
	  return (this._repaint = true, this);
	};
	
	prototype.destroy = function() {
	  if (this._detach) this._detach();
	};
	
	function build() {
	  var v = this;
	  v._renderNode = new df.Node(v._model)
	    .router(true);
	
	  v._renderNode.evaluate = function(input) {
	    log.debug(input, ['rendering']);
	
	    var s = v._model.scene(),
	        h = v._handler;
	
	    if (h && h.scene) h.scene(s);
	
	    if (input.trans) {
	      input.trans.start(function(items) { v._renderer.render(s, items); });
	    } else if (v._repaint) {
	      v._renderer.render(s);
	    } else if (input.dirty.length) {
	      v._renderer.render(s, input.dirty);
	    }
	
	    if (input.dirty.length) {
	      input.dirty.forEach(function(i) { i._dirty = false; });
	      s.items[0]._dirty = false;
	    }
	
	    v._repaint = v._skipSignals = false;
	    return input;
	  };
	
	  return (v._model.scene(v._renderNode), true);
	}
	
	prototype.update = function(opt) {
	  opt = opt || {};
	  var v = this,
	      model = this._model,
	      streamer = this._streamer,
	      cs = this._changeset,
	      trans = opt.duration ? new Transition(opt.duration, opt.ease) : null;
	
	  if (trans) cs.trans = trans;
	  if (opt.props !== undefined) {
	    if (dl.keys(cs.data).length > 0) {
	      throw Error(
	        'New data values are not reflected in the visualization.' +
	        ' Please call view.update() before updating a specified property set.'
	      );
	    }
	
	    cs.reflow  = true;
	    cs.request = opt.props;
	  }
	
	  var built = v._build;
	  v._build = v._build || build.call(this);
	
	  // If specific items are specified, short-circuit dataflow graph.
	  // Else-If there are streaming updates, perform a targeted propagation.
	  // Otherwise, re-evaluate the entire model (datasources + scene).
	  if (opt.items && built) {
	    Encoder.update(model, opt.trans, opt.props, opt.items, cs.dirty);
	    v._renderNode.evaluate(cs);
	  } else if (streamer.listeners().length && built) {
	    // Include re-evaluation entire model when repaint flag is set
	    if (this._repaint) streamer.addListener(model.node());
	    model.propagate(cs, streamer, null, this._skipSignals);
	    streamer.disconnect();
	  } else {
	    model.fire(cs);
	  }
	
	  v._changeset = df.ChangeSet.create();
	
	  return v.autopad(opt);
	};
	
	prototype.toImageURL = function(type) {
	  var v = this, Renderer;
	
	  // lookup appropriate renderer
	  switch (type || 'png') {
	    case 'canvas':
	    case 'png':
	      Renderer = sg.canvas.Renderer; break;
	    case 'svg':
	      Renderer = sg.svg.string.Renderer; break;
	    default: throw Error('Unrecognized renderer type: ' + type);
	  }
	
	  var retina = sg.canvas.Renderer.RETINA;
	  sg.canvas.Renderer.RETINA = false; // ignore retina screen
	
	  // render the scenegraph
	  var ren = new Renderer(v._model.config.load)
	    .initialize(null, v._width, v._height, v._padding)
	    .background(v._bgcolor)
	    .render(v._model.scene());
	
	  sg.canvas.Renderer.RETINA = retina; // restore retina settings
	
	  // return data url
	  if (type === 'svg') {
	    var blob = new Blob([ren.svg()], {type: 'image/svg+xml'});
	    return window.URL.createObjectURL(blob);
	  } else {
	    return ren.canvas().toDataURL('image/png');
	  }
	};
	
	prototype.render = function(items) {
	  this._renderer.render(this._model.scene(), items);
	  return this;
	};
	
	prototype.on = function() {
	  this._handler.on.apply(this._handler, arguments);
	  return this;
	};
	
	prototype.onSignal = function(name, handler) {
	  var sg = this._model.signal(name);
	  return (sg ?
	    sg.on(handler) : log.error('Signal "'+name+'" is not defined.'), this);
	};
	
	prototype.off = function() {
	  this._handler.off.apply(this._handler, arguments);
	  return this;
	};
	
	prototype.offSignal = function(name, handler) {
	  var sg = this._model.signal(name);
	  return (sg ?
	    sg.off(handler) : log.error('Signal "'+name+'" is not defined.'), this);
	};
	
	View.factory = function(model) {
	  var HeadlessView = __jupyter_require__('vega@~2.6.3/src/core/HeadlessView.js');
	  return function(opt) {
	    opt = opt || {};
	    var defs = model.defs();
	    var v = (opt.el ? new View() : new HeadlessView())
	      .model(model)
	      .renderer(opt.renderer || 'canvas')
	      .width(defs.width)
	      .height(defs.height)
	      .background(defs.background)
	      .padding(defs.padding)
	      .viewport(defs.viewport)
	      .initialize(opt.el);
	
	    if (opt.data) v.data(opt.data);
	
	    // Register handlers for the hover propset and cursors.
	    if (opt.el) {
	      if (opt.hover !== false) {
	        v.on('mouseover', function(evt, item) {
	          if (item && item.hasPropertySet('hover')) {
	            this.update({props:'hover', items:item});
	          }
	        })
	        .on('mouseout', function(evt, item) {
	          if (item && item.hasPropertySet('hover')) {
	            this.update({props:'update', items:item});
	          }
	        });
	      }
	
	      if (opt.cursor !== false) {
	        // If value is a string, it is a custom value set by the user.
	        // In this case, the user is responsible for maintaining the cursor state
	        // and control only reverts back to this handler if set back to 'default'.
	        v.onSignal('cursor', function(name, value) {
	          var body = d3.select('body');
	          if (dl.isString(value)) {
	            v._cursor = value === 'default';
	            body.style('cursor', value);
	          } else if (dl.isObject(value) && v._cursor) {
	            body.style('cursor', value.default);
	          }
	        });
	      }
	    }
	
	    return v;
	  };
	};
	
	module.exports = View;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/core/View.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/parse/streams.js **/
jupyter.define('vega@2.6.3/src/parse/streams.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    df = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js'),
	    selector = __jupyter_require__('vega-event-selector@^1.0.0/index.js'),
	    parseSignals = __jupyter_require__('vega@~2.6.3/src/parse/signals.js');
	
	var GATEKEEPER = '_vgGATEKEEPER',
	    EVALUATOR  = '_vgEVALUATOR';
	
	var vgEvent = {
	  getItem: function() { return this.item; },
	  getGroup: function(name) {
	    var group = name ? this.name[name] : this.group,
	        mark = group && group.mark,
	        interactive = mark && (mark.interactive || mark.interactive === undefined);
	    return interactive ? group : {};
	  },
	  getXY: function(item) {
	      var p = {x: this.x, y: this.y};
	      if (typeof item === 'string') {
	        item = this.name[item];
	      }
	      for (; item; item = item.mark && item.mark.group) {
	        p.x -= item.x || 0;
	        p.y -= item.y || 0;
	      }
	      return p;
	    },
	  getX: function(item) { return this.getXY(item).x; },
	  getY: function(item) { return this.getXY(item).y; }
	};
	
	function parseStreams(view) {
	  var model = view.model(),
	      trueFn  = model.expr('true'),
	      falseFn = model.expr('false'),
	      spec    = model.defs().signals,
	      registry = {handlers: {}, nodes: {}},
	      internal = dl.duplicate(registry),  // Internal event processing
	      external = dl.duplicate(registry);  // External event processing
	
	  dl.array(spec).forEach(function(sig) {
	    var signal = model.signal(sig.name);
	    if (sig.expr) return;  // Cannot have an expr and stream definition.
	
	    dl.array(sig.streams).forEach(function(stream) {
	      var sel = selector.parse(stream.type),
	          exp = model.expr(stream.expr);
	      mergedStream(signal, sel, exp, stream);
	    });
	  });
	
	  // We register the event listeners all together so that if multiple
	  // signals are registered on the same event, they will receive the
	  // new value on the same pulse.
	  dl.keys(internal.handlers).forEach(function(type) {
	    view.on(type, function(evt, item) {
	      evt.preventDefault(); // stop text selection
	      extendEvent(evt, item);
	      fire(internal, type, (item && item.datum) || {}, (item && item.mark && item.mark.group && item.mark.group.datum) || {}, evt);
	    });
	  });
	
	  // add external event listeners
	  dl.keys(external.handlers).forEach(function(type) {
	    if (typeof window === 'undefined') return; // No external support
	
	    var h = external.handlers[type],
	        t = type.split(':'), // --> no element pseudo-selectors
	        elt = (t[0] === 'window') ? [window] :
	              window.document.querySelectorAll(t[0]);
	
	    function handler(evt) {
	      extendEvent(evt);
	      fire(external, type, d3.select(this).datum(), this.parentNode && d3.select(this.parentNode).datum(), evt);
	    }
	
	    for (var i=0; i<elt.length; ++i) {
	      elt[i].addEventListener(t[1], handler);
	    }
	
	    h.elements = elt;
	    h.listener = handler;
	  });
	
	  // remove external event listeners
	  external.detach = function() {
	    dl.keys(external.handlers).forEach(function(type) {
	      var h = external.handlers[type],
	          t = type.split(':'),
	          elt = dl.array(h.elements);
	
	      for (var i=0; i<elt.length; ++i) {
	        elt[i].removeEventListener(t[1], h.listener);
	      }
	    });
	  };
	
	  // export detach method
	  return external.detach;
	
	  // -- helper functions -----
	
	  function extendEvent(evt, item) {
	    var mouse = d3.mouse((d3.event=evt, view.renderer().scene())),
	        pad = view.padding(),
	        names = {}, mark, group, i;
	
	    if (item) {
	      mark = item.mark;
	      group = mark.marktype === 'group' ? item : mark.group;
	      for (i=item; i!=null; i=i.mark.group) {
	        if (i.mark.def.name) {
	          names[i.mark.def.name] = i;
	        }
	      }
	    }
	    names.root = view.model().scene().items[0];
	
	    evt.vg = Object.create(vgEvent);
	    evt.vg.group = group;
	    evt.vg.item = item || {};
	    evt.vg.name = names;
	    evt.vg.x = mouse[0] - pad.left;
	    evt.vg.y = mouse[1] - pad.top;
	  }
	
	  function fire(registry, type, datum, parent, evt) {
	    var handlers = registry.handlers[type],
	        node = registry.nodes[type],
	        cs = df.ChangeSet.create(null, true),
	        filtered = false,
	        val, i, n, h;
	
	    function invoke(f) {
	      return !f.fn(datum, parent, evt);
	    }
	
	    for (i=0, n=handlers.length; i<n; ++i) {
	      h = handlers[i];
	      filtered = h.filters.some(invoke);
	      if (filtered) continue;
	
	      val = h.exp.fn(datum, parent, evt);
	      if (h.spec.scale) {
	        val = parseSignals.scale(model, h.spec, val, datum, evt);
	      }
	
	      if (val !== h.signal.value() || h.signal.verbose()) {
	        h.signal.value(val);
	        cs.signals[h.signal.name()] = 1;
	      }
	    }
	
	    model.propagate(cs, node);
	  }
	
	  function mergedStream(sig, selector, exp, spec) {
	    selector.forEach(function(s) {
	      if (s.event)       domEvent(sig, s, exp, spec);
	      else if (s.signal) signal(sig, s, exp, spec);
	      else if (s.start)  orderedStream(sig, s, exp, spec);
	      else if (s.stream) {
	        if (s.filters) s.stream.forEach(function(ms) {
	          ms.filters = dl.array(ms.filters).concat(s.filters);
	        });
	        mergedStream(sig, s.stream, exp, spec);
	      }
	    });
	  }
	
	  function domEvent(sig, selector, exp, spec) {
	    var evt = selector.event,
	        name = selector.name,
	        mark = selector.mark,
	        target   = selector.target,
	        filters  = dl.array(selector.filters),
	        registry = target ? external : internal,
	        type = target ? target+':'+evt : evt,
	        node = registry.nodes[type] || (registry.nodes[type] = new df.Node(model)),
	        handlers = registry.handlers[type] || (registry.handlers[type] = []);
	
	    if (name) {
	      filters.push('!!event.vg.name["' + name + '"]'); // Mimic event bubbling
	    } else if (mark) {
	      filters.push('event.vg.item.mark && event.vg.item.mark.marktype==='+dl.str(mark));
	    }
	
	    handlers.push({
	      signal: sig,
	      exp: exp,
	      spec: spec,
	      filters: filters.map(function(f) { return model.expr(f); })
	    });
	
	    node.addListener(sig);
	  }
	
	  function signal(sig, selector, exp, spec) {
	    var n = sig.name(), s = model.signal(n+EVALUATOR, null);
	    s.evaluate = function(input) {
	      if (!input.signals[selector.signal]) return model.doNotPropagate;
	      var val = exp.fn();
	      if (spec.scale) {
	        val = parseSignals.scale(model, spec, val);
	      }
	
	      if (val !== sig.value() || sig.verbose()) {
	        sig.value(val);
	        input.signals[n] = 1;
	        input.reflow = true;
	      }
	
	      return input;
	    };
	    s.dependency(df.Dependencies.SIGNALS, selector.signal);
	    s.addListener(sig);
	    model.signal(selector.signal).addListener(s);
	  }
	
	  function orderedStream(sig, selector, exp, spec) {
	    var name = sig.name(),
	        gk = name + GATEKEEPER,
	        middle  = selector.middle,
	        filters = middle.filters || (middle.filters = []),
	        gatekeeper = model.signal(gk) || model.signal(gk, false);
	
	    // Register an anonymous signal to act as a gatekeeper. Its value is
	    // true or false depending on whether the start or end streams occur.
	    // The middle signal then simply filters for the gatekeeper's value.
	    mergedStream(gatekeeper, [selector.start], trueFn, {});
	    mergedStream(gatekeeper, [selector.end], falseFn, {});
	
	    filters.push(gatekeeper.name());
	    mergedStream(sig, [selector.middle], exp, spec);
	  }
	}
	
	module.exports = parseStreams;
	parseStreams.schema = {
	  "defs": {
	    "streams": {
	      "type": "array",
	      "items": {
	        "type": "object",
	
	        "properties": {
	          "type": {"type": "string"},
	          "expr": {"type": "string"},
	          "scale": {"$ref": "#/refs/scopedScale"}
	        },
	
	        "additionalProperties": false,
	        "required": ["type", "expr"]
	      }
	    }
	  }
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/parse/streams.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/scene/Transition.js **/
jupyter.define('vega@2.6.3/src/scene/Transition.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    bound = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').bound,
	    Tuple = __jupyter_require__('vega-dataflow@^1.4.0/src/index.js').Tuple,
	    Status = __jupyter_require__('vega@~2.6.3/src/scene/Builder.js').STATUS;
	
	function Transition(duration, ease) {
	  this.duration = duration || 500;
	  this.ease = ease && d3.ease(ease) || d3.ease('cubic-in-out');
	  this.updates = {next: null};
	}
	
	var prototype = Transition.prototype;
	
	var skip = {
	  'text': 1,
	  'url':  1
	};
	
	prototype.interpolate = function(item, values) {
	  var key, curr, next, interp, list = null;
	
	  for (key in values) {
	    curr = item[key];
	    next = values[key];
	    if (curr !== next) {
	      if (skip[key] || curr === undefined) {
	        // skip interpolation for specific keys or undefined start values
	        Tuple.set(item, key, next);
	      } else if (typeof curr === 'number' && !isFinite(curr)) {
	        // for NaN or infinite numeric values, skip to final value
	        Tuple.set(item, key, next);
	      } else {
	        // otherwise lookup interpolator
	        interp = d3.interpolate(curr, next);
	        interp.property = key;
	        (list || (list=[])).push(interp);
	      }
	    }
	  }
	
	  if (list === null && item.status === Status.EXIT) {
	    list = []; // ensure exiting items are included
	  }
	
	  if (list != null) {
	    list.item = item;
	    list.ease = item.mark.ease || this.ease;
	    list.next = this.updates.next;
	    this.updates.next = list;
	  }
	  return this;
	};
	
	prototype.start = function(callback) {
	  var t = this, prev = t.updates, curr = prev.next;
	  for (; curr!=null; prev=curr, curr=prev.next) {
	    if (curr.item.status === Status.EXIT) {
	      // Only mark item as exited when it is removed.
	      curr.item.status = Status.UPDATE;
	      curr.remove = true;
	    }
	  }
	  t.callback = callback;
	  d3.timer(function(elapsed) { return step.call(t, elapsed); });
	};
	
	function step(elapsed) {
	  var list = this.updates, prev = list, curr = prev.next,
	      duration = this.duration,
	      item, delay, f, e, i, n, stop = true;
	
	  for (; curr!=null; prev=curr, curr=prev.next) {
	    item = curr.item;
	    delay = item.delay || 0;
	
	    f = (elapsed - delay) / duration;
	    if (f < 0) { stop = false; continue; }
	    if (f > 1) f = 1;
	    e = curr.ease(f);
	
	    for (i=0, n=curr.length; i<n; ++i) {
	      item[curr[i].property] = curr[i](e);
	    }
	    item.touch();
	    bound.item(item);
	
	    if (f === 1) {
	      if (curr.remove) {
	        item.status = Status.EXIT;
	        item.remove();
	      }
	      prev.next = curr.next;
	      curr = prev;
	    } else {
	      stop = false;
	    }
	  }
	
	  this.callback();
	  return stop;
	}
	
	module.exports = Transition;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/scene/Transition.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/core/HeadlessView.js **/
jupyter.define('vega@2.6.3/src/core/HeadlessView.js', function (module, exports, __jupyter_require__) {
	var sg = __jupyter_require__('vega-scenegraph@^1.0.16/src/index.js').render,
	    canvas = sg.canvas,
	    svg = sg.svg.string,
	    View = __jupyter_require__('vega@~2.6.3/src/core/View.js');
	
	function HeadlessView(width, height, model) {
	  View.call(this, width, height, model);
	  this._type = 'canvas';
	  this._renderers = {canvas: canvas, svg: svg};
	}
	
	var prototype = (HeadlessView.prototype = new View());
	
	prototype.renderer = function(type) {
	  if(type) this._type = type;
	  return View.prototype.renderer.apply(this, arguments);
	};
	
	prototype.canvas = function() {
	  return (this._type === 'canvas') ? this._renderer.canvas() : null;
	};
	
	prototype.canvasAsync = function(callback) {
	  var r = this._renderer, view = this;
	
	  function wait() {
	    if (r.pendingImages() === 0) {
	      view.render(); // re-render with all images
	      callback(view.canvas());
	    } else {
	      setTimeout(wait, 10);
	    }
	  }
	
	  // if images loading, poll until ready
	  if (this._type !== 'canvas') return null;
	  if (r.pendingImages() > 0) { wait(); } else { callback(this.canvas()); }
	};
	
	prototype.svg = function() {
	  return (this._type === 'svg') ? this._renderer.svg() : null;
	};
	
	prototype.initialize = function() {
	  var w = this._width,
	      h = this._height,
	      bg  = this._bgcolor,
	      pad = this._padding,
	      config = this.model().config();
	
	  if (this._viewport) {
	    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);
	    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);
	  }
	
	  this._renderer = (this._renderer || new this._io.Renderer(config.load))
	    .initialize(null, w, h, pad)
	    .background(bg);
	
	  return this;
	};
	
	module.exports = HeadlessView;
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/core/HeadlessView.js **/


/** START DEFINE BLOCK for vega@2.6.3/src/core/schema.js **/
jupyter.define('vega@2.6.3/src/core/schema.js', function (module, exports, __jupyter_require__) {
	var dl = __jupyter_require__('datalib@^1.7.1/src/index.js'),
	    parse = __jupyter_require__('vega@~2.6.3/src/parse/index.js'),
	    Scale = __jupyter_require__('vega@~2.6.3/src/scene/Scale.js'),
	    config = __jupyter_require__('vega@~2.6.3/src/core/config.js');
	
	function compile(module, opt, schema) {
	  var s = module.schema;
	  if (!s) return;
	  if (s.refs) dl.extend(schema.refs, s.refs);
	  if (s.defs) dl.extend(schema.defs, s.defs);
	}
	
	module.exports = function(opt) {
	  var schema = null;
	  opt = opt || {};
	
	  // Compile if we're not loading the schema from a URL.
	  // Load from a URL to extend the existing base schema.
	  if (opt.url) {
	    schema = dl.json(dl.extend({url: opt.url}, config.load));
	  } else {
	    schema = {
	      "$schema": "http://json-schema.org/draft-04/schema#",
	      "title": "Vega Visualization Specification Language",
	      "defs": {},
	      "refs": {},
	      "$ref": "#/defs/spec"
	    };
	
	    dl.keys(parse).forEach(function(k) { compile(parse[k], opt, schema); });
	
	    // Scales aren't in the parser, add schema manually
	    compile(Scale, opt, schema);
	  }
	
	  // Extend schema to support custom mark properties or property sets.
	  if (opt.properties) dl.keys(opt.properties).forEach(function(k) {
	    schema.defs.propset.properties[k] = {"$ref": "#/refs/"+opt.properties[k]+"Value"};
	  });
	
	  if (opt.propertySets) dl.keys(opt.propertySets).forEach(function(k) {
	    schema.defs.mark.properties.properties.properties[k] = {"$ref": "#/defs/propset"};
	  });
	
	  return schema;
	};
	
})
/** END DEFINE BLOCK for vega@2.6.3/src/core/schema.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/vl.js **/
jupyter.define('vega-lite@1.2.0/src/vl.js', function (module, exports, __jupyter_require__) {
	"use strict";
	exports.axis = __jupyter_require__('vega-lite@~1.2.0/src/axis.js');
	exports.aggregate = __jupyter_require__('vega-lite@~1.2.0/src/aggregate.js');
	exports.bin = __jupyter_require__('vega-lite@~1.2.0/src/bin.js');
	exports.channel = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	exports.compile = __jupyter_require__('vega-lite@~1.2.0/src/compile/compile.js').compile;
	exports.config = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	exports.data = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	exports.datetime = __jupyter_require__('vega-lite@~1.2.0/src/datetime.js');
	exports.encoding = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	exports.facet = __jupyter_require__('vega-lite@~1.2.0/src/facet.js');
	exports.fieldDef = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	exports.legend = __jupyter_require__('vega-lite@~1.2.0/src/legend.js');
	exports.mark = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	exports.scale = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	exports.shorthand = __jupyter_require__('vega-lite@~1.2.0/src/shorthand.js');
	exports.sort = __jupyter_require__('vega-lite@~1.2.0/src/sort.js');
	exports.spec = __jupyter_require__('vega-lite@~1.2.0/src/spec.js');
	exports.stack = __jupyter_require__('vega-lite@~1.2.0/src/stack.js');
	exports.timeUnit = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	exports.transform = __jupyter_require__('vega-lite@~1.2.0/src/transform.js');
	exports.type = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	exports.util = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	exports.validate = __jupyter_require__('vega-lite@~1.2.0/src/validate.js');
	exports.version = '__VERSION__';
	//# sourceMappingURL=vl.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/vl.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/axis.js **/
jupyter.define('vega-lite@1.2.0/src/axis.js', function (module, exports, __jupyter_require__) {
	"use strict";
	(function (AxisOrient) {
	    AxisOrient[AxisOrient["TOP"] = 'top'] = "TOP";
	    AxisOrient[AxisOrient["RIGHT"] = 'right'] = "RIGHT";
	    AxisOrient[AxisOrient["LEFT"] = 'left'] = "LEFT";
	    AxisOrient[AxisOrient["BOTTOM"] = 'bottom'] = "BOTTOM";
	})(exports.AxisOrient || (exports.AxisOrient = {}));
	var AxisOrient = exports.AxisOrient;
	exports.defaultAxisConfig = {
	    offset: undefined,
	    grid: undefined,
	    labels: true,
	    labelMaxLength: 25,
	    tickSize: undefined,
	    characterWidth: 6
	};
	exports.defaultFacetAxisConfig = {
	    axisWidth: 0,
	    labels: true,
	    grid: false,
	    tickSize: 0
	};
	//# sourceMappingURL=axis.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/axis.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/aggregate.js **/
jupyter.define('vega-lite@1.2.0/src/aggregate.js', function (module, exports, __jupyter_require__) {
	"use strict";
	(function (AggregateOp) {
	    AggregateOp[AggregateOp["VALUES"] = 'values'] = "VALUES";
	    AggregateOp[AggregateOp["COUNT"] = 'count'] = "COUNT";
	    AggregateOp[AggregateOp["VALID"] = 'valid'] = "VALID";
	    AggregateOp[AggregateOp["MISSING"] = 'missing'] = "MISSING";
	    AggregateOp[AggregateOp["DISTINCT"] = 'distinct'] = "DISTINCT";
	    AggregateOp[AggregateOp["SUM"] = 'sum'] = "SUM";
	    AggregateOp[AggregateOp["MEAN"] = 'mean'] = "MEAN";
	    AggregateOp[AggregateOp["AVERAGE"] = 'average'] = "AVERAGE";
	    AggregateOp[AggregateOp["VARIANCE"] = 'variance'] = "VARIANCE";
	    AggregateOp[AggregateOp["VARIANCEP"] = 'variancep'] = "VARIANCEP";
	    AggregateOp[AggregateOp["STDEV"] = 'stdev'] = "STDEV";
	    AggregateOp[AggregateOp["STDEVP"] = 'stdevp'] = "STDEVP";
	    AggregateOp[AggregateOp["MEDIAN"] = 'median'] = "MEDIAN";
	    AggregateOp[AggregateOp["Q1"] = 'q1'] = "Q1";
	    AggregateOp[AggregateOp["Q3"] = 'q3'] = "Q3";
	    AggregateOp[AggregateOp["MODESKEW"] = 'modeskew'] = "MODESKEW";
	    AggregateOp[AggregateOp["MIN"] = 'min'] = "MIN";
	    AggregateOp[AggregateOp["MAX"] = 'max'] = "MAX";
	    AggregateOp[AggregateOp["ARGMIN"] = 'argmin'] = "ARGMIN";
	    AggregateOp[AggregateOp["ARGMAX"] = 'argmax'] = "ARGMAX";
	})(exports.AggregateOp || (exports.AggregateOp = {}));
	var AggregateOp = exports.AggregateOp;
	exports.AGGREGATE_OPS = [
	    AggregateOp.VALUES,
	    AggregateOp.COUNT,
	    AggregateOp.VALID,
	    AggregateOp.MISSING,
	    AggregateOp.DISTINCT,
	    AggregateOp.SUM,
	    AggregateOp.MEAN,
	    AggregateOp.AVERAGE,
	    AggregateOp.VARIANCE,
	    AggregateOp.VARIANCEP,
	    AggregateOp.STDEV,
	    AggregateOp.STDEVP,
	    AggregateOp.MEDIAN,
	    AggregateOp.Q1,
	    AggregateOp.Q3,
	    AggregateOp.MODESKEW,
	    AggregateOp.MIN,
	    AggregateOp.MAX,
	    AggregateOp.ARGMIN,
	    AggregateOp.ARGMAX,
	];
	exports.SUM_OPS = [
	    AggregateOp.COUNT,
	    AggregateOp.SUM,
	    AggregateOp.DISTINCT
	];
	exports.SHARED_DOMAIN_OPS = [
	    AggregateOp.MEAN,
	    AggregateOp.AVERAGE,
	    AggregateOp.STDEV,
	    AggregateOp.STDEVP,
	    AggregateOp.MEDIAN,
	    AggregateOp.Q1,
	    AggregateOp.Q3,
	    AggregateOp.MIN,
	    AggregateOp.MAX,
	];
	//# sourceMappingURL=aggregate.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/aggregate.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/bin.js **/
jupyter.define('vega-lite@1.2.0/src/bin.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	function autoMaxBins(channel) {
	    switch (channel) {
	        case channel_1.ROW:
	        case channel_1.COLUMN:
	        case channel_1.SIZE:
	        case channel_1.SHAPE:
	            return 6;
	        default:
	            return 10;
	    }
	}
	exports.autoMaxBins = autoMaxBins;
	//# sourceMappingURL=bin.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/bin.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/channel.js **/
jupyter.define('vega-lite@1.2.0/src/channel.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	(function (Channel) {
	    Channel[Channel["X"] = 'x'] = "X";
	    Channel[Channel["Y"] = 'y'] = "Y";
	    Channel[Channel["X2"] = 'x2'] = "X2";
	    Channel[Channel["Y2"] = 'y2'] = "Y2";
	    Channel[Channel["ROW"] = 'row'] = "ROW";
	    Channel[Channel["COLUMN"] = 'column'] = "COLUMN";
	    Channel[Channel["SHAPE"] = 'shape'] = "SHAPE";
	    Channel[Channel["SIZE"] = 'size'] = "SIZE";
	    Channel[Channel["COLOR"] = 'color'] = "COLOR";
	    Channel[Channel["TEXT"] = 'text'] = "TEXT";
	    Channel[Channel["DETAIL"] = 'detail'] = "DETAIL";
	    Channel[Channel["LABEL"] = 'label'] = "LABEL";
	    Channel[Channel["PATH"] = 'path'] = "PATH";
	    Channel[Channel["ORDER"] = 'order'] = "ORDER";
	    Channel[Channel["OPACITY"] = 'opacity'] = "OPACITY";
	})(exports.Channel || (exports.Channel = {}));
	var Channel = exports.Channel;
	exports.X = Channel.X;
	exports.Y = Channel.Y;
	exports.X2 = Channel.X2;
	exports.Y2 = Channel.Y2;
	exports.ROW = Channel.ROW;
	exports.COLUMN = Channel.COLUMN;
	exports.SHAPE = Channel.SHAPE;
	exports.SIZE = Channel.SIZE;
	exports.COLOR = Channel.COLOR;
	exports.TEXT = Channel.TEXT;
	exports.DETAIL = Channel.DETAIL;
	exports.LABEL = Channel.LABEL;
	exports.PATH = Channel.PATH;
	exports.ORDER = Channel.ORDER;
	exports.OPACITY = Channel.OPACITY;
	exports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.PATH, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL, exports.LABEL];
	exports.UNIT_CHANNELS = util_1.without(exports.CHANNELS, [exports.ROW, exports.COLUMN]);
	exports.UNIT_SCALE_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.PATH, exports.ORDER, exports.DETAIL, exports.TEXT, exports.LABEL, exports.X2, exports.Y2]);
	exports.NONSPATIAL_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);
	exports.NONSPATIAL_SCALE_CHANNELS = util_1.without(exports.UNIT_SCALE_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);
	exports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];
	;
	function supportMark(channel, mark) {
	    return !!getSupportedMark(channel)[mark];
	}
	exports.supportMark = supportMark;
	function getSupportedMark(channel) {
	    switch (channel) {
	        case exports.X:
	        case exports.Y:
	        case exports.COLOR:
	        case exports.DETAIL:
	        case exports.ORDER:
	        case exports.OPACITY:
	        case exports.ROW:
	        case exports.COLUMN:
	            return {
	                point: true, tick: true, rule: true, circle: true, square: true,
	                bar: true, line: true, area: true, text: true
	            };
	        case exports.X2:
	        case exports.Y2:
	            return {
	                rule: true, bar: true, area: true
	            };
	        case exports.SIZE:
	            return {
	                point: true, tick: true, rule: true, circle: true, square: true,
	                bar: true, text: true
	            };
	        case exports.SHAPE:
	            return { point: true };
	        case exports.TEXT:
	            return { text: true };
	        case exports.PATH:
	            return { line: true };
	    }
	    return {};
	}
	exports.getSupportedMark = getSupportedMark;
	;
	function getSupportedRole(channel) {
	    switch (channel) {
	        case exports.X:
	        case exports.Y:
	        case exports.COLOR:
	        case exports.OPACITY:
	        case exports.LABEL:
	        case exports.DETAIL:
	            return {
	                measure: true,
	                dimension: true
	            };
	        case exports.ROW:
	        case exports.COLUMN:
	        case exports.SHAPE:
	            return {
	                measure: false,
	                dimension: true
	            };
	        case exports.X2:
	        case exports.Y2:
	        case exports.SIZE:
	        case exports.TEXT:
	            return {
	                measure: true,
	                dimension: false
	            };
	        case exports.PATH:
	            return {
	                measure: false,
	                dimension: true
	            };
	    }
	    throw new Error('Invalid encoding channel' + channel);
	}
	exports.getSupportedRole = getSupportedRole;
	function hasScale(channel) {
	    return !util_1.contains([exports.DETAIL, exports.PATH, exports.TEXT, exports.LABEL, exports.ORDER], channel);
	}
	exports.hasScale = hasScale;
	//# sourceMappingURL=channel.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/channel.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/util.js **/
jupyter.define('vega-lite@1.2.0/src/util.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var stringify = __jupyter_require__('json-stable-stringify@~1.0.1/index.js');
	var util_1 = __jupyter_require__('datalib@~1.7.0/src/util.js');
	exports.keys = util_1.keys;
	exports.extend = util_1.extend;
	exports.duplicate = util_1.duplicate;
	exports.isArray = util_1.isArray;
	exports.vals = util_1.vals;
	exports.truncate = util_1.truncate;
	exports.toMap = util_1.toMap;
	exports.isObject = util_1.isObject;
	exports.isString = util_1.isString;
	exports.isNumber = util_1.isNumber;
	exports.isBoolean = util_1.isBoolean;
	var util_2 = __jupyter_require__('datalib@~1.7.0/src/util.js');
	var util_3 = __jupyter_require__('datalib@~1.7.0/src/util.js');
	function pick(obj, props) {
	    var copy = {};
	    props.forEach(function (prop) {
	        if (obj.hasOwnProperty(prop)) {
	            copy[prop] = obj[prop];
	        }
	    });
	    return copy;
	}
	exports.pick = pick;
	function range(start, stop, step) {
	    if (arguments.length < 3) {
	        step = 1;
	        if (arguments.length < 2) {
	            stop = start;
	            start = 0;
	        }
	    }
	    if ((stop - start) / step === Infinity) {
	        throw new Error('Infinite range');
	    }
	    var range = [], i = -1, j;
	    if (step < 0) {
	        while ((j = start + step * ++i) > stop) {
	            range.push(j);
	        }
	    }
	    else {
	        while ((j = start + step * ++i) < stop) {
	            range.push(j);
	        }
	    }
	    return range;
	}
	exports.range = range;
	;
	function omit(obj, props) {
	    var copy = util_2.duplicate(obj);
	    props.forEach(function (prop) {
	        delete copy[prop];
	    });
	    return copy;
	}
	exports.omit = omit;
	function hash(a) {
	    if (util_3.isString(a) || util_3.isNumber(a) || util_3.isBoolean(a)) {
	        return String(a);
	    }
	    return stringify(a);
	}
	exports.hash = hash;
	function contains(array, item) {
	    return array.indexOf(item) > -1;
	}
	exports.contains = contains;
	function without(array, excludedItems) {
	    return array.filter(function (item) {
	        return !contains(excludedItems, item);
	    });
	}
	exports.without = without;
	function union(array, other) {
	    return array.concat(without(other, array));
	}
	exports.union = union;
	function forEach(obj, f, thisArg) {
	    if (obj.forEach) {
	        obj.forEach.call(thisArg, f);
	    }
	    else {
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                f.call(thisArg, obj[k], k, obj);
	            }
	        }
	    }
	}
	exports.forEach = forEach;
	function reduce(obj, f, init, thisArg) {
	    if (obj.reduce) {
	        return obj.reduce.call(thisArg, f, init);
	    }
	    else {
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                init = f.call(thisArg, init, obj[k], k, obj);
	            }
	        }
	        return init;
	    }
	}
	exports.reduce = reduce;
	function map(obj, f, thisArg) {
	    if (obj.map) {
	        return obj.map.call(thisArg, f);
	    }
	    else {
	        var output = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                output.push(f.call(thisArg, obj[k], k, obj));
	            }
	        }
	        return output;
	    }
	}
	exports.map = map;
	function some(arr, f) {
	    var i = 0;
	    for (var k = 0; k < arr.length; k++) {
	        if (f(arr[k], k, i++)) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.some = some;
	function every(arr, f) {
	    var i = 0;
	    for (var k = 0; k < arr.length; k++) {
	        if (!f(arr[k], k, i++)) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.every = every;
	function flatten(arrays) {
	    return [].concat.apply([], arrays);
	}
	exports.flatten = flatten;
	function mergeDeep(dest) {
	    var src = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        src[_i - 1] = arguments[_i];
	    }
	    for (var i = 0; i < src.length; i++) {
	        dest = deepMerge_(dest, src[i]);
	    }
	    return dest;
	}
	exports.mergeDeep = mergeDeep;
	;
	function deepMerge_(dest, src) {
	    if (typeof src !== 'object' || src === null) {
	        return dest;
	    }
	    for (var p in src) {
	        if (!src.hasOwnProperty(p)) {
	            continue;
	        }
	        if (src[p] === undefined) {
	            continue;
	        }
	        if (typeof src[p] !== 'object' || src[p] === null) {
	            dest[p] = src[p];
	        }
	        else if (typeof dest[p] !== 'object' || dest[p] === null) {
	            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);
	        }
	        else {
	            mergeDeep(dest[p], src[p]);
	        }
	    }
	    return dest;
	}
	function unique(values, f) {
	    var results = [];
	    var u = {}, v, i, n;
	    for (i = 0, n = values.length; i < n; ++i) {
	        v = f ? f(values[i]) : values[i];
	        if (v in u) {
	            continue;
	        }
	        u[v] = 1;
	        results.push(values[i]);
	    }
	    return results;
	}
	exports.unique = unique;
	;
	function warning(message) {
	    console.warn('[VL Warning]', message);
	}
	exports.warning = warning;
	function error(message) {
	    console.error('[VL Error]', message);
	}
	exports.error = error;
	function differ(dict, other) {
	    for (var key in dict) {
	        if (dict.hasOwnProperty(key)) {
	            if (other[key] && dict[key] && other[key] !== dict[key]) {
	                return true;
	            }
	        }
	    }
	    return false;
	}
	exports.differ = differ;
	//# sourceMappingURL=util.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/util.js **/


/** START DEFINE BLOCK for json-stable-stringify@1.0.1/index.js **/
jupyter.define('json-stable-stringify@1.0.1/index.js', function (module, exports, __jupyter_require__) {
	var json = typeof JSON !== 'undefined' ? JSON : __jupyter_require__('jsonify@~0.0.0/index.js');
	
	module.exports = function (obj, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var space = opts.space || '';
	    if (typeof space === 'number') space = Array(space+1).join(' ');
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var replacer = opts.replacer || function(key, value) { return value; };
	
	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);
	
	    var seen = [];
	    return (function stringify (parent, key, node, level) {
	        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
	        var colonSeparator = space ? ': ' : ':';
	
	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }
	
	        node = replacer.call(parent, key, node);
	
	        if (node === undefined) {
	            return;
	        }
	        if (typeof node !== 'object' || node === null) {
	            return json.stringify(node);
	        }
	        if (isArray(node)) {
	            var out = [];
	            for (var i = 0; i < node.length; i++) {
	                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
	                out.push(indent + space + item);
	            }
	            return '[' + out.join(',') + indent + ']';
	        }
	        else {
	            if (seen.indexOf(node) !== -1) {
	                if (cycles) return json.stringify('__cycle__');
	                throw new TypeError('Converting circular structure to JSON');
	            }
	            else seen.push(node);
	
	            var keys = objectKeys(node).sort(cmp && cmp(node));
	            var out = [];
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                var value = stringify(node, key, node[key], level+1);
	
	                if(!value) continue;
	
	                var keyValue = json.stringify(key)
	                    + colonSeparator
	                    + value;
	                ;
	                out.push(indent + space + keyValue);
	            }
	            seen.splice(seen.indexOf(node), 1);
	            return '{' + out.join(',') + indent + '}';
	        }
	    })({ '': obj }, '', obj, 0);
	};
	
	var isArray = Array.isArray || function (x) {
	    return {}.toString.call(x) === '[object Array]';
	};
	
	var objectKeys = Object.keys || function (obj) {
	    var has = Object.prototype.hasOwnProperty || function () { return true };
	    var keys = [];
	    for (var key in obj) {
	        if (has.call(obj, key)) keys.push(key);
	    }
	    return keys;
	};
	
})
/** END DEFINE BLOCK for json-stable-stringify@1.0.1/index.js **/


/** START DEFINE BLOCK for jsonify@0.0.0/index.js **/
jupyter.define('jsonify@0.0.0/index.js', function (module, exports, __jupyter_require__) {
	exports.parse = __jupyter_require__('jsonify@~0.0.0/lib/parse.js');
	exports.stringify = __jupyter_require__('jsonify@~0.0.0/lib/stringify.js');
	
})
/** END DEFINE BLOCK for jsonify@0.0.0/index.js **/


/** START DEFINE BLOCK for jsonify@0.0.0/lib/parse.js **/
jupyter.define('jsonify@0.0.0/lib/parse.js', function (module, exports, __jupyter_require__) {
	var at, // The index of the current character
	    ch, // The current character
	    escapee = {
	        '"':  '"',
	        '\\': '\\',
	        '/':  '/',
	        b:    '\b',
	        f:    '\f',
	        n:    '\n',
	        r:    '\r',
	        t:    '\t'
	    },
	    text,
	
	    error = function (m) {
	        // Call error when something is wrong.
	        throw {
	            name:    'SyntaxError',
	            message: m,
	            at:      at,
	            text:    text
	        };
	    },
	    
	    next = function (c) {
	        // If a c parameter is provided, verify that it matches the current character.
	        if (c && c !== ch) {
	            error("Expected '" + c + "' instead of '" + ch + "'");
	        }
	        
	        // Get the next character. When there are no more characters,
	        // return the empty string.
	        
	        ch = text.charAt(at);
	        at += 1;
	        return ch;
	    },
	    
	    number = function () {
	        // Parse a number value.
	        var number,
	            string = '';
	        
	        if (ch === '-') {
	            string = '-';
	            next('-');
	        }
	        while (ch >= '0' && ch <= '9') {
	            string += ch;
	            next();
	        }
	        if (ch === '.') {
	            string += '.';
	            while (next() && ch >= '0' && ch <= '9') {
	                string += ch;
	            }
	        }
	        if (ch === 'e' || ch === 'E') {
	            string += ch;
	            next();
	            if (ch === '-' || ch === '+') {
	                string += ch;
	                next();
	            }
	            while (ch >= '0' && ch <= '9') {
	                string += ch;
	                next();
	            }
	        }
	        number = +string;
	        if (!isFinite(number)) {
	            error("Bad number");
	        } else {
	            return number;
	        }
	    },
	    
	    string = function () {
	        // Parse a string value.
	        var hex,
	            i,
	            string = '',
	            uffff;
	        
	        // When parsing for string values, we must look for " and \ characters.
	        if (ch === '"') {
	            while (next()) {
	                if (ch === '"') {
	                    next();
	                    return string;
	                } else if (ch === '\\') {
	                    next();
	                    if (ch === 'u') {
	                        uffff = 0;
	                        for (i = 0; i < 4; i += 1) {
	                            hex = parseInt(next(), 16);
	                            if (!isFinite(hex)) {
	                                break;
	                            }
	                            uffff = uffff * 16 + hex;
	                        }
	                        string += String.fromCharCode(uffff);
	                    } else if (typeof escapee[ch] === 'string') {
	                        string += escapee[ch];
	                    } else {
	                        break;
	                    }
	                } else {
	                    string += ch;
	                }
	            }
	        }
	        error("Bad string");
	    },
	
	    white = function () {
	
	// Skip whitespace.
	
	        while (ch && ch <= ' ') {
	            next();
	        }
	    },
	
	    word = function () {
	
	// true, false, or null.
	
	        switch (ch) {
	        case 't':
	            next('t');
	            next('r');
	            next('u');
	            next('e');
	            return true;
	        case 'f':
	            next('f');
	            next('a');
	            next('l');
	            next('s');
	            next('e');
	            return false;
	        case 'n':
	            next('n');
	            next('u');
	            next('l');
	            next('l');
	            return null;
	        }
	        error("Unexpected '" + ch + "'");
	    },
	
	    value,  // Place holder for the value function.
	
	    array = function () {
	
	// Parse an array value.
	
	        var array = [];
	
	        if (ch === '[') {
	            next('[');
	            white();
	            if (ch === ']') {
	                next(']');
	                return array;   // empty array
	            }
	            while (ch) {
	                array.push(value());
	                white();
	                if (ch === ']') {
	                    next(']');
	                    return array;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad array");
	    },
	
	    object = function () {
	
	// Parse an object value.
	
	        var key,
	            object = {};
	
	        if (ch === '{') {
	            next('{');
	            white();
	            if (ch === '}') {
	                next('}');
	                return object;   // empty object
	            }
	            while (ch) {
	                key = string();
	                white();
	                next(':');
	                if (Object.hasOwnProperty.call(object, key)) {
	                    error('Duplicate key "' + key + '"');
	                }
	                object[key] = value();
	                white();
	                if (ch === '}') {
	                    next('}');
	                    return object;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad object");
	    };
	
	value = function () {
	
	// Parse a JSON value. It could be an object, an array, a string, a number,
	// or a word.
	
	    white();
	    switch (ch) {
	    case '{':
	        return object();
	    case '[':
	        return array();
	    case '"':
	        return string();
	    case '-':
	        return number();
	    default:
	        return ch >= '0' && ch <= '9' ? number() : word();
	    }
	};
	
	// Return the json_parse function. It will have access to all of the above
	// functions and variables.
	
	module.exports = function (source, reviver) {
	    var result;
	    
	    text = source;
	    at = 0;
	    ch = ' ';
	    result = value();
	    white();
	    if (ch) {
	        error("Syntax error");
	    }
	
	    // If there is a reviver function, we recursively walk the new structure,
	    // passing each name/value pair to the reviver function for possible
	    // transformation, starting with a temporary root object that holds the result
	    // in an empty key. If there is not a reviver function, we simply return the
	    // result.
	
	    return typeof reviver === 'function' ? (function walk(holder, key) {
	        var k, v, value = holder[key];
	        if (value && typeof value === 'object') {
	            for (k in value) {
	                if (Object.prototype.hasOwnProperty.call(value, k)) {
	                    v = walk(value, k);
	                    if (v !== undefined) {
	                        value[k] = v;
	                    } else {
	                        delete value[k];
	                    }
	                }
	            }
	        }
	        return reviver.call(holder, key, value);
	    }({'': result}, '')) : result;
	};
	
})
/** END DEFINE BLOCK for jsonify@0.0.0/lib/parse.js **/


/** START DEFINE BLOCK for jsonify@0.0.0/lib/stringify.js **/
jupyter.define('jsonify@0.0.0/lib/stringify.js', function (module, exports, __jupyter_require__) {
	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    gap,
	    indent,
	    meta = {    // table of character substitutions
	        '\b': '\\b',
	        '\t': '\\t',
	        '\n': '\\n',
	        '\f': '\\f',
	        '\r': '\\r',
	        '"' : '\\"',
	        '\\': '\\\\'
	    },
	    rep;
	
	function quote(string) {
	    // If the string contains no control characters, no quote characters, and no
	    // backslash characters, then we can safely slap some quotes around it.
	    // Otherwise we must also replace the offending characters with safe escape
	    // sequences.
	    
	    escapable.lastIndex = 0;
	    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	        var c = meta[a];
	        return typeof c === 'string' ? c :
	            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    }) + '"' : '"' + string + '"';
	}
	
	function str(key, holder) {
	    // Produce a string from holder[key].
	    var i,          // The loop counter.
	        k,          // The member key.
	        v,          // The member value.
	        length,
	        mind = gap,
	        partial,
	        value = holder[key];
	    
	    // If the value has a toJSON method, call it to obtain a replacement value.
	    if (value && typeof value === 'object' &&
	            typeof value.toJSON === 'function') {
	        value = value.toJSON(key);
	    }
	    
	    // If we were called with a replacer function, then call the replacer to
	    // obtain a replacement value.
	    if (typeof rep === 'function') {
	        value = rep.call(holder, key, value);
	    }
	    
	    // What happens next depends on the value's type.
	    switch (typeof value) {
	        case 'string':
	            return quote(value);
	        
	        case 'number':
	            // JSON numbers must be finite. Encode non-finite numbers as null.
	            return isFinite(value) ? String(value) : 'null';
	        
	        case 'boolean':
	        case 'null':
	            // If the value is a boolean or null, convert it to a string. Note:
	            // typeof null does not produce 'null'. The case is included here in
	            // the remote chance that this gets fixed someday.
	            return String(value);
	            
	        case 'object':
	            if (!value) return 'null';
	            gap += indent;
	            partial = [];
	            
	            // Array.isArray
	            if (Object.prototype.toString.apply(value) === '[object Array]') {
	                length = value.length;
	                for (i = 0; i < length; i += 1) {
	                    partial[i] = str(i, value) || 'null';
	                }
	                
	                // Join all of the elements together, separated with commas, and
	                // wrap them in brackets.
	                v = partial.length === 0 ? '[]' : gap ?
	                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
	                    '[' + partial.join(',') + ']';
	                gap = mind;
	                return v;
	            }
	            
	            // If the replacer is an array, use it to select the members to be
	            // stringified.
	            if (rep && typeof rep === 'object') {
	                length = rep.length;
	                for (i = 0; i < length; i += 1) {
	                    k = rep[i];
	                    if (typeof k === 'string') {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            else {
	                // Otherwise, iterate through all of the keys in the object.
	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            
	        // Join all of the member texts together, separated with commas,
	        // and wrap them in braces.
	
	        v = partial.length === 0 ? '{}' : gap ?
	            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
	            '{' + partial.join(',') + '}';
	        gap = mind;
	        return v;
	    }
	}
	
	module.exports = function (value, replacer, space) {
	    var i;
	    gap = '';
	    indent = '';
	    
	    // If the space parameter is a number, make an indent string containing that
	    // many spaces.
	    if (typeof space === 'number') {
	        for (i = 0; i < space; i += 1) {
	            indent += ' ';
	        }
	    }
	    // If the space parameter is a string, it will be used as the indent string.
	    else if (typeof space === 'string') {
	        indent = space;
	    }
	
	    // If there is a replacer, it must be a function or an array.
	    // Otherwise, throw an error.
	    rep = replacer;
	    if (replacer && typeof replacer !== 'function'
	    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
	        throw new Error('JSON.stringify');
	    }
	    
	    // Make a fake root object containing our value under the key of ''.
	    // Return the result of stringifying the value.
	    return str('', {'': value});
	};
	
})
/** END DEFINE BLOCK for jsonify@0.0.0/lib/stringify.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/compile.js **/
jupyter.define('vega-lite@1.2.0/src/compile/compile.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var spec_1 = __jupyter_require__('vega-lite@~1.2.0/src/spec.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	function compile(inputSpec) {
	    var spec = spec_1.normalize(inputSpec);
	    var model = common_1.buildModel(spec, null, '');
	    model.parse();
	    return assemble(model);
	}
	exports.compile = compile;
	function assemble(model) {
	    var config = model.config();
	    var output = util_1.extend({
	        width: 1,
	        height: 1,
	        padding: 'auto'
	    }, config.viewport ? { viewport: config.viewport } : {}, config.background ? { background: config.background } : {}, {
	        data: [].concat(model.assembleData([]), model.assembleLayout([])),
	        marks: [assembleRootGroup(model)]
	    });
	    return {
	        spec: output
	    };
	}
	function assembleRootGroup(model) {
	    var rootGroup = util_1.extend({
	        name: model.name('root'),
	        type: 'group',
	    }, model.description() ? { description: model.description() } : {}, {
	        from: { data: data_1.LAYOUT },
	        properties: {
	            update: util_1.extend({
	                width: { field: 'width' },
	                height: { field: 'height' }
	            }, model.assembleParentGroupProperties(model.config().cell))
	        }
	    });
	    return util_1.extend(rootGroup, model.assembleGroup());
	}
	exports.assembleRootGroup = assembleRootGroup;
	//# sourceMappingURL=compile.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/compile.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/data.js **/
jupyter.define('vega-lite@1.2.0/src/data.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	(function (DataFormatType) {
	    DataFormatType[DataFormatType["JSON"] = 'json'] = "JSON";
	    DataFormatType[DataFormatType["CSV"] = 'csv'] = "CSV";
	    DataFormatType[DataFormatType["TSV"] = 'tsv'] = "TSV";
	    DataFormatType[DataFormatType["TOPOJSON"] = 'topojson'] = "TOPOJSON";
	})(exports.DataFormatType || (exports.DataFormatType = {}));
	var DataFormatType = exports.DataFormatType;
	(function (DataTable) {
	    DataTable[DataTable["SOURCE"] = 'source'] = "SOURCE";
	    DataTable[DataTable["SUMMARY"] = 'summary'] = "SUMMARY";
	    DataTable[DataTable["STACKED_SCALE"] = 'stacked_scale'] = "STACKED_SCALE";
	    DataTable[DataTable["LAYOUT"] = 'layout'] = "LAYOUT";
	})(exports.DataTable || (exports.DataTable = {}));
	var DataTable = exports.DataTable;
	exports.SUMMARY = DataTable.SUMMARY;
	exports.SOURCE = DataTable.SOURCE;
	exports.STACKED_SCALE = DataTable.STACKED_SCALE;
	exports.LAYOUT = DataTable.LAYOUT;
	exports.types = {
	    'boolean': type_1.Type.NOMINAL,
	    'number': type_1.Type.QUANTITATIVE,
	    'integer': type_1.Type.QUANTITATIVE,
	    'date': type_1.Type.TEMPORAL,
	    'string': type_1.Type.NOMINAL
	};
	//# sourceMappingURL=data.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/data.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/type.js **/
jupyter.define('vega-lite@1.2.0/src/type.js', function (module, exports, __jupyter_require__) {
	"use strict";
	(function (Type) {
	    Type[Type["QUANTITATIVE"] = 'quantitative'] = "QUANTITATIVE";
	    Type[Type["ORDINAL"] = 'ordinal'] = "ORDINAL";
	    Type[Type["TEMPORAL"] = 'temporal'] = "TEMPORAL";
	    Type[Type["NOMINAL"] = 'nominal'] = "NOMINAL";
	})(exports.Type || (exports.Type = {}));
	var Type = exports.Type;
	exports.QUANTITATIVE = Type.QUANTITATIVE;
	exports.ORDINAL = Type.ORDINAL;
	exports.TEMPORAL = Type.TEMPORAL;
	exports.NOMINAL = Type.NOMINAL;
	exports.SHORT_TYPE = {
	    quantitative: 'Q',
	    temporal: 'T',
	    nominal: 'N',
	    ordinal: 'O'
	};
	exports.TYPE_FROM_SHORT_TYPE = {
	    Q: exports.QUANTITATIVE,
	    T: exports.TEMPORAL,
	    O: exports.ORDINAL,
	    N: exports.NOMINAL
	};
	function getFullName(type) {
	    var typeString = type;
	    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||
	        typeString.toLowerCase();
	}
	exports.getFullName = getFullName;
	//# sourceMappingURL=type.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/type.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/spec.js **/
jupyter.define('vega-lite@1.2.0/src/spec.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var encoding_1 = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var stack_1 = __jupyter_require__('vega-lite@~1.2.0/src/stack.js');
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var vlEncoding = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	function isFacetSpec(spec) {
	    return spec['facet'] !== undefined;
	}
	exports.isFacetSpec = isFacetSpec;
	function isExtendedUnitSpec(spec) {
	    if (isSomeUnitSpec(spec)) {
	        var hasRow = encoding_1.has(spec.encoding, channel_1.ROW);
	        var hasColumn = encoding_1.has(spec.encoding, channel_1.COLUMN);
	        return hasRow || hasColumn;
	    }
	    return false;
	}
	exports.isExtendedUnitSpec = isExtendedUnitSpec;
	function isUnitSpec(spec) {
	    if (isSomeUnitSpec(spec)) {
	        return !isExtendedUnitSpec(spec);
	    }
	    return false;
	}
	exports.isUnitSpec = isUnitSpec;
	function isSomeUnitSpec(spec) {
	    return spec['mark'] !== undefined;
	}
	exports.isSomeUnitSpec = isSomeUnitSpec;
	function isLayerSpec(spec) {
	    return spec['layers'] !== undefined;
	}
	exports.isLayerSpec = isLayerSpec;
	function normalize(spec) {
	    if (isExtendedUnitSpec(spec)) {
	        return normalizeExtendedUnitSpec(spec);
	    }
	    if (isUnitSpec(spec)) {
	        return normalizeUnitSpec(spec);
	    }
	    return spec;
	}
	exports.normalize = normalize;
	function normalizeExtendedUnitSpec(spec) {
	    var hasRow = encoding_1.has(spec.encoding, channel_1.ROW);
	    var hasColumn = encoding_1.has(spec.encoding, channel_1.COLUMN);
	    var encoding = util_1.duplicate(spec.encoding);
	    delete encoding.column;
	    delete encoding.row;
	    return util_1.extend(spec.name ? { name: spec.name } : {}, spec.description ? { description: spec.description } : {}, { data: spec.data }, spec.transform ? { transform: spec.transform } : {}, {
	        facet: util_1.extend(hasRow ? { row: spec.encoding.row } : {}, hasColumn ? { column: spec.encoding.column } : {}),
	        spec: normalizeUnitSpec({
	            mark: spec.mark,
	            encoding: encoding
	        })
	    }, spec.config ? { config: spec.config } : {});
	}
	exports.normalizeExtendedUnitSpec = normalizeExtendedUnitSpec;
	function normalizeUnitSpec(spec) {
	    var config = spec.config;
	    var overlayConfig = config && config.overlay;
	    var overlayWithLine = overlayConfig && spec.mark === mark_1.AREA &&
	        util_1.contains([config_1.AreaOverlay.LINEPOINT, config_1.AreaOverlay.LINE], overlayConfig.area);
	    var overlayWithPoint = overlayConfig && ((overlayConfig.line && spec.mark === mark_1.LINE) ||
	        (overlayConfig.area === config_1.AreaOverlay.LINEPOINT && spec.mark === mark_1.AREA));
	    if (spec.mark === mark_1.ERRORBAR) {
	        return normalizeErrorBarUnitSpec(spec);
	    }
	    if (encoding_1.isRanged(spec.encoding)) {
	        return normalizeRangedUnitSpec(spec);
	    }
	    if (isStacked(spec)) {
	        return spec;
	    }
	    if (overlayWithPoint || overlayWithLine) {
	        return normalizeOverlay(spec, overlayWithPoint, overlayWithLine);
	    }
	    return spec;
	}
	exports.normalizeUnitSpec = normalizeUnitSpec;
	function normalizeRangedUnitSpec(spec) {
	    if (spec.encoding) {
	        var hasX = encoding_1.has(spec.encoding, channel_1.X);
	        var hasY = encoding_1.has(spec.encoding, channel_1.Y);
	        var hasX2 = encoding_1.has(spec.encoding, channel_1.X2);
	        var hasY2 = encoding_1.has(spec.encoding, channel_1.Y2);
	        if ((hasX2 && !hasX) || (hasY2 && !hasY)) {
	            var normalizedSpec = util_1.duplicate(spec);
	            if (hasX2 && !hasX) {
	                normalizedSpec.encoding.x = normalizedSpec.encoding.x2;
	                delete normalizedSpec.encoding.x2;
	            }
	            if (hasY2 && !hasY) {
	                normalizedSpec.encoding.y = normalizedSpec.encoding.y2;
	                delete normalizedSpec.encoding.y2;
	            }
	            return normalizedSpec;
	        }
	    }
	    return spec;
	}
	exports.normalizeRangedUnitSpec = normalizeRangedUnitSpec;
	function normalizeErrorBarUnitSpec(spec) {
	    var layerSpec = util_1.extend(spec.name ? { name: spec.name } : {}, spec.description ? { description: spec.description } : {}, spec.data ? { data: spec.data } : {}, spec.transform ? { transform: spec.transform } : {}, spec.config ? { config: spec.config } : {}, { layers: [] });
	    if (!spec.encoding) {
	        return layerSpec;
	    }
	    if (spec.mark === mark_1.ERRORBAR) {
	        var ruleSpec = {
	            mark: mark_1.RULE,
	            encoding: util_1.extend(spec.encoding.x ? { x: util_1.duplicate(spec.encoding.x) } : {}, spec.encoding.y ? { y: util_1.duplicate(spec.encoding.y) } : {}, spec.encoding.x2 ? { x2: util_1.duplicate(spec.encoding.x2) } : {}, spec.encoding.y2 ? { y2: util_1.duplicate(spec.encoding.y2) } : {}, {})
	        };
	        var lowerTickSpec = {
	            mark: mark_1.TICK,
	            encoding: util_1.extend(spec.encoding.x ? { x: util_1.duplicate(spec.encoding.x) } : {}, spec.encoding.y ? { y: util_1.duplicate(spec.encoding.y) } : {}, spec.encoding.size ? { size: util_1.duplicate(spec.encoding.size) } : {}, {})
	        };
	        var upperTickSpec = {
	            mark: mark_1.TICK,
	            encoding: util_1.extend({
	                x: spec.encoding.x2 ? util_1.duplicate(spec.encoding.x2) : util_1.duplicate(spec.encoding.x),
	                y: spec.encoding.y2 ? util_1.duplicate(spec.encoding.y2) : util_1.duplicate(spec.encoding.y)
	            }, spec.encoding.size ? { size: util_1.duplicate(spec.encoding.size) } : {})
	        };
	        layerSpec.layers.push(normalizeUnitSpec(ruleSpec));
	        layerSpec.layers.push(normalizeUnitSpec(lowerTickSpec));
	        layerSpec.layers.push(normalizeUnitSpec(upperTickSpec));
	    }
	    return layerSpec;
	}
	exports.normalizeErrorBarUnitSpec = normalizeErrorBarUnitSpec;
	function normalizeOverlay(spec, overlayWithPoint, overlayWithLine) {
	    var outerProps = ['name', 'description', 'data', 'transform'];
	    var baseSpec = util_1.omit(spec, outerProps.concat('config'));
	    var baseConfig = util_1.duplicate(spec.config);
	    delete baseConfig.overlay;
	    var layerSpec = util_1.extend(util_1.pick(spec, outerProps), { layers: [baseSpec] }, util_1.keys(baseConfig).length > 0 ? { config: baseConfig } : {});
	    if (overlayWithLine) {
	        var lineSpec = util_1.duplicate(baseSpec);
	        lineSpec.mark = mark_1.LINE;
	        var markConfig = util_1.extend({}, config_1.defaultOverlayConfig.lineStyle, spec.config.overlay.lineStyle);
	        if (util_1.keys(markConfig).length > 0) {
	            lineSpec.config = { mark: markConfig };
	        }
	        layerSpec.layers.push(lineSpec);
	    }
	    if (overlayWithPoint) {
	        var pointSpec = util_1.duplicate(baseSpec);
	        pointSpec.mark = mark_1.POINT;
	        var markConfig = util_1.extend({}, config_1.defaultOverlayConfig.pointStyle, spec.config.overlay.pointStyle);
	        ;
	        if (util_1.keys(markConfig).length > 0) {
	            pointSpec.config = { mark: markConfig };
	        }
	        layerSpec.layers.push(pointSpec);
	    }
	    return layerSpec;
	}
	exports.normalizeOverlay = normalizeOverlay;
	function fieldDefs(spec) {
	    return vlEncoding.fieldDefs(spec.encoding);
	}
	exports.fieldDefs = fieldDefs;
	;
	function isStacked(spec) {
	    return stack_1.stack(spec.mark, spec.encoding, spec.config) !== null;
	}
	exports.isStacked = isStacked;
	//# sourceMappingURL=spec.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/spec.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/config.js **/
jupyter.define('vega-lite@1.2.0/src/config.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var axis_1 = __jupyter_require__('vega-lite@~1.2.0/src/axis.js');
	var legend_1 = __jupyter_require__('vega-lite@~1.2.0/src/legend.js');
	exports.defaultCellConfig = {
	    width: 200,
	    height: 200
	};
	exports.defaultFacetCellConfig = {
	    stroke: '#ccc',
	    strokeWidth: 1
	};
	var defaultFacetGridConfig = {
	    color: '#000000',
	    opacity: 0.4,
	    offset: 0
	};
	exports.defaultFacetConfig = {
	    scale: scale_1.defaultFacetScaleConfig,
	    axis: axis_1.defaultFacetAxisConfig,
	    grid: defaultFacetGridConfig,
	    cell: exports.defaultFacetCellConfig
	};
	(function (FontWeight) {
	    FontWeight[FontWeight["NORMAL"] = 'normal'] = "NORMAL";
	    FontWeight[FontWeight["BOLD"] = 'bold'] = "BOLD";
	})(exports.FontWeight || (exports.FontWeight = {}));
	var FontWeight = exports.FontWeight;
	(function (Shape) {
	    Shape[Shape["CIRCLE"] = 'circle'] = "CIRCLE";
	    Shape[Shape["SQUARE"] = 'square'] = "SQUARE";
	    Shape[Shape["CROSS"] = 'cross'] = "CROSS";
	    Shape[Shape["DIAMOND"] = 'diamond'] = "DIAMOND";
	    Shape[Shape["TRIANGLEUP"] = 'triangle-up'] = "TRIANGLEUP";
	    Shape[Shape["TRIANGLEDOWN"] = 'triangle-down'] = "TRIANGLEDOWN";
	})(exports.Shape || (exports.Shape = {}));
	var Shape = exports.Shape;
	(function (Orient) {
	    Orient[Orient["HORIZONTAL"] = 'horizontal'] = "HORIZONTAL";
	    Orient[Orient["VERTICAL"] = 'vertical'] = "VERTICAL";
	})(exports.Orient || (exports.Orient = {}));
	var Orient = exports.Orient;
	(function (HorizontalAlign) {
	    HorizontalAlign[HorizontalAlign["LEFT"] = 'left'] = "LEFT";
	    HorizontalAlign[HorizontalAlign["RIGHT"] = 'right'] = "RIGHT";
	    HorizontalAlign[HorizontalAlign["CENTER"] = 'center'] = "CENTER";
	})(exports.HorizontalAlign || (exports.HorizontalAlign = {}));
	var HorizontalAlign = exports.HorizontalAlign;
	(function (VerticalAlign) {
	    VerticalAlign[VerticalAlign["TOP"] = 'top'] = "TOP";
	    VerticalAlign[VerticalAlign["MIDDLE"] = 'middle'] = "MIDDLE";
	    VerticalAlign[VerticalAlign["BOTTOM"] = 'bottom'] = "BOTTOM";
	})(exports.VerticalAlign || (exports.VerticalAlign = {}));
	var VerticalAlign = exports.VerticalAlign;
	(function (FontStyle) {
	    FontStyle[FontStyle["NORMAL"] = 'normal'] = "NORMAL";
	    FontStyle[FontStyle["ITALIC"] = 'italic'] = "ITALIC";
	})(exports.FontStyle || (exports.FontStyle = {}));
	var FontStyle = exports.FontStyle;
	(function (Interpolate) {
	    Interpolate[Interpolate["LINEAR"] = 'linear'] = "LINEAR";
	    Interpolate[Interpolate["LINEAR_CLOSED"] = 'linear-closed'] = "LINEAR_CLOSED";
	    Interpolate[Interpolate["STEP"] = 'step'] = "STEP";
	    Interpolate[Interpolate["STEP_BEFORE"] = 'step-before'] = "STEP_BEFORE";
	    Interpolate[Interpolate["STEP_AFTER"] = 'step-after'] = "STEP_AFTER";
	    Interpolate[Interpolate["BASIS"] = 'basis'] = "BASIS";
	    Interpolate[Interpolate["BASIS_OPEN"] = 'basis-open'] = "BASIS_OPEN";
	    Interpolate[Interpolate["BASIS_CLOSED"] = 'basis-closed'] = "BASIS_CLOSED";
	    Interpolate[Interpolate["CARDINAL"] = 'cardinal'] = "CARDINAL";
	    Interpolate[Interpolate["CARDINAL_OPEN"] = 'cardinal-open'] = "CARDINAL_OPEN";
	    Interpolate[Interpolate["CARDINAL_CLOSED"] = 'cardinal-closed'] = "CARDINAL_CLOSED";
	    Interpolate[Interpolate["BUNDLE"] = 'bundle'] = "BUNDLE";
	    Interpolate[Interpolate["MONOTONE"] = 'monotone'] = "MONOTONE";
	})(exports.Interpolate || (exports.Interpolate = {}));
	var Interpolate = exports.Interpolate;
	(function (AreaOverlay) {
	    AreaOverlay[AreaOverlay["LINE"] = 'line'] = "LINE";
	    AreaOverlay[AreaOverlay["LINEPOINT"] = 'linepoint'] = "LINEPOINT";
	    AreaOverlay[AreaOverlay["NONE"] = 'none'] = "NONE";
	})(exports.AreaOverlay || (exports.AreaOverlay = {}));
	var AreaOverlay = exports.AreaOverlay;
	exports.defaultOverlayConfig = {
	    line: false,
	    pointStyle: { filled: true },
	    lineStyle: {}
	};
	exports.defaultMarkConfig = {
	    color: '#4682b4',
	    shape: Shape.CIRCLE,
	    strokeWidth: 2,
	    size: 30,
	    barThinSize: 2,
	    ruleSize: 1,
	    tickThickness: 1,
	    fontSize: 10,
	    baseline: VerticalAlign.MIDDLE,
	    text: 'Abc',
	    shortTimeLabels: false,
	    applyColorToBackground: false
	};
	exports.defaultConfig = {
	    numberFormat: 's',
	    timeFormat: '%Y-%m-%d',
	    countTitle: 'Number of Records',
	    cell: exports.defaultCellConfig,
	    mark: exports.defaultMarkConfig,
	    overlay: exports.defaultOverlayConfig,
	    scale: scale_1.defaultScaleConfig,
	    axis: axis_1.defaultAxisConfig,
	    legend: legend_1.defaultLegendConfig,
	    facet: exports.defaultFacetConfig,
	};
	//# sourceMappingURL=config.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/config.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/scale.js **/
jupyter.define('vega-lite@1.2.0/src/scale.js', function (module, exports, __jupyter_require__) {
	"use strict";
	(function (ScaleType) {
	    ScaleType[ScaleType["LINEAR"] = 'linear'] = "LINEAR";
	    ScaleType[ScaleType["LOG"] = 'log'] = "LOG";
	    ScaleType[ScaleType["POW"] = 'pow'] = "POW";
	    ScaleType[ScaleType["SQRT"] = 'sqrt'] = "SQRT";
	    ScaleType[ScaleType["QUANTILE"] = 'quantile'] = "QUANTILE";
	    ScaleType[ScaleType["QUANTIZE"] = 'quantize'] = "QUANTIZE";
	    ScaleType[ScaleType["ORDINAL"] = 'ordinal'] = "ORDINAL";
	    ScaleType[ScaleType["TIME"] = 'time'] = "TIME";
	    ScaleType[ScaleType["UTC"] = 'utc'] = "UTC";
	})(exports.ScaleType || (exports.ScaleType = {}));
	var ScaleType = exports.ScaleType;
	(function (NiceTime) {
	    NiceTime[NiceTime["SECOND"] = 'second'] = "SECOND";
	    NiceTime[NiceTime["MINUTE"] = 'minute'] = "MINUTE";
	    NiceTime[NiceTime["HOUR"] = 'hour'] = "HOUR";
	    NiceTime[NiceTime["DAY"] = 'day'] = "DAY";
	    NiceTime[NiceTime["WEEK"] = 'week'] = "WEEK";
	    NiceTime[NiceTime["MONTH"] = 'month'] = "MONTH";
	    NiceTime[NiceTime["YEAR"] = 'year'] = "YEAR";
	})(exports.NiceTime || (exports.NiceTime = {}));
	var NiceTime = exports.NiceTime;
	(function (BandSize) {
	    BandSize[BandSize["FIT"] = 'fit'] = "FIT";
	})(exports.BandSize || (exports.BandSize = {}));
	var BandSize = exports.BandSize;
	exports.BANDSIZE_FIT = BandSize.FIT;
	exports.defaultScaleConfig = {
	    round: true,
	    textBandWidth: 90,
	    bandSize: 21,
	    padding: 0.1,
	    useRawDomain: false,
	    opacity: [0.3, 0.8],
	    nominalColorRange: 'category10',
	    sequentialColorRange: ['#AFC6A3', '#09622A'],
	    shapeRange: 'shapes',
	    fontSizeRange: [8, 40],
	    ruleSizeRange: [1, 5],
	    tickSizeRange: [1, 20]
	};
	exports.defaultFacetScaleConfig = {
	    round: true,
	    padding: 16
	};
	//# sourceMappingURL=scale.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/scale.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/legend.js **/
jupyter.define('vega-lite@1.2.0/src/legend.js', function (module, exports, __jupyter_require__) {
	"use strict";
	exports.defaultLegendConfig = {
	    orient: undefined,
	    shortTimeLabels: false
	};
	//# sourceMappingURL=legend.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/legend.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/encoding.js **/
jupyter.define('vega-lite@1.2.0/src/encoding.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	function countRetinal(encoding) {
	    var count = 0;
	    if (encoding.color) {
	        count++;
	    }
	    if (encoding.opacity) {
	        count++;
	    }
	    if (encoding.size) {
	        count++;
	    }
	    if (encoding.shape) {
	        count++;
	    }
	    return count;
	}
	exports.countRetinal = countRetinal;
	function channels(encoding) {
	    return channel_1.CHANNELS.filter(function (channel) {
	        return has(encoding, channel);
	    });
	}
	exports.channels = channels;
	function has(encoding, channel) {
	    var channelEncoding = encoding && encoding[channel];
	    return channelEncoding && (channelEncoding.field !== undefined ||
	        (util_1.isArray(channelEncoding) && channelEncoding.length > 0));
	}
	exports.has = has;
	function isAggregate(encoding) {
	    return util_1.some(channel_1.CHANNELS, function (channel) {
	        if (has(encoding, channel) && encoding[channel].aggregate) {
	            return true;
	        }
	        return false;
	    });
	}
	exports.isAggregate = isAggregate;
	function isRanged(encoding) {
	    return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));
	}
	exports.isRanged = isRanged;
	function fieldDefs(encoding) {
	    var arr = [];
	    channel_1.CHANNELS.forEach(function (channel) {
	        if (has(encoding, channel)) {
	            if (util_1.isArray(encoding[channel])) {
	                encoding[channel].forEach(function (fieldDef) {
	                    arr.push(fieldDef);
	                });
	            }
	            else {
	                arr.push(encoding[channel]);
	            }
	        }
	    });
	    return arr;
	}
	exports.fieldDefs = fieldDefs;
	;
	function forEach(encoding, f, thisArg) {
	    channelMappingForEach(channel_1.CHANNELS, encoding, f, thisArg);
	}
	exports.forEach = forEach;
	function channelMappingForEach(channels, mapping, f, thisArg) {
	    var i = 0;
	    channels.forEach(function (channel) {
	        if (has(mapping, channel)) {
	            if (util_1.isArray(mapping[channel])) {
	                mapping[channel].forEach(function (fieldDef) {
	                    f.call(thisArg, fieldDef, channel, i++);
	                });
	            }
	            else {
	                f.call(thisArg, mapping[channel], channel, i++);
	            }
	        }
	    });
	}
	exports.channelMappingForEach = channelMappingForEach;
	function map(encoding, f, thisArg) {
	    return channelMappingMap(channel_1.CHANNELS, encoding, f, thisArg);
	}
	exports.map = map;
	function channelMappingMap(channels, mapping, f, thisArg) {
	    var arr = [];
	    channels.forEach(function (channel) {
	        if (has(mapping, channel)) {
	            if (util_1.isArray(mapping[channel])) {
	                mapping[channel].forEach(function (fieldDef) {
	                    arr.push(f.call(thisArg, fieldDef, channel));
	                });
	            }
	            else {
	                arr.push(f.call(thisArg, mapping[channel], channel));
	            }
	        }
	    });
	    return arr;
	}
	exports.channelMappingMap = channelMappingMap;
	function reduce(encoding, f, init, thisArg) {
	    return channelMappingReduce(channel_1.CHANNELS, encoding, f, init, thisArg);
	}
	exports.reduce = reduce;
	function channelMappingReduce(channels, mapping, f, init, thisArg) {
	    var r = init;
	    channel_1.CHANNELS.forEach(function (channel) {
	        if (has(mapping, channel)) {
	            if (util_1.isArray(mapping[channel])) {
	                mapping[channel].forEach(function (fieldDef) {
	                    r = f.call(thisArg, r, fieldDef, channel);
	                });
	            }
	            else {
	                r = f.call(thisArg, r, mapping[channel], channel);
	            }
	        }
	    });
	    return r;
	}
	exports.channelMappingReduce = channelMappingReduce;
	//# sourceMappingURL=encoding.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/encoding.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/mark.js **/
jupyter.define('vega-lite@1.2.0/src/mark.js', function (module, exports, __jupyter_require__) {
	"use strict";
	(function (Mark) {
	    Mark[Mark["AREA"] = 'area'] = "AREA";
	    Mark[Mark["BAR"] = 'bar'] = "BAR";
	    Mark[Mark["LINE"] = 'line'] = "LINE";
	    Mark[Mark["POINT"] = 'point'] = "POINT";
	    Mark[Mark["TEXT"] = 'text'] = "TEXT";
	    Mark[Mark["TICK"] = 'tick'] = "TICK";
	    Mark[Mark["RULE"] = 'rule'] = "RULE";
	    Mark[Mark["CIRCLE"] = 'circle'] = "CIRCLE";
	    Mark[Mark["SQUARE"] = 'square'] = "SQUARE";
	    Mark[Mark["ERRORBAR"] = 'errorBar'] = "ERRORBAR";
	})(exports.Mark || (exports.Mark = {}));
	var Mark = exports.Mark;
	exports.AREA = Mark.AREA;
	exports.BAR = Mark.BAR;
	exports.LINE = Mark.LINE;
	exports.POINT = Mark.POINT;
	exports.TEXT = Mark.TEXT;
	exports.TICK = Mark.TICK;
	exports.RULE = Mark.RULE;
	exports.CIRCLE = Mark.CIRCLE;
	exports.SQUARE = Mark.SQUARE;
	exports.ERRORBAR = Mark.ERRORBAR;
	exports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RULE, exports.CIRCLE, exports.SQUARE];
	//# sourceMappingURL=mark.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/mark.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/stack.js **/
jupyter.define('vega-lite@1.2.0/src/stack.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var encoding_1 = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	(function (StackOffset) {
	    StackOffset[StackOffset["ZERO"] = 'zero'] = "ZERO";
	    StackOffset[StackOffset["CENTER"] = 'center'] = "CENTER";
	    StackOffset[StackOffset["NORMALIZE"] = 'normalize'] = "NORMALIZE";
	    StackOffset[StackOffset["NONE"] = 'none'] = "NONE";
	})(exports.StackOffset || (exports.StackOffset = {}));
	var StackOffset = exports.StackOffset;
	function stack(mark, encoding, config) {
	    var stacked = (config && config.mark) ? config.mark.stacked : undefined;
	    if (util_1.contains([StackOffset.NONE, null, false], stacked)) {
	        return null;
	    }
	    if (!util_1.contains([mark_1.BAR, mark_1.AREA], mark)) {
	        return null;
	    }
	    if (!encoding_1.isAggregate(encoding)) {
	        return null;
	    }
	    var stackByChannels = channel_1.STACK_GROUP_CHANNELS.reduce(function (sc, channel) {
	        if (encoding_1.has(encoding, channel) && !encoding[channel].aggregate) {
	            sc.push(channel);
	        }
	        return sc;
	    }, []);
	    if (stackByChannels.length === 0) {
	        return null;
	    }
	    var hasXField = encoding_1.has(encoding, channel_1.X);
	    var hasYField = encoding_1.has(encoding, channel_1.Y);
	    var xIsAggregate = hasXField && !!encoding.x.aggregate;
	    var yIsAggregate = hasYField && !!encoding.y.aggregate;
	    if (xIsAggregate !== yIsAggregate) {
	        return {
	            groupbyChannel: xIsAggregate ? (hasYField ? channel_1.Y : null) : (hasXField ? channel_1.X : null),
	            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,
	            stackByChannels: stackByChannels,
	            offset: stacked || StackOffset.ZERO
	        };
	    }
	    return null;
	}
	exports.stack = stack;
	//# sourceMappingURL=stack.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/stack.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/common.js **/
jupyter.define('vega-lite@1.2.0/src/compile/common.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var aggregate_1 = __jupyter_require__('vega-lite@~1.2.0/src/aggregate.js');
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var sort_1 = __jupyter_require__('vega-lite@~1.2.0/src/sort.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var facet_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/facet.js');
	var layer_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/layer.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	var unit_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/unit.js');
	var spec_1 = __jupyter_require__('vega-lite@~1.2.0/src/spec.js');
	function buildModel(spec, parent, parentGivenName) {
	    if (spec_1.isFacetSpec(spec)) {
	        return new facet_1.FacetModel(spec, parent, parentGivenName);
	    }
	    if (spec_1.isLayerSpec(spec)) {
	        return new layer_1.LayerModel(spec, parent, parentGivenName);
	    }
	    if (spec_1.isUnitSpec(spec)) {
	        return new unit_1.UnitModel(spec, parent, parentGivenName);
	    }
	    console.error('Invalid spec.');
	    return null;
	}
	exports.buildModel = buildModel;
	exports.STROKE_CONFIG = ['stroke', 'strokeWidth',
	    'strokeDash', 'strokeDashOffset', 'strokeOpacity', 'opacity'];
	exports.FILL_CONFIG = ['fill', 'fillOpacity',
	    'opacity'];
	exports.FILL_STROKE_CONFIG = util_1.union(exports.STROKE_CONFIG, exports.FILL_CONFIG);
	function applyColorAndOpacity(p, model) {
	    var filled = model.config().mark.filled;
	    var colorFieldDef = model.encoding().color;
	    var opacityFieldDef = model.encoding().opacity;
	    if (filled) {
	        applyMarkConfig(p, model, exports.FILL_CONFIG);
	    }
	    else {
	        applyMarkConfig(p, model, exports.STROKE_CONFIG);
	    }
	    var colorValue;
	    var opacityValue;
	    if (model.has(channel_1.COLOR)) {
	        colorValue = {
	            scale: model.scaleName(channel_1.COLOR),
	            field: model.field(channel_1.COLOR, colorFieldDef.type === type_1.ORDINAL ? { prefix: 'rank' } : {})
	        };
	    }
	    else if (colorFieldDef && colorFieldDef.value) {
	        colorValue = { value: colorFieldDef.value };
	    }
	    if (model.has(channel_1.OPACITY)) {
	        opacityValue = {
	            scale: model.scaleName(channel_1.OPACITY),
	            field: model.field(channel_1.OPACITY, opacityFieldDef.type === type_1.ORDINAL ? { prefix: 'rank' } : {})
	        };
	    }
	    else if (opacityFieldDef && opacityFieldDef.value) {
	        opacityValue = { value: opacityFieldDef.value };
	    }
	    if (colorValue !== undefined) {
	        if (filled) {
	            p.fill = colorValue;
	        }
	        else {
	            p.stroke = colorValue;
	        }
	    }
	    else {
	        p[filled ? 'fill' : 'stroke'] = p[filled ? 'fill' : 'stroke'] ||
	            { value: model.config().mark.color };
	    }
	    if (!p.fill && util_1.contains([mark_1.BAR, mark_1.POINT, mark_1.CIRCLE, mark_1.SQUARE], model.mark())) {
	        p.fill = { value: 'transparent' };
	    }
	    if (opacityValue !== undefined) {
	        p.opacity = opacityValue;
	    }
	}
	exports.applyColorAndOpacity = applyColorAndOpacity;
	function applyConfig(properties, config, propsList) {
	    propsList.forEach(function (property) {
	        var value = config[property];
	        if (value !== undefined) {
	            properties[property] = { value: value };
	        }
	    });
	    return properties;
	}
	exports.applyConfig = applyConfig;
	function applyMarkConfig(marksProperties, model, propsList) {
	    return applyConfig(marksProperties, model.config().mark, propsList);
	}
	exports.applyMarkConfig = applyMarkConfig;
	function numberFormat(fieldDef, format, config) {
	    if (fieldDef.type === type_1.QUANTITATIVE && !fieldDef.bin) {
	        if (format) {
	            return format;
	        }
	        else if (fieldDef.aggregate === aggregate_1.AggregateOp.COUNT) {
	            return 'd';
	        }
	        return config.numberFormat;
	    }
	    return undefined;
	}
	exports.numberFormat = numberFormat;
	function sortField(orderChannelDef) {
	    return (orderChannelDef.sort === sort_1.SortOrder.DESCENDING ? '-' : '') +
	        fielddef_1.field(orderChannelDef, { binSuffix: 'mid' });
	}
	exports.sortField = sortField;
	function timeTemplate(templateField, timeUnit, format, shortTimeLabels, config) {
	    if (!timeUnit || format) {
	        var _format = format || config.timeFormat;
	        return '{{' + templateField + ' | time:\'' + _format + '\'}}';
	    }
	    else {
	        return timeunit_1.template(timeUnit, templateField, shortTimeLabels);
	    }
	}
	exports.timeTemplate = timeTemplate;
	//# sourceMappingURL=common.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/common.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/fielddef.js **/
jupyter.define('vega-lite@1.2.0/src/fielddef.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var aggregate_1 = __jupyter_require__('vega-lite@~1.2.0/src/aggregate.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	function field(fieldDef, opt) {
	    if (opt === void 0) { opt = {}; }
	    var field = fieldDef.field;
	    var prefix = opt.prefix;
	    var suffix = opt.suffix;
	    if (isCount(fieldDef)) {
	        field = 'count';
	    }
	    else {
	        var fn = opt.fn;
	        if (!opt.nofn) {
	            if (fieldDef.bin) {
	                fn = 'bin';
	                suffix = opt.binSuffix || (opt.scaleType === scale_1.ScaleType.ORDINAL ?
	                    'range' :
	                    'start');
	            }
	            else if (!opt.noAggregate && fieldDef.aggregate) {
	                fn = String(fieldDef.aggregate);
	            }
	            else if (fieldDef.timeUnit) {
	                fn = String(fieldDef.timeUnit);
	            }
	        }
	        if (!!fn) {
	            field = fn + "_" + field;
	        }
	    }
	    if (!!suffix) {
	        field = field + "_" + suffix;
	    }
	    if (!!prefix) {
	        field = prefix + "_" + field;
	    }
	    if (opt.datum) {
	        field = "datum[\"" + field + "\"]";
	    }
	    return field;
	}
	exports.field = field;
	function _isFieldDimension(fieldDef) {
	    if (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type)) {
	        return true;
	    }
	    else if (!!fieldDef.bin) {
	        return true;
	    }
	    else if (fieldDef.type === type_1.TEMPORAL) {
	        return !!fieldDef.timeUnit;
	    }
	    return false;
	}
	function isDimension(fieldDef) {
	    return fieldDef && fieldDef.field && _isFieldDimension(fieldDef);
	}
	exports.isDimension = isDimension;
	function isMeasure(fieldDef) {
	    return fieldDef && fieldDef.field && !_isFieldDimension(fieldDef);
	}
	exports.isMeasure = isMeasure;
	function count() {
	    return { field: '*', aggregate: aggregate_1.AggregateOp.COUNT, type: type_1.QUANTITATIVE };
	}
	exports.count = count;
	function isCount(fieldDef) {
	    return fieldDef.aggregate === aggregate_1.AggregateOp.COUNT;
	}
	exports.isCount = isCount;
	function title(fieldDef, config) {
	    if (fieldDef.title != null) {
	        return fieldDef.title;
	    }
	    if (isCount(fieldDef)) {
	        return config.countTitle;
	    }
	    var fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');
	    if (fn) {
	        return fn.toString().toUpperCase() + '(' + fieldDef.field + ')';
	    }
	    else {
	        return fieldDef.field;
	    }
	}
	exports.title = title;
	//# sourceMappingURL=fielddef.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/fielddef.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/sort.js **/
jupyter.define('vega-lite@1.2.0/src/sort.js', function (module, exports, __jupyter_require__) {
	"use strict";
	(function (SortOrder) {
	    SortOrder[SortOrder["ASCENDING"] = 'ascending'] = "ASCENDING";
	    SortOrder[SortOrder["DESCENDING"] = 'descending'] = "DESCENDING";
	    SortOrder[SortOrder["NONE"] = 'none'] = "NONE";
	})(exports.SortOrder || (exports.SortOrder = {}));
	var SortOrder = exports.SortOrder;
	function isSortField(sort) {
	    return !!sort && !!sort['field'] && !!sort['op'];
	}
	exports.isSortField = isSortField;
	//# sourceMappingURL=sort.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/sort.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/facet.js **/
jupyter.define('vega-lite@1.2.0/src/compile/facet.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var axis_1 = __jupyter_require__('vega-lite@~1.2.0/src/axis.js');
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var encoding_1 = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var axis_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/axis.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var data_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/data.js');
	var layout_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/layout.js');
	var model_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/model.js');
	var scale_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/scale.js');
	var FacetModel = (function (_super) {
	    __extends(FacetModel, _super);
	    function FacetModel(spec, parent, parentGivenName) {
	        _super.call(this, spec, parent, parentGivenName);
	        var config = this._config = this._initConfig(spec.config, parent);
	        var child = this._child = common_1.buildModel(spec.spec, this, this.name('child'));
	        var facet = this._facet = this._initFacet(spec.facet);
	        this._scale = this._initScale(facet, config, child);
	        this._axis = this._initAxis(facet, config, child);
	    }
	    FacetModel.prototype._initConfig = function (specConfig, parent) {
	        return util_1.mergeDeep(util_1.duplicate(config_1.defaultConfig), specConfig, parent ? parent.config() : {});
	    };
	    FacetModel.prototype._initFacet = function (facet) {
	        facet = util_1.duplicate(facet);
	        var model = this;
	        encoding_1.channelMappingForEach(this.channels(), facet, function (fieldDef, channel) {
	            if (!fielddef_1.isDimension(fieldDef)) {
	                model.addWarning(channel + ' encoding should be ordinal.');
	            }
	            if (fieldDef.type) {
	                fieldDef.type = type_1.getFullName(fieldDef.type);
	            }
	        });
	        return facet;
	    };
	    FacetModel.prototype._initScale = function (facet, config, child) {
	        return [channel_1.ROW, channel_1.COLUMN].reduce(function (_scale, channel) {
	            if (facet[channel]) {
	                var scaleSpec = facet[channel].scale || {};
	                _scale[channel] = util_1.extend({
	                    type: scale_1.ScaleType.ORDINAL,
	                    round: config.facet.scale.round,
	                    padding: (channel === channel_1.ROW && child.has(channel_1.Y)) || (channel === channel_1.COLUMN && child.has(channel_1.X)) ?
	                        config.facet.scale.padding : 0
	                }, scaleSpec);
	            }
	            return _scale;
	        }, {});
	    };
	    FacetModel.prototype._initAxis = function (facet, config, child) {
	        return [channel_1.ROW, channel_1.COLUMN].reduce(function (_axis, channel) {
	            if (facet[channel]) {
	                var axisSpec = facet[channel].axis;
	                if (axisSpec !== false) {
	                    var modelAxis = _axis[channel] = util_1.extend({}, config.facet.axis, axisSpec === true ? {} : axisSpec || {});
	                    if (channel === channel_1.ROW) {
	                        var yAxis = child.axis(channel_1.Y);
	                        if (yAxis && yAxis.orient !== axis_1.AxisOrient.RIGHT && !modelAxis.orient) {
	                            modelAxis.orient = axis_1.AxisOrient.RIGHT;
	                        }
	                        if (child.has(channel_1.X) && !modelAxis.labelAngle) {
	                            modelAxis.labelAngle = modelAxis.orient === axis_1.AxisOrient.RIGHT ? 90 : 270;
	                        }
	                    }
	                }
	            }
	            return _axis;
	        }, {});
	    };
	    FacetModel.prototype.facet = function () {
	        return this._facet;
	    };
	    FacetModel.prototype.has = function (channel) {
	        return !!this._facet[channel];
	    };
	    FacetModel.prototype.child = function () {
	        return this._child;
	    };
	    FacetModel.prototype.hasSummary = function () {
	        var summary = this.component.data.summary;
	        for (var i = 0; i < summary.length; i++) {
	            if (util_1.keys(summary[i].measures).length > 0) {
	                return true;
	            }
	        }
	        return false;
	    };
	    FacetModel.prototype.dataTable = function () {
	        return (this.hasSummary() ? data_1.SUMMARY : data_1.SOURCE) + '';
	    };
	    FacetModel.prototype.fieldDef = function (channel) {
	        return this.facet()[channel];
	    };
	    FacetModel.prototype.stack = function () {
	        return null;
	    };
	    FacetModel.prototype.parseData = function () {
	        this.child().parseData();
	        this.component.data = data_2.parseFacetData(this);
	    };
	    FacetModel.prototype.parseSelectionData = function () {
	    };
	    FacetModel.prototype.parseLayoutData = function () {
	        this.child().parseLayoutData();
	        this.component.layout = layout_1.parseFacetLayout(this);
	    };
	    FacetModel.prototype.parseScale = function () {
	        var child = this.child();
	        var model = this;
	        child.parseScale();
	        var scaleComponent = this.component.scale = scale_2.parseScaleComponent(this);
	        util_1.keys(child.component.scale).forEach(function (channel) {
	            if (true) {
	                scaleComponent[channel] = child.component.scale[channel];
	                util_1.vals(scaleComponent[channel]).forEach(function (scale) {
	                    var scaleNameWithoutPrefix = scale.name.substr(child.name('').length);
	                    var newName = model.scaleName(scaleNameWithoutPrefix);
	                    child.renameScale(scale.name, newName);
	                    scale.name = newName;
	                });
	                delete child.component.scale[channel];
	            }
	        });
	    };
	    FacetModel.prototype.parseMark = function () {
	        this.child().parseMark();
	        this.component.mark = util_1.extend({
	            name: this.name('cell'),
	            type: 'group',
	            from: util_1.extend(this.dataTable() ? { data: this.dataTable() } : {}, {
	                transform: [{
	                        type: 'facet',
	                        groupby: [].concat(this.has(channel_1.ROW) ? [this.field(channel_1.ROW)] : [], this.has(channel_1.COLUMN) ? [this.field(channel_1.COLUMN)] : [])
	                    }]
	            }),
	            properties: {
	                update: getFacetGroupProperties(this)
	            }
	        }, this.child().assembleGroup());
	    };
	    FacetModel.prototype.parseAxis = function () {
	        this.child().parseAxis();
	        this.component.axis = axis_2.parseAxisComponent(this, [channel_1.ROW, channel_1.COLUMN]);
	    };
	    FacetModel.prototype.parseAxisGroup = function () {
	        var xAxisGroup = parseAxisGroup(this, channel_1.X);
	        var yAxisGroup = parseAxisGroup(this, channel_1.Y);
	        this.component.axisGroup = util_1.extend(xAxisGroup ? { x: xAxisGroup } : {}, yAxisGroup ? { y: yAxisGroup } : {});
	    };
	    FacetModel.prototype.parseGridGroup = function () {
	        var child = this.child();
	        this.component.gridGroup = util_1.extend(!child.has(channel_1.X) && this.has(channel_1.COLUMN) ? { column: getColumnGridGroups(this) } : {}, !child.has(channel_1.Y) && this.has(channel_1.ROW) ? { row: getRowGridGroups(this) } : {});
	    };
	    FacetModel.prototype.parseLegend = function () {
	        this.child().parseLegend();
	        this.component.legend = this._child.component.legend;
	        this._child.component.legend = {};
	    };
	    FacetModel.prototype.assembleParentGroupProperties = function () {
	        return null;
	    };
	    FacetModel.prototype.assembleData = function (data) {
	        data_2.assembleData(this, data);
	        return this._child.assembleData(data);
	    };
	    FacetModel.prototype.assembleLayout = function (layoutData) {
	        this._child.assembleLayout(layoutData);
	        return layout_1.assembleLayout(this, layoutData);
	    };
	    FacetModel.prototype.assembleMarks = function () {
	        return [].concat(util_1.vals(this.component.axisGroup), util_1.flatten(util_1.vals(this.component.gridGroup)), this.component.mark);
	    };
	    FacetModel.prototype.channels = function () {
	        return [channel_1.ROW, channel_1.COLUMN];
	    };
	    FacetModel.prototype.mapping = function () {
	        return this.facet();
	    };
	    FacetModel.prototype.isFacet = function () {
	        return true;
	    };
	    return FacetModel;
	}(model_1.Model));
	exports.FacetModel = FacetModel;
	function getFacetGroupProperties(model) {
	    var child = model.child();
	    var mergedCellConfig = util_1.extend({}, child.config().cell, child.config().facet.cell);
	    return util_1.extend({
	        x: model.has(channel_1.COLUMN) ? {
	            scale: model.scaleName(channel_1.COLUMN),
	            field: model.field(channel_1.COLUMN),
	            offset: model.scale(channel_1.COLUMN).padding / 2
	        } : { value: model.config().facet.scale.padding / 2 },
	        y: model.has(channel_1.ROW) ? {
	            scale: model.scaleName(channel_1.ROW),
	            field: model.field(channel_1.ROW),
	            offset: model.scale(channel_1.ROW).padding / 2
	        } : { value: model.config().facet.scale.padding / 2 },
	        width: { field: { parent: model.child().sizeName('width') } },
	        height: { field: { parent: model.child().sizeName('height') } }
	    }, child.assembleParentGroupProperties(mergedCellConfig));
	}
	function parseAxisGroup(model, channel) {
	    var axisGroup = null;
	    var child = model.child();
	    if (child.has(channel)) {
	        if (child.axis(channel)) {
	            if (true) {
	                axisGroup = channel === channel_1.X ? getXAxesGroup(model) : getYAxesGroup(model);
	                if (child.axis(channel) && axis_2.gridShow(child, channel)) {
	                    child.component.axis[channel] = axis_2.parseInnerAxis(channel, child);
	                }
	                else {
	                    delete child.component.axis[channel];
	                }
	            }
	            else {
	            }
	        }
	    }
	    return axisGroup;
	}
	function getXAxesGroup(model) {
	    var hasCol = model.has(channel_1.COLUMN);
	    return util_1.extend({
	        name: model.name('x-axes'),
	        type: 'group'
	    }, hasCol ? {
	        from: {
	            data: model.dataTable(),
	            transform: [{
	                    type: 'aggregate',
	                    groupby: [model.field(channel_1.COLUMN)],
	                    summarize: { '*': ['count'] }
	                }]
	        }
	    } : {}, {
	        properties: {
	            update: {
	                width: { field: { parent: model.child().sizeName('width') } },
	                height: {
	                    field: { group: 'height' }
	                },
	                x: hasCol ? {
	                    scale: model.scaleName(channel_1.COLUMN),
	                    field: model.field(channel_1.COLUMN),
	                    offset: model.scale(channel_1.COLUMN).padding / 2
	                } : {
	                    value: model.config().facet.scale.padding / 2
	                }
	            }
	        },
	        axes: [axis_2.parseAxis(channel_1.X, model.child())]
	    });
	}
	function getYAxesGroup(model) {
	    var hasRow = model.has(channel_1.ROW);
	    return util_1.extend({
	        name: model.name('y-axes'),
	        type: 'group'
	    }, hasRow ? {
	        from: {
	            data: model.dataTable(),
	            transform: [{
	                    type: 'aggregate',
	                    groupby: [model.field(channel_1.ROW)],
	                    summarize: { '*': ['count'] }
	                }]
	        }
	    } : {}, {
	        properties: {
	            update: {
	                width: {
	                    field: { group: 'width' }
	                },
	                height: { field: { parent: model.child().sizeName('height') } },
	                y: hasRow ? {
	                    scale: model.scaleName(channel_1.ROW),
	                    field: model.field(channel_1.ROW),
	                    offset: model.scale(channel_1.ROW).padding / 2
	                } : {
	                    value: model.config().facet.scale.padding / 2
	                }
	            }
	        },
	        axes: [axis_2.parseAxis(channel_1.Y, model.child())]
	    });
	}
	function getRowGridGroups(model) {
	    var facetGridConfig = model.config().facet.grid;
	    var rowGrid = {
	        name: model.name('row-grid'),
	        type: 'rule',
	        from: {
	            data: model.dataTable(),
	            transform: [{ type: 'facet', groupby: [model.field(channel_1.ROW)] }]
	        },
	        properties: {
	            update: {
	                y: {
	                    scale: model.scaleName(channel_1.ROW),
	                    field: model.field(channel_1.ROW)
	                },
	                x: { value: 0, offset: -facetGridConfig.offset },
	                x2: { field: { group: 'width' }, offset: facetGridConfig.offset },
	                stroke: { value: facetGridConfig.color },
	                strokeOpacity: { value: facetGridConfig.opacity },
	                strokeWidth: { value: 0.5 }
	            }
	        }
	    };
	    return [rowGrid, {
	            name: model.name('row-grid-end'),
	            type: 'rule',
	            properties: {
	                update: {
	                    y: { field: { group: 'height' } },
	                    x: { value: 0, offset: -facetGridConfig.offset },
	                    x2: { field: { group: 'width' }, offset: facetGridConfig.offset },
	                    stroke: { value: facetGridConfig.color },
	                    strokeOpacity: { value: facetGridConfig.opacity },
	                    strokeWidth: { value: 0.5 }
	                }
	            }
	        }];
	}
	function getColumnGridGroups(model) {
	    var facetGridConfig = model.config().facet.grid;
	    var columnGrid = {
	        name: model.name('column-grid'),
	        type: 'rule',
	        from: {
	            data: model.dataTable(),
	            transform: [{ type: 'facet', groupby: [model.field(channel_1.COLUMN)] }]
	        },
	        properties: {
	            update: {
	                x: {
	                    scale: model.scaleName(channel_1.COLUMN),
	                    field: model.field(channel_1.COLUMN)
	                },
	                y: { value: 0, offset: -facetGridConfig.offset },
	                y2: { field: { group: 'height' }, offset: facetGridConfig.offset },
	                stroke: { value: facetGridConfig.color },
	                strokeOpacity: { value: facetGridConfig.opacity },
	                strokeWidth: { value: 0.5 }
	            }
	        }
	    };
	    return [columnGrid, {
	            name: model.name('column-grid-end'),
	            type: 'rule',
	            properties: {
	                update: {
	                    x: { field: { group: 'width' } },
	                    y: { value: 0, offset: -facetGridConfig.offset },
	                    y2: { field: { group: 'height' }, offset: facetGridConfig.offset },
	                    stroke: { value: facetGridConfig.color },
	                    strokeOpacity: { value: facetGridConfig.opacity },
	                    strokeWidth: { value: 0.5 }
	                }
	            }
	        }];
	}
	//# sourceMappingURL=facet.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/facet.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/axis.js **/
jupyter.define('vega-lite@1.2.0/src/compile/axis.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var axis_1 = __jupyter_require__('vega-lite@~1.2.0/src/axis.js');
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	function parseAxisComponent(model, axisChannels) {
	    return axisChannels.reduce(function (axis, channel) {
	        if (model.axis(channel)) {
	            axis[channel] = parseAxis(channel, model);
	        }
	        return axis;
	    }, {});
	}
	exports.parseAxisComponent = parseAxisComponent;
	function parseInnerAxis(channel, model) {
	    var isCol = channel === channel_1.COLUMN, isRow = channel === channel_1.ROW, type = isCol ? 'x' : isRow ? 'y' : channel;
	    var def = {
	        type: type,
	        scale: model.scaleName(channel),
	        grid: true,
	        tickSize: 0,
	        properties: {
	            labels: {
	                text: { value: '' }
	            },
	            axis: {
	                stroke: { value: 'transparent' }
	            }
	        }
	    };
	    var axis = model.axis(channel);
	    ['layer', 'ticks', 'values', 'subdivide'].forEach(function (property) {
	        var method;
	        var value = (method = exports[property]) ?
	            method(model, channel, def) :
	            axis[property];
	        if (value !== undefined) {
	            def[property] = value;
	        }
	    });
	    var props = model.axis(channel).properties || {};
	    ['grid'].forEach(function (group) {
	        var value = properties[group] ?
	            properties[group](model, channel, props[group] || {}, def) :
	            props[group];
	        if (value !== undefined && util_1.keys(value).length > 0) {
	            def.properties = def.properties || {};
	            def.properties[group] = value;
	        }
	    });
	    return def;
	}
	exports.parseInnerAxis = parseInnerAxis;
	function parseAxis(channel, model) {
	    var isCol = channel === channel_1.COLUMN, isRow = channel === channel_1.ROW, type = isCol ? 'x' : isRow ? 'y' : channel;
	    var axis = model.axis(channel);
	    var def = {
	        type: type,
	        scale: model.scaleName(channel)
	    };
	    [
	        'format', 'grid', 'layer', 'offset', 'orient', 'tickSize', 'ticks', 'tickSizeEnd', 'title', 'titleOffset',
	        'tickPadding', 'tickSize', 'tickSizeMajor', 'tickSizeMinor', 'values', 'subdivide'
	    ].forEach(function (property) {
	        var method;
	        var value = (method = exports[property]) ?
	            method(model, channel, def) :
	            axis[property];
	        if (value !== undefined) {
	            def[property] = value;
	        }
	    });
	    var props = model.axis(channel).properties || {};
	    [
	        'axis', 'labels',
	        'grid', 'title', 'ticks', 'majorTicks', 'minorTicks'
	    ].forEach(function (group) {
	        var value = properties[group] ?
	            properties[group](model, channel, props[group] || {}, def) :
	            props[group];
	        if (value !== undefined && util_1.keys(value).length > 0) {
	            def.properties = def.properties || {};
	            def.properties[group] = value;
	        }
	    });
	    return def;
	}
	exports.parseAxis = parseAxis;
	function format(model, channel) {
	    return common_1.numberFormat(model.fieldDef(channel), model.axis(channel).format, model.config());
	}
	exports.format = format;
	function offset(model, channel) {
	    return model.axis(channel).offset;
	}
	exports.offset = offset;
	function gridShow(model, channel) {
	    var grid = model.axis(channel).grid;
	    if (grid !== undefined) {
	        return grid;
	    }
	    return !model.isOrdinalScale(channel) && !model.fieldDef(channel).bin;
	}
	exports.gridShow = gridShow;
	function grid(model, channel) {
	    if (channel === channel_1.ROW || channel === channel_1.COLUMN) {
	        return undefined;
	    }
	    return gridShow(model, channel) && ((channel === channel_1.Y || channel === channel_1.X) && !(model.parent() && model.parent().isFacet()));
	}
	exports.grid = grid;
	function layer(model, channel, def) {
	    var layer = model.axis(channel).layer;
	    if (layer !== undefined) {
	        return layer;
	    }
	    if (def.grid) {
	        return 'back';
	    }
	    return undefined;
	}
	exports.layer = layer;
	;
	function orient(model, channel) {
	    var orient = model.axis(channel).orient;
	    if (orient) {
	        return orient;
	    }
	    else if (channel === channel_1.COLUMN) {
	        return axis_1.AxisOrient.TOP;
	    }
	    return undefined;
	}
	exports.orient = orient;
	function ticks(model, channel) {
	    var ticks = model.axis(channel).ticks;
	    if (ticks !== undefined) {
	        return ticks;
	    }
	    if (channel === channel_1.X && !model.fieldDef(channel).bin) {
	        return 5;
	    }
	    return undefined;
	}
	exports.ticks = ticks;
	function tickSize(model, channel) {
	    var tickSize = model.axis(channel).tickSize;
	    if (tickSize !== undefined) {
	        return tickSize;
	    }
	    return undefined;
	}
	exports.tickSize = tickSize;
	function tickSizeEnd(model, channel) {
	    var tickSizeEnd = model.axis(channel).tickSizeEnd;
	    if (tickSizeEnd !== undefined) {
	        return tickSizeEnd;
	    }
	    return undefined;
	}
	exports.tickSizeEnd = tickSizeEnd;
	function title(model, channel) {
	    var axis = model.axis(channel);
	    if (axis.title !== undefined) {
	        return axis.title;
	    }
	    var fieldTitle = fielddef_1.title(model.fieldDef(channel), model.config());
	    var maxLength;
	    if (axis.titleMaxLength) {
	        maxLength = axis.titleMaxLength;
	    }
	    else if (channel === channel_1.X && !model.isOrdinalScale(channel_1.X)) {
	        var unitModel = model;
	        maxLength = unitModel.width / model.axis(channel_1.X).characterWidth;
	    }
	    else if (channel === channel_1.Y && !model.isOrdinalScale(channel_1.Y)) {
	        var unitModel = model;
	        maxLength = unitModel.height / model.axis(channel_1.Y).characterWidth;
	    }
	    return maxLength ? util_1.truncate(fieldTitle, maxLength) : fieldTitle;
	}
	exports.title = title;
	function titleOffset(model, channel) {
	    var titleOffset = model.axis(channel).titleOffset;
	    if (titleOffset !== undefined) {
	        return titleOffset;
	    }
	    return undefined;
	}
	exports.titleOffset = titleOffset;
	var properties;
	(function (properties) {
	    function axis(model, channel, axisPropsSpec) {
	        var axis = model.axis(channel);
	        return util_1.extend(axis.axisColor !== undefined ?
	            { stroke: { value: axis.axisColor } } :
	            {}, axis.axisWidth !== undefined ?
	            { strokeWidth: { value: axis.axisWidth } } :
	            {}, axisPropsSpec || {});
	    }
	    properties.axis = axis;
	    function grid(model, channel, gridPropsSpec) {
	        var axis = model.axis(channel);
	        return util_1.extend(axis.gridColor !== undefined ? { stroke: { value: axis.gridColor } } : {}, axis.gridOpacity !== undefined ? { strokeOpacity: { value: axis.gridOpacity } } : {}, axis.gridWidth !== undefined ? { strokeWidth: { value: axis.gridWidth } } : {}, axis.gridDash !== undefined ? { strokeDashOffset: { value: axis.gridDash } } : {}, gridPropsSpec || {});
	    }
	    properties.grid = grid;
	    function labels(model, channel, labelsSpec, def) {
	        var fieldDef = model.fieldDef(channel);
	        var axis = model.axis(channel);
	        var config = model.config();
	        if (!axis.labels) {
	            return util_1.extend({
	                text: ''
	            }, labelsSpec);
	        }
	        if (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) && axis.labelMaxLength) {
	            labelsSpec = util_1.extend({
	                text: {
	                    template: '{{ datum["data"] | truncate:' + axis.labelMaxLength + ' }}'
	                }
	            }, labelsSpec || {});
	        }
	        else if (fieldDef.type === type_1.TEMPORAL) {
	            labelsSpec = util_1.extend({
	                text: {
	                    template: common_1.timeTemplate('datum["data"]', fieldDef.timeUnit, axis.format, axis.shortTimeLabels, config)
	                }
	            }, labelsSpec);
	        }
	        if (axis.labelAngle !== undefined) {
	            labelsSpec.angle = { value: axis.labelAngle };
	        }
	        else {
	            if (channel === channel_1.X && (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin || fieldDef.type === type_1.TEMPORAL)) {
	                labelsSpec.angle = { value: 270 };
	            }
	        }
	        if (axis.labelAlign !== undefined) {
	            labelsSpec.align = { value: axis.labelAlign };
	        }
	        else {
	            if (labelsSpec.angle) {
	                if (labelsSpec.angle.value === 270) {
	                    labelsSpec.align = {
	                        value: def.orient === 'top' ? 'left' :
	                            def.type === 'x' ? 'right' :
	                                'center'
	                    };
	                }
	                else if (labelsSpec.angle.value === 90) {
	                    labelsSpec.align = { value: 'center' };
	                }
	            }
	        }
	        if (axis.labelBaseline !== undefined) {
	            labelsSpec.baseline = { value: axis.labelBaseline };
	        }
	        else {
	            if (labelsSpec.angle) {
	                if (labelsSpec.angle.value === 270) {
	                    labelsSpec.baseline = { value: def.type === 'x' ? 'middle' : 'bottom' };
	                }
	                else if (labelsSpec.angle.value === 90) {
	                    labelsSpec.baseline = { value: 'bottom' };
	                }
	            }
	        }
	        if (axis.tickLabelColor !== undefined) {
	            labelsSpec.stroke = { value: axis.tickLabelColor };
	        }
	        if (axis.tickLabelFont !== undefined) {
	            labelsSpec.font = { value: axis.tickLabelFont };
	        }
	        if (axis.tickLabelFontSize !== undefined) {
	            labelsSpec.fontSize = { value: axis.tickLabelFontSize };
	        }
	        return util_1.keys(labelsSpec).length === 0 ? undefined : labelsSpec;
	    }
	    properties.labels = labels;
	    function ticks(model, channel, ticksPropsSpec) {
	        var axis = model.axis(channel);
	        return util_1.extend(axis.tickColor !== undefined ? { stroke: { value: axis.tickColor } } : {}, axis.tickWidth !== undefined ? { strokeWidth: { value: axis.tickWidth } } : {}, ticksPropsSpec || {});
	    }
	    properties.ticks = ticks;
	    function title(model, channel, titlePropsSpec) {
	        var axis = model.axis(channel);
	        return util_1.extend(axis.titleColor !== undefined ? { stroke: { value: axis.titleColor } } : {}, axis.titleFont !== undefined ? { font: { value: axis.titleFont } } : {}, axis.titleFontSize !== undefined ? { fontSize: { value: axis.titleFontSize } } : {}, axis.titleFontWeight !== undefined ? { fontWeight: { value: axis.titleFontWeight } } : {}, titlePropsSpec || {});
	    }
	    properties.title = title;
	})(properties = exports.properties || (exports.properties = {}));
	//# sourceMappingURL=axis.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/axis.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/data.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/data.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var source_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/source.js');
	var formatparse_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/formatparse.js');
	var nullfilter_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/nullfilter.js');
	var filter_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/filter.js');
	var bin_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/bin.js');
	var formula_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/formula.js');
	var nonpositivenullfilter_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/nonpositivenullfilter.js');
	var summary_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/summary.js');
	var stackscale_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/stackscale.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/timeunit.js');
	var timeunitdomain_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/timeunitdomain.js');
	var colorrank_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/colorrank.js');
	function parseUnitData(model) {
	    return {
	        formatParse: formatparse_1.formatParse.parseUnit(model),
	        nullFilter: nullfilter_1.nullFilter.parseUnit(model),
	        filter: filter_1.filter.parseUnit(model),
	        nonPositiveFilter: nonpositivenullfilter_1.nonPositiveFilter.parseUnit(model),
	        source: source_1.source.parseUnit(model),
	        bin: bin_1.bin.parseUnit(model),
	        calculate: formula_1.formula.parseUnit(model),
	        timeUnit: timeunit_1.timeUnit.parseUnit(model),
	        timeUnitDomain: timeunitdomain_1.timeUnitDomain.parseUnit(model),
	        summary: summary_1.summary.parseUnit(model),
	        stackScale: stackscale_1.stackScale.parseUnit(model),
	        colorRank: colorrank_1.colorRank.parseUnit(model)
	    };
	}
	exports.parseUnitData = parseUnitData;
	function parseFacetData(model) {
	    return {
	        formatParse: formatparse_1.formatParse.parseFacet(model),
	        nullFilter: nullfilter_1.nullFilter.parseFacet(model),
	        filter: filter_1.filter.parseFacet(model),
	        nonPositiveFilter: nonpositivenullfilter_1.nonPositiveFilter.parseFacet(model),
	        source: source_1.source.parseFacet(model),
	        bin: bin_1.bin.parseFacet(model),
	        calculate: formula_1.formula.parseFacet(model),
	        timeUnit: timeunit_1.timeUnit.parseFacet(model),
	        timeUnitDomain: timeunitdomain_1.timeUnitDomain.parseFacet(model),
	        summary: summary_1.summary.parseFacet(model),
	        stackScale: stackscale_1.stackScale.parseFacet(model),
	        colorRank: colorrank_1.colorRank.parseFacet(model)
	    };
	}
	exports.parseFacetData = parseFacetData;
	function parseLayerData(model) {
	    return {
	        filter: filter_1.filter.parseLayer(model),
	        formatParse: formatparse_1.formatParse.parseLayer(model),
	        nullFilter: nullfilter_1.nullFilter.parseLayer(model),
	        nonPositiveFilter: nonpositivenullfilter_1.nonPositiveFilter.parseLayer(model),
	        source: source_1.source.parseLayer(model),
	        bin: bin_1.bin.parseLayer(model),
	        calculate: formula_1.formula.parseLayer(model),
	        timeUnit: timeunit_1.timeUnit.parseLayer(model),
	        timeUnitDomain: timeunitdomain_1.timeUnitDomain.parseLayer(model),
	        summary: summary_1.summary.parseLayer(model),
	        stackScale: stackscale_1.stackScale.parseLayer(model),
	        colorRank: colorrank_1.colorRank.parseLayer(model)
	    };
	}
	exports.parseLayerData = parseLayerData;
	function assembleData(model, data) {
	    var component = model.component.data;
	    var sourceData = source_1.source.assemble(model, component);
	    if (sourceData) {
	        data.push(sourceData);
	    }
	    summary_1.summary.assemble(component, model).forEach(function (summaryData) {
	        data.push(summaryData);
	    });
	    if (data.length > 0) {
	        var dataTable = data[data.length - 1];
	        var colorRankTransform = colorrank_1.colorRank.assemble(component);
	        if (colorRankTransform.length > 0) {
	            dataTable.transform = (dataTable.transform || []).concat(colorRankTransform);
	        }
	        var nonPositiveFilterTransform = nonpositivenullfilter_1.nonPositiveFilter.assemble(component);
	        if (nonPositiveFilterTransform.length > 0) {
	            dataTable.transform = (dataTable.transform || []).concat(nonPositiveFilterTransform);
	        }
	    }
	    else {
	        if (util_1.keys(component.colorRank).length > 0) {
	            throw new Error('Invalid colorRank not merged');
	        }
	        else if (util_1.keys(component.nonPositiveFilter).length > 0) {
	            throw new Error('Invalid nonPositiveFilter not merged');
	        }
	    }
	    var stackData = stackscale_1.stackScale.assemble(component);
	    if (stackData) {
	        data.push(stackData);
	    }
	    timeunitdomain_1.timeUnitDomain.assemble(component).forEach(function (timeUnitDomainData) {
	        data.push(timeUnitDomainData);
	    });
	    return data;
	}
	exports.assembleData = assembleData;
	//# sourceMappingURL=data.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/data.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/source.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/source.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var nullfilter_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/nullfilter.js');
	var filter_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/filter.js');
	var bin_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/bin.js');
	var formula_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/formula.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/timeunit.js');
	var source;
	(function (source) {
	    function parse(model) {
	        var data = model.data();
	        if (data) {
	            var sourceData = { name: model.dataName(data_1.SOURCE) };
	            if (data.values && data.values.length > 0) {
	                sourceData.values = data.values;
	                sourceData.format = { type: 'json' };
	            }
	            else if (data.url) {
	                sourceData.url = data.url;
	                var defaultExtension = /(?:\.([^.]+))?$/.exec(sourceData.url)[1];
	                if (!util_1.contains(['json', 'csv', 'tsv', 'topojson'], defaultExtension)) {
	                    defaultExtension = 'json';
	                }
	                var dataFormat = data.format || {};
	                var formatType = dataFormat.type || data['formatType'];
	                sourceData.format =
	                    util_1.extend({ type: formatType ? formatType : defaultExtension }, dataFormat.property ? { property: dataFormat.property } : {}, dataFormat.feature ?
	                        { feature: dataFormat.feature } :
	                        dataFormat.mesh ?
	                            { mesh: dataFormat.mesh } :
	                            {});
	            }
	            return sourceData;
	        }
	        else if (!model.parent()) {
	            return { name: model.dataName(data_1.SOURCE) };
	        }
	        return undefined;
	    }
	    source.parseUnit = parse;
	    function parseFacet(model) {
	        var sourceData = parse(model);
	        if (!model.child().component.data.source) {
	            model.child().renameData(model.child().dataName(data_1.SOURCE), model.dataName(data_1.SOURCE));
	        }
	        return sourceData;
	    }
	    source.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var sourceData = parse(model);
	        model.children().forEach(function (child) {
	            var childData = child.component.data;
	            if (model.compatibleSource(child)) {
	                var canMerge = !childData.filter && !childData.formatParse && !childData.nullFilter;
	                if (canMerge) {
	                    child.renameData(child.dataName(data_1.SOURCE), model.dataName(data_1.SOURCE));
	                    delete childData.source;
	                }
	                else {
	                    childData.source = {
	                        name: child.dataName(data_1.SOURCE),
	                        source: model.dataName(data_1.SOURCE)
	                    };
	                }
	            }
	        });
	        return sourceData;
	    }
	    source.parseLayer = parseLayer;
	    function assemble(model, component) {
	        if (component.source) {
	            var sourceData = component.source;
	            if (component.formatParse) {
	                component.source.format = component.source.format || {};
	                component.source.format.parse = component.formatParse;
	            }
	            sourceData.transform = [].concat(formula_1.formula.assemble(component), nullfilter_1.nullFilter.assemble(component), filter_1.filter.assemble(component), bin_1.bin.assemble(component), timeunit_1.timeUnit.assemble(component));
	            return sourceData;
	        }
	        return null;
	    }
	    source.assemble = assemble;
	})(source = exports.source || (exports.source = {}));
	//# sourceMappingURL=source.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/source.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/nullfilter.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/nullfilter.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var DEFAULT_NULL_FILTERS = {
	    nominal: false,
	    ordinal: false,
	    quantitative: true,
	    temporal: true
	};
	var nullFilter;
	(function (nullFilter) {
	    function parse(model) {
	        var transform = model.transform();
	        var filterInvalid = transform.filterInvalid;
	        if (filterInvalid === undefined && transform['filterNull'] !== undefined) {
	            filterInvalid = transform['filterNull'];
	            console.warn('filterNull is deprecated. Please use filterInvalid instead.');
	        }
	        return model.reduce(function (aggregator, fieldDef) {
	            if (fieldDef.field !== '*') {
	                if (filterInvalid ||
	                    (filterInvalid === undefined && fieldDef.field && DEFAULT_NULL_FILTERS[fieldDef.type])) {
	                    aggregator[fieldDef.field] = fieldDef;
	                }
	                else {
	                    aggregator[fieldDef.field] = null;
	                }
	            }
	            return aggregator;
	        }, {});
	    }
	    nullFilter.parseUnit = parse;
	    function parseFacet(model) {
	        var nullFilterComponent = parse(model);
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source) {
	            util_1.extend(nullFilterComponent, childDataComponent.nullFilter);
	            delete childDataComponent.nullFilter;
	        }
	        return nullFilterComponent;
	    }
	    nullFilter.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var nullFilterComponent = parse(model);
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (model.compatibleSource(child) && !util_1.differ(childDataComponent.nullFilter, nullFilterComponent)) {
	                util_1.extend(nullFilterComponent, childDataComponent.nullFilter);
	                delete childDataComponent.nullFilter;
	            }
	        });
	        return nullFilterComponent;
	    }
	    nullFilter.parseLayer = parseLayer;
	    function assemble(component) {
	        var filters = util_1.keys(component.nullFilter).reduce(function (_filters, field) {
	            var fieldDef = component.nullFilter[field];
	            if (fieldDef !== null) {
	                _filters.push('datum["' + fieldDef.field + '"] !== null');
	                if (util_1.contains([type_1.QUANTITATIVE, type_1.TEMPORAL], fieldDef.type)) {
	                    _filters.push('!isNaN(datum["' + fieldDef.field + '"])');
	                }
	            }
	            return _filters;
	        }, []);
	        return filters.length > 0 ?
	            [{
	                    type: 'filter',
	                    test: filters.join(' && ')
	                }] : [];
	    }
	    nullFilter.assemble = assemble;
	})(nullFilter = exports.nullFilter || (exports.nullFilter = {}));
	//# sourceMappingURL=nullfilter.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/nullfilter.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/filter.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/filter.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var filter_1 = __jupyter_require__('vega-lite@~1.2.0/src/filter.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var filter;
	(function (filter_2) {
	    function parse(model) {
	        var filter = model.transform().filter;
	        if (util_1.isArray(filter)) {
	            return '(' +
	                filter.map(function (f) { return filter_1.expression(f); })
	                    .filter(function (f) { return f !== undefined; })
	                    .join(') && (') +
	                ')';
	        }
	        else if (filter) {
	            return filter_1.expression(filter);
	        }
	        return undefined;
	    }
	    filter_2.parse = parse;
	    filter_2.parseUnit = parse;
	    function parseFacet(model) {
	        var filterComponent = parse(model);
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source && childDataComponent.filter) {
	            filterComponent =
	                (filterComponent ? filterComponent + ' && ' : '') +
	                    childDataComponent.filter;
	            delete childDataComponent.filter;
	        }
	        return filterComponent;
	    }
	    filter_2.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var filterComponent = parse(model);
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (model.compatibleSource(child) && childDataComponent.filter && childDataComponent.filter === filterComponent) {
	                delete childDataComponent.filter;
	            }
	        });
	        return filterComponent;
	    }
	    filter_2.parseLayer = parseLayer;
	    function assemble(component) {
	        var filter = component.filter;
	        return filter ? [{
	                type: 'filter',
	                test: filter
	            }] : [];
	    }
	    filter_2.assemble = assemble;
	})(filter = exports.filter || (exports.filter = {}));
	//# sourceMappingURL=filter.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/filter.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/filter.js **/
jupyter.define('vega-lite@1.2.0/src/filter.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var datetime_1 = __jupyter_require__('vega-lite@~1.2.0/src/datetime.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	function isEqualFilter(filter) {
	    return filter && !!filter.field && filter.equal !== undefined;
	}
	exports.isEqualFilter = isEqualFilter;
	function isRangeFilter(filter) {
	    if (filter && !!filter.field) {
	        if (util_1.isArray(filter.range) && filter.range.length === 2) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.isRangeFilter = isRangeFilter;
	function isOneOfFilter(filter) {
	    return filter && !!filter.field && (util_1.isArray(filter.oneOf) ||
	        util_1.isArray(filter.in));
	}
	exports.isOneOfFilter = isOneOfFilter;
	function expression(filter) {
	    if (util_1.isString(filter)) {
	        return filter;
	    }
	    else {
	        var fieldExpr = filter.timeUnit ?
	            ('time(' + timeunit_1.fieldExpr(filter.timeUnit, filter.field) + ')') :
	            fielddef_1.field(filter, { datum: true });
	        if (isEqualFilter(filter)) {
	            return fieldExpr + '===' + valueExpr(filter.equal, filter.timeUnit);
	        }
	        else if (isOneOfFilter(filter)) {
	            var oneOf = filter.oneOf || filter['in'];
	            return 'indexof([' +
	                oneOf.map(function (v) { return valueExpr(v, filter.timeUnit); }).join(',') +
	                '], ' + fieldExpr + ') !== -1';
	        }
	        else if (isRangeFilter(filter)) {
	            var lower = filter.range[0];
	            var upper = filter.range[1];
	            if (lower !== null && upper !== null) {
	                return 'inrange(' + fieldExpr + ', ' +
	                    valueExpr(lower, filter.timeUnit) + ', ' +
	                    valueExpr(upper, filter.timeUnit) + ')';
	            }
	            else if (lower !== null) {
	                return fieldExpr + ' >= ' + lower;
	            }
	            else if (upper !== null) {
	                return fieldExpr + ' <= ' + upper;
	            }
	        }
	    }
	    return undefined;
	}
	exports.expression = expression;
	function valueExpr(v, timeUnit) {
	    if (datetime_1.isDateTime(v)) {
	        var expr = datetime_1.dateTimeExpr(v, true);
	        return 'time(' + expr + ')';
	    }
	    if (timeunit_1.isSingleTimeUnit(timeUnit)) {
	        var datetime = {};
	        datetime[timeUnit] = v;
	        var expr = datetime_1.dateTimeExpr(datetime, true);
	        return 'time(' + expr + ')';
	    }
	    return JSON.stringify(v);
	}
	//# sourceMappingURL=filter.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/filter.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/datetime.js **/
jupyter.define('vega-lite@1.2.0/src/datetime.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	function isDateTime(o) {
	    return !!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||
	        !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds;
	}
	exports.isDateTime = isDateTime;
	exports.MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
	exports.SHORT_MONTHS = exports.MONTHS.map(function (m) { return m.substr(0, 3); });
	exports.DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
	exports.SHORT_DAYS = exports.DAYS.map(function (d) { return d.substr(0, 3); });
	function normalizeQuarter(q) {
	    if (util_1.isNumber(q)) {
	        return (q - 1) + '';
	    }
	    else {
	        console.warn('Potentially invalid quarter', q);
	        return q;
	    }
	}
	function normalizeMonth(m) {
	    if (util_1.isNumber(m)) {
	        return (m - 1) + '';
	    }
	    else {
	        var lowerM = m.toLowerCase();
	        var monthIndex = exports.MONTHS.indexOf(lowerM);
	        if (monthIndex !== -1) {
	            return monthIndex + '';
	        }
	        var shortM = lowerM.substr(0, 3);
	        var shortMonthIndex = exports.SHORT_MONTHS.indexOf(shortM);
	        if (shortMonthIndex !== -1) {
	            return shortMonthIndex + '';
	        }
	        console.warn('Potentially invalid month', m);
	        return m;
	    }
	}
	function normalizeDay(d) {
	    if (util_1.isNumber(d)) {
	        return (d % 7) + '';
	    }
	    else {
	        var lowerD = d.toLowerCase();
	        var dayIndex = exports.DAYS.indexOf(lowerD);
	        if (dayIndex !== -1) {
	            return dayIndex + '';
	        }
	        var shortD = lowerD.substr(0, 3);
	        var shortDayIndex = exports.SHORT_DAYS.indexOf(shortD);
	        if (shortDayIndex !== -1) {
	            return shortDayIndex + '';
	        }
	        console.warn('Potentially invalid day', d);
	        return d;
	    }
	}
	function dateTimeExpr(d, normalize) {
	    if (normalize === void 0) { normalize = false; }
	    var units = [];
	    if (normalize && d.day !== undefined) {
	        for (var _i = 0, _a = ['year', 'quarter', 'month', 'date']; _i < _a.length; _i++) {
	            var unit = _a[_i];
	            if (d[unit] !== undefined) {
	                console.warn('Dropping day from datetime', JSON.stringify(d), 'as day cannot be combined with', unit);
	                d = util_1.duplicate(d);
	                delete d.day;
	                break;
	            }
	        }
	    }
	    if (d.year !== undefined) {
	        units.push(d.year);
	    }
	    else if (d.day !== undefined) {
	        units.push(2006);
	    }
	    else {
	        units.push(0);
	    }
	    if (d.month !== undefined) {
	        var month = normalize ? normalizeMonth(d.month) : d.month;
	        units.push(month);
	    }
	    else if (d.quarter !== undefined) {
	        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;
	        units.push(quarter + '*3');
	    }
	    else {
	        units.push(0);
	    }
	    if (d.date !== undefined) {
	        units.push(d.date);
	    }
	    else if (d.day !== undefined) {
	        var day = normalize ? normalizeDay(d.day) : d.day;
	        units.push(day + '+1');
	    }
	    else {
	        units.push(1);
	    }
	    for (var _b = 0, _c = ['hours', 'minutes', 'seconds', 'milliseconds']; _b < _c.length; _b++) {
	        var timeUnit = _c[_b];
	        if (d[timeUnit] !== undefined) {
	            units.push(d[timeUnit]);
	        }
	        else {
	            units.push(0);
	        }
	    }
	    return 'datetime(' + units.join(', ') + ')';
	}
	exports.dateTimeExpr = dateTimeExpr;
	//# sourceMappingURL=datetime.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/datetime.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/timeunit.js **/
jupyter.define('vega-lite@1.2.0/src/timeunit.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var datetime_1 = __jupyter_require__('vega-lite@~1.2.0/src/datetime.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	(function (TimeUnit) {
	    TimeUnit[TimeUnit["YEAR"] = 'year'] = "YEAR";
	    TimeUnit[TimeUnit["MONTH"] = 'month'] = "MONTH";
	    TimeUnit[TimeUnit["DAY"] = 'day'] = "DAY";
	    TimeUnit[TimeUnit["DATE"] = 'date'] = "DATE";
	    TimeUnit[TimeUnit["HOURS"] = 'hours'] = "HOURS";
	    TimeUnit[TimeUnit["MINUTES"] = 'minutes'] = "MINUTES";
	    TimeUnit[TimeUnit["SECONDS"] = 'seconds'] = "SECONDS";
	    TimeUnit[TimeUnit["MILLISECONDS"] = 'milliseconds'] = "MILLISECONDS";
	    TimeUnit[TimeUnit["YEARMONTH"] = 'yearmonth'] = "YEARMONTH";
	    TimeUnit[TimeUnit["YEARMONTHDATE"] = 'yearmonthdate'] = "YEARMONTHDATE";
	    TimeUnit[TimeUnit["YEARMONTHDATEHOURS"] = 'yearmonthdatehours'] = "YEARMONTHDATEHOURS";
	    TimeUnit[TimeUnit["YEARMONTHDATEHOURSMINUTES"] = 'yearmonthdatehoursminutes'] = "YEARMONTHDATEHOURSMINUTES";
	    TimeUnit[TimeUnit["YEARMONTHDATEHOURSMINUTESSECONDS"] = 'yearmonthdatehoursminutesseconds'] = "YEARMONTHDATEHOURSMINUTESSECONDS";
	    TimeUnit[TimeUnit["HOURSMINUTES"] = 'hoursminutes'] = "HOURSMINUTES";
	    TimeUnit[TimeUnit["HOURSMINUTESSECONDS"] = 'hoursminutesseconds'] = "HOURSMINUTESSECONDS";
	    TimeUnit[TimeUnit["MINUTESSECONDS"] = 'minutesseconds'] = "MINUTESSECONDS";
	    TimeUnit[TimeUnit["SECONDSMILLISECONDS"] = 'secondsmilliseconds'] = "SECONDSMILLISECONDS";
	    TimeUnit[TimeUnit["QUARTER"] = 'quarter'] = "QUARTER";
	    TimeUnit[TimeUnit["YEARQUARTER"] = 'yearquarter'] = "YEARQUARTER";
	    TimeUnit[TimeUnit["QUARTERMONTH"] = 'quartermonth'] = "QUARTERMONTH";
	    TimeUnit[TimeUnit["YEARQUARTERMONTH"] = 'yearquartermonth'] = "YEARQUARTERMONTH";
	})(exports.TimeUnit || (exports.TimeUnit = {}));
	var TimeUnit = exports.TimeUnit;
	exports.SINGLE_TIMEUNITS = [
	    TimeUnit.YEAR,
	    TimeUnit.QUARTER,
	    TimeUnit.MONTH,
	    TimeUnit.DAY,
	    TimeUnit.DATE,
	    TimeUnit.HOURS,
	    TimeUnit.MINUTES,
	    TimeUnit.SECONDS,
	    TimeUnit.MILLISECONDS,
	];
	var SINGLE_TIMEUNIT_INDEX = exports.SINGLE_TIMEUNITS.reduce(function (d, timeUnit) {
	    d[timeUnit] = true;
	    return d;
	}, {});
	function isSingleTimeUnit(timeUnit) {
	    return !!SINGLE_TIMEUNIT_INDEX[timeUnit];
	}
	exports.isSingleTimeUnit = isSingleTimeUnit;
	function convert(unit, date) {
	    var result = new Date(0, 0, 1, 0, 0, 0, 0);
	    exports.SINGLE_TIMEUNITS.forEach(function (singleUnit) {
	        if (containsTimeUnit(unit, singleUnit)) {
	            switch (singleUnit) {
	                case TimeUnit.DAY:
	                    throw new Error('Cannot convert to TimeUnits containing \'day\'');
	                case TimeUnit.YEAR:
	                    result.setFullYear(date.getFullYear());
	                    break;
	                case TimeUnit.QUARTER:
	                    result.setMonth((Math.floor(date.getMonth() / 3)) * 3);
	                    break;
	                case TimeUnit.MONTH:
	                    result.setMonth(date.getMonth());
	                    break;
	                case TimeUnit.DATE:
	                    result.setDate(date.getDate());
	                    break;
	                case TimeUnit.HOURS:
	                    result.setHours(date.getHours());
	                    break;
	                case TimeUnit.MINUTES:
	                    result.setMinutes(date.getMinutes());
	                    break;
	                case TimeUnit.SECONDS:
	                    result.setSeconds(date.getSeconds());
	                    break;
	                case TimeUnit.MILLISECONDS:
	                    result.setMilliseconds(date.getMilliseconds());
	                    break;
	            }
	        }
	    });
	    return result;
	}
	exports.convert = convert;
	exports.MULTI_TIMEUNITS = [
	    TimeUnit.YEARQUARTER,
	    TimeUnit.YEARQUARTERMONTH,
	    TimeUnit.YEARMONTH,
	    TimeUnit.YEARMONTHDATE,
	    TimeUnit.YEARMONTHDATEHOURS,
	    TimeUnit.YEARMONTHDATEHOURSMINUTES,
	    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,
	    TimeUnit.QUARTERMONTH,
	    TimeUnit.HOURSMINUTES,
	    TimeUnit.HOURSMINUTESSECONDS,
	    TimeUnit.MINUTESSECONDS,
	    TimeUnit.SECONDSMILLISECONDS,
	];
	var MULTI_TIMEUNIT_INDEX = exports.MULTI_TIMEUNITS.reduce(function (d, timeUnit) {
	    d[timeUnit] = true;
	    return d;
	}, {});
	function isMultiTimeUnit(timeUnit) {
	    return !!MULTI_TIMEUNIT_INDEX[timeUnit];
	}
	exports.isMultiTimeUnit = isMultiTimeUnit;
	exports.TIMEUNITS = exports.SINGLE_TIMEUNITS.concat(exports.MULTI_TIMEUNITS);
	function containsTimeUnit(fullTimeUnit, timeUnit) {
	    var fullTimeUnitStr = fullTimeUnit.toString();
	    var timeUnitStr = timeUnit.toString();
	    var index = fullTimeUnitStr.indexOf(timeUnitStr);
	    return index > -1 &&
	        (timeUnit !== TimeUnit.SECONDS ||
	            index === 0 ||
	            fullTimeUnitStr.charAt(index - 1) !== 'i');
	}
	exports.containsTimeUnit = containsTimeUnit;
	function defaultScaleType(timeUnit) {
	    switch (timeUnit) {
	        case TimeUnit.HOURS:
	        case TimeUnit.DAY:
	        case TimeUnit.MONTH:
	        case TimeUnit.QUARTER:
	            return scale_1.ScaleType.ORDINAL;
	    }
	    return scale_1.ScaleType.TIME;
	}
	exports.defaultScaleType = defaultScaleType;
	function fieldExpr(fullTimeUnit, field) {
	    var fieldRef = 'datum["' + field + '"]';
	    function func(timeUnit) {
	        if (timeUnit === TimeUnit.QUARTER) {
	            return 'floor(month(' + fieldRef + ')' + '/3)';
	        }
	        else {
	            return timeUnit + '(' + fieldRef + ')';
	        }
	    }
	    var d = exports.SINGLE_TIMEUNITS.reduce(function (_d, tu) {
	        if (containsTimeUnit(fullTimeUnit, tu)) {
	            _d[tu] = func(tu);
	        }
	        return _d;
	    }, {});
	    if (d.day && util_1.keys(d).length > 1) {
	        console.warn('Time unit "' + fullTimeUnit + '" is not supported. We are replacing it with ', (fullTimeUnit + '').replace('day', 'date') + '.');
	        delete d.day;
	        d.date = func(TimeUnit.DATE);
	    }
	    return datetime_1.dateTimeExpr(d);
	}
	exports.fieldExpr = fieldExpr;
	function rawDomain(timeUnit, channel) {
	    if (util_1.contains([channel_1.ROW, channel_1.COLUMN, channel_1.SHAPE, channel_1.COLOR], channel)) {
	        return null;
	    }
	    switch (timeUnit) {
	        case TimeUnit.SECONDS:
	            return util_1.range(0, 60);
	        case TimeUnit.MINUTES:
	            return util_1.range(0, 60);
	        case TimeUnit.HOURS:
	            return util_1.range(0, 24);
	        case TimeUnit.DAY:
	            return util_1.range(0, 7);
	        case TimeUnit.DATE:
	            return util_1.range(1, 32);
	        case TimeUnit.MONTH:
	            return util_1.range(0, 12);
	        case TimeUnit.QUARTER:
	            return [0, 3, 6, 9];
	    }
	    return null;
	}
	exports.rawDomain = rawDomain;
	function smallestUnit(timeUnit) {
	    if (!timeUnit) {
	        return undefined;
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {
	        return 'second';
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {
	        return 'minute';
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {
	        return 'hour';
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||
	        containsTimeUnit(timeUnit, TimeUnit.DATE)) {
	        return 'day';
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {
	        return 'month';
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {
	        return 'year';
	    }
	    return undefined;
	}
	exports.smallestUnit = smallestUnit;
	function template(timeUnit, field, shortTimeLabels) {
	    if (!timeUnit) {
	        return undefined;
	    }
	    var dateComponents = [];
	    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {
	        dateComponents.push(shortTimeLabels ? '%y' : '%Y');
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {
	        dateComponents.push('\'}}Q{{' + field + ' | quarter}}{{' + field + ' | time:\'');
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {
	        dateComponents.push(shortTimeLabels ? '%b' : '%B');
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {
	        dateComponents.push(shortTimeLabels ? '%a' : '%A');
	    }
	    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {
	        dateComponents.push('%d');
	    }
	    var timeComponents = [];
	    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {
	        timeComponents.push('%H');
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {
	        timeComponents.push('%M');
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {
	        timeComponents.push('%S');
	    }
	    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {
	        timeComponents.push('%L');
	    }
	    var out = [];
	    if (dateComponents.length > 0) {
	        out.push(dateComponents.join('-'));
	    }
	    if (timeComponents.length > 0) {
	        out.push(timeComponents.join(':'));
	    }
	    if (out.length > 0) {
	        var template_1 = '{{' + field + ' | time:\'' + out.join(' ') + '\'}}';
	        var escapedField = field.replace(/(\[|\])/g, '\\$1');
	        return template_1.replace(new RegExp('{{' + escapedField + ' \\| time:\'\'}}', 'g'), '');
	    }
	    else {
	        return undefined;
	    }
	}
	exports.template = template;
	//# sourceMappingURL=timeunit.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/timeunit.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/bin.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/bin.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var bin_1 = __jupyter_require__('vega-lite@~1.2.0/src/bin.js');
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var bin;
	(function (bin_2) {
	    function parse(model) {
	        return model.reduce(function (binComponent, fieldDef, channel) {
	            var bin = model.fieldDef(channel).bin;
	            if (bin) {
	                var binTrans = util_1.extend({
	                    type: 'bin',
	                    field: fieldDef.field,
	                    output: {
	                        start: fielddef_1.field(fieldDef, { binSuffix: 'start' }),
	                        mid: fielddef_1.field(fieldDef, { binSuffix: 'mid' }),
	                        end: fielddef_1.field(fieldDef, { binSuffix: 'end' })
	                    }
	                }, typeof bin === 'boolean' ? {} : bin);
	                if (!binTrans.maxbins && !binTrans.step) {
	                    binTrans.maxbins = bin_1.autoMaxBins(channel);
	                }
	                var transform = [binTrans];
	                var isOrdinalColor = model.isOrdinalScale(channel) || channel === channel_1.COLOR;
	                if (isOrdinalColor) {
	                    transform.push({
	                        type: 'formula',
	                        field: fielddef_1.field(fieldDef, { binSuffix: 'range' }),
	                        expr: fielddef_1.field(fieldDef, { datum: true, binSuffix: 'start' }) +
	                            ' + \'-\' + ' +
	                            fielddef_1.field(fieldDef, { datum: true, binSuffix: 'end' })
	                    });
	                }
	                var key = util_1.hash(bin) + '_' + fieldDef.field + 'oc:' + isOrdinalColor;
	                binComponent[key] = transform;
	            }
	            return binComponent;
	        }, {});
	    }
	    bin_2.parseUnit = parse;
	    function parseFacet(model) {
	        var binComponent = parse(model);
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source) {
	            util_1.extend(binComponent, childDataComponent.bin);
	            delete childDataComponent.bin;
	        }
	        return binComponent;
	    }
	    bin_2.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var binComponent = parse(model);
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (!childDataComponent.source) {
	                util_1.extend(binComponent, childDataComponent.bin);
	                delete childDataComponent.bin;
	            }
	        });
	        return binComponent;
	    }
	    bin_2.parseLayer = parseLayer;
	    function assemble(component) {
	        return util_1.flatten(util_1.vals(component.bin));
	    }
	    bin_2.assemble = assemble;
	})(bin = exports.bin || (exports.bin = {}));
	//# sourceMappingURL=bin.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/bin.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/formula.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/formula.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var formula;
	(function (formula_1) {
	    function parse(model) {
	        return (model.transform().calculate || []).reduce(function (formulaComponent, formula) {
	            formulaComponent[util_1.hash(formula)] = formula;
	            return formulaComponent;
	        }, {});
	    }
	    formula_1.parseUnit = parse;
	    function parseFacet(model) {
	        var formulaComponent = parse(model);
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source) {
	            util_1.extend(formulaComponent, childDataComponent.calculate);
	            delete childDataComponent.calculate;
	        }
	        return formulaComponent;
	    }
	    formula_1.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var formulaComponent = parse(model);
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (!childDataComponent.source && childDataComponent.calculate) {
	                util_1.extend(formulaComponent || {}, childDataComponent.calculate);
	                delete childDataComponent.calculate;
	            }
	        });
	        return formulaComponent;
	    }
	    formula_1.parseLayer = parseLayer;
	    function assemble(component) {
	        return util_1.vals(component.calculate).reduce(function (transform, formula) {
	            transform.push(util_1.extend({ type: 'formula' }, formula));
	            return transform;
	        }, []);
	    }
	    formula_1.assemble = assemble;
	})(formula = exports.formula || (exports.formula = {}));
	//# sourceMappingURL=formula.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/formula.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/timeunit.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/timeunit.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var timeUnit;
	(function (timeUnit) {
	    function parse(model) {
	        return model.reduce(function (timeUnitComponent, fieldDef, channel) {
	            if (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit) {
	                var hash = fielddef_1.field(fieldDef);
	                timeUnitComponent[hash] = {
	                    type: 'formula',
	                    field: fielddef_1.field(fieldDef),
	                    expr: timeunit_1.fieldExpr(fieldDef.timeUnit, fieldDef.field)
	                };
	            }
	            return timeUnitComponent;
	        }, {});
	    }
	    timeUnit.parseUnit = parse;
	    function parseFacet(model) {
	        var timeUnitComponent = parse(model);
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source) {
	            util_1.extend(timeUnitComponent, childDataComponent.timeUnit);
	            delete childDataComponent.timeUnit;
	        }
	        return timeUnitComponent;
	    }
	    timeUnit.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var timeUnitComponent = parse(model);
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (!childDataComponent.source) {
	                util_1.extend(timeUnitComponent, childDataComponent.timeUnit);
	                delete childDataComponent.timeUnit;
	            }
	        });
	        return timeUnitComponent;
	    }
	    timeUnit.parseLayer = parseLayer;
	    function assemble(component) {
	        return util_1.vals(component.timeUnit);
	    }
	    timeUnit.assemble = assemble;
	})(timeUnit = exports.timeUnit || (exports.timeUnit = {}));
	//# sourceMappingURL=timeunit.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/timeunit.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/formatparse.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/formatparse.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var formatParse;
	(function (formatParse) {
	    function parse(model) {
	        var calcFieldMap = (model.transform().calculate || []).reduce(function (fieldMap, formula) {
	            fieldMap[formula.field] = true;
	            return fieldMap;
	        }, {});
	        var parseComponent = {};
	        model.forEach(function (fieldDef) {
	            if (fieldDef.type === type_1.TEMPORAL) {
	                parseComponent[fieldDef.field] = 'date';
	            }
	            else if (fieldDef.type === type_1.QUANTITATIVE) {
	                if (fielddef_1.isCount(fieldDef) || calcFieldMap[fieldDef.field]) {
	                    return;
	                }
	                parseComponent[fieldDef.field] = 'number';
	            }
	        });
	        return parseComponent;
	    }
	    formatParse.parseUnit = parse;
	    function parseFacet(model) {
	        var parseComponent = parse(model);
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source && childDataComponent.formatParse) {
	            util_1.extend(parseComponent, childDataComponent.formatParse);
	            delete childDataComponent.formatParse;
	        }
	        return parseComponent;
	    }
	    formatParse.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var parseComponent = parse(model);
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (model.compatibleSource(child) && !util_1.differ(childDataComponent.formatParse, parseComponent)) {
	                util_1.extend(parseComponent, childDataComponent.formatParse);
	                delete childDataComponent.formatParse;
	            }
	        });
	        return parseComponent;
	    }
	    formatParse.parseLayer = parseLayer;
	})(formatParse = exports.formatParse || (exports.formatParse = {}));
	//# sourceMappingURL=formatparse.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/formatparse.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/nonpositivenullfilter.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/nonpositivenullfilter.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var nonPositiveFilter;
	(function (nonPositiveFilter_1) {
	    function parseUnit(model) {
	        return model.channels().reduce(function (nonPositiveComponent, channel) {
	            var scale = model.scale(channel);
	            if (!model.field(channel) || !scale) {
	                return nonPositiveComponent;
	            }
	            nonPositiveComponent[model.field(channel)] = scale.type === scale_1.ScaleType.LOG;
	            return nonPositiveComponent;
	        }, {});
	    }
	    nonPositiveFilter_1.parseUnit = parseUnit;
	    function parseFacet(model) {
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source) {
	            var nonPositiveFilterComponent = childDataComponent.nonPositiveFilter;
	            delete childDataComponent.nonPositiveFilter;
	            return nonPositiveFilterComponent;
	        }
	        return {};
	    }
	    nonPositiveFilter_1.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var nonPositiveFilter = {};
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (model.compatibleSource(child) && !util_1.differ(childDataComponent.nonPositiveFilter, nonPositiveFilter)) {
	                util_1.extend(nonPositiveFilter, childDataComponent.nonPositiveFilter);
	                delete childDataComponent.nonPositiveFilter;
	            }
	        });
	        return nonPositiveFilter;
	    }
	    nonPositiveFilter_1.parseLayer = parseLayer;
	    function assemble(component) {
	        return util_1.keys(component.nonPositiveFilter).filter(function (field) {
	            return component.nonPositiveFilter[field];
	        }).map(function (field) {
	            return {
	                type: 'filter',
	                test: 'datum["' + field + '"] > 0'
	            };
	        });
	    }
	    nonPositiveFilter_1.assemble = assemble;
	})(nonPositiveFilter = exports.nonPositiveFilter || (exports.nonPositiveFilter = {}));
	//# sourceMappingURL=nonpositivenullfilter.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/nonpositivenullfilter.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/summary.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/summary.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var aggregate_1 = __jupyter_require__('vega-lite@~1.2.0/src/aggregate.js');
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var summary;
	(function (summary) {
	    function addDimension(dims, fieldDef) {
	        if (fieldDef.bin) {
	            dims[fielddef_1.field(fieldDef, { binSuffix: 'start' })] = true;
	            dims[fielddef_1.field(fieldDef, { binSuffix: 'mid' })] = true;
	            dims[fielddef_1.field(fieldDef, { binSuffix: 'end' })] = true;
	            dims[fielddef_1.field(fieldDef, { binSuffix: 'range' })] = true;
	        }
	        else {
	            dims[fielddef_1.field(fieldDef)] = true;
	        }
	        return dims;
	    }
	    function parseUnit(model) {
	        var dims = {};
	        var meas = {};
	        model.forEach(function (fieldDef, channel) {
	            if (fieldDef.aggregate) {
	                if (fieldDef.aggregate === aggregate_1.AggregateOp.COUNT) {
	                    meas['*'] = meas['*'] || {};
	                    meas['*']['count'] = true;
	                }
	                else {
	                    meas[fieldDef.field] = meas[fieldDef.field] || {};
	                    meas[fieldDef.field][fieldDef.aggregate] = true;
	                }
	            }
	            else {
	                addDimension(dims, fieldDef);
	            }
	        });
	        return [{
	                name: model.dataName(data_1.SUMMARY),
	                dimensions: dims,
	                measures: meas
	            }];
	    }
	    summary.parseUnit = parseUnit;
	    function parseFacet(model) {
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source && childDataComponent.summary) {
	            var summaryComponents = childDataComponent.summary.map(function (summaryComponent) {
	                summaryComponent.dimensions = model.reduce(addDimension, summaryComponent.dimensions);
	                var summaryNameWithoutPrefix = summaryComponent.name.substr(model.child().name('').length);
	                model.child().renameData(summaryComponent.name, summaryNameWithoutPrefix);
	                summaryComponent.name = summaryNameWithoutPrefix;
	                return summaryComponent;
	            });
	            delete childDataComponent.summary;
	            return summaryComponents;
	        }
	        return [];
	    }
	    summary.parseFacet = parseFacet;
	    function mergeMeasures(parentMeasures, childMeasures) {
	        for (var field_1 in childMeasures) {
	            if (childMeasures.hasOwnProperty(field_1)) {
	                var ops = childMeasures[field_1];
	                for (var op in ops) {
	                    if (ops.hasOwnProperty(op)) {
	                        if (field_1 in parentMeasures) {
	                            parentMeasures[field_1][op] = true;
	                        }
	                        else {
	                            parentMeasures[field_1] = { op: true };
	                        }
	                    }
	                }
	            }
	        }
	    }
	    function parseLayer(model) {
	        var summaries = {};
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (!childDataComponent.source && childDataComponent.summary) {
	                childDataComponent.summary.forEach(function (childSummary) {
	                    var key = util_1.hash(childSummary.dimensions);
	                    if (key in summaries) {
	                        mergeMeasures(summaries[key].measures, childSummary.measures);
	                    }
	                    else {
	                        childSummary.name = model.dataName(data_1.SUMMARY) + '_' + util_1.keys(summaries).length;
	                        summaries[key] = childSummary;
	                    }
	                    child.renameData(child.dataName(data_1.SUMMARY), summaries[key].name);
	                    delete childDataComponent.summary;
	                });
	            }
	        });
	        return util_1.vals(summaries);
	    }
	    summary.parseLayer = parseLayer;
	    function assemble(component, model) {
	        if (!component.summary) {
	            return [];
	        }
	        return component.summary.reduce(function (summaryData, summaryComponent) {
	            var dims = summaryComponent.dimensions;
	            var meas = summaryComponent.measures;
	            var groupby = util_1.keys(dims);
	            var summarize = util_1.reduce(meas, function (aggregator, fnDictSet, field) {
	                aggregator[field] = util_1.keys(fnDictSet);
	                return aggregator;
	            }, {});
	            if (util_1.keys(meas).length > 0) {
	                summaryData.push({
	                    name: summaryComponent.name,
	                    source: model.dataName(data_1.SOURCE),
	                    transform: [{
	                            type: 'aggregate',
	                            groupby: groupby,
	                            summarize: summarize
	                        }]
	                });
	            }
	            return summaryData;
	        }, []);
	    }
	    summary.assemble = assemble;
	})(summary = exports.summary || (exports.summary = {}));
	//# sourceMappingURL=summary.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/summary.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/stackscale.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/stackscale.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var stackScale;
	(function (stackScale) {
	    function parseUnit(model) {
	        var stackProps = model.stack();
	        if (stackProps) {
	            var groupbyChannel = stackProps.groupbyChannel;
	            var fieldChannel = stackProps.fieldChannel;
	            var fields = [];
	            var field_1 = model.field(groupbyChannel);
	            if (field_1) {
	                fields.push(field_1);
	            }
	            return {
	                name: model.dataName(data_1.STACKED_SCALE),
	                source: model.dataName(data_1.SUMMARY),
	                transform: [util_1.extend({
	                        type: 'aggregate',
	                        summarize: [{ ops: ['sum'], field: model.field(fieldChannel) }]
	                    }, fields.length > 0 ? {
	                        groupby: fields
	                    } : {})]
	            };
	        }
	        return null;
	    }
	    stackScale.parseUnit = parseUnit;
	    ;
	    function parseFacet(model) {
	        var child = model.child();
	        var childDataComponent = child.component.data;
	        if (!childDataComponent.source && childDataComponent.stackScale) {
	            var stackComponent = childDataComponent.stackScale;
	            var newName = model.dataName(data_1.STACKED_SCALE);
	            child.renameData(stackComponent.name, newName);
	            stackComponent.name = newName;
	            stackComponent.source = model.dataName(data_1.SUMMARY);
	            stackComponent.transform[0].groupby = model.reduce(function (groupby, fieldDef) {
	                groupby.push(fielddef_1.field(fieldDef));
	                return groupby;
	            }, stackComponent.transform[0].groupby);
	            delete childDataComponent.stackScale;
	            return stackComponent;
	        }
	        return null;
	    }
	    stackScale.parseFacet = parseFacet;
	    function parseLayer(model) {
	        return null;
	    }
	    stackScale.parseLayer = parseLayer;
	    function assemble(component) {
	        return component.stackScale;
	    }
	    stackScale.assemble = assemble;
	})(stackScale = exports.stackScale || (exports.stackScale = {}));
	//# sourceMappingURL=stackscale.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/stackscale.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/timeunitdomain.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/timeunitdomain.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var datetime_1 = __jupyter_require__('vega-lite@~1.2.0/src/datetime.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var timeUnitDomain;
	(function (timeUnitDomain) {
	    function parse(model) {
	        return model.reduce(function (timeUnitDomainMap, fieldDef, channel) {
	            if (fieldDef.timeUnit) {
	                var domain = timeunit_1.rawDomain(fieldDef.timeUnit, channel);
	                if (domain) {
	                    timeUnitDomainMap[fieldDef.timeUnit] = true;
	                }
	            }
	            return timeUnitDomainMap;
	        }, {});
	    }
	    timeUnitDomain.parseUnit = parse;
	    function parseFacet(model) {
	        return util_1.extend(parse(model), model.child().component.data.timeUnitDomain);
	    }
	    timeUnitDomain.parseFacet = parseFacet;
	    function parseLayer(model) {
	        return util_1.extend(parse(model), model.children().forEach(function (child) {
	            return child.component.data.timeUnitDomain;
	        }));
	    }
	    timeUnitDomain.parseLayer = parseLayer;
	    function assemble(component) {
	        return util_1.keys(component.timeUnitDomain).reduce(function (timeUnitData, tu) {
	            var timeUnit = tu;
	            var domain = timeunit_1.rawDomain(timeUnit, null);
	            if (domain) {
	                var datetime = {};
	                datetime[timeUnit] = 'datum["data"]';
	                timeUnitData.push({
	                    name: timeUnit,
	                    values: domain,
	                    transform: [{
	                            type: 'formula',
	                            field: 'date',
	                            expr: datetime_1.dateTimeExpr(datetime)
	                        }]
	                });
	            }
	            return timeUnitData;
	        }, []);
	    }
	    timeUnitDomain.assemble = assemble;
	})(timeUnitDomain = exports.timeUnitDomain || (exports.timeUnitDomain = {}));
	//# sourceMappingURL=timeunitdomain.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/timeunitdomain.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/colorrank.js **/
jupyter.define('vega-lite@1.2.0/src/compile/data/colorrank.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var colorRank;
	(function (colorRank) {
	    function parseUnit(model) {
	        var colorRankComponent = {};
	        if (model.has(channel_1.COLOR) && model.encoding().color.type === type_1.ORDINAL) {
	            colorRankComponent[model.field(channel_1.COLOR)] = [{
	                    type: 'sort',
	                    by: model.field(channel_1.COLOR)
	                }, {
	                    type: 'rank',
	                    field: model.field(channel_1.COLOR),
	                    output: {
	                        rank: model.field(channel_1.COLOR, { prefix: 'rank' })
	                    }
	                }];
	        }
	        return colorRankComponent;
	    }
	    colorRank.parseUnit = parseUnit;
	    function parseFacet(model) {
	        var childDataComponent = model.child().component.data;
	        if (!childDataComponent.source) {
	            var colorRankComponent = childDataComponent.colorRank;
	            delete childDataComponent.colorRank;
	            return colorRankComponent;
	        }
	        return {};
	    }
	    colorRank.parseFacet = parseFacet;
	    function parseLayer(model) {
	        var colorRankComponent = {};
	        model.children().forEach(function (child) {
	            var childDataComponent = child.component.data;
	            if (!childDataComponent.source) {
	                util_1.extend(colorRankComponent, childDataComponent.colorRank);
	                delete childDataComponent.colorRank;
	            }
	        });
	        return colorRankComponent;
	    }
	    colorRank.parseLayer = parseLayer;
	    function assemble(component) {
	        return util_1.flatten(util_1.vals(component.colorRank));
	    }
	    colorRank.assemble = assemble;
	})(colorRank = exports.colorRank || (exports.colorRank = {}));
	//# sourceMappingURL=colorrank.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/data/colorrank.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/layout.js **/
jupyter.define('vega-lite@1.2.0/src/compile/layout.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	function assembleLayout(model, layoutData) {
	    var layoutComponent = model.component.layout;
	    if (!layoutComponent.width && !layoutComponent.height) {
	        return layoutData;
	    }
	    if (true) {
	        var distinctFields = util_1.keys(util_1.extend(layoutComponent.width.distinct, layoutComponent.height.distinct));
	        var formula = layoutComponent.width.formula.concat(layoutComponent.height.formula)
	            .map(function (formula) {
	            return util_1.extend({ type: 'formula' }, formula);
	        });
	        return [
	            distinctFields.length > 0 ? {
	                name: model.dataName(data_1.LAYOUT),
	                source: model.dataTable(),
	                transform: [{
	                        type: 'aggregate',
	                        summarize: distinctFields.map(function (field) {
	                            return { field: field, ops: ['distinct'] };
	                        })
	                    }].concat(formula)
	            } : {
	                name: model.dataName(data_1.LAYOUT),
	                values: [{}],
	                transform: formula
	            }
	        ];
	    }
	}
	exports.assembleLayout = assembleLayout;
	function parseUnitLayout(model) {
	    return {
	        width: parseUnitSizeLayout(model, channel_1.X),
	        height: parseUnitSizeLayout(model, channel_1.Y)
	    };
	}
	exports.parseUnitLayout = parseUnitLayout;
	function parseUnitSizeLayout(model, channel) {
	    return {
	        distinct: getDistinct(model, channel),
	        formula: [{
	                field: model.channelSizeName(channel),
	                expr: unitSizeExpr(model, channel)
	            }]
	    };
	}
	function unitSizeExpr(model, channel) {
	    var scale = model.scale(channel);
	    if (scale) {
	        if (scale.type === scale_1.ScaleType.ORDINAL && scale.bandSize !== scale_1.BANDSIZE_FIT) {
	            return '(' + cardinalityExpr(model, channel) +
	                ' + ' + 1 +
	                ') * ' + scale.bandSize;
	        }
	    }
	    return (channel === channel_1.X ? model.width : model.height) + '';
	}
	exports.unitSizeExpr = unitSizeExpr;
	function parseFacetLayout(model) {
	    return {
	        width: parseFacetSizeLayout(model, channel_1.COLUMN),
	        height: parseFacetSizeLayout(model, channel_1.ROW)
	    };
	}
	exports.parseFacetLayout = parseFacetLayout;
	function parseFacetSizeLayout(model, channel) {
	    var childLayoutComponent = model.child().component.layout;
	    var sizeType = channel === channel_1.ROW ? 'height' : 'width';
	    var childSizeComponent = childLayoutComponent[sizeType];
	    if (true) {
	        var distinct = util_1.extend(getDistinct(model, channel), childSizeComponent.distinct);
	        var formula = childSizeComponent.formula.concat([{
	                field: model.channelSizeName(channel),
	                expr: facetSizeFormula(model, channel, model.child().channelSizeName(channel))
	            }]);
	        delete childLayoutComponent[sizeType];
	        return {
	            distinct: distinct,
	            formula: formula
	        };
	    }
	}
	function facetSizeFormula(model, channel, innerSize) {
	    var scale = model.scale(channel);
	    if (model.has(channel)) {
	        return '(datum["' + innerSize + '"] + ' + scale.padding + ')' + ' * ' + cardinalityExpr(model, channel);
	    }
	    else {
	        return 'datum["' + innerSize + '"] + ' + model.config().facet.scale.padding;
	    }
	}
	function parseLayerLayout(model) {
	    return {
	        width: parseLayerSizeLayout(model, channel_1.X),
	        height: parseLayerSizeLayout(model, channel_1.Y)
	    };
	}
	exports.parseLayerLayout = parseLayerLayout;
	function parseLayerSizeLayout(model, channel) {
	    if (true) {
	        var childLayoutComponent = model.children()[0].component.layout;
	        var sizeType_1 = channel === channel_1.Y ? 'height' : 'width';
	        var childSizeComponent = childLayoutComponent[sizeType_1];
	        var distinct = childSizeComponent.distinct;
	        var formula = [{
	                field: model.channelSizeName(channel),
	                expr: childSizeComponent.formula[0].expr
	            }];
	        model.children().forEach(function (child) {
	            delete child.component.layout[sizeType_1];
	        });
	        return {
	            distinct: distinct,
	            formula: formula
	        };
	    }
	}
	function getDistinct(model, channel) {
	    if (model.has(channel) && model.isOrdinalScale(channel)) {
	        var scale = model.scale(channel);
	        if (scale.type === scale_1.ScaleType.ORDINAL && !(scale.domain instanceof Array)) {
	            var distinctField = model.field(channel);
	            var distinct = {};
	            distinct[distinctField] = true;
	            return distinct;
	        }
	    }
	    return {};
	}
	function cardinalityExpr(model, channel) {
	    var scale = model.scale(channel);
	    if (scale.domain instanceof Array) {
	        return scale.domain.length;
	    }
	    var timeUnit = model.fieldDef(channel).timeUnit;
	    var timeUnitDomain = timeUnit ? timeunit_1.rawDomain(timeUnit, channel) : null;
	    return timeUnitDomain !== null ? timeUnitDomain.length :
	        model.field(channel, { datum: true, prefix: 'distinct' });
	}
	exports.cardinalityExpr = cardinalityExpr;
	//# sourceMappingURL=layout.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/layout.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/model.js **/
jupyter.define('vega-lite@1.2.0/src/compile/model.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var encoding_1 = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var NameMap = (function () {
	    function NameMap() {
	        this._nameMap = {};
	    }
	    NameMap.prototype.rename = function (oldName, newName) {
	        this._nameMap[oldName] = newName;
	    };
	    NameMap.prototype.get = function (name) {
	        while (this._nameMap[name]) {
	            name = this._nameMap[name];
	        }
	        return name;
	    };
	    return NameMap;
	}());
	var Model = (function () {
	    function Model(spec, parent, parentGivenName) {
	        this._warnings = [];
	        this._parent = parent;
	        this._name = spec.name || parentGivenName;
	        this._dataNameMap = parent ? parent._dataNameMap : new NameMap();
	        this._scaleNameMap = parent ? parent._scaleNameMap : new NameMap();
	        this._sizeNameMap = parent ? parent._sizeNameMap : new NameMap();
	        this._data = spec.data;
	        this._description = spec.description;
	        this._transform = spec.transform;
	        this.component = { data: null, layout: null, mark: null, scale: null, axis: null, axisGroup: null, gridGroup: null, legend: null };
	    }
	    Model.prototype.parse = function () {
	        this.parseData();
	        this.parseSelectionData();
	        this.parseLayoutData();
	        this.parseScale();
	        this.parseAxis();
	        this.parseLegend();
	        this.parseAxisGroup();
	        this.parseGridGroup();
	        this.parseMark();
	    };
	    Model.prototype.assembleScales = function () {
	        return util_1.flatten(util_1.vals(this.component.scale).map(function (scales) {
	            var arr = [scales.main];
	            if (scales.colorLegend) {
	                arr.push(scales.colorLegend);
	            }
	            if (scales.binColorLegend) {
	                arr.push(scales.binColorLegend);
	            }
	            return arr;
	        }));
	    };
	    Model.prototype.assembleAxes = function () {
	        return util_1.vals(this.component.axis);
	    };
	    Model.prototype.assembleLegends = function () {
	        return util_1.vals(this.component.legend);
	    };
	    Model.prototype.assembleGroup = function () {
	        var group = {};
	        group.marks = this.assembleMarks();
	        var scales = this.assembleScales();
	        if (scales.length > 0) {
	            group.scales = scales;
	        }
	        var axes = this.assembleAxes();
	        if (axes.length > 0) {
	            group.axes = axes;
	        }
	        var legends = this.assembleLegends();
	        if (legends.length > 0) {
	            group.legends = legends;
	        }
	        return group;
	    };
	    Model.prototype.reduce = function (f, init, t) {
	        return encoding_1.channelMappingReduce(this.channels(), this.mapping(), f, init, t);
	    };
	    Model.prototype.forEach = function (f, t) {
	        encoding_1.channelMappingForEach(this.channels(), this.mapping(), f, t);
	    };
	    Model.prototype.parent = function () {
	        return this._parent;
	    };
	    Model.prototype.name = function (text, delimiter) {
	        if (delimiter === void 0) { delimiter = '_'; }
	        return (this._name ? this._name + delimiter : '') + text;
	    };
	    Model.prototype.description = function () {
	        return this._description;
	    };
	    Model.prototype.data = function () {
	        return this._data;
	    };
	    Model.prototype.renameData = function (oldName, newName) {
	        this._dataNameMap.rename(oldName, newName);
	    };
	    Model.prototype.dataName = function (dataSourceType) {
	        return this._dataNameMap.get(this.name(String(dataSourceType)));
	    };
	    Model.prototype.renameSize = function (oldName, newName) {
	        this._sizeNameMap.rename(oldName, newName);
	    };
	    Model.prototype.channelSizeName = function (channel) {
	        return this.sizeName(channel === channel_1.X || channel === channel_1.COLUMN ? 'width' : 'height');
	    };
	    Model.prototype.sizeName = function (size) {
	        return this._sizeNameMap.get(this.name(size, '_'));
	    };
	    Model.prototype.transform = function () {
	        return this._transform || {};
	    };
	    Model.prototype.field = function (channel, opt) {
	        if (opt === void 0) { opt = {}; }
	        var fieldDef = this.fieldDef(channel);
	        if (fieldDef.bin) {
	            opt = util_1.extend({
	                binSuffix: this.scale(channel).type === scale_1.ScaleType.ORDINAL ? 'range' : 'start'
	            }, opt);
	        }
	        return fielddef_1.field(fieldDef, opt);
	    };
	    Model.prototype.scale = function (channel) {
	        return this._scale[channel];
	    };
	    Model.prototype.isOrdinalScale = function (channel) {
	        var scale = this.scale(channel);
	        return scale && scale.type === scale_1.ScaleType.ORDINAL;
	    };
	    Model.prototype.renameScale = function (oldName, newName) {
	        this._scaleNameMap.rename(oldName, newName);
	    };
	    Model.prototype.scaleName = function (channel) {
	        return this._scaleNameMap.get(this.name(channel + ''));
	    };
	    Model.prototype.sort = function (channel) {
	        return (this.mapping()[channel] || {}).sort;
	    };
	    Model.prototype.axis = function (channel) {
	        return this._axis[channel];
	    };
	    Model.prototype.legend = function (channel) {
	        return this._legend[channel];
	    };
	    Model.prototype.config = function () {
	        return this._config;
	    };
	    Model.prototype.addWarning = function (message) {
	        util_1.warning(message);
	        this._warnings.push(message);
	    };
	    Model.prototype.warnings = function () {
	        return this._warnings;
	    };
	    Model.prototype.isUnit = function () {
	        return false;
	    };
	    Model.prototype.isFacet = function () {
	        return false;
	    };
	    Model.prototype.isLayer = function () {
	        return false;
	    };
	    return Model;
	}());
	exports.Model = Model;
	//# sourceMappingURL=model.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/model.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/scale.js **/
jupyter.define('vega-lite@1.2.0/src/compile/scale.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var aggregate_1 = __jupyter_require__('vega-lite@~1.2.0/src/aggregate.js');
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var sort_1 = __jupyter_require__('vega-lite@~1.2.0/src/sort.js');
	var stack_1 = __jupyter_require__('vega-lite@~1.2.0/src/stack.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	exports.COLOR_LEGEND = 'color_legend';
	exports.COLOR_LEGEND_LABEL = 'color_legend_label';
	function parseScaleComponent(model) {
	    return model.channels().reduce(function (scale, channel) {
	        if (model.scale(channel)) {
	            var fieldDef = model.fieldDef(channel);
	            var scales = {
	                main: parseMainScale(model, fieldDef, channel)
	            };
	            if (channel === channel_1.COLOR && model.legend(channel_1.COLOR) && (fieldDef.type === type_1.ORDINAL || fieldDef.bin || fieldDef.timeUnit)) {
	                scales.colorLegend = parseColorLegendScale(model, fieldDef);
	                if (fieldDef.bin) {
	                    scales.binColorLegend = parseBinColorLegendLabel(model, fieldDef);
	                }
	            }
	            scale[channel] = scales;
	        }
	        return scale;
	    }, {});
	}
	exports.parseScaleComponent = parseScaleComponent;
	function parseMainScale(model, fieldDef, channel) {
	    var scale = model.scale(channel);
	    var sort = model.sort(channel);
	    var scaleDef = {
	        name: model.scaleName(channel),
	        type: scale.type,
	    };
	    if (channel === channel_1.X && model.has(channel_1.X2)) {
	        if (model.has(channel_1.X)) {
	            scaleDef.domain = { fields: [domain(scale, model, channel_1.X), domain(scale, model, channel_1.X2)] };
	        }
	        else {
	            scaleDef.domain = domain(scale, model, channel_1.X2);
	        }
	    }
	    else if (channel === channel_1.Y && model.has(channel_1.Y2)) {
	        if (model.has(channel_1.Y)) {
	            scaleDef.domain = { fields: [domain(scale, model, channel_1.Y), domain(scale, model, channel_1.Y2)] };
	        }
	        else {
	            scaleDef.domain = domain(scale, model, channel_1.Y2);
	        }
	    }
	    else {
	        scaleDef.domain = domain(scale, model, channel);
	    }
	    util_1.extend(scaleDef, rangeMixins(scale, model, channel));
	    if (sort && (sort_1.isSortField(sort) ? sort.order : sort) === sort_1.SortOrder.DESCENDING) {
	        scaleDef.reverse = true;
	    }
	    [
	        'round',
	        'clamp', 'nice',
	        'exponent', 'zero',
	        'points',
	        'padding'
	    ].forEach(function (property) {
	        var value = exports[property](scale, channel, fieldDef, model, scaleDef);
	        if (value !== undefined) {
	            scaleDef[property] = value;
	        }
	    });
	    return scaleDef;
	}
	function parseColorLegendScale(model, fieldDef) {
	    return {
	        name: model.scaleName(exports.COLOR_LEGEND),
	        type: scale_1.ScaleType.ORDINAL,
	        domain: {
	            data: model.dataTable(),
	            field: model.field(channel_1.COLOR, (fieldDef.bin || fieldDef.timeUnit) ? {} : { prefix: 'rank' }),
	            sort: true
	        },
	        range: { data: model.dataTable(), field: model.field(channel_1.COLOR), sort: true }
	    };
	}
	function parseBinColorLegendLabel(model, fieldDef) {
	    return {
	        name: model.scaleName(exports.COLOR_LEGEND_LABEL),
	        type: scale_1.ScaleType.ORDINAL,
	        domain: {
	            data: model.dataTable(),
	            field: model.field(channel_1.COLOR),
	            sort: true
	        },
	        range: {
	            data: model.dataTable(),
	            field: fielddef_1.field(fieldDef, { binSuffix: 'range' }),
	            sort: {
	                field: model.field(channel_1.COLOR, { binSuffix: 'start' }),
	                op: 'min'
	            }
	        }
	    };
	}
	function scaleType(scale, fieldDef, channel, mark) {
	    if (!channel_1.hasScale(channel)) {
	        return null;
	    }
	    if (util_1.contains([channel_1.ROW, channel_1.COLUMN, channel_1.SHAPE], channel)) {
	        if (scale && scale.type !== undefined && scale.type !== scale_1.ScaleType.ORDINAL) {
	            console.warn('Channel', channel, 'does not work with scale type =', scale.type);
	        }
	        return scale_1.ScaleType.ORDINAL;
	    }
	    if (scale.type !== undefined) {
	        return scale.type;
	    }
	    switch (fieldDef.type) {
	        case type_1.NOMINAL:
	            return scale_1.ScaleType.ORDINAL;
	        case type_1.ORDINAL:
	            if (channel === channel_1.COLOR) {
	                return scale_1.ScaleType.LINEAR;
	            }
	            return scale_1.ScaleType.ORDINAL;
	        case type_1.TEMPORAL:
	            if (channel === channel_1.COLOR) {
	                return scale_1.ScaleType.TIME;
	            }
	            if (fieldDef.timeUnit) {
	                return timeunit_1.defaultScaleType(fieldDef.timeUnit);
	            }
	            return scale_1.ScaleType.TIME;
	        case type_1.QUANTITATIVE:
	            if (fieldDef.bin) {
	                return util_1.contains([channel_1.X, channel_1.Y, channel_1.COLOR], channel) ? scale_1.ScaleType.LINEAR : scale_1.ScaleType.ORDINAL;
	            }
	            return scale_1.ScaleType.LINEAR;
	    }
	    return null;
	}
	exports.scaleType = scaleType;
	function scaleBandSize(scaleType, bandSize, scaleConfig, topLevelSize, mark, channel) {
	    if (scaleType === scale_1.ScaleType.ORDINAL) {
	        if (topLevelSize === undefined) {
	            if (bandSize) {
	                return bandSize;
	            }
	            else if (channel === channel_1.X && mark === mark_1.TEXT) {
	                return scaleConfig.textBandWidth;
	            }
	            else {
	                return scaleConfig.bandSize;
	            }
	        }
	        else {
	            if (bandSize) {
	                console.warn('bandSize for', channel, 'overridden as top-level', channel === channel_1.X ? 'width' : 'height', 'is provided.');
	            }
	            return scale_1.BANDSIZE_FIT;
	        }
	    }
	    else {
	        return undefined;
	    }
	}
	exports.scaleBandSize = scaleBandSize;
	function domain(scale, model, channel) {
	    var fieldDef = model.fieldDef(channel);
	    if (scale.domain) {
	        return scale.domain;
	    }
	    if (fieldDef.type === type_1.TEMPORAL) {
	        if (timeunit_1.rawDomain(fieldDef.timeUnit, channel)) {
	            return {
	                data: fieldDef.timeUnit,
	                field: 'date'
	            };
	        }
	        return {
	            data: model.dataTable(),
	            field: model.field(channel),
	            sort: {
	                field: model.field(channel),
	                op: 'min'
	            }
	        };
	    }
	    var stack = model.stack();
	    if (stack && channel === stack.fieldChannel) {
	        if (stack.offset === stack_1.StackOffset.NORMALIZE) {
	            return [0, 1];
	        }
	        return {
	            data: model.dataName(data_1.STACKED_SCALE),
	            field: model.field(channel, { prefix: 'sum' })
	        };
	    }
	    var useRawDomain = _useRawDomain(scale, model, channel), sort = domainSort(model, channel, scale.type);
	    if (useRawDomain) {
	        return {
	            data: data_1.SOURCE,
	            field: model.field(channel, { noAggregate: true })
	        };
	    }
	    else if (fieldDef.bin) {
	        if (scale.type === scale_1.ScaleType.ORDINAL) {
	            return {
	                data: model.dataTable(),
	                field: model.field(channel, { binSuffix: 'range' }),
	                sort: {
	                    field: model.field(channel, { binSuffix: 'start' }),
	                    op: 'min'
	                }
	            };
	        }
	        else if (channel === channel_1.COLOR) {
	            return {
	                data: model.dataTable(),
	                field: model.field(channel, { binSuffix: 'start' })
	            };
	        }
	        else {
	            return {
	                data: model.dataTable(),
	                field: [
	                    model.field(channel, { binSuffix: 'start' }),
	                    model.field(channel, { binSuffix: 'end' })
	                ]
	            };
	        }
	    }
	    else if (sort) {
	        return {
	            data: sort.op ? data_1.SOURCE : model.dataTable(),
	            field: (fieldDef.type === type_1.ORDINAL && channel === channel_1.COLOR) ? model.field(channel, { prefix: 'rank' }) : model.field(channel),
	            sort: sort
	        };
	    }
	    else {
	        return {
	            data: model.dataTable(),
	            field: (fieldDef.type === type_1.ORDINAL && channel === channel_1.COLOR) ? model.field(channel, { prefix: 'rank' }) : model.field(channel),
	        };
	    }
	}
	exports.domain = domain;
	function domainSort(model, channel, scaleType) {
	    if (scaleType !== scale_1.ScaleType.ORDINAL) {
	        return undefined;
	    }
	    var sort = model.sort(channel);
	    if (sort_1.isSortField(sort)) {
	        return {
	            op: sort.op,
	            field: sort.field
	        };
	    }
	    if (util_1.contains([sort_1.SortOrder.ASCENDING, sort_1.SortOrder.DESCENDING, undefined], sort)) {
	        return true;
	    }
	    return undefined;
	}
	exports.domainSort = domainSort;
	function _useRawDomain(scale, model, channel) {
	    var fieldDef = model.fieldDef(channel);
	    return scale.useRawDomain &&
	        fieldDef.aggregate &&
	        aggregate_1.SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) >= 0 &&
	        ((fieldDef.type === type_1.QUANTITATIVE && !fieldDef.bin) ||
	            (fieldDef.type === type_1.TEMPORAL && util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type)));
	}
	function rangeMixins(scale, model, channel) {
	    var fieldDef = model.fieldDef(channel);
	    var scaleConfig = model.config().scale;
	    if (scale.type === scale_1.ScaleType.ORDINAL && scale.bandSize && scale.bandSize !== scale_1.BANDSIZE_FIT && util_1.contains([channel_1.X, channel_1.Y], channel)) {
	        return { bandSize: scale.bandSize };
	    }
	    if (scale.range && !util_1.contains([channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN], channel)) {
	        return { range: scale.range };
	    }
	    switch (channel) {
	        case channel_1.ROW:
	            return { range: 'height' };
	        case channel_1.COLUMN:
	            return { range: 'width' };
	    }
	    var unitModel = model;
	    switch (channel) {
	        case channel_1.X:
	            return {
	                rangeMin: 0,
	                rangeMax: unitModel.width
	            };
	        case channel_1.Y:
	            return {
	                rangeMin: unitModel.height,
	                rangeMax: 0
	            };
	        case channel_1.SIZE:
	            if (unitModel.mark() === mark_1.BAR) {
	                if (scaleConfig.barSizeRange !== undefined) {
	                    return { range: scaleConfig.barSizeRange };
	                }
	                var dimension = model.config().mark.orient === config_1.Orient.HORIZONTAL ? channel_1.Y : channel_1.X;
	                return { range: [model.config().mark.barThinSize, model.scale(dimension).bandSize] };
	            }
	            else if (unitModel.mark() === mark_1.TEXT) {
	                return { range: scaleConfig.fontSizeRange };
	            }
	            else if (unitModel.mark() === mark_1.RULE) {
	                return { range: scaleConfig.ruleSizeRange };
	            }
	            else if (unitModel.mark() === mark_1.TICK) {
	                return { range: scaleConfig.tickSizeRange };
	            }
	            if (scaleConfig.pointSizeRange !== undefined) {
	                return { range: scaleConfig.pointSizeRange };
	            }
	            var bandSize = pointBandSize(unitModel);
	            return { range: [9, (bandSize - 2) * (bandSize - 2)] };
	        case channel_1.SHAPE:
	            return { range: scaleConfig.shapeRange };
	        case channel_1.COLOR:
	            if (fieldDef.type === type_1.NOMINAL) {
	                return { range: scaleConfig.nominalColorRange };
	            }
	            return { range: scaleConfig.sequentialColorRange };
	        case channel_1.OPACITY:
	            return { range: scaleConfig.opacity };
	    }
	    return {};
	}
	exports.rangeMixins = rangeMixins;
	function pointBandSize(model) {
	    var scaleConfig = model.config().scale;
	    var hasX = model.has(channel_1.X);
	    var hasY = model.has(channel_1.Y);
	    var xIsMeasure = fielddef_1.isMeasure(model.encoding().x);
	    var yIsMeasure = fielddef_1.isMeasure(model.encoding().y);
	    if (hasX && hasY) {
	        return xIsMeasure !== yIsMeasure ?
	            model.scale(xIsMeasure ? channel_1.Y : channel_1.X).bandSize :
	            Math.min(model.scale(channel_1.X).bandSize || scaleConfig.bandSize, model.scale(channel_1.Y).bandSize || scaleConfig.bandSize);
	    }
	    else if (hasY) {
	        return yIsMeasure ? model.config().scale.bandSize : model.scale(channel_1.Y).bandSize;
	    }
	    else if (hasX) {
	        return xIsMeasure ? model.config().scale.bandSize : model.scale(channel_1.X).bandSize;
	    }
	    return model.config().scale.bandSize;
	}
	function clamp(scale) {
	    if (util_1.contains([scale_1.ScaleType.LINEAR, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT,
	        scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type)) {
	        return scale.clamp;
	    }
	    return undefined;
	}
	exports.clamp = clamp;
	function exponent(scale) {
	    if (scale.type === scale_1.ScaleType.POW) {
	        return scale.exponent;
	    }
	    return undefined;
	}
	exports.exponent = exponent;
	function nice(scale, channel, fieldDef) {
	    if (util_1.contains([scale_1.ScaleType.LINEAR, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.LOG,
	        scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.QUANTIZE], scale.type)) {
	        if (scale.nice !== undefined) {
	            return scale.nice;
	        }
	        if (util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type)) {
	            return timeunit_1.smallestUnit(fieldDef.timeUnit);
	        }
	        return util_1.contains([channel_1.X, channel_1.Y], channel);
	    }
	    return undefined;
	}
	exports.nice = nice;
	function padding(scale, channel, __, ___, scaleDef) {
	    if (scale.type === scale_1.ScaleType.ORDINAL && util_1.contains([channel_1.X, channel_1.Y], channel)) {
	        return scaleDef.points ? 1 : scale.padding;
	    }
	    return undefined;
	}
	exports.padding = padding;
	function points(scale, channel, __, model) {
	    if (scale.type === scale_1.ScaleType.ORDINAL && util_1.contains([channel_1.X, channel_1.Y], channel)) {
	        return model.mark() === mark_1.BAR && scale.bandSize === scale_1.BANDSIZE_FIT ? undefined : true;
	    }
	    return undefined;
	}
	exports.points = points;
	function round(scale, channel) {
	    if (util_1.contains([channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE], channel) && scale.round !== undefined) {
	        return scale.round;
	    }
	    return undefined;
	}
	exports.round = round;
	function zero(scale, channel, fieldDef) {
	    if (!util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.ORDINAL], scale.type)) {
	        if (scale.zero !== undefined) {
	            return scale.zero;
	        }
	        return !scale.domain && !fieldDef.bin && util_1.contains([channel_1.X, channel_1.Y], channel);
	    }
	    return undefined;
	}
	exports.zero = zero;
	//# sourceMappingURL=scale.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/scale.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/layer.js **/
jupyter.define('vega-lite@1.2.0/src/compile/layer.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/data.js');
	var layout_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/layout.js');
	var model_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/model.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var vega_schema_1 = __jupyter_require__('vega-lite@~1.2.0/src/vega.schema.js');
	var LayerModel = (function (_super) {
	    __extends(LayerModel, _super);
	    function LayerModel(spec, parent, parentGivenName) {
	        var _this = this;
	        _super.call(this, spec, parent, parentGivenName);
	        this._width = spec.width;
	        this._height = spec.height;
	        this._config = this._initConfig(spec.config, parent);
	        this._children = spec.layers.map(function (layer, i) {
	            return common_1.buildModel(layer, _this, _this.name('layer_' + i));
	        });
	    }
	    LayerModel.prototype._initConfig = function (specConfig, parent) {
	        return util_1.mergeDeep(util_1.duplicate(config_1.defaultConfig), specConfig, parent ? parent.config() : {});
	    };
	    Object.defineProperty(LayerModel.prototype, "width", {
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LayerModel.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LayerModel.prototype.has = function (channel) {
	        return false;
	    };
	    LayerModel.prototype.children = function () {
	        return this._children;
	    };
	    LayerModel.prototype.isOrdinalScale = function (channel) {
	        return this._children[0].isOrdinalScale(channel);
	    };
	    LayerModel.prototype.dataTable = function () {
	        return this._children[0].dataTable();
	    };
	    LayerModel.prototype.fieldDef = function (channel) {
	        return null;
	    };
	    LayerModel.prototype.stack = function () {
	        return null;
	    };
	    LayerModel.prototype.parseData = function () {
	        this._children.forEach(function (child) {
	            child.parseData();
	        });
	        this.component.data = data_1.parseLayerData(this);
	    };
	    LayerModel.prototype.parseSelectionData = function () {
	    };
	    LayerModel.prototype.parseLayoutData = function () {
	        this._children.forEach(function (child, i) {
	            child.parseLayoutData();
	        });
	        this.component.layout = layout_1.parseLayerLayout(this);
	    };
	    LayerModel.prototype.parseScale = function () {
	        var model = this;
	        var scaleComponent = this.component.scale = {};
	        this._children.forEach(function (child) {
	            child.parseScale();
	            if (true) {
	                util_1.keys(child.component.scale).forEach(function (channel) {
	                    var childScales = child.component.scale[channel];
	                    if (!childScales) {
	                        return;
	                    }
	                    var modelScales = scaleComponent[channel];
	                    if (modelScales && modelScales.main) {
	                        var modelDomain = modelScales.main.domain;
	                        var childDomain = childScales.main.domain;
	                        if (util_1.isArray(modelDomain)) {
	                            if (util_1.isArray(childScales.main.domain)) {
	                                modelScales.main.domain = modelDomain.concat(childDomain);
	                            }
	                            else {
	                                model.addWarning('custom domain scale cannot be unioned with default field-based domain');
	                            }
	                        }
	                        else {
	                            var unionedFields = vega_schema_1.isUnionedDomain(modelDomain) ? modelDomain.fields : [modelDomain];
	                            if (util_1.isArray(childDomain)) {
	                                model.addWarning('custom domain scale cannot be unioned with default field-based domain');
	                            }
	                            var fields = vega_schema_1.isDataRefDomain(childDomain) ? unionedFields.concat([childDomain]) :
	                                vega_schema_1.isUnionedDomain(childDomain) ? unionedFields.concat(childDomain.fields) :
	                                    unionedFields;
	                            fields = util_1.unique(fields, util_1.hash);
	                            if (fields.length > 1) {
	                                modelScales.main.domain = { fields: fields };
	                            }
	                            else {
	                                modelScales.main.domain = fields[0];
	                            }
	                        }
	                        modelScales.colorLegend = modelScales.colorLegend ? modelScales.colorLegend : childScales.colorLegend;
	                        modelScales.binColorLegend = modelScales.binColorLegend ? modelScales.binColorLegend : childScales.binColorLegend;
	                    }
	                    else {
	                        scaleComponent[channel] = childScales;
	                    }
	                    util_1.vals(childScales).forEach(function (scale) {
	                        var scaleNameWithoutPrefix = scale.name.substr(child.name('').length);
	                        var newName = model.scaleName(scaleNameWithoutPrefix);
	                        child.renameScale(scale.name, newName);
	                        scale.name = newName;
	                    });
	                    delete childScales[channel];
	                });
	            }
	        });
	    };
	    LayerModel.prototype.parseMark = function () {
	        this._children.forEach(function (child) {
	            child.parseMark();
	        });
	    };
	    LayerModel.prototype.parseAxis = function () {
	        var axisComponent = this.component.axis = {};
	        this._children.forEach(function (child) {
	            child.parseAxis();
	            if (true) {
	                util_1.keys(child.component.axis).forEach(function (channel) {
	                    if (!axisComponent[channel]) {
	                        axisComponent[channel] = child.component.axis[channel];
	                    }
	                });
	            }
	        });
	    };
	    LayerModel.prototype.parseAxisGroup = function () {
	        return null;
	    };
	    LayerModel.prototype.parseGridGroup = function () {
	        return null;
	    };
	    LayerModel.prototype.parseLegend = function () {
	        var legendComponent = this.component.legend = {};
	        this._children.forEach(function (child) {
	            child.parseLegend();
	            if (true) {
	                util_1.keys(child.component.legend).forEach(function (channel) {
	                    if (!legendComponent[channel]) {
	                        legendComponent[channel] = child.component.legend[channel];
	                    }
	                });
	            }
	        });
	    };
	    LayerModel.prototype.assembleParentGroupProperties = function () {
	        return null;
	    };
	    LayerModel.prototype.assembleData = function (data) {
	        data_1.assembleData(this, data);
	        this._children.forEach(function (child) {
	            child.assembleData(data);
	        });
	        return data;
	    };
	    LayerModel.prototype.assembleLayout = function (layoutData) {
	        this._children.forEach(function (child) {
	            child.assembleLayout(layoutData);
	        });
	        return layout_1.assembleLayout(this, layoutData);
	    };
	    LayerModel.prototype.assembleMarks = function () {
	        return util_1.flatten(this._children.map(function (child) {
	            return child.assembleMarks();
	        }));
	    };
	    LayerModel.prototype.channels = function () {
	        return [];
	    };
	    LayerModel.prototype.mapping = function () {
	        return null;
	    };
	    LayerModel.prototype.isLayer = function () {
	        return true;
	    };
	    LayerModel.prototype.compatibleSource = function (child) {
	        var data = this.data();
	        var childData = child.component.data;
	        var compatible = !childData.source || (data && data.url === childData.source.url);
	        return compatible;
	    };
	    return LayerModel;
	}(model_1.Model));
	exports.LayerModel = LayerModel;
	//# sourceMappingURL=layer.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/layer.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/vega.schema.js **/
jupyter.define('vega-lite@1.2.0/src/vega.schema.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	function isUnionedDomain(domain) {
	    if (!util_1.isArray(domain)) {
	        return 'fields' in domain;
	    }
	    return false;
	}
	exports.isUnionedDomain = isUnionedDomain;
	function isDataRefDomain(domain) {
	    if (!util_1.isArray(domain)) {
	        return 'data' in domain;
	    }
	    return false;
	}
	exports.isDataRefDomain = isDataRefDomain;
	//# sourceMappingURL=vega.schema.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/vega.schema.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/unit.js **/
jupyter.define('vega-lite@1.2.0/src/compile/unit.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var aggregate_1 = __jupyter_require__('vega-lite@~1.2.0/src/aggregate.js');
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var data_1 = __jupyter_require__('vega-lite@~1.2.0/src/data.js');
	var vlEncoding = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var axis_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/axis.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var config_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/config.js');
	var data_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/data/data.js');
	var legend_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/legend.js');
	var layout_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/layout.js');
	var model_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/model.js');
	var mark_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/mark.js');
	var scale_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/scale.js');
	var stack_1 = __jupyter_require__('vega-lite@~1.2.0/src/stack.js');
	var UnitModel = (function (_super) {
	    __extends(UnitModel, _super);
	    function UnitModel(spec, parent, parentGivenName) {
	        _super.call(this, spec, parent, parentGivenName);
	        var providedWidth = spec.width !== undefined ? spec.width :
	            parent ? parent['width'] : undefined;
	        var providedHeight = spec.height !== undefined ? spec.height :
	            parent ? parent['height'] : undefined;
	        var mark = this._mark = spec.mark;
	        var encoding = this._encoding = this._initEncoding(mark, spec.encoding || {});
	        var config = this._config = this._initConfig(spec.config, parent, mark, encoding);
	        this._scale = this._initScale(mark, encoding, config, providedWidth, providedHeight);
	        this._axis = this._initAxis(encoding, config);
	        this._legend = this._initLegend(encoding, config);
	        this._initSize(mark, this._scale, providedWidth, providedHeight, config.cell, config.scale);
	        this._stack = stack_1.stack(mark, encoding, config);
	    }
	    UnitModel.prototype._initEncoding = function (mark, encoding) {
	        encoding = util_1.duplicate(encoding);
	        vlEncoding.forEach(encoding, function (fieldDef, channel) {
	            if (!channel_1.supportMark(channel, mark)) {
	                console.warn(channel, 'dropped as it is incompatible with', mark);
	                delete fieldDef.field;
	                return;
	            }
	            if (fieldDef.type) {
	                fieldDef.type = type_1.getFullName(fieldDef.type);
	            }
	            if ((channel === channel_1.PATH || channel === channel_1.ORDER) && !fieldDef.aggregate && fieldDef.type === type_1.QUANTITATIVE) {
	                fieldDef.aggregate = aggregate_1.AggregateOp.MIN;
	            }
	        });
	        return encoding;
	    };
	    UnitModel.prototype._initConfig = function (specConfig, parent, mark, encoding) {
	        var config = util_1.mergeDeep(util_1.duplicate(config_1.defaultConfig), parent ? parent.config() : {}, specConfig);
	        config.mark = config_2.initMarkConfig(mark, encoding, config);
	        return config;
	    };
	    UnitModel.prototype._initScale = function (mark, encoding, config, topLevelWidth, topLevelHeight) {
	        return channel_1.UNIT_SCALE_CHANNELS.reduce(function (_scale, channel) {
	            if (vlEncoding.has(encoding, channel) ||
	                (channel === channel_1.X && vlEncoding.has(encoding, channel_1.X2)) ||
	                (channel === channel_1.Y && vlEncoding.has(encoding, channel_1.Y2))) {
	                var channelDef = encoding[channel];
	                var scaleSpec = (channelDef || {}).scale || {};
	                var _scaleType = scale_2.scaleType(scaleSpec, channelDef, channel, mark);
	                var scale = _scale[channel] = util_1.extend({
	                    type: _scaleType,
	                    round: config.scale.round,
	                    padding: config.scale.padding,
	                    useRawDomain: config.scale.useRawDomain
	                }, scaleSpec);
	                scale.bandSize = scale_2.scaleBandSize(scale.type, scale.bandSize, config.scale, channel === channel_1.X ? topLevelWidth : topLevelHeight, mark, channel);
	            }
	            return _scale;
	        }, {});
	    };
	    UnitModel.prototype._initSize = function (mark, scale, width, height, cellConfig, scaleConfig) {
	        if (width !== undefined) {
	            this._width = width;
	        }
	        else if (scale[channel_1.X]) {
	            if (scale[channel_1.X].type !== scale_1.ScaleType.ORDINAL || scale[channel_1.X].bandSize === scale_1.BANDSIZE_FIT) {
	                this._width = cellConfig.width;
	            }
	        }
	        else {
	            if (mark === mark_1.TEXT) {
	                this._width = scaleConfig.textBandWidth;
	            }
	            else {
	                this._width = scaleConfig.bandSize;
	            }
	        }
	        if (height !== undefined) {
	            this._height = height;
	        }
	        else if (scale[channel_1.Y]) {
	            if (scale[channel_1.Y].type !== scale_1.ScaleType.ORDINAL || scale[channel_1.Y].bandSize === scale_1.BANDSIZE_FIT) {
	                this._height = cellConfig.height;
	            }
	        }
	        else {
	            this._height = scaleConfig.bandSize;
	        }
	    };
	    UnitModel.prototype._initAxis = function (encoding, config) {
	        return [channel_1.X, channel_1.Y].reduce(function (_axis, channel) {
	            if (vlEncoding.has(encoding, channel) ||
	                (channel === channel_1.X && vlEncoding.has(encoding, channel_1.X2)) ||
	                (channel === channel_1.Y && vlEncoding.has(encoding, channel_1.Y2))) {
	                var axisSpec = (encoding[channel] || {}).axis;
	                if (axisSpec !== false) {
	                    _axis[channel] = util_1.extend({}, config.axis, axisSpec === true ? {} : axisSpec || {});
	                }
	            }
	            return _axis;
	        }, {});
	    };
	    UnitModel.prototype._initLegend = function (encoding, config) {
	        return channel_1.NONSPATIAL_SCALE_CHANNELS.reduce(function (_legend, channel) {
	            if (vlEncoding.has(encoding, channel)) {
	                var legendSpec = encoding[channel].legend;
	                if (legendSpec !== false) {
	                    _legend[channel] = util_1.extend({}, config.legend, legendSpec === true ? {} : legendSpec || {});
	                }
	            }
	            return _legend;
	        }, {});
	    };
	    Object.defineProperty(UnitModel.prototype, "width", {
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(UnitModel.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    UnitModel.prototype.parseData = function () {
	        this.component.data = data_2.parseUnitData(this);
	    };
	    UnitModel.prototype.parseSelectionData = function () {
	    };
	    UnitModel.prototype.parseLayoutData = function () {
	        this.component.layout = layout_1.parseUnitLayout(this);
	    };
	    UnitModel.prototype.parseScale = function () {
	        this.component.scale = scale_2.parseScaleComponent(this);
	    };
	    UnitModel.prototype.parseMark = function () {
	        this.component.mark = mark_2.parseMark(this);
	    };
	    UnitModel.prototype.parseAxis = function () {
	        this.component.axis = axis_1.parseAxisComponent(this, [channel_1.X, channel_1.Y]);
	    };
	    UnitModel.prototype.parseAxisGroup = function () {
	        return null;
	    };
	    UnitModel.prototype.parseGridGroup = function () {
	        return null;
	    };
	    UnitModel.prototype.parseLegend = function () {
	        this.component.legend = legend_1.parseLegendComponent(this);
	    };
	    UnitModel.prototype.assembleData = function (data) {
	        return data_2.assembleData(this, data);
	    };
	    UnitModel.prototype.assembleLayout = function (layoutData) {
	        return layout_1.assembleLayout(this, layoutData);
	    };
	    UnitModel.prototype.assembleMarks = function () {
	        return this.component.mark;
	    };
	    UnitModel.prototype.assembleParentGroupProperties = function (cellConfig) {
	        return common_1.applyConfig({}, cellConfig, common_1.FILL_STROKE_CONFIG.concat(['clip']));
	    };
	    UnitModel.prototype.channels = function () {
	        return channel_1.UNIT_CHANNELS;
	    };
	    UnitModel.prototype.mapping = function () {
	        return this.encoding();
	    };
	    UnitModel.prototype.stack = function () {
	        return this._stack;
	    };
	    UnitModel.prototype.toSpec = function (excludeConfig, excludeData) {
	        var encoding = util_1.duplicate(this._encoding);
	        var spec;
	        spec = {
	            mark: this._mark,
	            encoding: encoding
	        };
	        if (!excludeConfig) {
	            spec.config = util_1.duplicate(this._config);
	        }
	        if (!excludeData) {
	            spec.data = util_1.duplicate(this._data);
	        }
	        return spec;
	    };
	    UnitModel.prototype.mark = function () {
	        return this._mark;
	    };
	    UnitModel.prototype.has = function (channel) {
	        return vlEncoding.has(this._encoding, channel);
	    };
	    UnitModel.prototype.encoding = function () {
	        return this._encoding;
	    };
	    UnitModel.prototype.fieldDef = function (channel) {
	        return this._encoding[channel] || {};
	    };
	    UnitModel.prototype.field = function (channel, opt) {
	        if (opt === void 0) { opt = {}; }
	        var fieldDef = this.fieldDef(channel);
	        if (fieldDef.bin) {
	            opt = util_1.extend({
	                binSuffix: this.scale(channel).type === scale_1.ScaleType.ORDINAL ? 'range' : 'start'
	            }, opt);
	        }
	        return fielddef_1.field(fieldDef, opt);
	    };
	    UnitModel.prototype.dataTable = function () {
	        return this.dataName(vlEncoding.isAggregate(this._encoding) ? data_1.SUMMARY : data_1.SOURCE);
	    };
	    UnitModel.prototype.isUnit = function () {
	        return true;
	    };
	    return UnitModel;
	}(model_1.Model));
	exports.UnitModel = UnitModel;
	//# sourceMappingURL=unit.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/unit.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/config.js **/
jupyter.define('vega-lite@1.2.0/src/compile/config.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var encoding_1 = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var scale_2 = __jupyter_require__('vega-lite@~1.2.0/src/compile/scale.js');
	function initMarkConfig(mark, encoding, config) {
	    return util_1.extend(['filled', 'opacity', 'orient', 'align'].reduce(function (cfg, property) {
	        var value = config.mark[property];
	        switch (property) {
	            case 'filled':
	                if (value === undefined) {
	                    cfg[property] = mark !== mark_1.POINT && mark !== mark_1.LINE && mark !== mark_1.RULE;
	                }
	                break;
	            case 'opacity':
	                if (value === undefined) {
	                    if (util_1.contains([mark_1.POINT, mark_1.TICK, mark_1.CIRCLE, mark_1.SQUARE], mark)) {
	                        if (!encoding_1.isAggregate(encoding) || encoding_1.has(encoding, channel_1.DETAIL)) {
	                            cfg[property] = 0.7;
	                        }
	                    }
	                    if (mark === mark_1.AREA) {
	                        cfg[property] = 0.7;
	                    }
	                }
	                break;
	            case 'orient':
	                cfg[property] = orient(mark, encoding, config.mark);
	                break;
	            case 'align':
	                if (value === undefined) {
	                    cfg[property] = encoding_1.has(encoding, channel_1.X) ? 'center' : 'right';
	                }
	        }
	        return cfg;
	    }, {}), config.mark);
	}
	exports.initMarkConfig = initMarkConfig;
	function orient(mark, encoding, markConfig) {
	    if (markConfig === void 0) { markConfig = {}; }
	    switch (mark) {
	        case mark_1.POINT:
	        case mark_1.CIRCLE:
	        case mark_1.SQUARE:
	        case mark_1.TEXT:
	            return undefined;
	    }
	    var yIsRange = encoding.y && encoding.y2;
	    var xIsRange = encoding.x && encoding.x2;
	    switch (mark) {
	        case mark_1.TICK:
	            var xScaleType = encoding.x ? scale_2.scaleType(encoding.x.scale || {}, encoding.x, channel_1.X, mark) : null;
	            var yScaleType = encoding.y ? scale_2.scaleType(encoding.y.scale || {}, encoding.y, channel_1.Y, mark) : null;
	            if (xScaleType !== scale_1.ScaleType.ORDINAL && (!encoding.y || yScaleType === scale_1.ScaleType.ORDINAL)) {
	                return config_1.Orient.VERTICAL;
	            }
	            return config_1.Orient.HORIZONTAL;
	        case mark_1.RULE:
	            if (xIsRange) {
	                return config_1.Orient.HORIZONTAL;
	            }
	            if (yIsRange) {
	                return config_1.Orient.VERTICAL;
	            }
	            if (encoding.y) {
	                return config_1.Orient.HORIZONTAL;
	            }
	            if (encoding.x) {
	                return config_1.Orient.VERTICAL;
	            }
	            return undefined;
	        case mark_1.BAR:
	        case mark_1.AREA:
	            if (yIsRange) {
	                return config_1.Orient.VERTICAL;
	            }
	            if (xIsRange) {
	                return config_1.Orient.HORIZONTAL;
	            }
	        case mark_1.LINE:
	            var xIsMeasure = fielddef_1.isMeasure(encoding.x) || fielddef_1.isMeasure(encoding.x2);
	            var yIsMeasure = fielddef_1.isMeasure(encoding.y) || fielddef_1.isMeasure(encoding.y2);
	            if (xIsMeasure && !yIsMeasure) {
	                return config_1.Orient.HORIZONTAL;
	            }
	            return config_1.Orient.VERTICAL;
	    }
	    console.warn('orient unimplemented for mark', mark);
	    return config_1.Orient.VERTICAL;
	}
	exports.orient = orient;
	//# sourceMappingURL=config.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/config.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/legend.js **/
jupyter.define('vega-lite@1.2.0/src/compile/legend.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/scale.js');
	function parseLegendComponent(model) {
	    return [channel_1.COLOR, channel_1.SIZE, channel_1.SHAPE, channel_1.OPACITY].reduce(function (legendComponent, channel) {
	        if (model.legend(channel)) {
	            legendComponent[channel] = parseLegend(model, channel);
	        }
	        return legendComponent;
	    }, {});
	}
	exports.parseLegendComponent = parseLegendComponent;
	function getLegendDefWithScale(model, channel) {
	    switch (channel) {
	        case channel_1.COLOR:
	            var fieldDef = model.encoding().color;
	            var scale = model.scaleName(useColorLegendScale(fieldDef) ?
	                scale_1.COLOR_LEGEND :
	                channel_1.COLOR);
	            return model.config().mark.filled ? { fill: scale } : { stroke: scale };
	        case channel_1.SIZE:
	            return { size: model.scaleName(channel_1.SIZE) };
	        case channel_1.SHAPE:
	            return { shape: model.scaleName(channel_1.SHAPE) };
	        case channel_1.OPACITY:
	            return { opacity: model.scaleName(channel_1.OPACITY) };
	    }
	    return null;
	}
	function parseLegend(model, channel) {
	    var fieldDef = model.fieldDef(channel);
	    var legend = model.legend(channel);
	    var config = model.config();
	    var def = getLegendDefWithScale(model, channel);
	    def.title = title(legend, fieldDef, config);
	    var format = common_1.numberFormat(fieldDef, legend.format, config);
	    if (format) {
	        def.format = format;
	    }
	    ['offset', 'orient', 'values'].forEach(function (property) {
	        var value = legend[property];
	        if (value !== undefined) {
	            def[property] = value;
	        }
	    });
	    var props = (typeof legend !== 'boolean' && legend.properties) || {};
	    ['title', 'symbols', 'legend', 'labels'].forEach(function (group) {
	        var value = properties[group] ?
	            properties[group](fieldDef, props[group], model, channel) :
	            props[group];
	        if (value !== undefined && util_1.keys(value).length > 0) {
	            def.properties = def.properties || {};
	            def.properties[group] = value;
	        }
	    });
	    return def;
	}
	exports.parseLegend = parseLegend;
	function title(legend, fieldDef, config) {
	    if (typeof legend !== 'boolean' && legend.title) {
	        return legend.title;
	    }
	    return fielddef_1.title(fieldDef, config);
	}
	exports.title = title;
	function useColorLegendScale(fieldDef) {
	    return fieldDef.type === type_1.ORDINAL || fieldDef.bin || fieldDef.timeUnit;
	}
	exports.useColorLegendScale = useColorLegendScale;
	var properties;
	(function (properties) {
	    function symbols(fieldDef, symbolsSpec, model, channel) {
	        var symbols = {};
	        var mark = model.mark();
	        var legend = model.legend(channel);
	        switch (mark) {
	            case mark_1.BAR:
	            case mark_1.TICK:
	            case mark_1.TEXT:
	                symbols.shape = { value: 'square' };
	                break;
	            case mark_1.CIRCLE:
	            case mark_1.SQUARE:
	                symbols.shape = { value: mark };
	                break;
	            case mark_1.POINT:
	            case mark_1.LINE:
	            case mark_1.AREA:
	                break;
	        }
	        var cfg = model.config();
	        var filled = cfg.mark.filled;
	        var config = channel === channel_1.COLOR ?
	            util_1.without(common_1.FILL_STROKE_CONFIG, [filled ? 'fill' : 'stroke', 'strokeDash', 'strokeDashOffset']) :
	            util_1.without(common_1.FILL_STROKE_CONFIG, ['strokeDash', 'strokeDashOffset']);
	        config = util_1.without(config, ['strokeDash', 'strokeDashOffset']);
	        common_1.applyMarkConfig(symbols, model, config);
	        if (filled) {
	            symbols.strokeWidth = { value: 0 };
	        }
	        if (channel === channel_1.OPACITY) {
	            delete symbols.opacity;
	        }
	        var value;
	        if (model.has(channel_1.COLOR) && channel === channel_1.COLOR) {
	            if (useColorLegendScale(fieldDef)) {
	                value = { scale: model.scaleName(channel_1.COLOR), field: 'data' };
	            }
	        }
	        else if (model.encoding().color && model.encoding().color.value) {
	            value = { value: model.encoding().color.value };
	        }
	        if (value !== undefined) {
	            if (filled) {
	                symbols.fill = value;
	            }
	            else {
	                symbols.stroke = value;
	            }
	        }
	        else if (channel !== channel_1.COLOR) {
	            symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||
	                { value: cfg.mark.color };
	        }
	        if (legend.symbolColor !== undefined) {
	            symbols.fill = { value: legend.symbolColor };
	        }
	        else if (symbols.fill === undefined) {
	            if (cfg.mark.fill !== undefined) {
	                symbols.fill = { value: cfg.mark.fill };
	            }
	            else if (cfg.mark.stroke !== undefined) {
	                symbols.stroke = { value: cfg.mark.stroke };
	            }
	        }
	        if (channel !== channel_1.SHAPE) {
	            if (legend.symbolShape !== undefined) {
	                symbols.shape = { value: legend.symbolShape };
	            }
	            else if (cfg.mark.shape !== undefined) {
	                symbols.shape = { value: cfg.mark.shape };
	            }
	        }
	        if (channel !== channel_1.SIZE) {
	            if (legend.symbolSize !== undefined) {
	                symbols.size = { value: legend.symbolSize };
	            }
	        }
	        if (legend.symbolStrokeWidth !== undefined) {
	            symbols.strokeWidth = { value: legend.symbolStrokeWidth };
	        }
	        symbols = util_1.extend(symbols, symbolsSpec || {});
	        return util_1.keys(symbols).length > 0 ? symbols : undefined;
	    }
	    properties.symbols = symbols;
	    function labels(fieldDef, labelsSpec, model, channel) {
	        var legend = model.legend(channel);
	        var config = model.config();
	        var labels = {};
	        if (channel === channel_1.COLOR) {
	            if (fieldDef.type === type_1.ORDINAL) {
	                labelsSpec = util_1.extend({
	                    text: {
	                        scale: model.scaleName(scale_1.COLOR_LEGEND),
	                        field: 'data'
	                    }
	                }, labelsSpec || {});
	            }
	            else if (fieldDef.bin) {
	                labelsSpec = util_1.extend({
	                    text: {
	                        scale: model.scaleName(scale_1.COLOR_LEGEND_LABEL),
	                        field: 'data'
	                    }
	                }, labelsSpec || {});
	            }
	            else if (fieldDef.type === type_1.TEMPORAL) {
	                labelsSpec = util_1.extend({
	                    text: {
	                        template: common_1.timeTemplate('datum["data"]', fieldDef.timeUnit, legend.format, legend.shortTimeLabels, config)
	                    }
	                }, labelsSpec || {});
	            }
	        }
	        if (legend.labelAlign !== undefined) {
	            labels.align = { value: legend.labelAlign };
	        }
	        if (legend.labelColor !== undefined) {
	            labels.stroke = { value: legend.labelColor };
	        }
	        if (legend.labelFont !== undefined) {
	            labels.font = { value: legend.labelFont };
	        }
	        if (legend.labelFontSize !== undefined) {
	            labels.fontSize = { value: legend.labelFontSize };
	        }
	        if (legend.labelBaseline !== undefined) {
	            labels.baseline = { value: legend.labelBaseline };
	        }
	        labels = util_1.extend(labels, labelsSpec || {});
	        return util_1.keys(labels).length > 0 ? labels : undefined;
	    }
	    properties.labels = labels;
	    function title(fieldDef, titleSpec, model, channel) {
	        var legend = model.legend(channel);
	        var titles = {};
	        if (legend.titleColor !== undefined) {
	            titles.stroke = { value: legend.titleColor };
	        }
	        if (legend.titleFont !== undefined) {
	            titles.font = { value: legend.titleFont };
	        }
	        if (legend.titleFontSize !== undefined) {
	            titles.fontSize = { value: legend.titleFontSize };
	        }
	        if (legend.titleFontWeight !== undefined) {
	            titles.fontWeight = { value: legend.titleFontWeight };
	        }
	        titles = util_1.extend(titles, titleSpec || {});
	        return util_1.keys(titles).length > 0 ? titles : undefined;
	    }
	    properties.title = title;
	})(properties = exports.properties || (exports.properties = {}));
	//# sourceMappingURL=legend.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/legend.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/mark.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/mark.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var encoding_1 = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var sort_1 = __jupyter_require__('vega-lite@~1.2.0/src/sort.js');
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var area_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/area.js');
	var bar_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/bar.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var line_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/line.js');
	var point_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/point.js');
	var rule_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/rule.js');
	var text_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/text.js');
	var tick_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/mark/tick.js');
	var markCompiler = {
	    area: area_1.area,
	    bar: bar_1.bar,
	    line: line_1.line,
	    point: point_1.point,
	    text: text_1.text,
	    tick: tick_1.tick,
	    rule: rule_1.rule,
	    circle: point_1.circle,
	    square: point_1.square
	};
	function parseMark(model) {
	    if (util_1.contains([mark_1.LINE, mark_1.AREA], model.mark())) {
	        return parsePathMark(model);
	    }
	    else {
	        return parseNonPathMark(model);
	    }
	}
	exports.parseMark = parseMark;
	function parsePathMark(model) {
	    var mark = model.mark();
	    var isFaceted = model.parent() && model.parent().isFacet();
	    var dataFrom = { data: model.dataTable() };
	    var details = detailFields(model);
	    var pathMarks = [
	        {
	            name: model.name('marks'),
	            type: markCompiler[mark].markType(),
	            from: util_1.extend(isFaceted || details.length > 0 ? {} : dataFrom, { transform: [{ type: 'sort', by: sortPathBy(model) }] }),
	            properties: { update: markCompiler[mark].properties(model) }
	        }
	    ];
	    if (details.length > 0) {
	        var facetTransform = { type: 'facet', groupby: details };
	        var transform = mark === mark_1.AREA && model.stack() ?
	            stackTransforms(model, true).concat(facetTransform) :
	            [].concat(facetTransform, model.has(channel_1.ORDER) ? [{ type: 'sort', by: sortBy(model) }] : []);
	        return [{
	                name: model.name('pathgroup'),
	                type: 'group',
	                from: util_1.extend(isFaceted ? {} : dataFrom, { transform: transform }),
	                properties: {
	                    update: {
	                        width: { field: { group: 'width' } },
	                        height: { field: { group: 'height' } }
	                    }
	                },
	                marks: pathMarks
	            }];
	    }
	    else {
	        return pathMarks;
	    }
	}
	function parseNonPathMark(model) {
	    var mark = model.mark();
	    var isFaceted = model.parent() && model.parent().isFacet();
	    var dataFrom = { data: model.dataTable() };
	    var marks = [];
	    if (mark === mark_1.TEXT &&
	        model.has(channel_1.COLOR) &&
	        model.config().mark.applyColorToBackground && !model.has(channel_1.X) && !model.has(channel_1.Y)) {
	        marks.push(util_1.extend({
	            name: model.name('background'),
	            type: 'rect'
	        }, isFaceted ? {} : { from: dataFrom }, { properties: { update: text_1.text.background(model) } }));
	    }
	    marks.push(util_1.extend({
	        name: model.name('marks'),
	        type: markCompiler[mark].markType()
	    }, (!isFaceted || model.stack() || model.has(channel_1.ORDER)) ? {
	        from: util_1.extend(isFaceted ? {} : dataFrom, model.stack() ?
	            { transform: stackTransforms(model, false) } :
	            model.has(channel_1.ORDER) ?
	                { transform: [{ type: 'sort', by: sortBy(model) }] } :
	                {})
	    } : {}, { properties: { update: markCompiler[mark].properties(model) } }));
	    return marks;
	}
	function sortBy(model) {
	    if (model.has(channel_1.ORDER)) {
	        var channelDef = model.encoding().order;
	        if (channelDef instanceof Array) {
	            return channelDef.map(common_1.sortField);
	        }
	        else {
	            return common_1.sortField(channelDef);
	        }
	    }
	    return null;
	}
	function sortPathBy(model) {
	    if (model.mark() === mark_1.LINE && model.has(channel_1.PATH)) {
	        var channelDef = model.encoding().path;
	        if (channelDef instanceof Array) {
	            return channelDef.map(common_1.sortField);
	        }
	        else {
	            return common_1.sortField(channelDef);
	        }
	    }
	    else {
	        var dimensionChannel = model.config().mark.orient === config_1.Orient.HORIZONTAL ? channel_1.Y : channel_1.X;
	        var sort = model.sort(dimensionChannel);
	        if (sort_1.isSortField(sort)) {
	            return '-' + fielddef_1.field({
	                aggregate: encoding_1.isAggregate(model.encoding()) ? sort.op : undefined,
	                field: sort.field
	            });
	        }
	        else {
	            return '-' + model.field(dimensionChannel, { binSuffix: 'mid' });
	        }
	    }
	}
	function detailFields(model) {
	    return [channel_1.COLOR, channel_1.DETAIL, channel_1.OPACITY, channel_1.SHAPE].reduce(function (details, channel) {
	        if (model.has(channel) && !model.fieldDef(channel).aggregate) {
	            details.push(model.field(channel));
	        }
	        return details;
	    }, []);
	}
	function stackTransforms(model, impute) {
	    var stackByFields = getStackByFields(model);
	    if (impute) {
	        return [imputeTransform(model, stackByFields), stackTransform(model, stackByFields)];
	    }
	    return [stackTransform(model, stackByFields)];
	}
	function getStackByFields(model) {
	    var encoding = model.encoding();
	    return channel_1.STACK_GROUP_CHANNELS.reduce(function (fields, channel) {
	        var channelEncoding = encoding[channel];
	        if (encoding_1.has(encoding, channel)) {
	            if (util_1.isArray(channelEncoding)) {
	                channelEncoding.forEach(function (fieldDef) {
	                    fields.push(fielddef_1.field(fieldDef));
	                });
	            }
	            else {
	                var fieldDef = channelEncoding;
	                var scale = model.scale(channel);
	                var _field = fielddef_1.field(fieldDef, {
	                    binSuffix: scale && scale.type === scale_1.ScaleType.ORDINAL ? 'range' : 'start'
	                });
	                if (!!_field) {
	                    fields.push(_field);
	                }
	            }
	        }
	        return fields;
	    }, []);
	}
	function imputeTransform(model, stackFields) {
	    var stack = model.stack();
	    return {
	        type: 'impute',
	        field: model.field(stack.fieldChannel),
	        groupby: stackFields,
	        orderby: [model.field(stack.groupbyChannel, { binSuffix: 'mid' })],
	        method: 'value',
	        value: 0
	    };
	}
	function stackTransform(model, stackFields) {
	    var stack = model.stack();
	    var encoding = model.encoding();
	    var sortby = model.has(channel_1.ORDER) ?
	        (util_1.isArray(encoding[channel_1.ORDER]) ? encoding[channel_1.ORDER] : [encoding[channel_1.ORDER]]).map(common_1.sortField) :
	        stackFields.map(function (field) {
	            return '-' + field;
	        });
	    var valName = model.field(stack.fieldChannel);
	    var transform = {
	        type: 'stack',
	        groupby: [model.field(stack.groupbyChannel, { binSuffix: 'mid' }) || 'undefined'],
	        field: model.field(stack.fieldChannel),
	        sortby: sortby,
	        output: {
	            start: valName + '_start',
	            end: valName + '_end'
	        }
	    };
	    if (stack.offset) {
	        transform.offset = stack.offset;
	    }
	    return transform;
	}
	//# sourceMappingURL=mark.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/mark.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/area.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/area.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var area;
	(function (area) {
	    function markType() {
	        return 'area';
	    }
	    area.markType = markType;
	    function properties(model) {
	        var p = {};
	        var config = model.config();
	        var orient = config.mark.orient;
	        p.orient = { value: orient };
	        var stack = model.stack();
	        p.x = x(model.encoding().x, model.scaleName(channel_1.X), model.scale(channel_1.X), orient, stack);
	        p.y = y(model.encoding().y, model.scaleName(channel_1.Y), model.scale(channel_1.Y), orient, stack);
	        var _x2 = x2(model.encoding().x, model.encoding().x2, model.scaleName(channel_1.X), model.scale(channel_1.X), orient, stack);
	        if (_x2) {
	            p.x2 = _x2;
	        }
	        var _y2 = y2(model.encoding().y, model.encoding().y2, model.scaleName(channel_1.Y), model.scale(channel_1.Y), orient, stack);
	        if (_y2) {
	            p.y2 = _y2;
	        }
	        common_1.applyColorAndOpacity(p, model);
	        common_1.applyMarkConfig(p, model, ['interpolate', 'tension']);
	        return p;
	    }
	    area.properties = properties;
	    function x(fieldDef, scaleName, scale, orient, stack) {
	        if (stack && channel_1.X === stack.fieldChannel) {
	            return {
	                scale: scaleName,
	                field: fielddef_1.field(fieldDef, { suffix: 'start' })
	            };
	        }
	        else if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	            else if (fieldDef.value) {
	                return {
	                    scale: scaleName,
	                    value: fieldDef.value
	                };
	            }
	        }
	        return { value: 0 };
	    }
	    area.x = x;
	    function x2(xFieldDef, x2FieldDef, scaleName, scale, orient, stack) {
	        if (orient === config_1.Orient.HORIZONTAL) {
	            if (stack && channel_1.X === stack.fieldChannel) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(xFieldDef, { suffix: 'end' })
	                };
	            }
	            else if (x2FieldDef) {
	                if (x2FieldDef.field) {
	                    return {
	                        scale: scaleName,
	                        field: fielddef_1.field(x2FieldDef)
	                    };
	                }
	                else if (x2FieldDef.value) {
	                    return {
	                        scale: scaleName,
	                        value: x2FieldDef.value
	                    };
	                }
	            }
	            if (scale.type === scale_1.ScaleType.LOG || scale.zero === false) {
	                return {
	                    value: 0
	                };
	            }
	            return {
	                scale: scaleName,
	                value: 0
	            };
	        }
	        return undefined;
	    }
	    area.x2 = x2;
	    function y(fieldDef, scaleName, scale, orient, stack) {
	        if (stack && channel_1.Y === stack.fieldChannel) {
	            return {
	                scale: scaleName,
	                field: fielddef_1.field(fieldDef, { suffix: 'start' })
	            };
	        }
	        else if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	            else if (fieldDef.value) {
	                return {
	                    scale: scaleName,
	                    value: fieldDef.value
	                };
	            }
	        }
	        return { value: 0 };
	    }
	    area.y = y;
	    function y2(yFieldDef, y2FieldDef, scaleName, scale, orient, stack) {
	        if (orient !== config_1.Orient.HORIZONTAL) {
	            if (stack && channel_1.Y === stack.fieldChannel) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(yFieldDef, { suffix: 'end' })
	                };
	            }
	            else if (y2FieldDef) {
	                if (y2FieldDef.field) {
	                    return {
	                        scale: scaleName,
	                        field: fielddef_1.field(y2FieldDef)
	                    };
	                }
	                else if (y2FieldDef.value) {
	                    return {
	                        scale: scaleName,
	                        value: y2FieldDef.value
	                    };
	                }
	            }
	            if (scale.type === scale_1.ScaleType.LOG || scale.zero === false) {
	                return {
	                    field: { group: 'height' }
	                };
	            }
	            return {
	                scale: scaleName,
	                value: 0
	            };
	        }
	        return undefined;
	    }
	    area.y2 = y2;
	})(area = exports.area || (exports.area = {}));
	//# sourceMappingURL=area.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/area.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/bar.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/bar.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var scale_1 = __jupyter_require__('vega-lite@~1.2.0/src/scale.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var bar;
	(function (bar) {
	    function markType() {
	        return 'rect';
	    }
	    bar.markType = markType;
	    function properties(model) {
	        var p = {};
	        var orient = model.config().mark.orient;
	        var stack = model.stack();
	        var xFieldDef = model.encoding().x;
	        var x2FieldDef = model.encoding().x2;
	        var xIsMeasure = fielddef_1.isMeasure(xFieldDef) || fielddef_1.isMeasure(x2FieldDef);
	        if (stack && channel_1.X === stack.fieldChannel) {
	            p.x = {
	                scale: model.scaleName(channel_1.X),
	                field: model.field(channel_1.X, { suffix: 'start' })
	            };
	            p.x2 = {
	                scale: model.scaleName(channel_1.X),
	                field: model.field(channel_1.X, { suffix: 'end' })
	            };
	        }
	        else if (xIsMeasure) {
	            if (orient === config_1.Orient.HORIZONTAL) {
	                if (model.has(channel_1.X)) {
	                    p.x = {
	                        scale: model.scaleName(channel_1.X),
	                        field: model.field(channel_1.X)
	                    };
	                }
	                else {
	                    p.x = {
	                        scale: model.scaleName(channel_1.X),
	                        value: 0
	                    };
	                }
	                if (model.has(channel_1.X2)) {
	                    p.x2 = {
	                        scale: model.scaleName(channel_1.X),
	                        field: model.field(channel_1.X2)
	                    };
	                }
	                else {
	                    if (model.scale(channel_1.X).type === scale_1.ScaleType.LOG || model.scale(channel_1.X).zero === false) {
	                        p.x2 = { value: 0 };
	                    }
	                    else {
	                        p.x2 = {
	                            scale: model.scaleName(channel_1.X),
	                            value: 0
	                        };
	                    }
	                }
	            }
	            else {
	                p.xc = {
	                    scale: model.scaleName(channel_1.X),
	                    field: model.field(channel_1.X)
	                };
	                p.width = { value: sizeValue(model, channel_1.X) };
	            }
	        }
	        else {
	            if (model.has(channel_1.X)) {
	                if (model.encoding().x.bin) {
	                    if (model.has(channel_1.SIZE) && orient !== config_1.Orient.HORIZONTAL) {
	                        p.xc = {
	                            scale: model.scaleName(channel_1.X),
	                            field: model.field(channel_1.X, { binSuffix: 'mid' })
	                        };
	                        p.width = {
	                            scale: model.scaleName(channel_1.SIZE),
	                            field: model.field(channel_1.SIZE)
	                        };
	                    }
	                    else {
	                        p.x = {
	                            scale: model.scaleName(channel_1.X),
	                            field: model.field(channel_1.X, { binSuffix: 'start' }),
	                            offset: 1
	                        };
	                        p.x2 = {
	                            scale: model.scaleName(channel_1.X),
	                            field: model.field(channel_1.X, { binSuffix: 'end' })
	                        };
	                    }
	                }
	                else if (model.scale(channel_1.X).bandSize === scale_1.BANDSIZE_FIT) {
	                    p.x = {
	                        scale: model.scaleName(channel_1.X),
	                        field: model.field(channel_1.X),
	                        offset: 0.5
	                    };
	                }
	                else {
	                    p.xc = {
	                        scale: model.scaleName(channel_1.X),
	                        field: model.field(channel_1.X)
	                    };
	                }
	            }
	            else {
	                p.x = { value: 0, offset: 2 };
	            }
	            p.width = model.has(channel_1.X) && model.scale(channel_1.X).bandSize === scale_1.BANDSIZE_FIT ? {
	                scale: model.scaleName(channel_1.X),
	                band: true,
	                offset: -0.5
	            } : model.has(channel_1.SIZE) && orient !== config_1.Orient.HORIZONTAL ? {
	                scale: model.scaleName(channel_1.SIZE),
	                field: model.field(channel_1.SIZE)
	            } : {
	                value: sizeValue(model, (channel_1.X))
	            };
	        }
	        var yFieldDef = model.encoding().y;
	        var y2FieldDef = model.encoding().y2;
	        var yIsMeasure = fielddef_1.isMeasure(yFieldDef) || fielddef_1.isMeasure(y2FieldDef);
	        if (stack && channel_1.Y === stack.fieldChannel) {
	            p.y = {
	                scale: model.scaleName(channel_1.Y),
	                field: model.field(channel_1.Y, { suffix: 'start' })
	            };
	            p.y2 = {
	                scale: model.scaleName(channel_1.Y),
	                field: model.field(channel_1.Y, { suffix: 'end' })
	            };
	        }
	        else if (yIsMeasure) {
	            if (orient !== config_1.Orient.HORIZONTAL) {
	                if (model.has(channel_1.Y)) {
	                    p.y = {
	                        scale: model.scaleName(channel_1.Y),
	                        field: model.field(channel_1.Y)
	                    };
	                }
	                else {
	                    p.y = {
	                        scale: model.scaleName(channel_1.Y),
	                        value: 0
	                    };
	                }
	                if (model.has(channel_1.Y2)) {
	                    p.y2 = {
	                        scale: model.scaleName(channel_1.Y),
	                        field: model.field(channel_1.Y2)
	                    };
	                }
	                else {
	                    if (model.scale(channel_1.Y).type === scale_1.ScaleType.LOG || model.scale(channel_1.Y).zero === false) {
	                        p.y2 = {
	                            field: { group: 'height' }
	                        };
	                    }
	                    else {
	                        p.y2 = {
	                            scale: model.scaleName(channel_1.Y),
	                            value: 0
	                        };
	                    }
	                }
	            }
	            else {
	                p.yc = {
	                    scale: model.scaleName(channel_1.Y),
	                    field: model.field(channel_1.Y)
	                };
	                p.height = { value: sizeValue(model, channel_1.Y) };
	            }
	        }
	        else {
	            if (model.has(channel_1.Y)) {
	                if (model.encoding().y.bin) {
	                    if (model.has(channel_1.SIZE) && orient === config_1.Orient.HORIZONTAL) {
	                        p.yc = {
	                            scale: model.scaleName(channel_1.Y),
	                            field: model.field(channel_1.Y, { binSuffix: 'mid' })
	                        };
	                        p.height = {
	                            scale: model.scaleName(channel_1.SIZE),
	                            field: model.field(channel_1.SIZE)
	                        };
	                    }
	                    else {
	                        p.y = {
	                            scale: model.scaleName(channel_1.Y),
	                            field: model.field(channel_1.Y, { binSuffix: 'start' })
	                        };
	                        p.y2 = {
	                            scale: model.scaleName(channel_1.Y),
	                            field: model.field(channel_1.Y, { binSuffix: 'end' }),
	                            offset: 1
	                        };
	                    }
	                }
	                else if (model.scale(channel_1.Y).bandSize === scale_1.BANDSIZE_FIT) {
	                    p.y = {
	                        scale: model.scaleName(channel_1.Y),
	                        field: model.field(channel_1.Y),
	                        offset: 0.5
	                    };
	                }
	                else {
	                    p.yc = {
	                        scale: model.scaleName(channel_1.Y),
	                        field: model.field(channel_1.Y)
	                    };
	                }
	            }
	            else {
	                p.y2 = {
	                    field: { group: 'height' },
	                    offset: -1
	                };
	            }
	            p.height = model.has(channel_1.Y) && model.scale(channel_1.Y).bandSize === scale_1.BANDSIZE_FIT ? {
	                scale: model.scaleName(channel_1.Y),
	                band: true,
	                offset: -0.5
	            } : model.has(channel_1.SIZE) && orient === config_1.Orient.HORIZONTAL ? {
	                scale: model.scaleName(channel_1.SIZE),
	                field: model.field(channel_1.SIZE)
	            } : {
	                value: sizeValue(model, channel_1.Y)
	            };
	        }
	        common_1.applyColorAndOpacity(p, model);
	        return p;
	    }
	    bar.properties = properties;
	    function sizeValue(model, channel) {
	        var fieldDef = model.encoding().size;
	        if (fieldDef && fieldDef.value !== undefined) {
	            return fieldDef.value;
	        }
	        var markConfig = model.config().mark;
	        if (markConfig.barSize) {
	            return markConfig.barSize;
	        }
	        return model.isOrdinalScale(channel) ?
	            model.scale(channel).bandSize - 1 :
	            !model.has(channel) ?
	                model.config().scale.bandSize - 1 :
	                markConfig.barThinSize;
	    }
	})(bar = exports.bar || (exports.bar = {}));
	//# sourceMappingURL=bar.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/bar.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/line.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/line.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var line;
	(function (line) {
	    function markType() {
	        return 'line';
	    }
	    line.markType = markType;
	    function properties(model) {
	        var p = {};
	        var config = model.config();
	        p.x = x(model.encoding().x, model.scaleName(channel_1.X), config);
	        p.y = y(model.encoding().y, model.scaleName(channel_1.Y), config);
	        var _size = size(model.encoding().size, config);
	        if (_size) {
	            p.strokeWidth = _size;
	        }
	        common_1.applyColorAndOpacity(p, model);
	        common_1.applyMarkConfig(p, model, ['interpolate', 'tension']);
	        return p;
	    }
	    line.properties = properties;
	    function x(fieldDef, scaleName, config) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	        }
	        return { value: 0 };
	    }
	    function y(fieldDef, scaleName, config) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	        }
	        return { field: { group: 'height' } };
	    }
	    function size(fieldDef, config) {
	        if (fieldDef && fieldDef.value !== undefined) {
	            return { value: fieldDef.value };
	        }
	        return { value: config.mark.lineSize };
	    }
	})(line = exports.line || (exports.line = {}));
	//# sourceMappingURL=line.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/line.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/point.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/point.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var point;
	(function (point) {
	    function markType() {
	        return 'symbol';
	    }
	    point.markType = markType;
	    function properties(model, fixedShape) {
	        var p = {};
	        var config = model.config();
	        p.x = x(model.encoding().x, model.scaleName(channel_1.X), config);
	        p.y = y(model.encoding().y, model.scaleName(channel_1.Y), config);
	        p.size = size(model.encoding().size, model.scaleName(channel_1.SIZE), model.scale(channel_1.SIZE), config);
	        p.shape = shape(model.encoding().shape, model.scaleName(channel_1.SHAPE), model.scale(channel_1.SHAPE), config, fixedShape);
	        common_1.applyColorAndOpacity(p, model);
	        return p;
	    }
	    point.properties = properties;
	    function x(fieldDef, scaleName, config) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	        }
	        return { value: config.scale.bandSize / 2 };
	    }
	    function y(fieldDef, scaleName, config) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	        }
	        return { value: config.scale.bandSize / 2 };
	    }
	    function size(fieldDef, scaleName, scale, config) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { scaleType: scale.type })
	                };
	            }
	            else if (fieldDef.value !== undefined) {
	                return { value: fieldDef.value };
	            }
	        }
	        return { value: config.mark.size };
	    }
	    function shape(fieldDef, scaleName, scale, config, fixedShape) {
	        if (fixedShape) {
	            return { value: fixedShape };
	        }
	        else if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { scaleType: scale.type })
	                };
	            }
	            else if (fieldDef.value) {
	                return { value: fieldDef.value };
	            }
	        }
	        return { value: config.mark.shape };
	    }
	})(point = exports.point || (exports.point = {}));
	var circle;
	(function (circle) {
	    function markType() {
	        return 'symbol';
	    }
	    circle.markType = markType;
	    function properties(model) {
	        return point.properties(model, 'circle');
	    }
	    circle.properties = properties;
	})(circle = exports.circle || (exports.circle = {}));
	var square;
	(function (square) {
	    function markType() {
	        return 'symbol';
	    }
	    square.markType = markType;
	    function properties(model) {
	        return point.properties(model, 'square');
	    }
	    square.properties = properties;
	})(square = exports.square || (exports.square = {}));
	//# sourceMappingURL=point.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/point.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/rule.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/rule.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var rule;
	(function (rule) {
	    function markType() {
	        return 'rule';
	    }
	    rule.markType = markType;
	    function properties(model) {
	        var p = {};
	        if (model.config().mark.orient === config_1.Orient.VERTICAL) {
	            if (model.has(channel_1.X)) {
	                p.x = {
	                    scale: model.scaleName(channel_1.X),
	                    field: model.field(channel_1.X, { binSuffix: 'mid' })
	                };
	            }
	            else {
	                p.x = { value: 0 };
	            }
	            if (model.has(channel_1.Y)) {
	                p.y = {
	                    scale: model.scaleName(channel_1.Y),
	                    field: model.field(channel_1.Y, { binSuffix: 'mid' })
	                };
	            }
	            else {
	                p.y = { field: { group: 'height' } };
	            }
	            if (model.has(channel_1.Y2)) {
	                p.y2 = {
	                    scale: model.scaleName(channel_1.Y),
	                    field: model.field(channel_1.Y2, { binSuffix: 'mid' })
	                };
	            }
	            else {
	                p.y2 = { value: 0 };
	            }
	        }
	        else {
	            if (model.has(channel_1.Y)) {
	                p.y = {
	                    scale: model.scaleName(channel_1.Y),
	                    field: model.field(channel_1.Y, { binSuffix: 'mid' })
	                };
	            }
	            else {
	                p.y = { value: 0 };
	            }
	            if (model.has(channel_1.X)) {
	                p.x = {
	                    scale: model.scaleName(channel_1.X),
	                    field: model.field(channel_1.X, { binSuffix: 'mid' })
	                };
	            }
	            else {
	                p.x = { value: 0 };
	            }
	            if (model.has(channel_1.X2)) {
	                p.x2 = {
	                    scale: model.scaleName(channel_1.X),
	                    field: model.field(channel_1.X2, { binSuffix: 'mid' })
	                };
	            }
	            else {
	                p.x2 = { field: { group: 'width' } };
	            }
	        }
	        common_1.applyColorAndOpacity(p, model);
	        if (model.has(channel_1.SIZE)) {
	            p.strokeWidth = {
	                scale: model.scaleName(channel_1.SIZE),
	                field: model.field(channel_1.SIZE)
	            };
	        }
	        else {
	            p.strokeWidth = { value: sizeValue(model) };
	        }
	        return p;
	    }
	    rule.properties = properties;
	    function sizeValue(model) {
	        var fieldDef = model.encoding().size;
	        if (fieldDef && fieldDef.value !== undefined) {
	            return fieldDef.value;
	        }
	        return model.config().mark.ruleSize;
	    }
	})(rule = exports.rule || (exports.rule = {}));
	//# sourceMappingURL=rule.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/rule.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/text.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/text.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var text;
	(function (text_1) {
	    function markType() {
	        return 'text';
	    }
	    text_1.markType = markType;
	    function background(model) {
	        return {
	            x: { value: 0 },
	            y: { value: 0 },
	            width: { field: { group: 'width' } },
	            height: { field: { group: 'height' } },
	            fill: {
	                scale: model.scaleName(channel_1.COLOR),
	                field: model.field(channel_1.COLOR, model.encoding().color.type === type_1.ORDINAL ? { prefix: 'rank' } : {})
	            }
	        };
	    }
	    text_1.background = background;
	    function properties(model) {
	        var p = {};
	        common_1.applyMarkConfig(p, model, ['angle', 'align', 'baseline', 'dx', 'dy', 'font', 'fontWeight',
	            'fontStyle', 'radius', 'theta', 'text']);
	        var config = model.config();
	        var textFieldDef = model.encoding().text;
	        p.x = x(model.encoding().x, model.scaleName(channel_1.X), config, textFieldDef);
	        p.y = y(model.encoding().y, model.scaleName(channel_1.Y), config);
	        p.fontSize = size(model.encoding().size, model.scaleName(channel_1.SIZE), config);
	        p.text = text(textFieldDef, model.scaleName(channel_1.TEXT), config);
	        if (model.config().mark.applyColorToBackground && !model.has(channel_1.X) && !model.has(channel_1.Y)) {
	            p.fill = { value: 'black' };
	            var opacity = model.config().mark.opacity;
	            if (opacity) {
	                p.opacity = { value: opacity };
	            }
	            ;
	        }
	        else {
	            common_1.applyColorAndOpacity(p, model);
	        }
	        return p;
	    }
	    text_1.properties = properties;
	    function x(xFieldDef, scaleName, config, textFieldDef) {
	        if (xFieldDef) {
	            if (xFieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(xFieldDef, { binSuffix: 'mid' })
	                };
	            }
	        }
	        if (textFieldDef && textFieldDef.type === type_1.QUANTITATIVE) {
	            return { field: { group: 'width' }, offset: -5 };
	        }
	        else {
	            return { value: config.scale.textBandWidth / 2 };
	        }
	    }
	    function y(yFieldDef, scaleName, config) {
	        if (yFieldDef) {
	            if (yFieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(yFieldDef, { binSuffix: 'mid' })
	                };
	            }
	        }
	        return { value: config.scale.bandSize / 2 };
	    }
	    function size(sizeFieldDef, scaleName, config) {
	        if (sizeFieldDef) {
	            if (sizeFieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(sizeFieldDef)
	                };
	            }
	            if (sizeFieldDef.value) {
	                return { value: sizeFieldDef.value };
	            }
	        }
	        return { value: config.mark.fontSize };
	    }
	    function text(textFieldDef, scaleName, config) {
	        if (textFieldDef) {
	            if (textFieldDef.field) {
	                if (type_1.QUANTITATIVE === textFieldDef.type) {
	                    var format = common_1.numberFormat(textFieldDef, config.mark.format, config);
	                    var filter = 'number' + (format ? ':\'' + format + '\'' : '');
	                    return {
	                        template: '{{' + fielddef_1.field(textFieldDef, { datum: true }) + ' | ' + filter + '}}'
	                    };
	                }
	                else if (type_1.TEMPORAL === textFieldDef.type) {
	                    return {
	                        template: common_1.timeTemplate(fielddef_1.field(textFieldDef, { datum: true }), textFieldDef.timeUnit, config.mark.format, config.mark.shortTimeLabels, config)
	                    };
	                }
	                else {
	                    return { field: textFieldDef.field };
	                }
	            }
	            else if (textFieldDef.value) {
	                return { value: textFieldDef.value };
	            }
	        }
	        return { value: config.mark.text };
	    }
	})(text = exports.text || (exports.text = {}));
	//# sourceMappingURL=text.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/text.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/tick.js **/
jupyter.define('vega-lite@1.2.0/src/compile/mark/tick.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var channel_1 = __jupyter_require__('vega-lite@~1.2.0/src/channel.js');
	var config_1 = __jupyter_require__('vega-lite@~1.2.0/src/config.js');
	var fielddef_1 = __jupyter_require__('vega-lite@~1.2.0/src/fielddef.js');
	var common_1 = __jupyter_require__('vega-lite@~1.2.0/src/compile/common.js');
	var tick;
	(function (tick) {
	    function markType() {
	        return 'rect';
	    }
	    tick.markType = markType;
	    function properties(model) {
	        var p = {};
	        var config = model.config();
	        p.xc = x(model.encoding().x, model.scaleName(channel_1.X), config);
	        p.yc = y(model.encoding().y, model.scaleName(channel_1.Y), config);
	        if (config.mark.orient === config_1.Orient.HORIZONTAL) {
	            p.width = size(model.encoding().size, model.scaleName(channel_1.SIZE), config, (model.scale(channel_1.X) || {}).bandSize);
	            p.height = { value: config.mark.tickThickness };
	        }
	        else {
	            p.width = { value: config.mark.tickThickness };
	            p.height = size(model.encoding().size, model.scaleName(channel_1.SIZE), config, (model.scale(channel_1.Y) || {}).bandSize);
	        }
	        common_1.applyColorAndOpacity(p, model);
	        return p;
	    }
	    tick.properties = properties;
	    function x(fieldDef, scaleName, config) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	            else if (fieldDef.value) {
	                return { value: fieldDef.value };
	            }
	        }
	        return { value: config.scale.bandSize / 2 };
	    }
	    function y(fieldDef, scaleName, config) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fielddef_1.field(fieldDef, { binSuffix: 'mid' })
	                };
	            }
	            else if (fieldDef.value) {
	                return { value: fieldDef.value };
	            }
	        }
	        return { value: config.scale.bandSize / 2 };
	    }
	    function size(fieldDef, scaleName, config, scaleBandSize) {
	        if (fieldDef) {
	            if (fieldDef.field) {
	                return {
	                    scale: scaleName,
	                    field: fieldDef.field
	                };
	            }
	            else if (fieldDef.value !== undefined) {
	                return { value: fieldDef.value };
	            }
	        }
	        if (config.mark.tickSize) {
	            return { value: config.mark.tickSize };
	        }
	        var bandSize = scaleBandSize !== undefined ?
	            scaleBandSize :
	            config.scale.bandSize;
	        return { value: bandSize / 1.5 };
	    }
	})(tick = exports.tick || (exports.tick = {}));
	//# sourceMappingURL=tick.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/compile/mark/tick.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/facet.js **/
jupyter.define('vega-lite@1.2.0/src/facet.js', function (module, exports, __jupyter_require__) {
	"use strict";
	//# sourceMappingURL=facet.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/facet.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/shorthand.js **/
jupyter.define('vega-lite@1.2.0/src/shorthand.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var aggregate_1 = __jupyter_require__('vega-lite@~1.2.0/src/aggregate.js');
	var timeunit_1 = __jupyter_require__('vega-lite@~1.2.0/src/timeunit.js');
	var type_1 = __jupyter_require__('vega-lite@~1.2.0/src/type.js');
	var vlEncoding = __jupyter_require__('vega-lite@~1.2.0/src/encoding.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	exports.DELIM = '|';
	exports.ASSIGN = '=';
	exports.TYPE = ',';
	exports.FUNC = '_';
	function shorten(spec) {
	    return 'mark' + exports.ASSIGN + spec.mark +
	        exports.DELIM + shortenEncoding(spec.encoding);
	}
	exports.shorten = shorten;
	function parse(shorthand, data, config) {
	    var split = shorthand.split(exports.DELIM), mark = split.shift().split(exports.ASSIGN)[1].trim(), encoding = parseEncoding(split.join(exports.DELIM));
	    var spec = {
	        mark: mark_1.Mark[mark],
	        encoding: encoding
	    };
	    if (data !== undefined) {
	        spec.data = data;
	    }
	    if (config !== undefined) {
	        spec.config = config;
	    }
	    return spec;
	}
	exports.parse = parse;
	function shortenEncoding(encoding) {
	    return vlEncoding.map(encoding, function (fieldDef, channel) {
	        return channel + exports.ASSIGN + shortenFieldDef(fieldDef);
	    }).join(exports.DELIM);
	}
	exports.shortenEncoding = shortenEncoding;
	function parseEncoding(encodingShorthand) {
	    return encodingShorthand.split(exports.DELIM).reduce(function (m, e) {
	        var split = e.split(exports.ASSIGN), enctype = split[0].trim(), fieldDefShorthand = split[1];
	        m[enctype] = parseFieldDef(fieldDefShorthand);
	        return m;
	    }, {});
	}
	exports.parseEncoding = parseEncoding;
	function shortenFieldDef(fieldDef) {
	    return (fieldDef.aggregate ? fieldDef.aggregate + exports.FUNC : '') +
	        (fieldDef.timeUnit ? fieldDef.timeUnit + exports.FUNC : '') +
	        (fieldDef.bin ? 'bin' + exports.FUNC : '') +
	        (fieldDef.field || '') + exports.TYPE + type_1.SHORT_TYPE[fieldDef.type];
	}
	exports.shortenFieldDef = shortenFieldDef;
	function shortenFieldDefs(fieldDefs, delim) {
	    if (delim === void 0) { delim = exports.DELIM; }
	    return fieldDefs.map(shortenFieldDef).join(delim);
	}
	exports.shortenFieldDefs = shortenFieldDefs;
	function parseFieldDef(fieldDefShorthand) {
	    var split = fieldDefShorthand.split(exports.TYPE);
	    var fieldDef = {
	        field: split[0].trim(),
	        type: type_1.TYPE_FROM_SHORT_TYPE[split[1].trim()]
	    };
	    for (var i = 0; i < aggregate_1.AGGREGATE_OPS.length; i++) {
	        var a = aggregate_1.AGGREGATE_OPS[i];
	        if (fieldDef.field.indexOf(a + '_') === 0) {
	            fieldDef.field = fieldDef.field.substr(a.toString().length + 1);
	            if (a === aggregate_1.AggregateOp.COUNT && fieldDef.field.length === 0) {
	                fieldDef.field = '*';
	            }
	            fieldDef.aggregate = a;
	            break;
	        }
	    }
	    for (var i = 0; i < timeunit_1.TIMEUNITS.length; i++) {
	        var tu = timeunit_1.TIMEUNITS[i];
	        if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {
	            fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);
	            fieldDef.timeUnit = tu;
	            break;
	        }
	    }
	    if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {
	        fieldDef.field = fieldDef.field.substr(4);
	        fieldDef.bin = true;
	    }
	    return fieldDef;
	}
	exports.parseFieldDef = parseFieldDef;
	//# sourceMappingURL=shorthand.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/shorthand.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/transform.js **/
jupyter.define('vega-lite@1.2.0/src/transform.js', function (module, exports, __jupyter_require__) {
	"use strict";
	//# sourceMappingURL=transform.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/transform.js **/


/** START DEFINE BLOCK for vega-lite@1.2.0/src/validate.js **/
jupyter.define('vega-lite@1.2.0/src/validate.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var util_1 = __jupyter_require__('vega-lite@~1.2.0/src/util.js');
	var mark_1 = __jupyter_require__('vega-lite@~1.2.0/src/mark.js');
	exports.DEFAULT_REQUIRED_CHANNEL_MAP = {
	    text: ['text'],
	    line: ['x', 'y'],
	    area: ['x', 'y']
	};
	exports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {
	    bar: util_1.toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),
	    line: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),
	    area: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),
	    tick: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),
	    circle: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),
	    square: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),
	    point: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),
	    text: util_1.toMap(['row', 'column', 'size', 'color', 'text'])
	};
	function getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {
	    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }
	    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }
	    var mark = spec.mark;
	    var encoding = spec.encoding;
	    var requiredChannels = requiredChannelMap[mark];
	    var supportedChannels = supportedChannelMap[mark];
	    for (var i in requiredChannels) {
	        if (!(requiredChannels[i] in encoding)) {
	            return 'Missing encoding channel \"' + requiredChannels[i] +
	                '\" for mark \"' + mark + '\"';
	        }
	    }
	    for (var channel in encoding) {
	        if (!supportedChannels[channel]) {
	            return 'Encoding channel \"' + channel +
	                '\" is not supported by mark type \"' + mark + '\"';
	        }
	    }
	    if (mark === mark_1.BAR && !encoding.x && !encoding.y) {
	        return 'Missing both x and y for bar';
	    }
	    return null;
	}
	exports.getEncodingMappingError = getEncodingMappingError;
	//# sourceMappingURL=validate.js.map
})
/** END DEFINE BLOCK for vega-lite@1.2.0/src/validate.js **/


/** START DEFINE BLOCK for vega-embed@2.2.0/src/parameter.js **/
jupyter.define('vega-embed@2.2.0/src/parameter.js', function (module, exports, __jupyter_require__) {
	var d3 = __jupyter_require__('d3@3.5.17/d3.js'),
	    $ = __jupyter_require__('vega@2.6.3/index.js').util.mutator;
	
	module.exports = {
	  init: function(el, param, spec) {
	    return (rewrite(param, spec), handle(el, param));
	  },
	  bind: function(param, view) {
	    param.dom.forEach(function(el) { el.__vega__ = view; });
	    view.onSignal(param.dom[0].name, function(k, v) { param.set(v); });
	  }
	};
	
	// spec re-write
	
	function rewrite(param, spec) {
	  // add signal to top-level if not defined
	  var sg = spec.signals || (spec.signals = []);
	  for (var i=0; i<sg.length; ++i) {
	    if (sg[i].name === param.signal) break;
	  }
	  if (i === sg.length) {
	    sg.push({
	      name: param.signal,
	      init: param.value
	    });
	  }
	
	  // replace values for re-write entries
	  (param.rewrite || []).forEach(function(path) {
	    $(path)(spec, {signal: param.signal});
	  });
	}
	
	// HTML output handlers
	
	function handle(el, param) {
	  var p = el.append('div')
	    .attr('class', 'vega-param');
	
	  p.append('span')
	    .attr('class', 'vega-param-name')
	    .text(param.name || param.signal);
	
	  var input = form;
	  switch (param.type) {
	    case 'checkbox': input = checkbox; break;
	    case 'select':   input = select; break;
	    case 'radio':    input = radio; break;
	    case 'range':    input = range; break;
	  }
	
	  return input(p, param);
	}
	
	function form(el, param) {
	  var fm = el.append('input')
	    .on('input', update);
	
	  for (var key in param) {
	    if (key === 'signal' || key === 'rewrite') continue;
	    fm.attr(key, param[key]);
	  }
	  fm.attr('name', param.signal);
	
	  var node = fm.node();
	  return {
	    dom: [node],
	    set: function(value) { node.value = value; }
	  };
	}
	
	function checkbox(el, param) {
	  var cb = el.append('input')
	    .on('change', function() { update.call(this, this.checked); })
	    .attr('type', 'checkbox')
	    .attr('name', param.signal)
	    .attr('checked', param.value || null)
	    .node();
	
	  return {
	    dom: [cb],
	    set: function(value) { cb.checked = !!value || null; }
	  };
	}
	
	function select(el, param) {
	  var sl = el.append('select')
	    .attr('name', param.signal)
	    .on('change', function() {
	      update.call(this, this.options[this.selectedIndex].__data__);
	    });
	
	  sl.selectAll('option')
	    .data(param.options)
	   .enter().append('option')
	    .attr('value', vg.util.identity)
	    .attr('selected', function(x) { return x === param.value || null; })
	    .text(vg.util.identity);
	  
	  var node = sl.node();
	  return {
	    dom: [node],
	    set: function(value) {
	      var idx = param.options.indexOf(value);
	      node.selectedIndex = idx;
	    }
	  };
	}
	
	function radio(el, param) {
	  var rg = el.append('span')
	    .attr('class', 'vega-param-radio');
	
	  var nodes = param.options.map(function(option) {
	    var id = 'vega-option-' + param.signal + '-' + option;
	
	    var rb = rg.append('input')
	      .datum(option)
	      .on('change', update)
	      .attr('id', id)
	      .attr('type', 'radio')
	      .attr('name', param.signal)
	      .attr('value', option)
	      .attr('checked', option === param.value || null);
	
	    rg.append('label')
	      .attr('for', id)
	      .text(option);
	
	    return rb.node();
	  });
	
	  return {
	    dom: nodes,
	    set: function(value) {
	      for (var i=0; i<nodes.length; ++i) {
	        if (nodes[i].value === value) {
	          nodes[i].checked = true;
	        }
	      }
	    }
	  };
	}
	
	function range(el, param) {
	  var val = param.value !== undefined ? param.value :
	    ((+param.max) + (+param.min)) / 2;
	
	  var rn = el.append('input')
	    .on('input', function() {
	      lbl.text(this.value);
	      update.call(this, +this.value);
	    })
	    .attr('type', 'range')
	    .attr('name', param.signal)
	    .attr('value', val)
	    .attr('min', param.min)
	    .attr('max', param.max)
	    .attr('step', param.step || vg.util.bins({
	      min: param.min,
	      max: param.max,
	      maxbins: 100
	    }).step);
	
	  var lbl = el.append('label')
	    .attr('class', 'vega-range')
	    .text(val);
	
	  var node = rn.node();
	  return {
	    dom: [node],
	    set: function(value) {
	      node.value = value;
	      lbl.text(value);
	    }
	  };
	}
	
	function update(value) {
	  if (value === undefined) value = this.__data__ || d3.event.target.value;
	  this.__vega__.signal(this.name, value).update();
	}
	
})
/** END DEFINE BLOCK for vega-embed@2.2.0/src/parameter.js **/


/** START DEFINE BLOCK for vega-embed@2.2.0/src/post.js **/
jupyter.define('vega-embed@2.2.0/src/post.js', function (module, exports, __jupyter_require__) {
	// open editor url in a new window, and pass a message
	module.exports = function(window, url, data) {
	  var editor = window.open(url),
	      wait = 10000,
	      step = 250,
	      count = ~~(wait/step);
	
	  function listen(evt) {
	    if (evt.source === editor) {
	      count = 0;
	      window.removeEventListener('message', listen, false);
	    }
	  }
	  window.addEventListener('message', listen, false);
	
	  // send message
	  // periodically resend until ack received or timeout
	  function send() {
	    if (count <= 0) return;
	    editor.postMessage(data, '*');
	    setTimeout(send, step);
	    count -= 1;
	  }
	  setTimeout(send, step);
	};
	
})
/** END DEFINE BLOCK for vega-embed@2.2.0/src/post.js **/


/** START DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/renderer.js **/
jupyter.define('jupyterlab_vega@0.1.0/lib/renderer.js', function (module, exports, __jupyter_require__) {
	"use strict";
	var rendererwidget_1 = __jupyter_require__('jupyterlab_vega@~0.1.0/lib/rendererwidget.js');
	var VegaRenderer = (function () {
	    function VegaRenderer() {
	        /**
	         * The mimetypes this renderer accepts.
	         */
	        this.mimetypes = ['application/vnd.vega+json'];
	    }
	    /**
	     * Whether the input can safely sanitized for a given mimetype.
	     */
	    VegaRenderer.prototype.isSanitizable = function (mimetype) {
	        return this.mimetypes.indexOf(mimetype) !== -1;
	    };
	    /**
	     * Whether the input is safe without sanitization.
	     */
	    VegaRenderer.prototype.isSafe = function (mimetype) {
	        return false;
	    };
	    /**
	     * Render the transformed mime bundle.
	     */
	    VegaRenderer.prototype.render = function (options) {
	        return new rendererwidget_1.RenderedVega(options);
	    };
	    return VegaRenderer;
	}());
	exports.VegaRenderer = VegaRenderer;
	var VegaLiteRenderer = (function () {
	    function VegaLiteRenderer() {
	        /**
	         * The mimetypes this renderer accepts.
	         */
	        this.mimetypes = ['application/vnd.vegalite+json'];
	    }
	    /**
	     * Whether the input can safely sanitized for a given mimetype.
	     */
	    VegaLiteRenderer.prototype.isSanitizable = function (mimetype) {
	        return this.mimetypes.indexOf(mimetype) !== -1;
	    };
	    /**
	     * Whether the input is safe without sanitization.
	     */
	    VegaLiteRenderer.prototype.isSafe = function (mimetype) {
	        return false;
	    };
	    /**
	     * Render the transformed mime bundle.
	     */
	    VegaLiteRenderer.prototype.render = function (options) {
	        return new rendererwidget_1.RenderedVegaLite(options);
	    };
	    return VegaLiteRenderer;
	}());
	exports.VegaLiteRenderer = VegaLiteRenderer;
	
})
/** END DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/renderer.js **/


/** START DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/index.css **/
jupyter.define('jupyterlab_vega@0.1.0/lib/index.css', function (module, exports, __jupyter_require__) {
	// removed by extract-text-webpack-plugin
})
/** END DEFINE BLOCK for jupyterlab_vega@0.1.0/lib/index.css **/
